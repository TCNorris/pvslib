(bounding_circuits_defs (is_less_MM_list_TCC1 0 (is_less_MM_list_TCC1-1 nil 3654423363 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (Sign3 type-eq-decl nil sign3 reals) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil)) nil (is_less_MM_list subtype "bounding_circuits_defs.LM" "(list_adt[Measure_Matrix[N]].cons?)"))) (is_less_MM_list_TCC2 0 (is_less_MM_list_TCC2-1 nil 3654423363 ("" (skeep) (("" (inst + "car(LM)") (("" (ground) (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (Sign3 type-eq-decl nil sign3 reals) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (member def-decl "bool" list_props nil)) nil (is_less_MM_list subtype "booleans.TRUE" "{b: booleans.bool | booleans.IMPLIES(b, EXISTS (MM: measures[bounding_circuits_defs.N].Measure_Matrix): booleans.AND(list_props[Measure_Matrix[N]].member(MM, bounding_circuits_defs.LM), measures[bounding_circuits_defs.N].<=(MM, bounding_circuits_defs.M)))}"))) (is_less_MM_list_TCC3 0 (is_less_MM_list_TCC3-1 nil 3654423363 ("" (termination-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign3 type-eq-decl nil sign3 reals) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (get const-decl "Sign3" measures nil) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (le const-decl "bool" measures nil) (<= const-decl "bool" measures nil)) nil (is_less_MM_list termination "bounding_circuits_defs.is_less_MM_list(bounding_circuits_defs.M, list_adt[Measure_Matrix[N]].cdr(bounding_circuits_defs.LM))" "nil"))) (is_less_MM_list_TCC4 0 (is_less_MM_list_TCC4-1 nil 3654423363 ("" (skeep :preds? t) (("" (typepred "  v(M, cdr[Measure_Matrix[N]](LM))") (("" (ground) (("" (skeep -) (("" (inst + "MM") (("" (ground) (("" (expand "member" 1) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (<= const-decl "bool" measures nil) (member def-decl "bool" list_props nil) (< const-decl "bool" reals nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (is_less_MM_list subtype "bounding_circuits_defs.is_less_MM_list(bounding_circuits_defs.M, list_adt[Measure_Matrix[N]].cdr(bounding_circuits_defs.LM))" "{b: booleans.bool | booleans.IMPLIES(b, EXISTS (MM: measures[bounding_circuits_defs.N].Measure_Matrix): booleans.AND(list_props[Measure_Matrix[N]].member(MM, bounding_circuits_defs.LM), measures[bounding_circuits_defs.N].<=(MM, bounding_circuits_defs.M)))}"))) (minimalize_iter_TCC1 0 (minimalize_iter_TCC1-1 nil 3654423363 ("" (skeep) (("" (ground) (("1" (skeep) (("1" (typepred (M)) (("1" (hide (-1 -2)) (("1" (ground) (("1" (expand "member") (("1" (propax) nil nil)) nil) ("2" (inst 1 "M") (("2" (ground) (("2" (expand "<=") (("2" (ground) (("2" (expand "le") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) nil nil)) nil)) nil) ((member def-decl "bool" list_props nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (le const-decl "bool" measures nil) (<= const-decl "bool" measures nil)) nil (minimalize_iter subtype "bounding_circuits_defs.ret" "{L: list_adt[Measure_Matrix[N]].list | booleans.AND(FORALL ((M: measures[bounding_circuits_defs.N].Measure_Matrix | booleans.OR(list_props[Measure_Matrix[N]].member(M, bounding_circuits_defs.LM), list_props[Measure_Matrix[N]].member(M, bounding_circuits_defs.ret)))): EXISTS (MM: measures[bounding_circuits_defs.N].Measure_Matrix): booleans.AND(list_props[Measure_Matrix[N]].member(MM, L), measures[bounding_circuits_defs.N].<=(MM, M)), FORALL (m: measures[bounding_circuits_defs.N].Measure_Matrix): booleans.IMPLIES(list_props[Measure_Matrix[N]].member(m, L), (booleans.OR(list_props[Measure_Matrix[N]].member(m, bounding_circuits_defs.ret), list_props[Measure_Matrix[N]].member(m, bounding_circuits_defs.LM)))))}"))) (minimalize_iter_TCC2 0 (minimalize_iter_TCC2-1 nil 3654423363 ("" (skeep) (("" (skeep) (("" (expand " length" 2 2) (("" (ground) nil nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil)) nil (minimalize_iter termination "bounding_circuits_defs.minimalize_iter(list_adt[Measure_Matrix[N]].cdr(bounding_circuits_defs.LM), bounding_circuits_defs.ret)" "nil"))) (minimalize_iter_TCC3 0 (minimalize_iter_TCC3-1 nil 3654423363 ("" (skeep) (("" (skeep) (("" (ground) (("1" (typepred " v(cdr[Measure_Matrix[N]](LM), ret)") (("1" (skeep) (("1" (typepred (M)) (("1" (hide (-1 -2 -4)) (("1" (split -1) (("1" (case "NOT member(M, cdr(LM))") (("1" (expand "member" -1) (("1" (ground) (("1" (typepred "is_less_MM_list(fr, ret)") (("1" (ground) (("1" (skeep) (("1" (inst -4 "MM") (("1" (skeep) (("1" (inst + "MM_1") (("1" (ground) (("1" (lemma "matrices_order") (("1" (expand "partial_order?") (("1" (expand "preorder?") (("1" (expand "transitive?") (("1" (flatten) (("1" (inst -2 "MM_1" "MM" "fr") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -3 "M") (("2" (ground) nil nil)) nil)) nil) ("2" (inst -2 "M") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length" 1 2) (("2" (ground) nil nil)) nil)) nil) ("2" (skeep) (("2" (typepred " v(cdr[Measure_Matrix[N]](LM), ret)") (("2" (inst -3 "m") (("2" (ground) (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" measures nil) (member def-decl "bool" list_props nil) (< const-decl "bool" reals nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (M skolem-const-decl "{M: Measure_Matrix | member(M, LM) OR member(M, ret)}" bounding_circuits_defs nil) (is_less_MM_list def-decl "{b: bool |
   b IMPLIES EXISTS (MM: Measure_Matrix): member(MM, LM) AND MM <= M}" bounding_circuits_defs nil) (partial_order? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (preorder? const-decl "bool" orders nil) (matrices_order formula-decl nil measures nil) (ret skolem-const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (LM skolem-const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (MM skolem-const-decl "Measure_Matrix[N]" bounding_circuits_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (minimalize_iter subtype "bounding_circuits_defs.minimalize_iter(list_adt[Measure_Matrix[N]].cdr(bounding_circuits_defs.LM), bounding_circuits_defs.ret)" "{L: list_adt[Measure_Matrix[N]].list | booleans.AND(FORALL ((M: measures[bounding_circuits_defs.N].Measure_Matrix | booleans.OR(list_props[Measure_Matrix[N]].member(M, bounding_circuits_defs.LM), list_props[Measure_Matrix[N]].member(M, bounding_circuits_defs.ret)))): EXISTS (MM: measures[bounding_circuits_defs.N].Measure_Matrix): booleans.AND(list_props[Measure_Matrix[N]].member(MM, L), measures[bounding_circuits_defs.N].<=(MM, M)), FORALL (m: measures[bounding_circuits_defs.N].Measure_Matrix): booleans.IMPLIES(list_props[Measure_Matrix[N]].member(m, L), (booleans.OR(list_props[Measure_Matrix[N]].member(m, bounding_circuits_defs.ret), list_props[Measure_Matrix[N]].member(m, bounding_circuits_defs.LM)))))}"))) (minimalize_iter_TCC4 0 (minimalize_iter_TCC4-1 nil 3654423363 ("" (skeep) (("" (skeep) (("" (expand "length" 3 2) (("" (ground) nil nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil)) nil (minimalize_iter termination "bounding_circuits_defs.minimalize_iter(list_adt[Measure_Matrix[N]].cdr(bounding_circuits_defs.LM), list_adt[Measure_Matrix[N]].cons(bounding_circuits_defs.fr, bounding_circuits_defs.ret))" "nil"))) (minimalize_iter_TCC5 0 (minimalize_iter_TCC5-1 nil 3654423363 ("" (skeep) (("" (skeep) (("" (ground) (("1" (typepred "v(cdr[Measure_Matrix[N]](LM),
                 cons[Measure_Matrix[N]](fr, ret))") (("1" (skeep) (("1" (typepred (M)) (("1" (hide (-1 -2 -4)) (("1" (split -1) (("1" (case "NOT member(M, cdr(LM))") (("1" (expand "member" -1) (("1" (ground) (("1" (inst -2 "fr") (("1" (ground) (("1" (skeep) (("1" (inst 2 "MM") (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -3 " M") (("2" (ground) nil nil)) nil)) nil) ("2" (inst -2 "M") (("2" (expand "member" 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length" 1 2) (("2" (ground) nil nil)) nil)) nil) ("2" (skeep) (("2" (typepred "v(cdr[Measure_Matrix[N]](LM), cons[Measure_Matrix[N]](fr, ret))") (("2" (hide (-1 -2)) (("2" (inst?) (("2" (ground) (("1" (expand "member" -1) (("1" (expand "member") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" measures nil) (member def-decl "bool" list_props nil) (< const-decl "bool" reals nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (LM skolem-const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (M skolem-const-decl "{M: Measure_Matrix | member(M, LM) OR member(M, ret)}" bounding_circuits_defs nil) (fr skolem-const-decl "Measure_Matrix[N]" bounding_circuits_defs nil) (ret skolem-const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (minimalize_iter subtype "bounding_circuits_defs.minimalize_iter(list_adt[Measure_Matrix[N]].cdr(bounding_circuits_defs.LM), list_adt[Measure_Matrix[N]].cons(bounding_circuits_defs.fr, bounding_circuits_defs.ret))" "{L: list_adt[Measure_Matrix[N]].list | booleans.AND(FORALL ((M: measures[bounding_circuits_defs.N].Measure_Matrix | booleans.OR(list_props[Measure_Matrix[N]].member(M, bounding_circuits_defs.LM), list_props[Measure_Matrix[N]].member(M, bounding_circuits_defs.ret)))): EXISTS (MM: measures[bounding_circuits_defs.N].Measure_Matrix): booleans.AND(list_props[Measure_Matrix[N]].member(MM, L), measures[bounding_circuits_defs.N].<=(MM, M)), FORALL (m: measures[bounding_circuits_defs.N].Measure_Matrix): booleans.IMPLIES(list_props[Measure_Matrix[N]].member(m, L), (booleans.OR(list_props[Measure_Matrix[N]].member(m, bounding_circuits_defs.ret), list_props[Measure_Matrix[N]].member(m, bounding_circuits_defs.LM)))))}"))) (minimalize_iter_TCC6 0 (minimalize_iter_TCC6-1 nil 3770219239 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (Sign3 type-eq-decl nil sign3 reals) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil)) nil (minimalize_iter subtype "bounding_circuits_defs.LM" "(list_adt[Measure_Matrix[N]].cons?)"))) (minimalize_TCC1 0 (minimalize_TCC1-1 nil 3654423541 ("" (skeep) (("" (ground) (("1" (skeep) (("1" (typepred (M)) (("1" (hide (-1 -2)) (("1" (typepred "minimalize_iter(LM, null[Measure_Matrix[N]])") (("1" (hide (-1 -3)) (("1" (inst -1 "M") (("1" (skeep) (("1" (typepred "minimalize_iter(minimalize_iter(LM, null[Measure_Matrix[N]]),
                                   null[Measure_Matrix[N]])") (("1" (hide (-1 -3)) (("1" (inst -1 "MM") (("1" (skeep) (("1" (inst 1 "MM_1") (("1" (ground) (("1" (lemma "matrices_order") (("1" (expand "partial_order?") (("1" (expand "preorder?") (("1" (expand "transitive?") (("1" (flatten) (("1" (inst -2 "MM_1" "MM" "M") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "minimalize_iter(minimalize_iter(LM, null[Measure_Matrix[N]]),
                                   null[Measure_Matrix[N]])") (("2" (hide (-1 -2)) (("2" (inst -1 "m") (("2" (assert) (("2" (expand "member" -1 1) (("2" (hide -2) (("2" (typepred "minimalize_iter(LM, null[Measure_Matrix[N]])") (("2" (hide (-1 -2)) (("2" (inst - "m") (("2" (assert) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member def-decl "bool" list_props nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (minimalize_iter def-decl "{L: list[Measure_Matrix[N]] |
   (FORALL ((M: Measure_Matrix | member(M, LM) OR member(M, ret))):
      EXISTS (MM: Measure_Matrix): member(MM, L) AND MM <= M)
    AND
    (FORALL (m: Measure_Matrix):
       member(m, L) IMPLIES (member(m, ret) OR member(m, LM)))}" bounding_circuits_defs nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" measures nil) (LM skolem-const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (MM skolem-const-decl "Measure_Matrix[N]" bounding_circuits_defs nil) (matrices_order formula-decl nil measures nil) (preorder? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (partial_order? const-decl "bool" orders nil)) nil (minimalize subtype "bounding_circuits_defs.minimalize_iter(bounding_circuits_defs.minimalize_iter(bounding_circuits_defs.LM, list_adt[Measure_Matrix[N]].null), list_adt[Measure_Matrix[N]].null)" "{L: list_adt[Measure_Matrix[N]].list | booleans.AND(FORALL ((M: measures[bounding_circuits_defs.N].Measure_Matrix | list_props[Measure_Matrix[N]].member(M, bounding_circuits_defs.LM))): EXISTS (MM: measures[bounding_circuits_defs.N].Measure_Matrix): booleans.AND(list_props[Measure_Matrix[N]].member(MM, L), measures[bounding_circuits_defs.N].<=(MM, M)), FORALL (m: measures[bounding_circuits_defs.N].Measure_Matrix): booleans.IMPLIES(list_props[Measure_Matrix[N]].member(m, L), list_props[Measure_Matrix[N]].member(m, bounding_circuits_defs.LM)))}"))) (list_prod_pre_TCC1 0 (list_prod_pre_TCC1-1 nil 3657884095 ("" (skeep) (("" (skeep) (("" (expand "member") (("" (ground) nil nil)) nil)) nil)) nil) ((member def-decl "bool" list_props nil)) nil (list_prod_pre subtype "list_adt[Measure_Matrix[N]].null" "{L: list_adt[Measure_Matrix[N]].list | FORALL (m1, m2: measures[bounding_circuits_defs.N].Measure_Matrix): booleans.IMPLIES(booleans.AND(list_props[Measure_Matrix[N]].member(m1, bounding_circuits_defs.l1), list_props[Measure_Matrix[N]].member(m2, bounding_circuits_defs.l2)), list_props[Measure_Matrix[N]].member(measures[bounding_circuits_defs.N].*(m1, m2), L))}"))) (list_prod_pre_TCC2 0 (list_prod_pre_TCC2-1 nil 3657884095 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (Sign3 type-eq-decl nil sign3 reals) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (list_prod_pre termination "bounding_circuits_defs.list_prod_pre(list_adt[Measure_Matrix[N]].cdr(bounding_circuits_defs.l1), bounding_circuits_defs.l2)" "nil"))) (list_prod_pre_TCC3 0 (list_prod_pre_TCC3-1 nil 3657884095 ("" (skeep) (("" (skeep :preds? t) (("" (expand "member" -5) (("" (lift-if -5) (("" (ground) (("1" (lemma "member_append_l[Measure_Matrix]") (("1" (inst?) (("1" (assert) (("1" (hide 4) (("1" (lemma "member_nth[Measure_Matrix]") (("1" (inst - "l2" "m2") (("1" (assert) (("1" (skeep) (("1" (lemma "nth_member[Measure_Matrix]") (("1" (inst - "map[Measure_Matrix[N], Measure_Matrix[N]]
                 (LAMBDA (M: Measure_Matrix[N]):
                    *[N](car[Measure_Matrix[N]](l1), M))
                 (l2)" "m1*m2" "i") (("1" (assert) (("1" (hide 2) (("1" (lemma "map_nth_rw[Measure_Matrix, Measure_Matrix]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length[Measure_Matrix, Measure_Matrix]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "v(cdr[Measure_Matrix[N]](l1), l2)") (("2" (hide (-1 -4 -6)) (("2" (inst?) (("2" (lemma "member_append_r[Measure_Matrix]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (member_append_r formula-decl nil more_list_props structures) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (member_append_l formula-decl nil more_list_props structures) (member_nth formula-decl nil more_list_props structures) (nth_member formula-decl nil more_list_props structures) (map_length formula-decl nil more_map_props nil) (map_nth_rw formula-decl nil more_map_props nil) (l1 skolem-const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (i skolem-const-decl "below(length(l2))" bounding_circuits_defs nil) (below type-eq-decl nil naturalnumbers nil) (l2 skolem-const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (map adt-def-decl "list[T1]" list_adt_map nil) (* const-decl "Measure_Matrix" measures nil) (member def-decl "bool" list_props nil)) nil (list_prod_pre subtype "list_props[Measure_Matrix[N]].append(list_adt_map[Measure_Matrix[N], Measure_Matrix[N]].map(LAMBDA (M: measures[bounding_circuits_defs.N].Measure_Matrix): measures[bounding_circuits_defs.N].*(list_adt[Measure_Matrix[N]].car(bounding_circuits_defs.l1), M))(bounding_circuits_defs.l2), bounding_circuits_defs.list_prod_pre(list_adt[Measure_Matrix[N]].cdr(bounding_circuits_defs.l1), bounding_circuits_defs.l2))" "{L: list_adt[Measure_Matrix[N]].list | FORALL (m1, m2: measures[bounding_circuits_defs.N].Measure_Matrix): booleans.IMPLIES(booleans.AND(list_props[Measure_Matrix[N]].member(m1, bounding_circuits_defs.l1), list_props[Measure_Matrix[N]].member(m2, bounding_circuits_defs.l2)), list_props[Measure_Matrix[N]].member(measures[bounding_circuits_defs.N].*(m1, m2), L))}"))) (list_prod_TCC1 0 (list_prod_TCC1-1 nil 3657884095 ("" (skeep) (("" (skeep) (("" (typepred " list_prod_pre(l1, l2)") (("" (hide -1) (("" (inst?) (("" (assert) (("" (typepred " minimalize(list_prod_pre(l1, l2))") (("" (hide -1) (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((<= const-decl "bool" measures nil) (minimalize const-decl "{L: list[Measure_Matrix[N]] |
   (FORALL ((M: Measure_Matrix | member(M, LM))):
      EXISTS (MM: Measure_Matrix): member(MM, L) AND MM <= M)
    AND (FORALL (m: Measure_Matrix): member(m, L) IMPLIES member(m, LM))}" bounding_circuits_defs nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (Sign3 type-eq-decl nil sign3 reals) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (* const-decl "Measure_Matrix" measures nil) (list_prod_pre def-decl "{L: list[Measure_Matrix[N]] |
   FORALL (m1, m2: Measure_Matrix):
     member(m1, l1) AND member(m2, l2) IMPLIES member(m1 * m2, L)}" bounding_circuits_defs nil)) nil (list_prod subtype "bounding_circuits_defs.minimalize(bounding_circuits_defs.list_prod_pre(bounding_circuits_defs.l1, bounding_circuits_defs.l2))" "{L: list_adt[Measure_Matrix[N]].list | FORALL (m1, m2: measures[bounding_circuits_defs.N].Measure_Matrix): booleans.IMPLIES(booleans.AND(list_props[Measure_Matrix[N]].member(m1, bounding_circuits_defs.l1), list_props[Measure_Matrix[N]].member(m2, bounding_circuits_defs.l2)), EXISTS (M: measures[bounding_circuits_defs.N].Measure_Matrix): booleans.AND(list_props[Measure_Matrix[N]].member(M, L), measures[bounding_circuits_defs.N].<=(M, measures[bounding_circuits_defs.N].*(m1, m2))))}"))) (decomp_weight_TCC1 0 (decomp_weight_TCC1-1 nil 3657446634 ("" (skeep) (("" (typepred "vc`v") (("" (expand "vert?") (("" (propax) nil nil)) nil)) nil)) nil) ((vert type-eq-decl nil digraphs_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (T formal-type-decl nil bounding_circuits_defs nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (decomp_weight subtype "bounding_circuits_defs.vc`v" "(c_digraphs_imp[bounding_circuits_defs.T].digraph_verts(dg(bounding_circuits_defs.G)))"))) (decomp_weight_TCC2 0 (decomp_weight_TCC2-2 "" 3790335600 ("" (use "measure_matrix_assoc") (("" (assert) nil nil)) nil) ((N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_matrix_assoc formula-decl nil measures nil)) shostak (decomp_weight subtype "measures[bounding_circuits_defs.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(bounding_circuits_defs.f)}")) (decomp_weight_TCC2-1 nil 3657446634 ("" (then (use "measure_matrix_assoc") (assert))) ((measure_matrix_assoc formula-decl nil measures nil)) nil (decomp_weight subtype "measures[bounding_circuits_defs.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(bounding_circuits_defs.f)}"))) (decomp_weight_TCC3 0 (decomp_weight_TCC3-2 "" 3790335600 ("" (rewrite "id_is_identity") (("" (assert) nil nil)) nil) ((N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (id_is_identity formula-decl nil measures nil)) shostak (decomp_weight subtype "measures[bounding_circuits_defs.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[bounding_circuits_defs.N].*)(bounding_circuits_defs.zero)}")) (decomp_weight_TCC3-1 nil 3657446634 ("" (then (rewrite "id_is_identity") (assert))) ((id_is_identity formula-decl nil measures nil)) shostak (decomp_weight subtype "measures[bounding_circuits_defs.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[bounding_circuits_defs.N].*)(bounding_circuits_defs.zero)}"))) (decomp_weight_TCC4 0 (decomp_weight_TCC4-1 nil 3657446634 ("" (use "measure_matrix_assoc") (("" (assert) nil nil)) nil) ((wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign3 type-eq-decl nil sign3 reals) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (T formal-type-decl nil bounding_circuits_defs nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_matrix_assoc formula-decl nil measures nil)) nil (decomp_weight subtype "c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].get_wgt" "[[W: wgd_type[T, Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[bounding_circuits_defs.T].digraph_edges(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (decomp_weight_TCC5 0 (decomp_weight_TCC5-2 "" 3790335601 ("" (assert) nil nil) nil shostak (decomp_weight subtype "0" "below[length[vert_circ[T, digraph_type[T], digraph_verts[T], digraph_edges[T], digraph_size[T], digraph_make[T]](dg(G))](cd)]")) (decomp_weight_TCC5-1 nil 3657446634 ("" (rewrite "id_is_identity") (("" (assert) nil nil)) nil) nil nil (decomp_weight subtype "0" "below[length[vert_circ[T, digraph_type[T], digraph_verts[T], digraph_edges[T], digraph_size[T], digraph_make[T]](dg(G))](cd)]"))) (decomp_weight_TCC6 0 (decomp_weight_TCC6-4 nil 3661770964 ("" (assert) (("" (skeep) (("" (typepred "nth
                 [vert_circ
                      [T, digraph_type[T], digraph_verts, digraph_edges,
                       digraph_size, digraph_make](dg(G))]
                 (cd, 0)`c") (("1" (propax) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((c_digraph type-eq-decl nil c_digraphs_def digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (NOT const-decl "[bool -> bool]" booleans nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (Walk type-eq-decl nil walks_ digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (vert type-eq-decl nil digraphs_ digraphs) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (verts_in? const-decl "bool" walks_ digraphs) (Seq type-eq-decl nil walks_ digraphs) (gen_seq1 const-decl "Seq(G)" walks_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (vert_circ type-eq-decl nil circuit_decomp_ digraphs) (< const-decl "bool" reals nil) (nth def-decl "T" list_props nil) (walk? const-decl "bool" walks_ digraphs) (list2finseq const-decl "finseq[T]" list2finseq nil) (map adt-def-decl "list[T1]" list_adt_map nil) (walk_decomp type-eq-decl nil circuit_decomp_ digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil bounding_circuits_defs nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs)) nil (decomp_weight subtype "list_props[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.cd, 0)`c" "walks_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].Walk(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(bounding_circuits_defs.G))")) (decomp_weight_TCC6-3 nil 3661770924 ("" (subtype-tcc) nil nil) nil nil (decomp_weight subtype "list_props[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.cd, 0)`c" "walks_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].Walk(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(bounding_circuits_defs.G))")) (decomp_weight_TCC6-2 nil 3659963461 ("" (assert) nil nil) ((edges const-decl "bool" c_digraphs_def digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs)) nil (decomp_weight subtype "list_props[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.cd, 0)`c" "walks_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].Walk(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(bounding_circuits_defs.G))")) (decomp_weight_TCC6-1 nil 3657446634 ("" (skeep) (("" (typepred " nth[vert_circ[T](dg(G))](cd, 0)`v") (("1" (expand "vert?") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((finseq type-eq-decl nil finite_sequences nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (finite_set type-eq-decl nil finite_sets nil)) nil (decomp_weight subtype "list_props[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.cd, 0)`c" "walks_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].Walk(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(bounding_circuits_defs.G))"))) (decomp_weight_TCC7 0 (decomp_weight_TCC7-1 nil 3657446634 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (decomp_weight subtype "0" "below[length[vert_circ[T, digraph_type[T], digraph_verts[T], digraph_edges[T], digraph_size[T], digraph_make[T]](dg(G))](cd)]"))) (decomp_weight_TCC8 0 (decomp_weight_TCC8-3 nil 3661625596 ("" (assert) (("" (skeep) (("" (typepred "nth
               [vert_circ
                    [T, digraph_type[T], digraph_verts, digraph_edges,
                     digraph_size, digraph_make](dg(G))]
               (cd, 0)`c") (("1" (propax) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((c_digraph type-eq-decl nil c_digraphs_def digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (NOT const-decl "[bool -> bool]" booleans nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (Walk type-eq-decl nil walks_ digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (vert type-eq-decl nil digraphs_ digraphs) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (verts_in? const-decl "bool" walks_ digraphs) (Seq type-eq-decl nil walks_ digraphs) (gen_seq1 const-decl "Seq(G)" walks_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (vert_circ type-eq-decl nil circuit_decomp_ digraphs) (< const-decl "bool" reals nil) (nth def-decl "T" list_props nil) (walk? const-decl "bool" walks_ digraphs) (list2finseq const-decl "finseq[T]" list2finseq nil) (map adt-def-decl "list[T1]" list_adt_map nil) (walk_decomp type-eq-decl nil circuit_decomp_ digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil bounding_circuits_defs nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs)) nil (decomp_weight subtype "list_props[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.cd, 0)`c" "walks_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].Walk(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(bounding_circuits_defs.G))")) (decomp_weight_TCC8-2 nil 3659963475 ("" (skeep) (("" (typepred " nth[vert_circ(dg(G))](cd, 1)`v") (("1" (expand "vert?") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((walk_decomp type-eq-decl nil circuit_decomp_ digraphs) (walk? const-decl "bool" walks_ digraphs) (vert_circ type-eq-decl nil circuit_decomp_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (gen_seq1 const-decl "Seq(G)" walks_ digraphs) (Seq type-eq-decl nil walks_ digraphs) (verts_in? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (vert type-eq-decl nil digraphs_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (is_finite const-decl "bool" finite_sets nil)) nil (decomp_weight subtype "list_props[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.cd, 0)`c" "walks_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].Walk(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(bounding_circuits_defs.G))")) (decomp_weight_TCC8-1 nil 3657446634 ("" (skeep) (("" (typepred " nth[vert_circ[T](dg(G))](cd, 1)`v") (("1" (expand "vert?") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((finseq type-eq-decl nil finite_sequences nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (finite_set type-eq-decl nil finite_sets nil)) nil (decomp_weight subtype "list_props[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.cd, 0)`c" "walks_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].Walk(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(bounding_circuits_defs.G))"))) (decomp_weight_TCC9 0 (decomp_weight_TCC9-4 "" 3790335605 ("" (use "measure_matrix_assoc") (("" (assert) nil nil)) nil) ((N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_matrix_assoc formula-decl nil measures nil)) shostak (decomp_weight subtype "measures[bounding_circuits_defs.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(bounding_circuits_defs.f)}")) (decomp_weight_TCC9-3 nil 3661627129 ("" (then (use "measure_matrix_assoc") (assert))) ((measure_matrix_assoc formula-decl nil measures nil)) nil (decomp_weight subtype "measures[bounding_circuits_defs.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(bounding_circuits_defs.f)}")) (decomp_weight_TCC9-2 nil 3659963520 ("" (skeep) (("" (typepred (cd)) (("" (name "ed" "gen_seq2
                      (dg(G), nth[vert_circ(dg(G))](cd, 0)`v,
                       nth[vert_circ(dg(G))](cd, 1)`v)") (("1" (replace -1) (("1" (expand "walk?" 2) (("1" (ground) (("1" (skeep :preds? t) (("1" (expand "ed" -2) (("1" (expand "gen_seq2" -2) (("1" (expand "finseq_appl" 1) (("1" (expand "walk?") (("1" (flatten) (("1" (hide -6) (("1" (inst -6 "0") (("1" (assert) (("1" (expand "list2finseq" -6 1) (("1" (rewrite "map_length[vert_circ(dg(G)), vert(dg(G))]") (("1" (assert) (("1" (expand "finseq_appl" -6) (("1" (expand "list2finseq" -6) (("1" (lemma "map_nth_rw[vert_circ(dg(G)), vert(dg(G))]") (("1" (inst?) (("1" (replaces -1) (("1" (lemma "map_nth_rw[vert_circ(dg(G)), vert(dg(G))]") (("1" (inst?) (("1" (replaces -1) (("1" (replaces -3 1 :dir rl) (("1" (case "n=0") (("1" (replaces -1) (("1" (expand "gen_seq2") (("1" (propax) nil nil)) nil)) nil) ("2" (expand "gen_seq2") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((walk_decomp type-eq-decl nil circuit_decomp_ digraphs) (walk? const-decl "bool" walks_ digraphs) (vert_circ type-eq-decl nil circuit_decomp_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (gen_seq1 const-decl "Seq(G)" walks_ digraphs) (Seq type-eq-decl nil walks_ digraphs) (verts_in? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (vert type-eq-decl nil digraphs_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (is_finite const-decl "bool" finite_sets nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (gen_seq2 const-decl "Seq(G)" walks_ digraphs)) nil (decomp_weight subtype "measures[bounding_circuits_defs.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(bounding_circuits_defs.f)}")) (decomp_weight_TCC9-1 nil 3657446634 ("" (skeep) (("" (typepred (cd)) (("" (name "ed" "gen_seq2[T]
               (dg(G), nth[vert_circ[T](dg(G))](cd, 0)`v,
                nth[vert_circ[T](dg(G))](cd, 1)`v)") (("1" (replace -1) (("1" (expand "walk?" 2) (("1" (ground) (("1" (skeep :preds? t) (("1" (expand "ed" -2) (("1" (expand "gen_seq2" -2) (("1" (expand "finseq_appl" 1) (("1" (expand "walk?") (("1" (flatten) (("1" (hide -6) (("1" (inst -6 "0") (("1" (assert) (("1" (expand "list2finseq" -6 1) (("1" (rewrite "map_length[vert_circ[T](dg(G)), vert[T](dg(G))]") (("1" (assert) (("1" (expand "finseq_appl" -6) (("1" (expand "list2finseq" -6) (("1" (lemma "map_nth_rw[vert_circ[T](dg(G)), vert[T](dg(G))]") (("1" (inst?) (("1" (replaces -1) (("1" (lemma "map_nth_rw[vert_circ[T](dg(G)), vert[T](dg(G))]") (("1" (inst?) (("1" (replaces -1) (("1" (replaces -3 1 :dir rl) (("1" (case "n=0") (("1" (replaces -1) (("1" (expand "gen_seq2") (("1" (propax) nil nil)) nil)) nil) ("2" (expand "gen_seq2") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_set type-eq-decl nil finite_sets nil) (finseq type-eq-decl nil finite_sequences nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (decomp_weight subtype "measures[bounding_circuits_defs.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(bounding_circuits_defs.f)}"))) (decomp_weight_TCC10 0 (decomp_weight_TCC10-2 "" 3790335605 ("" (rewrite "id_is_identity") (("" (assert) nil nil)) nil) ((N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (id_is_identity formula-decl nil measures nil)) shostak (decomp_weight subtype "measures[bounding_circuits_defs.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[bounding_circuits_defs.N].*)(bounding_circuits_defs.zero)}")) (decomp_weight_TCC10-1 nil 3657446634 ("" (then (rewrite "id_is_identity") (assert))) ((id_is_identity formula-decl nil measures nil)) shostak (decomp_weight subtype "measures[bounding_circuits_defs.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[bounding_circuits_defs.N].*)(bounding_circuits_defs.zero)}"))) (decomp_weight_TCC11 0 (decomp_weight_TCC11-1 nil 3657446634 ("" (use "measure_matrix_assoc") (("" (assert) nil nil)) nil) ((wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign3 type-eq-decl nil sign3 reals) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (T formal-type-decl nil bounding_circuits_defs nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_matrix_assoc formula-decl nil measures nil)) nil (decomp_weight subtype "c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].get_wgt" "[[W: wgd_type[T, Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[bounding_circuits_defs.T].digraph_edges(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (decomp_weight_TCC12 0 (decomp_weight_TCC12-2 nil 3661771030 ("" (skeep) (("" (typepred " nth[vert_circ(dg(G))](cd, 0)`v") (("1" (expand "vert?") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((walk_decomp type-eq-decl nil circuit_decomp_ digraphs) (map adt-def-decl "list[T1]" list_adt_map nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (walk? const-decl "bool" walks_ digraphs) (nth def-decl "T" list_props nil) (< const-decl "bool" reals nil) (vert_circ type-eq-decl nil circuit_decomp_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (gen_seq1 const-decl "Seq(G)" walks_ digraphs) (Seq type-eq-decl nil walks_ digraphs) (verts_in? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (vert type-eq-decl nil digraphs_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (T formal-type-decl nil bounding_circuits_defs nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (vert const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs)) nil (decomp_weight subtype "list_props[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.cd, 0)`v" "(c_digraphs_imp[bounding_circuits_defs.T].digraph_verts(dg(bounding_circuits_defs.G)))")) (decomp_weight_TCC12-1 nil 3657446634 ("" (rewrite "id_is_identity") (("" (assert) nil nil)) nil) ((id_is_identity formula-decl nil measures nil)) nil (decomp_weight subtype "list_props[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.cd, 0)`v" "(c_digraphs_imp[bounding_circuits_defs.T].digraph_verts(dg(bounding_circuits_defs.G)))"))) (decomp_weight_TCC13 0 (decomp_weight_TCC13-1 nil 3661624396 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil bounding_circuits_defs nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (Walk type-eq-decl nil walks_ digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (vert type-eq-decl nil digraphs_ digraphs) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (verts_in? const-decl "bool" walks_ digraphs) (Seq type-eq-decl nil walks_ digraphs) (gen_seq1 const-decl "Seq(G)" walks_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (vert_circ type-eq-decl nil circuit_decomp_ digraphs) (walk? const-decl "bool" walks_ digraphs) (list2finseq const-decl "finseq[T]" list2finseq nil) (map adt-def-decl "list[T1]" list_adt_map nil) (walk_decomp type-eq-decl nil circuit_decomp_ digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (decomp_weight subtype "1" "below[length[vert_circ[T, digraph_type[T], digraph_verts[T], digraph_edges[T], digraph_size[T], digraph_make[T]](dg(G))](cd)]"))) (decomp_weight_TCC14 0 (decomp_weight_TCC14-3 nil 3661771059 ("" (skeep) (("" (typepred " nth[vert_circ(dg(G))](cd, 1)`v") (("1" (expand "vert?") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((walk_decomp type-eq-decl nil circuit_decomp_ digraphs) (map adt-def-decl "list[T1]" list_adt_map nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (walk? const-decl "bool" walks_ digraphs) (nth def-decl "T" list_props nil) (< const-decl "bool" reals nil) (vert_circ type-eq-decl nil circuit_decomp_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (gen_seq1 const-decl "Seq(G)" walks_ digraphs) (Seq type-eq-decl nil walks_ digraphs) (verts_in? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (vert type-eq-decl nil digraphs_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (T formal-type-decl nil bounding_circuits_defs nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (vert const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs)) nil (decomp_weight subtype "list_props[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.cd, 1)`v" "(c_digraphs_imp[bounding_circuits_defs.T].digraph_verts(dg(bounding_circuits_defs.G)))")) (decomp_weight_TCC14-2 nil 3661626263 ("" (skeep) (("" (typepred " nth[vert_circ(dg(G))](cd, 0)`v") (("1" (expand "vert?") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((walk_decomp type-eq-decl nil circuit_decomp_ digraphs) (walk? const-decl "bool" walks_ digraphs) (vert_circ type-eq-decl nil circuit_decomp_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (gen_seq1 const-decl "Seq(G)" walks_ digraphs) (Seq type-eq-decl nil walks_ digraphs) (verts_in? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (vert type-eq-decl nil digraphs_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs)) nil (decomp_weight subtype "list_props[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.cd, 1)`v" "(c_digraphs_imp[bounding_circuits_defs.T].digraph_verts(dg(bounding_circuits_defs.G)))")) (decomp_weight_TCC14-1 nil 3661624396 ("" (subtype-tcc) nil nil) nil nil (decomp_weight subtype "list_props[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.cd, 1)`v" "(c_digraphs_imp[bounding_circuits_defs.T].digraph_verts(dg(bounding_circuits_defs.G)))"))) (decomp_weight_TCC15 0 (decomp_weight_TCC15-2 nil 3661771108 ("" (skeep) (("" (typepred (cd)) (("" (name "ed" "gen_seq2
                                           (dg(G), nth[vert_circ(dg(G))](cd, 0)`v,
                                            nth[vert_circ(dg(G))](cd, 1)`v)") (("1" (replace -1) (("1" (expand "walk?" 2) (("1" (ground) (("1" (skeep :preds? t) (("1" (expand "ed" -2) (("1" (expand "gen_seq2" -2) (("1" (expand "finseq_appl" 1) (("1" (expand "walk?") (("1" (flatten) (("1" (hide -6) (("1" (inst -6 "0") (("1" (assert) (("1" (expand "list2finseq" -6 1) (("1" (with-tccs (rewrite "map_length[vert_circ(dg(G)), vert(dg(G))]")) (("1" (assert) (("1" (expand "finseq_appl" -6) (("1" (expand "list2finseq" -6) (("1" (with-tccs (lemma "map_nth_rw[vert_circ(dg(G)), vert(dg(G))]")) (("1" (inst?) (("1" (replaces -1) (("1" (with-tccs (lemma "map_nth_rw[vert_circ(dg(G)), vert(dg(G))]")) (("1" (inst?) (("1" (replaces -1) (("1" (replaces -3 1 :dir rl) (("1" (case "n=0") (("1" (replaces -1) (("1" (expand "gen_seq2") (("1" (propax) nil nil)) nil)) nil) ("2" (expand "gen_seq2") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((walk_decomp type-eq-decl nil circuit_decomp_ digraphs) (map adt-def-decl "list[T1]" list_adt_map nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (walk? const-decl "bool" walks_ digraphs) (vert_circ type-eq-decl nil circuit_decomp_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (gen_seq1 const-decl "Seq(G)" walks_ digraphs) (Seq type-eq-decl nil walks_ digraphs) (verts_in? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (vert type-eq-decl nil digraphs_ digraphs) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Walk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil bounding_circuits_defs nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ed skolem-const-decl "Seq[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
    digraph_make](dg(G))" bounding_circuits_defs nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (below type-eq-decl nil naturalnumbers nil) (map_nth_rw formula-decl nil more_map_props nil) (map_length formula-decl nil more_map_props nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (gen_seq2 const-decl "Seq(G)" walks_ digraphs) (< const-decl "bool" reals nil) (nth def-decl "T" list_props nil)) nil (decomp_weight subtype "walks_[bounding_circuits_defs.T, digraph_type[bounding_circuits_defs.T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].gen_seq2(dg(bounding_circuits_defs.G), list_props[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.cd, 0)`v, list_props[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.cd, 1)`v)" "walks_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].Walk(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(bounding_circuits_defs.G))")) (decomp_weight_TCC15-1 nil 3661624396 ("" (subtype-tcc) nil nil) ((ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (Walk type-eq-decl nil walks_ digraphs) (Sign3 type-eq-decl nil sign3 reals) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (vert type-eq-decl nil digraphs_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (verts_in? const-decl "bool" walks_ digraphs) (Seq type-eq-decl nil walks_ digraphs) (gen_seq1 const-decl "Seq(G)" walks_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (vert_circ type-eq-decl nil circuit_decomp_ digraphs) (walk? const-decl "bool" walks_ digraphs) (walk_decomp type-eq-decl nil circuit_decomp_ digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs)) nil (decomp_weight subtype "walks_[bounding_circuits_defs.T, digraph_type[bounding_circuits_defs.T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].gen_seq2(dg(bounding_circuits_defs.G), list_props[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.cd, 0)`v, list_props[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.cd, 1)`v)" "walks_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].Walk(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(bounding_circuits_defs.G))"))) (decomp_weight_TCC16 0 (decomp_weight_TCC16-3 nil 3661771236 ("" (skeep) (("" (typepred (cd)) (("" (expand "length") (("" (assert) nil nil)) nil)) nil)) nil) ((walk_decomp type-eq-decl nil circuit_decomp_ digraphs) (map adt-def-decl "list[T1]" list_adt_map nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (walk? const-decl "bool" walks_ digraphs) (vert_circ type-eq-decl nil circuit_decomp_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (gen_seq1 const-decl "Seq(G)" walks_ digraphs) (Seq type-eq-decl nil walks_ digraphs) (verts_in? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (vert type-eq-decl nil digraphs_ digraphs) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Walk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil bounding_circuits_defs nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (decomp_weight subtype "bounding_circuits_defs.cd" "(list_adt[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].cons?)")) (decomp_weight_TCC16-2 nil 3661626335 ("" (skeep) (("" (typepred " nth[vert_circ(dg(G))](cd, 1)`v") (("1" (expand "vert?") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((walk_decomp type-eq-decl nil circuit_decomp_ digraphs) (walk? const-decl "bool" walks_ digraphs) (vert_circ type-eq-decl nil circuit_decomp_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (gen_seq1 const-decl "Seq(G)" walks_ digraphs) (Seq type-eq-decl nil walks_ digraphs) (verts_in? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (vert type-eq-decl nil digraphs_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs)) nil (decomp_weight subtype "bounding_circuits_defs.cd" "(list_adt[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].cons?)")) (decomp_weight_TCC16-1 nil 3661624396 ("" (subtype-tcc) nil nil) nil nil (decomp_weight subtype "bounding_circuits_defs.cd" "(list_adt[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].cons?)"))) (decomp_weight_TCC17 0 (decomp_weight_TCC17-3 nil 3661771287 ("" (lemma "cdr_decomp") (("" (skeep) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (walk_decomp type-eq-decl nil circuit_decomp_ digraphs) (map adt-def-decl "list[T1]" list_adt_map nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (walk? const-decl "bool" walks_ digraphs) (vert_circ type-eq-decl nil circuit_decomp_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (gen_seq1 const-decl "Seq(G)" walks_ digraphs) (Seq type-eq-decl nil walks_ digraphs) (verts_in? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (vert type-eq-decl nil digraphs_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (cdr_decomp formula-decl nil circuit_decomp_ digraphs) (T formal-type-decl nil bounding_circuits_defs nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs)) nil (decomp_weight subtype "list_adt[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].cdr(bounding_circuits_defs.cd)" "circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].walk_decomp(dg(bounding_circuits_defs.G))")) (decomp_weight_TCC17-2 nil 3661627348 ("" (skeep) (("" (typepred (cd)) (("" (name "ed" "gen_seq2
                             (dg(G), nth[vert_circ(dg(G))](cd, 0)`v,
                              nth[vert_circ(dg(G))](cd, 1)`v)") (("1" (replace -1) (("1" (expand "walk?" 2) (("1" (ground) (("1" (skeep :preds? t) (("1" (expand "ed" -2) (("1" (expand "gen_seq2" -2) (("1" (expand "finseq_appl" 1) (("1" (expand "walk?") (("1" (flatten) (("1" (hide -6) (("1" (inst -6 "0") (("1" (assert) (("1" (expand "list2finseq" -6 1) (("1" (rewrite "map_length[vert_circ(dg(G)), vert(dg(G))]") (("1" (assert) (("1" (expand "finseq_appl" -6) (("1" (expand "list2finseq" -6) (("1" (lemma "map_nth_rw[vert_circ(dg(G)), vert(dg(G))]") (("1" (inst?) (("1" (replaces -1) (("1" (lemma "map_nth_rw[vert_circ(dg(G)), vert(dg(G))]") (("1" (inst?) (("1" (replaces -1) (("1" (replaces -3 1 :dir rl) (("1" (case "n=0") (("1" (replaces -1) (("1" (expand "gen_seq2") (("1" (propax) nil nil)) nil)) nil) ("2" (expand "gen_seq2") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((walk_decomp type-eq-decl nil circuit_decomp_ digraphs) (walk? const-decl "bool" walks_ digraphs) (vert_circ type-eq-decl nil circuit_decomp_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (gen_seq1 const-decl "Seq(G)" walks_ digraphs) (Seq type-eq-decl nil walks_ digraphs) (verts_in? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (vert type-eq-decl nil digraphs_ digraphs) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (Walk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (gen_seq2 const-decl "Seq(G)" walks_ digraphs)) nil (decomp_weight subtype "list_adt[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].cdr(bounding_circuits_defs.cd)" "circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].walk_decomp(dg(bounding_circuits_defs.G))")) (decomp_weight_TCC17-1 nil 3661624396 ("" (subtype-tcc) nil nil) nil nil (decomp_weight subtype "list_adt[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].cdr(bounding_circuits_defs.cd)" "circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].walk_decomp(dg(bounding_circuits_defs.G))"))) (decomp_weight_TCC18 0 (decomp_weight_TCC18-3 nil 3661771487 ("" (skeep) (("" (typepred (cd)) (("" (expand "length" 2 2) (("" (ground) (("" (expand "length" -2) (("" (lift-if 2) (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((walk_decomp type-eq-decl nil circuit_decomp_ digraphs) (map adt-def-decl "list[T1]" list_adt_map nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (walk? const-decl "bool" walks_ digraphs) (vert_circ type-eq-decl nil circuit_decomp_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (gen_seq1 const-decl "Seq(G)" walks_ digraphs) (Seq type-eq-decl nil walks_ digraphs) (verts_in? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (vert type-eq-decl nil digraphs_ digraphs) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Walk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil bounding_circuits_defs nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil (decomp_weight termination "bounding_circuits_defs.decomp_weight(list_adt[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].cdr(bounding_circuits_defs.cd))" "nil")) (decomp_weight_TCC18-2 nil 3661627390 ("" (skeep) (("" (typepred (cd)) (("" (expand "length") (("" (assert) nil nil)) nil)) nil)) nil) ((walk_decomp type-eq-decl nil circuit_decomp_ digraphs) (walk? const-decl "bool" walks_ digraphs) (vert_circ type-eq-decl nil circuit_decomp_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (gen_seq1 const-decl "Seq(G)" walks_ digraphs) (Seq type-eq-decl nil walks_ digraphs) (verts_in? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (vert type-eq-decl nil digraphs_ digraphs) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (Walk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs)) nil (decomp_weight termination "bounding_circuits_defs.decomp_weight(list_adt[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].cdr(bounding_circuits_defs.cd))" "nil")) (decomp_weight_TCC18-1 nil 3661624396 ("" (subtype-tcc) nil nil) nil nil (decomp_weight termination "bounding_circuits_defs.decomp_weight(list_adt[circuit_decomp_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert_circ(dg(bounding_circuits_defs.G))].cdr(bounding_circuits_defs.cd))" "nil"))) (decomp_weight_def_TCC1 0 (decomp_weight_def_TCC1-1 nil 3661779169 ("" (skeep) (("" (typepred "decomp_to_walk
               [T, digraph_type[T], digraph_verts, digraph_edges,
                digraph_size, digraph_make]
               (dg(G), cd)") (("" (assert) nil nil)) nil)) nil) ((G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Sign3 type-eq-decl nil sign3 reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (decomp_to_walk def-decl "{ww: Walk(G) |
   LET W = drop_circuits(G, cd) IN
     first(ww) = first(W) AND last(ww) = last(W)}" circuit_decomp_ digraphs) (last const-decl "T" seq_extras structures) (drop_circuits const-decl "{W: Walk(G) | length(W) = length(cd)}" circuit_decomp_ digraphs) (first const-decl "T" seq_extras structures) (not_empty_seq type-eq-decl nil seq_extras structures) (/= const-decl "boolean" notequal nil) (walk_decomp type-eq-decl nil circuit_decomp_ digraphs) (map adt-def-decl "list[T1]" list_adt_map nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (walk? const-decl "bool" walks_ digraphs) (length def-decl "nat" list_props nil) (vert_circ type-eq-decl nil circuit_decomp_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (gen_seq1 const-decl "Seq(G)" walks_ digraphs) (Seq type-eq-decl nil walks_ digraphs) (verts_in? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (= const-decl "[T, T -> boolean]" equalities nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (vert type-eq-decl nil digraphs_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (T formal-type-decl nil bounding_circuits_defs nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs)) nil (decomp_weight_def subtype "circuit_decomp_[bounding_circuits_defs.T, digraph_type[bounding_circuits_defs.T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].decomp_to_walk(dg(bounding_circuits_defs.G), bounding_circuits_defs.cd)" "walks_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].Walk(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(bounding_circuits_defs.G))"))) (decomp_weight_def_TCC2 0 (decomp_weight_def_TCC2-2 "" 3790335625 ("" (use "measure_matrix_assoc") (("" (assert) nil nil)) nil) ((N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_matrix_assoc formula-decl nil measures nil)) shostak (decomp_weight_def subtype "measures[bounding_circuits_defs.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(bounding_circuits_defs.f)}")) (decomp_weight_def_TCC2-1 nil 3661779169 ("" (then (use "measure_matrix_assoc") (assert))) ((measure_matrix_assoc formula-decl nil measures nil)) nil (decomp_weight_def subtype "measures[bounding_circuits_defs.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(bounding_circuits_defs.f)}"))) (decomp_weight_def_TCC3 0 (decomp_weight_def_TCC3-2 "" 3790335625 ("" (rewrite "id_is_identity") (("" (assert) nil nil)) nil) ((N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (id_is_identity formula-decl nil measures nil)) shostak (decomp_weight_def subtype "measures[bounding_circuits_defs.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[bounding_circuits_defs.N].*)(bounding_circuits_defs.zero)}")) (decomp_weight_def_TCC3-1 nil 3661779169 ("" (then (rewrite "id_is_identity") (assert))) ((id_is_identity formula-decl nil measures nil)) shostak (decomp_weight_def subtype "measures[bounding_circuits_defs.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[bounding_circuits_defs.N].*)(bounding_circuits_defs.zero)}"))) (decomp_weight_def_TCC4 0 (decomp_weight_def_TCC4-1 nil 3661779169 ("" (subtype-tcc) nil nil) ((T formal-type-decl nil bounding_circuits_defs nil) (vert const-decl "bool" c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (decomp_weight_def subtype "c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].get_wgt" "[[W: wgd_type[T, Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[bounding_circuits_defs.T].digraph_edges(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (decomp_weight_def 0 (decomp_weight_def-1 nil 3661799940 ("" (case "FORALL (n:posnat, cd: walk_decomp(dg(G))):
                     n=length(cd) IMPLIES decomp_weight(cd) = wgt_walk(G, decomp_to_walk(dg(G), cd))") (("1" (skeep) (("1" (inst?) (("1" (inst -1 "length(cd)") (("1" (skeep) (("1" (typepred "vc`v") (("1" (expand "vert?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "n") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (skeep) (("3" (case "j=0") (("1" (replaces -1) (("1" (hide -1) (("1" (skeep) (("1" (expand "decomp_weight") (("1" (assert) (("1" (expand "decomp_to_walk") (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "decomp_to_walk" 2 1) (("2" (assert) (("2" (rewrite "wgt_comp") (("1" (expand "decomp_weight" 2 1) (("1" (expand "nth" 2 1) (("1" (typepred "decomp_to_walk(dg(G), cdr(cd))") (("1" (replace -3) (("1" (typepred "car(cd)") (("1" (case "last(car(cd)`c) = car(cd)`v") (("1" (replaces -1) (("1" (expand "nth" 2 1) (("1" (expand "drop_circuits" 2 1) (("1" (expand "first" 2 1) (("1" (expand "finseq_appl" 2) (("1" (expand "list2finseq" 2 1) (("1" (with-tccs (lemma "map_nth_rw[vert_circ(dg(G)), vert(dg(G))]")) (("1" (inst?) (("1" (replaces -1) (("1" (expand "nth" 2 1) (("1" (inst - "cdr(cd)") (("1" (expand "length" -8) (("1" (assert) (("1" (lift-if -7) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred (cd)) (("2" (expand "length" -11) (("2" (lift-if -11) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skeep) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) (("1" (replaces -1 1) (("1" (expand "gen_seq1") (("1" (expand "last") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "circuit_at?") (("2" (expand "circuit?") (("2" (expand "pre_circuit?") (("2" (flatten) (("2" (expand "finseq_appl") (("2" (expand "last") (("2" (expand "finseq_appl") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "cd") (("2" (typepred "decomp_to_walk(dg(G), cdr(cd))") (("1" (replace -3 1) (("1" (case "last(car(cd)`c) = car(cd)`v") (("1" (replaces -1) (("1" (expand "drop_circuits" 1 1) (("1" (expand "first " 1) (("1" (expand "finseq_appl" 1) (("1" (expand "list2finseq" 1) (("1" (lemma "map_nth_rw[vert_circ(dg(G)), vert(dg(G))]") (("1" (inst?) (("1" (replaces -1) (("1" (hide (-1 -2 -3 -4 -5 -8 3)) (("1" (expand "walk?") (("1" (flatten) (("1" (hide -2) (("1" (inst -2 "0") (("1" (assert) (("1" (expand "list2finseq" -2 1) (("1" (with-tccs (rewrite "map_length[vert_circ(dg(G)), vert(dg(G))]")) (("1" (assert) (("1" (expand "finseq_appl") (("1" (expand "list2finseq") (("1" (with-tccs (lemma "map_nth_rw[vert_circ(dg(G)), vert(dg(G))]")) (("1" (inst?) (("1" (replaces -1) (("1" (with-tccs (lemma "map_nth_rw[vert_circ(dg(G)), vert(dg(G))]")) (("1" (inst?) (("1" (replaces -1) (("1" (expand "nth" -2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred (cd)) (("2" (expand "length" -) (("2" (ground) nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "car(cd)") (("1" (ground) (("1" (replaces -1) (("1" (expand "last") (("1" (expand "gen_seq1") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "circuit_at?") (("2" (expand "circuit?") (("2" (expand "pre_circuit?") (("2" (expand "last") (("2" (expand "finseq_appl") (("2" (assert) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "id_is_identity") (("4" (assert) nil nil)) nil) ("5" (lemma "measure_matrix_assoc") (("5" (assert) nil nil)) nil) ("6" (hide-all-but 1) (("6" (skeep*) (("6" (typepred "decomp_to_walk
                     [T, digraph_type[T], digraph_verts, digraph_edges,
                      digraph_size, digraph_make]
                     (dg(G), cd)") (("6" (propax) nil nil)) nil)) nil)) nil) ("7" (hide-all-but 1) (("7" (skeep*) (("7" (typepred "vc`v") (("7" (expand "vert?") (("7" (expand "digraph_verts") (("7" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "id_is_identity") (("3" (skeep) nil nil)) nil) ("4" (lemma "measure_matrix_assoc") (("4" (assert) nil nil)) nil) ("5" (hide-all-but 1) (("5" (skeep*) (("5" (typepred "decomp_to_walk
                   [T, digraph_type[T], digraph_verts, digraph_edges,
                    digraph_size, digraph_make]
                   (dg(G), cd)") (("5" (propax) nil nil)) nil)) nil)) nil) ("6" (hide-all-but 1) (("6" (skeep :preds? t) (("6" (typepred "vc`v") (("6" (expand "vert?") (("6" (expand "digraph_verts") (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((measure_matrix_assoc formula-decl nil measures nil) (id_is_identity formula-decl nil measures nil) (map_length formula-decl nil more_map_props nil) (circuit? const-decl "bool" circuits_ digraphs) (int_minus_int_is_int application-judgement "int" integers nil) (pre_circuit? const-decl "bool" circuits_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (< const-decl "bool" reals nil) (gen_seq2 const-decl "Seq(G)" walks_ digraphs) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (map_nth_rw formula-decl nil more_map_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (cd skolem-const-decl "walk_decomp
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G))" bounding_circuits_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (wgt_comp formula-decl nil weighted_digraphs_ digraphs) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (nth def-decl "T" list_props nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (identity? const-decl "bool" operator_defs nil) (associative? const-decl "bool" operator_defs nil) (vert const-decl "bool" c_digraphs_def digraphs) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (T formal-type-decl nil bounding_circuits_defs nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (Walk type-eq-decl nil walks_ digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (vert type-eq-decl nil digraphs_ digraphs) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (verts_in? const-decl "bool" walks_ digraphs) (Seq type-eq-decl nil walks_ digraphs) (gen_seq1 const-decl "Seq(G)" walks_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (vert_circ type-eq-decl nil circuit_decomp_ digraphs) (walk? const-decl "bool" walks_ digraphs) (list2finseq const-decl "finseq[T]" list2finseq nil) (map adt-def-decl "list[T1]" list_adt_map nil) (walk_decomp type-eq-decl nil circuit_decomp_ digraphs) (decomp_weight def-decl "Measure_Matrix" bounding_circuits_defs nil) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (/= const-decl "boolean" notequal nil) (not_empty_seq type-eq-decl nil seq_extras structures) (first const-decl "T" seq_extras structures) (drop_circuits const-decl "{W: Walk(G) | length(W) = length(cd)}" circuit_decomp_ digraphs) (last const-decl "T" seq_extras structures) (decomp_to_walk def-decl "{ww: Walk(G) |
   LET W = drop_circuits(G, cd) IN
     first(ww) = first(W) AND last(ww) = last(W)}" circuit_decomp_ digraphs)) nil)) (walk_bounding_TCC1 0 (walk_bounding_TCC1-1 nil 3658703132 ("" (skeep) (("" (lemma "walk?_caret") (("" (inst?) (("1" (assert) (("1" (expand "^") (("1" (expand "min") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "id_is_identity") nil nil) ("3" (use "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ((digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil bounding_circuits_defs nil) (walk?_caret formula-decl nil walks_ digraphs) (measure_matrix_assoc formula-decl nil measures nil) (id_is_identity formula-decl nil measures nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (^ const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (Walk type-eq-decl nil walks_ digraphs) (walk? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (identity? const-decl "bool" operator_defs nil) (id const-decl "Measure_Matrix" measures nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (associative? const-decl "bool" operator_defs nil) (* const-decl "Measure_Matrix" measures nil)) nil (walk_bounding subtype "finite_sequences[bounding_circuits_defs.T].^(bounding_circuits_defs.walk, (0, 1))" "walks_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].Walk(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(bounding_circuits_defs.G))"))) (walk_bounding_TCC2 0 (walk_bounding_TCC2-1 nil 3658703132 ("" (use "measure_matrix_assoc") (("" (assert) nil nil)) nil) ((N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_matrix_assoc formula-decl nil measures nil)) nil (walk_bounding subtype "measures[bounding_circuits_defs.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(bounding_circuits_defs.f)}"))) (walk_bounding_TCC3 0 (walk_bounding_TCC3-1 nil 3658703132 ("" (rewrite "id_is_identity") (("" (assert) nil nil)) nil) ((N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (id_is_identity formula-decl nil measures nil)) nil (walk_bounding subtype "measures[bounding_circuits_defs.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[bounding_circuits_defs.N].*)(bounding_circuits_defs.zero)}"))) (walk_bounding_TCC4 0 (walk_bounding_TCC4-1 nil 3658703132 ("" (termination-tcc) nil nil) ((N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (id_fun const-decl "Sign3" measures nil) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (form_matrix const-decl "{m: Measure_Matrix | eq(m, f)}" measures nil) (id const-decl "Measure_Matrix" measures nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (T formal-type-decl nil bounding_circuits_defs nil) (vert const-decl "bool" c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Sign3 type-eq-decl nil sign3 reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (walk_bounding subtype "c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].get_wgt" "[[W: wgd_type[T, Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[bounding_circuits_defs.T].digraph_edges(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (walk_bounding_TCC5 0 (walk_bounding_TCC5-1 nil 3658703132 ("" (subtype-tcc) nil nil) ((array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (form_matrix const-decl "{m: Measure_Matrix | eq(m, f)}" measures nil) (id const-decl "Measure_Matrix" measures nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (walk_bounding subtype "(number_fields.-)(length(bounding_circuits_defs.walk), 1)" "nat"))) (walk_bounding_TCC6 0 (walk_bounding_TCC6-2 nil 3661627907 ("" (skeep) (("" (lemma "walk?_caret") (("" (inst?) (("" (assert) (("" (expand "^") (("" (expand "min") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil bounding_circuits_defs nil) (walk?_caret formula-decl nil walks_ digraphs) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (^ const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (Walk type-eq-decl nil walks_ digraphs) (walk? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (walk_bounding subtype "finite_sequences[bounding_circuits_defs.T].^(bounding_circuits_defs.walk, (1, (number_fields.-)(length(bounding_circuits_defs.walk), 1)))" "walks_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].Walk(dg(bounding_circuits_defs.G))")) (walk_bounding_TCC6-1 nil 3658703132 ("" (subtype-tcc) nil nil) ((finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (walk? const-decl "bool" walks_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (edge? const-decl "bool" digraphs_ digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (is_finite const-decl "bool" finite_sets nil) (vert? const-decl "bool" digraphs_ digraphs)) shostak (walk_bounding subtype "finite_sequences[bounding_circuits_defs.T].^(bounding_circuits_defs.walk, (1, (number_fields.-)(length(bounding_circuits_defs.walk), 1)))" "walks_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].Walk(dg(bounding_circuits_defs.G))"))) (walk_bounding_TCC7 0 (walk_bounding_TCC7-1 nil 3661624396 ("" (termination-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-type-decl nil bounding_circuits_defs nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (prewalk type-eq-decl nil walks_ digraphs) (walk? const-decl "bool" walks_ digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (Walk type-eq-decl nil walks_ digraphs) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (vert const-decl "bool" c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (append def-decl "list[T]" list_props nil) (^ def-decl "list[T]" more_list_props structures) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (id_fun const-decl "Sign3" measures nil) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (form_matrix const-decl "{m: Measure_Matrix | eq(m, f)}" measures nil) (id const-decl "Measure_Matrix" measures nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (^ const-decl "finseq" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (walk_bounding termination "bounding_circuits_defs.walk_bounding(finite_sequences[bounding_circuits_defs.T].^(bounding_circuits_defs.walk, (1, (number_fields.-)(length(bounding_circuits_defs.walk), 1))), bounding_circuits_defs.bs)" "nil"))) (walk_bounding_TCC8 0 (walk_bounding_TCC8-1 nil 3661624396 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (walk_bounding subtype "0" "below[length(walk)]"))) (walk_bounding_TCC9 0 (walk_bounding_TCC9-1 nil 3661624396 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (walk? const-decl "bool" walks_ digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (Walk type-eq-decl nil walks_ digraphs) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (edge? const-decl "bool" digraphs_ digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (T formal-type-decl nil bounding_circuits_defs nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (vert? const-decl "bool" digraphs_ digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (walk_bounding subtype "finite_sequences[bounding_circuits_defs.T].finseq_appl(bounding_circuits_defs.walk)(0)" "digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))"))) (walk_bounding_def_TCC1 0 (walk_bounding_def_TCC1-1 nil 3661801027 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (Walk type-eq-decl nil walks_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (<= const-decl "bool" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil bounding_circuits_defs nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (walk_bounding_def subtype "bounding_circuits_defs.cc" "walks_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].Walk(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(bounding_circuits_defs.G))"))) (walk_bounding_def_TCC2 0 (walk_bounding_def_TCC2-2 "" 3790335660 ("" (use "measure_matrix_assoc") (("" (assert) nil nil)) nil) ((N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_matrix_assoc formula-decl nil measures nil)) shostak (walk_bounding_def subtype "measures[bounding_circuits_defs.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(bounding_circuits_defs.f)}")) (walk_bounding_def_TCC2-1 nil 3661801027 ("" (then (use "measure_matrix_assoc") (assert))) ((measure_matrix_assoc formula-decl nil measures nil)) nil (walk_bounding_def subtype "measures[bounding_circuits_defs.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(bounding_circuits_defs.f)}"))) (walk_bounding_def_TCC3 0 (walk_bounding_def_TCC3-2 "" 3790335660 ("" (rewrite "id_is_identity") (("" (assert) nil nil)) nil) ((N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (id_is_identity formula-decl nil measures nil)) shostak (walk_bounding_def subtype "measures[bounding_circuits_defs.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[bounding_circuits_defs.N].*)(bounding_circuits_defs.zero)}")) (walk_bounding_def_TCC3-1 nil 3661801027 ("" (then (rewrite "id_is_identity") (assert))) ((id_is_identity formula-decl nil measures nil)) shostak (walk_bounding_def subtype "measures[bounding_circuits_defs.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[bounding_circuits_defs.N].*)(bounding_circuits_defs.zero)}"))) (walk_bounding_def_TCC4 0 (walk_bounding_def_TCC4-1 nil 3661801027 ("" (subtype-tcc) nil nil) ((T formal-type-decl nil bounding_circuits_defs nil) (vert const-decl "bool" c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (walk_bounding_def subtype "c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].get_wgt" "[[W: wgd_type[T, Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[bounding_circuits_defs.T].digraph_edges(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (walk_bounding_def 0 (walk_bounding_def-3 nil 3661802428 ("" (skolem 1 ("n" "_" "bs")) (("" (case "FORALL (m:posnat, walk: Walk(dg(G))):
              m=length(walk) AND ( FORALL (v2: vert(dg(G))):
                  FORALL (cc: prewalk
                              | (circuit_at?(dg(G), cc, v2) AND length(cc) <= n)):
                    EXISTS (M2: Measure_Matrix):
                      member(M2, bs(v2)) AND M2 <= wgt_walk(G, cc))
                IMPLIES
                (FORALL ((cd: walk_decomp(dg(G))
                              | FORALL (j: below(length(cd))):
                                  nth(cd, j)`c`length <= n)):
                   drop_circuits(dg(G), cd) = walk IMPLIES
                    (EXISTS (M: Measure_Matrix):
                       member(M, walk_bounding(walk, bs)) AND
                        M <= decomp_weight(cd)))") (("1" (skeep) (("1" (inst - "length(walk)" "walk") (("1" (assert) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "m") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (skeep) (("3" (skeep) (("3" (assert) (("3" (skeep :preds? t) (("3" (hide -1) (("3" (case "j=0") (("1" (hide -5) (("1" (expand "walk_bounding") (("1" (assert) (("1" (lemma "decomp_weight_def") (("1" (inst?) (("1" (replace -1) (("1" (expand "decomp_to_walk") (("1" (expand "finseq_appl") (("1" (inst -8 "walk`seq(0)") (("1" (typepred "car(cd)") (("1" (ground) (("1" (replace -1) (("1" (expand "gen_seq1") (("1" (expand "wgt_walk") (("1" (expand "wgt_aux") (("1" (inst 1 "id") (("1" (expand "member") (("1" (expand "<=") (("1" (expand "le") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -9 "car(cd)`c") (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (inst?) (("1" (assert) (("1" (expand "member" +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst - " 0 ") (("2" (expand "nth") (("2" (assert) (("2" (replace -9 1 :dir rl) (("2" (expand "drop_circuits") (("2" (expand "list2finseq") (("2" (expand "nth") (("2" (expand "map") (("2" (lift-if 1) (("2" (ground) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walk") (("2" (hide -6) (("2" (expand "walk?") (("2" (expand "verts_in?") (("2" (inst -2 "0") (("2" (expand "vert?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst -4 "walk^(1, length(walk)-1)") (("1" (expand "^" -4 1) (("1" (expand "min") (("1" (ground) (("1" (inst -1 "cdr(cd)") (("1" (ground) (("1" (skeep) (("1" (expand "walk_bounding" 2) (("1" (typepred "list_prod(map(LAMBDA (m1: Measure_Matrix):
                                             m1 * wgt_walk(G, walk ^ (0, 1)))
                                          (cons(id, bs(finseq_appl[T](walk)(0)))),
                                       walk_bounding(
                                                     walk ^ (1, length(walk) - 1),
                                                     bs))") (("1" (hide -1) (("1" (expand "decomp_weight" 2) (("1" (inst -9 "walk`seq(0)") (("1" (inst -9 "nth(cd, 0)`c") (("1" (skeep) (("1" (inst -1 "M2* wgt_walk(G, walk ^ (0, 1))" "M") (("1" (assert) (("1" (ground) (("1" (skeep) (("1" (inst 2 "M_1") (("1" (assert) (("1" (case-replace "gen_seq2(dg(G), nth(cd, 0)`v, nth(cd, 1)`v) = walk ^ (0, 1)") (("1" (lemma "mult_right_preserves_order") (("1" (inst - " wgt_walk(G, walk ^ (0, 1))" "M2" "wgt_walk(G, nth(cd, 0)`c)") (("1" (assert) (("1" (lemma "mult_right_preserves_order") (("1" (inst -1 " M" "M2 * wgt_walk(G, walk ^ (0, 1))" "       wgt_walk(G, nth(cd, 0)`c) * wgt_walk(G, walk ^ (0, 1))") (("1" (assert) (("1" (lemma "mult_left_preserves_order") (("1" (inst - "  wgt_walk(G, nth(cd, 0)`c) * wgt_walk(G, walk ^ (0, 1))" "M" "decomp_weight(cdr(cd))") (("1" (assert) (("1" (lemma "matrices_order") (("1" (expand "partial_order?") (("1" (expand "preorder?") (("1" (flatten) (("1" (hide (-1 -3)) (("1" (expand "transitive?") (("1" (inst-cp - "M_1" "M2 * wgt_walk(G, walk ^ (0, 1)) * M" "wgt_walk(G, nth(cd, 0)`c) * wgt_walk(G, walk ^ (0, 1)) * M") (("1" (assert) (("1" (inst - " M_1" "wgt_walk(G, nth(cd, 0)`c) * wgt_walk(G, walk ^ (0, 1)) * M " "wgt_walk(G, nth(cd, 0)`c) * wgt_walk(G, walk ^ (0, 1)) *
                                          decomp_weight(cdr(cd))") (("1" (assert) nil nil) ("2" (lemma "id_is_identity") (("2" (propax) nil nil)) nil) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil nil)) nil) ("4" (hide-all-but 1) (("4" (skeep :preds? t) (("4" (typepred "vc`v") (("4" (expand "vert?") (("4" (expand "digraph_verts") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "id_is_identity") (("3" (propax) nil nil)) nil) ("4" (lemma "measure_matrix_assoc") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "id_is_identity") (("2" (propax) nil nil)) nil) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil nil)) nil) ("4" (hide-all-but 1) (("4" (skeep :preds? t) (("4" (typepred "vc`v") (("4" (expand "vert?") (("4" (expand "digraph_verts") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "id_is_identity") (("3" (propax) nil nil)) nil) ("4" (lemma "measure_matrix_assoc") (("4" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "id_is_identity") (("3" (propax) nil nil)) nil) ("4" (lemma "measure_matrix_assoc") (("4" (propax) nil nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("1" (expand "gen_seq2") (("1" (expand "^") (("1" (expand "min") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("1" (expand "^") (("1" (expand "gen_seq2") (("1" (ground) (("1" (lift-if 1) (("1" (replace -12 1 :dir rl) (("1" (hide (-1 -2 -3 -4 -6)) (("1" (hide 3) (("1" (expand "drop_circuits") (("1" (expand "list2finseq") (("1" (with-tccs (lemma "map_nth_rw[vert_circ(dg(G)), vert(dg(G))]")) (("1" (inst?) (("1" (replaces -1) (("1" (ground) (("1" (typepred "x!1") (("1" (ground) (("1" (expand "gen_seq2") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred (x!1)) (("2" (expand "gen_seq2") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "member_nth[Measure_Matrix]") (("2" (inst - " bs(walk`seq(0))" " M2") (("2" (assert) (("2" (skeep) (("2" (lemma "nth_member[Measure_Matrix]") (("2" (inst - "map(LAMBDA (m1: Measure_Matrix):
                                           m1 * wgt_walk(G, walk ^ (0, 1)))
                                        (cons(id, bs(finseq_appl[T](walk)(0))))" "M2* wgt_walk(G, walk ^ (0, 1))" "i+1") (("1" (assert) (("1" (lemma "map_nth_rw[Measure_Matrix, Measure_Matrix]") (("1" (inst?) (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "finseq_appl") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (expand "length" 1) (("2" (expand "finseq_appl") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (lemma "id_is_identity") (("3" (propax) nil nil)) nil) ("4" (lemma "measure_matrix_assoc") (("4" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length[Measure_Matrix, Measure_Matrix]") (("2" (expand "length") (("2" (typepred "i") (("2" (expand "finseq_appl") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (lemma "id_is_identity") (("3" (propax) nil nil)) nil) ("4" (lemma "measure_matrix_assoc") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "id_is_identity") (("2" (propax) nil nil)) nil) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil nil)) nil) ("4" (lemma "walk?_caret") (("4" (inst?) (("4" (assert) (("4" (expand "^") (("4" (expand "min") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -6 "0") (("2" (assert) (("2" (typepred "nth(cd, 0)") (("1" (ground) (("1" (inst -2 "id * wgt_walk(G, walk ^ (0, 1))" "M") (("1" (ground) (("1" (skeep) (("1" (inst 3 " M_1") (("1" (assert) (("1" (replace -3 3) (("1" (expand "wgt_walk" 3 1) (("1" (expand "gen_seq1") (("1" (expand "wgt_aux") (("1" (case-replace "gen_seq2(dg(G), nth(cd, 0)`v, nth(cd, 1)`v) = walk ^ (0, 1)") (("1" (lemma "mult_left_preserves_order") (("1" (inst -1 "id * wgt_walk(G, walk ^ (0, 1))" "M " " decomp_weight(cdr(cd))") (("1" (assert) (("1" (lemma "matrices_order") (("1" (expand "partial_order?") (("1" (expand "preorder?") (("1" (flatten) (("1" (hide -1 -3) (("1" (expand "transitive?") (("1" (inst -1 "M_1 " "id * wgt_walk(G, walk ^ (0, 1)) * M " "id * wgt_walk(G, walk ^ (0, 1)) * decomp_weight(cdr(cd))") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "id_is_identity") (("3" (propax) nil nil)) nil) ("4" (lemma "measure_matrix_assoc") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "id_is_identity") (("3" (propax) nil nil)) nil) ("4" (lemma "measure_matrix_assoc") (("4" (propax) nil nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("1" (expand "gen_seq2") (("1" (expand "^") (("1" (expand "min") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("1" (expand "^") (("1" (expand "gen_seq2") (("1" (replace -11 1 :dir rl) (("1" (expand "drop_circuits " 1) (("1" (expand "list2finseq") (("1" (lemma "map_nth_rw[vert_circ(dg(G)), vert(dg(G))]") (("1" (inst?) (("1" (replaces -1) (("1" (lift-if 1) (("1" (ground) (("1" (typepred (x!1)) (("1" (expand "gen_seq2") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred (x!1)) (("2" (expand "gen_seq2") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "map") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma "id_is_identity") (("2" (propax) nil nil)) nil) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil nil)) nil) ("4" (lemma "walk?_caret") (("4" (inst?) (("4" (assert) (("4" (expand "^") (("4" (expand "min") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -10 1 :dir rl) (("2" (expand "drop_circuits " 1) (("2" (expand "list2finseq") (("2" (expand "map" 1) (("2" (lift-if 1) (("2" (ground) (("1" (expand "length") (("1" (ground) nil nil)) nil) ("2" (expand "nth " 2 2) (("2" (expand "nth" -1 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -) (("2" (typepred "walk") (("2" (expand "walk?") (("2" (flatten) (("2" (expand "verts_in?") (("2" (inst -2 "0") (("2" (ground) (("2" (expand "vert?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "id_is_identity") (("2" (propax) nil nil)) nil) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil nil)) nil) ("4" (lemma "walk?_caret") (("4" (inst?) (("4" (assert) (("4" (expand "^") (("4" (expand "min") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "finseq_appl") (("5" (assert) (("5" (typepred "walk") (("5" (expand "walk?") (("5" (hide -6) (("5" (expand "verts_in?") (("5" (flatten) (("5" (inst?) (("5" (assert) (("5" (expand "vert?") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("1" (expand "drop_circuits" 1 1) (("1" (expand "list2finseq" 1) (("1" (rewrite "map_length[vert_circ(dg(G)), vert(dg(G))]") (("1" (expand "^") (("1" (expand "min") (("1" (case "length(cd) = walk`length") (("1" (expand " length" -1 1) (("1" (lift-if -1) (("1" (ground) nil nil)) nil)) nil) ("2" (replace -7 :dir rl) (("2" (expand "drop_circuits") (("2" (expand "list2finseq") (("2" (rewrite "map_length[vert_circ(dg(G)), vert(dg(G))]") nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("1" (expand "drop_circuits" 1) (("1" (expand "list2finseq") (("1" (lemma "map_nth_rw[vert_circ(dg(G)), vert(dg(G))]") (("1" (inst?) (("1" (replace -1) (("1" (expand "^") (("1" (replace -8 1 :dir rl) (("1" (expand "drop_circuits") (("1" (expand "list2finseq") (("1" (expand "map" 1) (("1" (lift-if 1) (("1" (ground) (("1" (expand "length") (("1" (assert) nil nil)) nil) ("2" (expand "nth" 2 2) (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "length(cd) = walk`length") (("1" (assert) (("1" (expand " length" -1 1) (("1" (lift-if -1) (("1" (assert) (("1" (ground) (("1" (expand "walk?") (("1" (ground) (("1" (expand "verts_in?") (("1" (skeep) (("1" (inst -3 "i+1") (("1" (expand "list2finseq") (("1" (hide -4) (("1" (expand "nth" -3) (("1" (expand "map" -3) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred (i)) (("2" (expand "map" 1) (("2" (expand "list2finseq") (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -5 "n!1+1") (("2" (expand "map" -5 1) (("2" (expand "list2finseq" -5 1) (("2" (expand "list2finseq" -1 1) (("2" (expand "length" -5 1) (("2" (assert) (("2" (expand "finseq_appl") (("2" (expand "map" -5) (("2" (expand "list2finseq") (("2" (expand "nth" -5) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -4 "j!1+1") (("2" (expand "nth " -4) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -7 1 :dir rl) (("2" (expand "drop_circuits") (("2" (expand "list2finseq") (("2" (rewrite "map_length[vert_circ(dg(G)), vert(dg(G))]") nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "length") (("4" (lift-if -1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "walk?_caret") (("2" (inst?) (("2" (assert) (("2" (expand "^") (("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (skeep* :preds? t) (("4" (typepred "vc`v") (("4" (expand "vert?") (("4" (expand "digraph_verts") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (lemma "id_is_identity") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (skeep) (("6" (lemma "measure_matrix_assoc") (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (skeep) (("7" (skeep) (("7" (typepred (cc)) (("7" (expand "circuit_at?") (("7" (expand "circuit?") (("7" (expand "pre_circuit?") (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (hide-all-but 1) (("3" (skeep* :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (lemma "id_is_identity") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (lemma "measure_matrix_assoc") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (typepred (cc)) (("6" (expand "circuit_at?") (("6" (expand "circuit?") (("6" (expand "pre_circuit?") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((decomp_weight def-decl "Measure_Matrix" bounding_circuits_defs nil) (walk_bounding def-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (drop_circuits const-decl "{W: Walk(G) | length(W) = length(cd)}" circuit_decomp_ digraphs) (nth def-decl "T" list_props nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (walk_decomp type-eq-decl nil circuit_decomp_ digraphs) (map adt-def-decl "list[T1]" list_adt_map nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (vert_circ type-eq-decl nil circuit_decomp_ digraphs) (gen_seq1 const-decl "Seq(G)" walks_ digraphs) (Seq type-eq-decl nil walks_ digraphs) (verts_in? const-decl "bool" walks_ digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (<= const-decl "bool" measures nil) (member def-decl "bool" list_props nil) (<= const-decl "bool" reals nil) (circuit_at? const-decl "bool" circuits_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (walk? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (T formal-type-decl nil bounding_circuits_defs nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (associative? const-decl "bool" operator_defs nil) (identity? const-decl "bool" operator_defs nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (vert const-decl "bool" c_digraphs_def digraphs) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (n skolem-const-decl "nat" bounding_circuits_defs nil) (bs skolem-const-decl "[vert[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
      digraph_make](dg(G)) ->
   list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (decomp_weight_def formula-decl nil bounding_circuits_defs nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (NOT const-decl "[bool -> bool]" booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (cd skolem-const-decl "{cd: walk_decomp(dg(G)) |
   FORALL (j: below(length(cd))): nth(cd, j)`c`length <= n}" bounding_circuits_defs nil) (le const-decl "bool" measures nil) (wgt_aux def-decl "Weight" weighted_digraphs_ digraphs) (walk skolem-const-decl "Walk[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G))" bounding_circuits_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (decomp_to_walk def-decl "{ww: Walk(G) |
   LET W = drop_circuits(G, cd) IN
     first(ww) = first(W) AND last(ww) = last(W)}" circuit_decomp_ digraphs) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (^ const-decl "finseq" finite_sequences nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (list_prod const-decl "{L: list[Measure_Matrix[N]] |
   FORALL (m1, m2: Measure_Matrix):
     member(m1, l1) AND member(m2, l2) IMPLIES
      EXISTS (M: Measure_Matrix): member(M, L) AND M <= m1 * m2}" bounding_circuits_defs nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (gen_seq2 const-decl "Seq(G)" walks_ digraphs) (matrices_order formula-decl nil measures nil) (preorder? const-decl "bool" orders nil) (id_is_identity formula-decl nil measures nil) (measure_matrix_assoc formula-decl nil measures nil) (transitive? const-decl "bool" relations nil) (partial_order? const-decl "bool" orders nil) (mult_left_preserves_order formula-decl nil measures nil) (mult_right_preserves_order formula-decl nil measures nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (map_nth_rw formula-decl nil more_map_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (x!1 skolem-const-decl "below[gen_seq2(dg(G), nth(cd, 0)`v, nth(cd, 1)`v)`length]" bounding_circuits_defs nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (i skolem-const-decl "below(length(bs(walk`seq(0))))" bounding_circuits_defs nil) (map_length formula-decl nil more_map_props nil) (nth_member formula-decl nil more_list_props structures) (member_nth formula-decl nil more_list_props structures) (walk?_caret formula-decl nil walks_ digraphs) (x!1 skolem-const-decl "below[gen_seq2(dg(G), nth(cd, 0)`v, nth(cd, 1)`v)`length]" bounding_circuits_defs nil) (i skolem-const-decl "below(length
        (list2finseq
             [vert[T, digraph_type[T], digraph_verts[T], digraph_edges[T],
                   digraph_size[T], digraph_make[T]](dg(G))]
             (map[vert_circ
                      [T, digraph_type[T], digraph_verts[T],
                       digraph_edges[T], digraph_size[T],
                       digraph_make[T]](dg(G)),
                  vert[T, digraph_type[T], digraph_verts[T],
                       digraph_edges[T], digraph_size[T],
                       digraph_make[T]](dg(G))]
                  (LAMBDA (vc:
                             vert_circ
                                 [T, digraph_type[T], digraph_verts[T],
                                  digraph_edges[T], digraph_size[T],
                                  digraph_make[T]](dg(G))):
                     vc`v)
                  (cdr[vert_circ
                           [T, digraph_type[T], digraph_verts,
                            digraph_edges, digraph_size, digraph_make](dg
                                                                       (G))]
                       (cd)))))" bounding_circuits_defs nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs)) nil) (walk_bounding_def-2 nil 3661801873 ("" (skolem 1 ("n" "_" "bs")) (("" (case "FORALL (m:posnat, walk: Walk(dg(G))):
              m=length(walk) AND ( FORALL (v2: vert(dg(G))):
                  FORALL (cc: prewalk
                              | (circuit_at?(dg(G), cc, v2) AND length(cc) <= n)):
                    EXISTS (M2: Measure_Matrix):
                      member(M2, bs(v2)) AND M2 <= wgt_walk(G, cc))
                IMPLIES
                (FORALL ((cd: walk_decomp(dg(G))
                              | FORALL (j: below(length(cd))):
                                  nth(cd, j)`c`length <= n)):
                   drop_circuits(dg(G), cd) = walk IMPLIES
                    (EXISTS (M: Measure_Matrix):
                       member(M, walk_bounding(walk, bs)) AND
                        M <= decomp_weight(cd)))") (("1" (skeep) (("1" (inst - "length(walk)" "walk") (("1" (assert) (("1" (ground) nil))))))) ("2" (hide 2) (("2" (induct "m") (("1" (assert) nil) ("2" (assert) nil) ("3" (skeep) (("3" (skeep) (("3" (assert) (("3" (skeep :preds? t) (("3" (hide -1) (("3" (case "j=0") (("1" (hide -5) (("1" (expand "walk_bounding") (("1" (assert) (("1" (lemma "decomp_weight_def") (("1" (inst?) (("1" (replace -1) (("1" (expand "decomp_to_walk") (("1" (expand "finseq_appl") (("1" (inst -8 "walk`seq(0)") (("1" (typepred "car(cd)") (("1" (ground) (("1" (replace -1) (("1" (expand "gen_seq1") (("1" (expand "wgt_walk") (("1" (expand "wgt_aux") (("1" (inst 1 "id") (("1" (expand "member") (("1" (expand "<=") (("1" (expand "le") (("1" (propax) nil))))))))))))))))) ("2" (inst -9 "car(cd)`c") (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (inst?) (("1" (assert) (("1" (expand "member" +) (("1" (propax) nil))))))))))))) ("2" (inst - " 0 ") (("2" (expand "nth") (("2" (assert) (("2" (replace -9 1 :dir rl) (("2" (expand "drop_circuits") (("2" (expand "list2finseq") (("2" (expand "nth") (("2" (expand "map") (("2" (lift-if 1) (("2" (ground) (("2" (expand "length") (("2" (assert) nil))))))))))))))))))))))) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil))))))))))))))) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil))))))))))))) ("2" (typepred "walk") (("2" (hide -6) (("2" (expand "walk?") (("2" (expand "verts_in?") (("2" (inst -2 "0") (("2" (expand "vert?") (("2" (propax) nil))))))))))))))))))))))))))))))) ("2" (assert) (("2" (inst -4 "walk^(1, length(walk)-1)") (("1" (expand "^" -4 1) (("1" (expand "min") (("1" (ground) (("1" (inst -1 "cdr(cd)") (("1" (ground) (("1" (skeep) (("1" (expand "walk_bounding" 2) (("1" (typepred "list_prod(map(LAMBDA (m1: Measure_Matrix):
                                             m1 * wgt_walk(G, walk ^ (0, 1)))
                                          (cons(id, bs(finseq_appl[T](walk)(0)))),
                                       walk_bounding(
                                                     walk ^ (1, length(walk) - 1),
                                                     bs))") (("1" (hide -1) (("1" (expand "decomp_weight" 2) (("1" (inst -9 "walk`seq(0)") (("1" (inst -9 "nth(cd, 0)`c") (("1" (skeep) (("1" (inst -1 "M2* wgt_walk(G, walk ^ (0, 1))" "M") (("1" (assert) (("1" (ground) (("1" (skeep) (("1" (inst 2 "M_1") (("1" (assert) (("1" (case-replace "gen_seq2(dg(G), nth(cd, 0)`v, nth(cd, 1)`v) = walk ^ (0, 1)") (("1" (lemma "mult_right_preserves_order") (("1" (inst - " wgt_walk(G, walk ^ (0, 1))" "M2" "wgt_walk(G, nth(cd, 0)`c)") (("1" (assert) (("1" (lemma "mult_right_preserves_order") (("1" (inst -1 " M" "M2 * wgt_walk(G, walk ^ (0, 1))" "       wgt_walk(G, nth(cd, 0)`c) * wgt_walk(G, walk ^ (0, 1))") (("1" (assert) (("1" (lemma "mult_left_preserves_order") (("1" (inst - "  wgt_walk(G, nth(cd, 0)`c) * wgt_walk(G, walk ^ (0, 1))" "M" "decomp_weight(G, cdr(cd))") (("1" (assert) (("1" (lemma "matrices_order") (("1" (expand "partial_order?") (("1" (expand "preorder?") (("1" (flatten) (("1" (hide (-1 -3)) (("1" (expand "transitive?") (("1" (inst-cp - "M_1" "M2 * wgt_walk(G, walk ^ (0, 1)) * M" "wgt_walk(G, nth(cd, 0)`c) * wgt_walk(G, walk ^ (0, 1)) * M") (("1" (assert) (("1" (inst - " M_1" "wgt_walk(G, nth(cd, 0)`c) * wgt_walk(G, walk ^ (0, 1)) * M " "wgt_walk(G, nth(cd, 0)`c) * wgt_walk(G, walk ^ (0, 1)) *
                                          decomp_weight(G, cdr(cd))") (("1" (assert) nil) ("2" (lemma "id_is_identity") (("2" (propax) nil))) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil))) ("4" (hide-all-but 1) (("4" (skeep :preds? t) (("4" (typepred "vc`v") (("4" (expand "vert?") (("4" (expand "digraph_verts") (("4" (propax) nil))))))))))))))) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil))))))))))) ("3" (lemma "id_is_identity") (("3" (propax) nil))) ("4" (lemma "measure_matrix_assoc") (("4" (propax) nil))))))))))))))))))) ("2" (lemma "id_is_identity") (("2" (propax) nil))) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil))) ("4" (hide-all-but 1) (("4" (skeep :preds? t) (("4" (typepred "vc`v") (("4" (expand "vert?") (("4" (expand "digraph_verts") (("4" (propax) nil))))))))))))))))) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil))))))))))) ("3" (lemma "id_is_identity") (("3" (propax) nil))) ("4" (lemma "measure_matrix_assoc") (("4" (propax) nil))))))))) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil))))))))))) ("3" (lemma "id_is_identity") (("3" (propax) nil))) ("4" (lemma "measure_matrix_assoc") (("4" (propax) nil))))))) ("2" (decompose-equality 1) (("1" (expand "gen_seq2") (("1" (expand "^") (("1" (expand "min") (("1" (propax) nil))))))) ("2" (decompose-equality 1) (("1" (expand "^") (("1" (expand "gen_seq2") (("1" (ground) (("1" (lift-if 1) (("1" (replace -12 1 :dir rl) (("1" (hide (-1 -2 -3 -4 -6)) (("1" (hide 3) (("1" (expand "drop_circuits") (("1" (expand "list2finseq") (("1" (lemma "map_nth_rw[vert_circ(dg(G)), vert(dg(G))]") (("1" (inst?) (("1" (replaces -1) (("1" (ground) (("1" (typepred "x!1") (("1" (ground) (("1" (expand "gen_seq2") (("1" (ground) nil))))))))))) ("2" (typepred (x!1)) (("2" (expand "gen_seq2") (("2" (ground) nil))))))))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil))))))))))))) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil))))))))))))) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil))))))))))))))))))) ("2" (lemma "member_nth[Measure_Matrix]") (("2" (inst - " bs(walk`seq(0))" " M2") (("2" (assert) (("2" (skeep) (("2" (lemma "nth_member[Measure_Matrix]") (("2" (inst - "map(LAMBDA (m1: Measure_Matrix):
                                           m1 * wgt_walk(G, walk ^ (0, 1)))
                                        (cons(id, bs(finseq_appl[T](walk)(0))))" "M2* wgt_walk(G, walk ^ (0, 1))" "i+1") (("1" (assert) (("1" (lemma "map_nth_rw[Measure_Matrix, Measure_Matrix]") (("1" (inst?) (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "finseq_appl") (("1" (assert) nil))))))) ("2" (typepred "i") (("2" (expand "length" 1) (("2" (expand "finseq_appl") (("2" (assert) nil))))))) ("3" (lemma "id_is_identity") (("3" (propax) nil))) ("4" (lemma "measure_matrix_assoc") (("4" (propax) nil))))))))) ("2" (rewrite "map_length[Measure_Matrix, Measure_Matrix]") (("2" (expand "length") (("2" (typepred "i") (("2" (expand "finseq_appl") (("2" (assert) nil))))))))) ("3" (lemma "id_is_identity") (("3" (propax) nil))) ("4" (lemma "measure_matrix_assoc") (("4" (propax) nil))))))))))))))))))) ("2" (lemma "id_is_identity") (("2" (propax) nil))) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil))) ("4" (lemma "walk?_caret") (("4" (inst?) (("4" (assert) (("4" (expand "^") (("4" (expand "min") (("4" (assert) nil))))))))))))))) ("2" (inst -6 "0") (("2" (assert) (("2" (typepred "nth(cd, 0)") (("1" (ground) (("1" (inst -2 "id * wgt_walk(G, walk ^ (0, 1))" "M") (("1" (ground) (("1" (skeep) (("1" (inst 3 " M_1") (("1" (assert) (("1" (replace -3 3) (("1" (expand "wgt_walk" 3 1) (("1" (expand "gen_seq1") (("1" (expand "wgt_aux") (("1" (case-replace "gen_seq2(dg(G), nth(cd, 0)`v, nth(cd, 1)`v) = walk ^ (0, 1)") (("1" (lemma "mult_left_preserves_order") (("1" (inst -1 "id * wgt_walk(G, walk ^ (0, 1))" "M " " decomp_weight(cdr(cd))") (("1" (assert) (("1" (lemma "matrices_order") (("1" (expand "partial_order?") (("1" (expand "preorder?") (("1" (flatten) (("1" (hide -1 -3) (("1" (expand "transitive?") (("1" (inst -1 "M_1 " "id * wgt_walk(G, walk ^ (0, 1)) * M " "id * wgt_walk(G, walk ^ (0, 1)) * decomp_weight(cdr(cd))") (("1" (assert) nil) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil))))))))))) ("3" (lemma "id_is_identity") (("3" (propax) nil))) ("4" (lemma "measure_matrix_assoc") (("4" (propax) nil))))))))))))))))))) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil))))))))))) ("3" (lemma "id_is_identity") (("3" (propax) nil))) ("4" (lemma "measure_matrix_assoc") (("4" (propax) nil))))))) ("2" (decompose-equality 1) (("1" (expand "gen_seq2") (("1" (expand "^") (("1" (expand "min") (("1" (propax) nil))))))) ("2" (decompose-equality 1) (("1" (expand "^") (("1" (expand "gen_seq2") (("1" (replace -11 1 :dir rl) (("1" (expand "drop_circuits " 1) (("1" (expand "list2finseq") (("1" (lemma "map_nth_rw[vert_circ(dg(G)), vert(dg(G))]") (("1" (inst?) (("1" (replaces -1) (("1" (lift-if 1) (("1" (ground) (("1" (typepred (x!1)) (("1" (expand "gen_seq2") (("1" (ground) nil))))))))))) ("2" (typepred (x!1)) (("2" (expand "gen_seq2") (("2" (assert) nil))))))))))))))))))) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil))))))))))))) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil))))))))))))) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil))))))))))))))))))))))))))) ("2" (expand "map") (("2" (expand "member") (("2" (propax) nil))))))) ("2" (lemma "id_is_identity") (("2" (propax) nil))) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil))) ("4" (lemma "walk?_caret") (("4" (inst?) (("4" (assert) (("4" (expand "^") (("4" (expand "min") (("4" (assert) nil))))))))))))) ("2" (replace -10 1 :dir rl) (("2" (expand "drop_circuits " 1) (("2" (expand "list2finseq") (("2" (expand "map" 1) (("2" (lift-if 1) (("2" (ground) (("1" (expand "length") (("1" (ground) nil))) ("2" (expand "nth " 2 2) (("2" (expand "nth" -1 2) (("2" (propax) nil))))))))))))))))))) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil))))))))))))))))) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil))))))))))))) ("2" (hide -) (("2" (typepred "walk") (("2" (expand "walk?") (("2" (flatten) (("2" (expand "verts_in?") (("2" (inst -2 "0") (("2" (ground) (("2" (expand "vert?") (("2" (assert) nil))))))))))))))))))))))) ("2" (lemma "id_is_identity") (("2" (propax) nil))) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil))) ("4" (lemma "walk?_caret") (("4" (inst?) (("4" (assert) (("4" (expand "^") (("4" (expand "min") (("4" (assert) nil))))))))))) ("5" (expand "finseq_appl") (("5" (assert) (("5" (typepred "walk") (("5" (expand "walk?") (("5" (hide -6) (("5" (expand "verts_in?") (("5" (flatten) (("5" (inst?) (("5" (assert) (("5" (expand "vert?") (("5" (assert) nil))))))))))))))))))))))))))) ("2" (decompose-equality 1) (("1" (expand "drop_circuits" 1 1) (("1" (expand "list2finseq" 1) (("1" (rewrite "map_length[vert_circ(dg(G)), vert(dg(G))]") (("1" (expand "^") (("1" (expand "min") (("1" (case "length(cd) = walk`length") (("1" (expand " length" -1 1) (("1" (lift-if -1) (("1" (ground) nil))))) ("2" (replace -7 :dir rl) (("2" (expand "drop_circuits") (("2" (expand "list2finseq") (("2" (rewrite "map_length[vert_circ(dg(G)), vert(dg(G))]") nil))))))) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil))))))))))))))))) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil))))))))))))))))) ("2" (decompose-equality 1) (("1" (expand "drop_circuits" 1) (("1" (expand "list2finseq") (("1" (lemma "map_nth_rw[vert_circ(dg(G)), vert(dg(G))]") (("1" (inst?) (("1" (replace -1) (("1" (expand "^") (("1" (replace -8 1 :dir rl) (("1" (expand "drop_circuits") (("1" (expand "list2finseq") (("1" (expand "map" 1) (("1" (lift-if 1) (("1" (ground) (("1" (expand "length") (("1" (assert) nil))) ("2" (expand "nth" 2 2) (("2" (replace -1) (("2" (propax) nil))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil))))))))))))))))))) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil))))))))))))) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil))))))))))))))) ("2" (case "length(cd) = walk`length") (("1" (assert) (("1" (expand " length" -1 1) (("1" (lift-if -1) (("1" (assert) (("1" (ground) (("1" (expand "walk?") (("1" (ground) (("1" (expand "verts_in?") (("1" (skeep) (("1" (inst -3 "i+1") (("1" (expand "list2finseq") (("1" (hide -4) (("1" (expand "nth" -3) (("1" (expand "map" -3) (("1" (propax) nil))))))))) ("2" (typepred (i)) (("2" (expand "map" 1) (("2" (expand "list2finseq") (("2" (expand "length" 1) (("2" (assert) nil))))))))))))))) ("2" (skeep) (("2" (inst -5 "n!1+1") (("2" (expand "map" -5 1) (("2" (expand "list2finseq" -5 1) (("2" (expand "list2finseq" -1 1) (("2" (expand "length" -5 1) (("2" (assert) (("2" (expand "finseq_appl") (("2" (expand "map" -5) (("2" (expand "list2finseq") (("2" (expand "nth" -5) (("2" (propax) nil))))))))))))))))))))))))))) ("2" (skeep) (("2" (inst -4 "j!1+1") (("2" (expand "nth " -4) (("2" (propax) nil))))))))))))))))) ("2" (hide 2) (("2" (replace -7 1 :dir rl) (("2" (expand "drop_circuits") (("2" (expand "list2finseq") (("2" (rewrite "map_length[vert_circ(dg(G)), vert(dg(G))]") nil))))))))) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil))))))))))))) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil))))))))))) ("4" (expand "length") (("4" (lift-if -1) (("4" (assert) nil))))))))))))) ("2" (lemma "walk?_caret") (("2" (inst?) (("2" (assert) (("2" (expand "^") (("2" (expand "min") (("2" (assert) nil))))))))))))))))))))))))))) ("4" (hide-all-but 1) (("4" (skeep* :preds? t) (("4" (typepred "vc`v") (("4" (expand "vert?") (("4" (expand "digraph_verts") (("4" (propax) nil))))))))))) ("5" (hide 2) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (lemma "id_is_identity") (("5" (propax) nil))))))))))) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (skeep) (("6" (lemma "measure_matrix_assoc") (("6" (propax) nil))))))))))) ("7" (hide 2) (("7" (skeep) (("7" (skeep) (("7" (skeep) (("7" (typepred (cc)) (("7" (expand "circuit_at?") (("7" (expand "circuit?") (("7" (expand "pre_circuit?") (("7" (assert) nil))))))))))))))))))))) ("3" (hide 2) (("3" (skeep) (("3" (hide-all-but 1) (("3" (skeep* :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil))))))))))))))) ("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (lemma "id_is_identity") (("4" (propax) nil))))))))))) ("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (lemma "measure_matrix_assoc") (("5" (propax) nil))))))))))) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (typepred (cc)) (("6" (expand "circuit_at?") (("6" (expand "circuit?") (("6" (expand "pre_circuit?") (("6" (assert) nil)))))))))))))))))) nil) nil nil) (walk_bounding_def-1 nil 3661801791 ("" (skolem 1 ("n" "_" "bs")) (("" (case "FORALL (m:posnat, walk: Walk(dg(G))):
              m=length(walk) AND ( FORALL (v2: vert(dg(G))):
                  FORALL (cc: prewalk
                              | (circuit_at?(dg(G), cc, v2) AND length(cc) <= n)):
                    EXISTS (M2: Measure_Matrix):
                      member(M2, bs(v2)) AND M2 <= wgt_walk(G, cc))
                IMPLIES
                (FORALL ((cd: walk_decomp(dg(G))
                              | FORALL (j: below(length(cd))):
                                  nth(cd, j)`c`length <= n)):
                   drop_circuits(dg(G), cd) = walk IMPLIES
                    (EXISTS (M: Measure_Matrix):
                       member(M, walk_bounding(walk, bs)) AND
                        M <= decomp_weight(G, cd)))") (("1" (skeep) (("1" (inst - "length(walk)" "walk") (("1" (assert) (("1" (ground) nil))))))) ("2" (hide 2) (("2" (induct "m") (("1" (assert) nil) ("2" (assert) nil) ("3" (skeep) (("3" (skeep) (("3" (assert) (("3" (skeep :preds? t) (("3" (hide -1) (("3" (case "j=0") (("1" (hide -5) (("1" (expand "walk_bounding") (("1" (assert) (("1" (lemma "decomp_weight_def") (("1" (inst?) (("1" (replace -1) (("1" (expand "decomp_to_walk") (("1" (expand "finseq_appl") (("1" (inst -8 "walk`seq(0)") (("1" (typepred "car(cd)") (("1" (ground) (("1" (replace -1) (("1" (expand "gen_seq1") (("1" (expand "wgt_walk") (("1" (expand "wgt_aux") (("1" (inst 1 "id") (("1" (expand "member") (("1" (expand "<=") (("1" (expand "le") (("1" (propax) nil))))))))))))))))) ("2" (inst -9 "car(cd)`c") (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (inst?) (("1" (assert) (("1" (expand "member" +) (("1" (propax) nil))))))))))))) ("2" (inst - " 0 ") (("2" (expand "nth") (("2" (assert) (("2" (replace -9 1 :dir rl) (("2" (expand "drop_circuits") (("2" (expand "list2finseq") (("2" (expand "nth") (("2" (expand "map") (("2" (lift-if 1) (("2" (ground) (("2" (expand "length") (("2" (assert) nil))))))))))))))))))))))) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil))))))))))))))) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil))))))))))))) ("2" (typepred "walk") (("2" (hide -6) (("2" (expand "walk?") (("2" (expand "verts_in?") (("2" (inst -2 "0") (("2" (expand "vert?") (("2" (propax) nil))))))))))))))))))))))))))))))) ("2" (assert) (("2" (inst -4 "walk^(1, length(walk)-1)") (("1" (expand "^" -4 1) (("1" (expand "min") (("1" (ground) (("1" (inst -1 "cdr(cd)") (("1" (ground) (("1" (skeep) (("1" (expand "walk_bounding" 2) (("1" (typepred "list_prod(map(LAMBDA (m1: Measure_Matrix):
                                             m1 * wgt_walk(G, walk ^ (0, 1)))
                                          (cons(id, bs(finseq_appl[T](walk)(0)))),
                                       walk_bounding(
                                                     walk ^ (1, length(walk) - 1),
                                                     bs))") (("1" (hide -1) (("1" (expand "decomp_weight" 2) (("1" (inst -9 "walk`seq(0)") (("1" (inst -9 "nth(cd, 0)`c") (("1" (skeep) (("1" (inst -1 "M2* wgt_walk(G, walk ^ (0, 1))" "M") (("1" (assert) (("1" (ground) (("1" (skeep) (("1" (inst 2 "M_1") (("1" (assert) (("1" (case-replace "gen_seq2(dg(G), nth(cd, 0)`v, nth(cd, 1)`v) = walk ^ (0, 1)") (("1" (lemma "mult_right_preserves_order") (("1" (inst - " wgt_walk(G, walk ^ (0, 1))" "M2" "wgt_walk(G, nth(cd, 0)`c)") (("1" (assert) (("1" (lemma "mult_right_preserves_order") (("1" (inst -1 " M" "M2 * wgt_walk(G, walk ^ (0, 1))" "       wgt_walk(G, nth(cd, 0)`c) * wgt_walk(G, walk ^ (0, 1))") (("1" (assert) (("1" (lemma "mult_left_preserves_order") (("1" (inst - "  wgt_walk(G, nth(cd, 0)`c) * wgt_walk(G, walk ^ (0, 1))" "M" "decomp_weight(G, cdr(cd))") (("1" (assert) (("1" (lemma "matrices_order") (("1" (expand "partial_order?") (("1" (expand "preorder?") (("1" (flatten) (("1" (hide (-1 -3)) (("1" (expand "transitive?") (("1" (inst-cp - "M_1" "M2 * wgt_walk(G, walk ^ (0, 1)) * M" "wgt_walk(G, nth(cd, 0)`c) * wgt_walk(G, walk ^ (0, 1)) * M") (("1" (assert) (("1" (inst - " M_1" "wgt_walk(G, nth(cd, 0)`c) * wgt_walk(G, walk ^ (0, 1)) * M " "wgt_walk(G, nth(cd, 0)`c) * wgt_walk(G, walk ^ (0, 1)) *
                                          decomp_weight(G, cdr(cd))") (("1" (assert) nil) ("2" (lemma "id_is_identity") (("2" (propax) nil))) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil))) ("4" (hide-all-but 1) (("4" (skeep :preds? t) (("4" (typepred "vc`v") (("4" (expand "vert?") (("4" (expand "digraph_verts") (("4" (propax) nil))))))))))))))) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil))))))))))) ("3" (lemma "id_is_identity") (("3" (propax) nil))) ("4" (lemma "measure_matrix_assoc") (("4" (propax) nil))))))))))))))))))) ("2" (lemma "id_is_identity") (("2" (propax) nil))) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil))) ("4" (hide-all-but 1) (("4" (skeep :preds? t) (("4" (typepred "vc`v") (("4" (expand "vert?") (("4" (expand "digraph_verts") (("4" (propax) nil))))))))))))))))) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil))))))))))) ("3" (lemma "id_is_identity") (("3" (propax) nil))) ("4" (lemma "measure_matrix_assoc") (("4" (propax) nil))))))))) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil))))))))))) ("3" (lemma "id_is_identity") (("3" (propax) nil))) ("4" (lemma "measure_matrix_assoc") (("4" (propax) nil))))))) ("2" (decompose-equality 1) (("1" (expand "gen_seq2") (("1" (expand "^") (("1" (expand "min") (("1" (propax) nil))))))) ("2" (decompose-equality 1) (("1" (expand "^") (("1" (expand "gen_seq2") (("1" (ground) (("1" (lift-if 1) (("1" (replace -12 1 :dir rl) (("1" (hide (-1 -2 -3 -4 -6)) (("1" (hide 3) (("1" (expand "drop_circuits") (("1" (expand "list2finseq") (("1" (lemma "map_nth_rw[vert_circ(dg(G)), vert(dg(G))]") (("1" (inst?) (("1" (replaces -1) (("1" (ground) (("1" (typepred "x!1") (("1" (ground) (("1" (expand "gen_seq2") (("1" (ground) nil))))))))))) ("2" (typepred (x!1)) (("2" (expand "gen_seq2") (("2" (ground) nil))))))))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil))))))))))))) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil))))))))))))) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil))))))))))))))))))) ("2" (lemma "member_nth[Measure_Matrix]") (("2" (inst - " bs(walk`seq(0))" " M2") (("2" (assert) (("2" (skeep) (("2" (lemma "nth_member[Measure_Matrix]") (("2" (inst - "map(LAMBDA (m1: Measure_Matrix):
                                           m1 * wgt_walk(G, walk ^ (0, 1)))
                                        (cons(id, bs(finseq_appl[T](walk)(0))))" "M2* wgt_walk(G, walk ^ (0, 1))" "i+1") (("1" (assert) (("1" (lemma "map_nth_rw[Measure_Matrix, Measure_Matrix]") (("1" (inst?) (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "finseq_appl") (("1" (assert) nil))))))) ("2" (typepred "i") (("2" (expand "length" 1) (("2" (expand "finseq_appl") (("2" (assert) nil))))))) ("3" (lemma "id_is_identity") (("3" (propax) nil))) ("4" (lemma "measure_matrix_assoc") (("4" (propax) nil))))))))) ("2" (rewrite "map_length[Measure_Matrix, Measure_Matrix]") (("2" (expand "length") (("2" (typepred "i") (("2" (expand "finseq_appl") (("2" (assert) nil))))))))) ("3" (lemma "id_is_identity") (("3" (propax) nil))) ("4" (lemma "measure_matrix_assoc") (("4" (propax) nil))))))))))))))))))) ("2" (lemma "id_is_identity") (("2" (propax) nil))) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil))) ("4" (lemma "walk?_caret") (("4" (inst?) (("4" (assert) (("4" (expand "^") (("4" (expand "min") (("4" (assert) nil))))))))))))))) ("2" (inst -6 "0") (("2" (assert) (("2" (typepred "nth(cd, 0)") (("1" (ground) (("1" (inst -2 "id * wgt_walk(G, walk ^ (0, 1))" "M") (("1" (ground) (("1" (skeep) (("1" (inst 3 " M_1") (("1" (assert) (("1" (replace -3 3) (("1" (expand "wgt_walk" 3 1) (("1" (expand "gen_seq1") (("1" (expand "wgt_aux") (("1" (case-replace "gen_seq2(dg(G), nth(cd, 0)`v, nth(cd, 1)`v) = walk ^ (0, 1)") (("1" (lemma "mult_left_preserves_order") (("1" (inst -1 "id * wgt_walk(G, walk ^ (0, 1))" "M " " decomp_weight(cdr(cd))") (("1" (assert) (("1" (lemma "matrices_order") (("1" (expand "partial_order?") (("1" (expand "preorder?") (("1" (flatten) (("1" (hide -1 -3) (("1" (expand "transitive?") (("1" (inst -1 "M_1 " "id * wgt_walk(G, walk ^ (0, 1)) * M " "id * wgt_walk(G, walk ^ (0, 1)) * decomp_weight(cdr(cd))") (("1" (assert) nil) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil))))))))))) ("3" (lemma "id_is_identity") (("3" (propax) nil))) ("4" (lemma "measure_matrix_assoc") (("4" (propax) nil))))))))))))))))))) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil))))))))))) ("3" (lemma "id_is_identity") (("3" (propax) nil))) ("4" (lemma "measure_matrix_assoc") (("4" (propax) nil))))))) ("2" (decompose-equality 1) (("1" (expand "gen_seq2") (("1" (expand "^") (("1" (expand "min") (("1" (propax) nil))))))) ("2" (decompose-equality 1) (("1" (expand "^") (("1" (expand "gen_seq2") (("1" (replace -11 1 :dir rl) (("1" (expand "drop_circuits " 1) (("1" (expand "list2finseq") (("1" (lemma "map_nth_rw[vert_circ(dg(G)), vert(dg(G))]") (("1" (inst?) (("1" (replaces -1) (("1" (lift-if 1) (("1" (ground) (("1" (typepred (x!1)) (("1" (expand "gen_seq2") (("1" (ground) nil))))))))))) ("2" (typepred (x!1)) (("2" (expand "gen_seq2") (("2" (assert) nil))))))))))))))))))) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil))))))))))))) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil))))))))))))) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil))))))))))))))))))))))))))) ("2" (expand "map") (("2" (expand "member") (("2" (propax) nil))))))) ("2" (lemma "id_is_identity") (("2" (propax) nil))) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil))) ("4" (lemma "walk?_caret") (("4" (inst?) (("4" (assert) (("4" (expand "^") (("4" (expand "min") (("4" (assert) nil))))))))))))) ("2" (replace -10 1 :dir rl) (("2" (expand "drop_circuits " 1) (("2" (expand "list2finseq") (("2" (expand "map" 1) (("2" (lift-if 1) (("2" (ground) (("1" (expand "length") (("1" (ground) nil))) ("2" (expand "nth " 2 2) (("2" (expand "nth" -1 2) (("2" (propax) nil))))))))))))))))))) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil))))))))))))))))) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil))))))))))))) ("2" (hide -) (("2" (typepred "walk") (("2" (expand "walk?") (("2" (flatten) (("2" (expand "verts_in?") (("2" (inst -2 "0") (("2" (ground) (("2" (expand "vert?") (("2" (assert) nil))))))))))))))))))))))) ("2" (lemma "id_is_identity") (("2" (propax) nil))) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil))) ("4" (lemma "walk?_caret") (("4" (inst?) (("4" (assert) (("4" (expand "^") (("4" (expand "min") (("4" (assert) nil))))))))))) ("5" (expand "finseq_appl") (("5" (assert) (("5" (typepred "walk") (("5" (expand "walk?") (("5" (hide -6) (("5" (expand "verts_in?") (("5" (flatten) (("5" (inst?) (("5" (assert) (("5" (expand "vert?") (("5" (assert) nil))))))))))))))))))))))))))) ("2" (decompose-equality 1) (("1" (expand "drop_circuits" 1 1) (("1" (expand "list2finseq" 1) (("1" (rewrite "map_length[vert_circ(dg(G)), vert(dg(G))]") (("1" (expand "^") (("1" (expand "min") (("1" (case "length(cd) = walk`length") (("1" (expand " length" -1 1) (("1" (lift-if -1) (("1" (ground) nil))))) ("2" (replace -7 :dir rl) (("2" (expand "drop_circuits") (("2" (expand "list2finseq") (("2" (rewrite "map_length[vert_circ(dg(G)), vert(dg(G))]") nil))))))) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil))))))))))))))))) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil))))))))))))))))) ("2" (decompose-equality 1) (("1" (expand "drop_circuits" 1) (("1" (expand "list2finseq") (("1" (lemma "map_nth_rw[vert_circ(dg(G)), vert(dg(G))]") (("1" (inst?) (("1" (replace -1) (("1" (expand "^") (("1" (replace -8 1 :dir rl) (("1" (expand "drop_circuits") (("1" (expand "list2finseq") (("1" (expand "map" 1) (("1" (lift-if 1) (("1" (ground) (("1" (expand "length") (("1" (assert) nil))) ("2" (expand "nth" 2 2) (("2" (replace -1) (("2" (propax) nil))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil))))))))))))))))))) ("2" (hide-all-but 1) (("2" (skeep :preds? t) (("2" (typepred "vc`v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil))))))))))))) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil))))))))))))))) ("2" (case "length(cd) = walk`length") (("1" (assert) (("1" (expand " length" -1 1) (("1" (lift-if -1) (("1" (assert) (("1" (ground) (("1" (expand "walk?") (("1" (ground) (("1" (expand "verts_in?") (("1" (skeep) (("1" (inst -3 "i+1") (("1" (expand "list2finseq") (("1" (hide -4) (("1" (expand "nth" -3) (("1" (expand "map" -3) (("1" (propax) nil))))))))) ("2" (typepred (i)) (("2" (expand "map" 1) (("2" (expand "list2finseq") (("2" (expand "length" 1) (("2" (assert) nil))))))))))))))) ("2" (skeep) (("2" (inst -5 "n!1+1") (("2" (expand "map" -5 1) (("2" (expand "list2finseq" -5 1) (("2" (expand "list2finseq" -1 1) (("2" (expand "length" -5 1) (("2" (assert) (("2" (expand "finseq_appl") (("2" (expand "map" -5) (("2" (expand "list2finseq") (("2" (expand "nth" -5) (("2" (propax) nil))))))))))))))))))))))))))) ("2" (skeep) (("2" (inst -4 "j!1+1") (("2" (expand "nth " -4) (("2" (propax) nil))))))))))))))))) ("2" (hide 2) (("2" (replace -7 1 :dir rl) (("2" (expand "drop_circuits") (("2" (expand "list2finseq") (("2" (rewrite "map_length[vert_circ(dg(G)), vert(dg(G))]") nil))))))))) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil))))))))))))) ("3" (hide-all-but 1) (("3" (skeep :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil))))))))))) ("4" (expand "length") (("4" (lift-if -1) (("4" (assert) nil))))))))))))) ("2" (lemma "walk?_caret") (("2" (inst?) (("2" (assert) (("2" (expand "^") (("2" (expand "min") (("2" (assert) nil))))))))))))))))))))))))))) ("4" (hide-all-but 1) (("4" (skeep* :preds? t) (("4" (typepred "vc`v") (("4" (expand "vert?") (("4" (expand "digraph_verts") (("4" (propax) nil))))))))))) ("5" (hide 2) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (lemma "id_is_identity") (("5" (propax) nil))))))))))) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (skeep) (("6" (lemma "measure_matrix_assoc") (("6" (propax) nil))))))))))) ("7" (hide 2) (("7" (skeep) (("7" (skeep) (("7" (skeep) (("7" (typepred (cc)) (("7" (expand "circuit_at?") (("7" (expand "circuit?") (("7" (expand "pre_circuit?") (("7" (assert) nil))))))))))))))))))))) ("3" (hide 2) (("3" (skeep) (("3" (hide-all-but 1) (("3" (skeep* :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil))))))))))))))) ("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (lemma "id_is_identity") (("4" (propax) nil))))))))))) ("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (lemma "measure_matrix_assoc") (("5" (propax) nil))))))))))) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (typepred (cc)) (("6" (expand "circuit_at?") (("6" (expand "circuit?") (("6" (expand "pre_circuit?") (("6" (assert) nil)))))))))))))))))) nil) nil nil)) (walk_bounding_has_walk_wgt_TCC1 0 (walk_bounding_has_walk_wgt_TCC1-1 nil 3661799793 ("" (subtype-tcc) nil nil) ((id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil bounding_circuits_defs nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (walk_bounding_has_walk_wgt subtype "bounding_circuits_defs.walk" "walks_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].Walk(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(bounding_circuits_defs.G))"))) (walk_bounding_has_walk_wgt_TCC2 0 (walk_bounding_has_walk_wgt_TCC2-2 "" 3790335735 ("" (use "measure_matrix_assoc") (("" (assert) nil nil)) nil) ((N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_matrix_assoc formula-decl nil measures nil)) shostak (walk_bounding_has_walk_wgt subtype "measures[bounding_circuits_defs.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(bounding_circuits_defs.f)}")) (walk_bounding_has_walk_wgt_TCC2-1 nil 3661799793 ("" (then (use "measure_matrix_assoc") (assert))) ((measure_matrix_assoc formula-decl nil measures nil)) nil (walk_bounding_has_walk_wgt subtype "measures[bounding_circuits_defs.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(bounding_circuits_defs.f)}"))) (walk_bounding_has_walk_wgt_TCC3 0 (walk_bounding_has_walk_wgt_TCC3-2 "" 3790335735 ("" (rewrite "id_is_identity") (("" (assert) nil nil)) nil) ((N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (id_is_identity formula-decl nil measures nil)) shostak (walk_bounding_has_walk_wgt subtype "measures[bounding_circuits_defs.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[bounding_circuits_defs.N].*)(bounding_circuits_defs.zero)}")) (walk_bounding_has_walk_wgt_TCC3-1 nil 3661799793 ("" (then (rewrite "id_is_identity") (assert))) ((id_is_identity formula-decl nil measures nil)) shostak (walk_bounding_has_walk_wgt subtype "measures[bounding_circuits_defs.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[bounding_circuits_defs.N].*)(bounding_circuits_defs.zero)}"))) (walk_bounding_has_walk_wgt_TCC4 0 (walk_bounding_has_walk_wgt_TCC4-1 nil 3661799793 ("" (subtype-tcc) nil nil) ((T formal-type-decl nil bounding_circuits_defs nil) (vert const-decl "bool" c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (walk_bounding_has_walk_wgt subtype "c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].get_wgt" "[[W: wgd_type[T, Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[bounding_circuits_defs.T].digraph_edges(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (walk_bounding_has_walk_wgt 0 (walk_bounding_has_walk_wgt-2 "" 3790335744 ("" (skolem 1 ("_" "bs")) (("" (case " FORALL (m:posnat, walk: Walk(dg(G))):
              m=walk`length IMPLIES  EXISTS (M: Measure_Matrix):
                 member(M, walk_bounding(walk, bs)) AND M <= wgt_walk(G, walk)") (("1" (skeep) (("1" (inst?) (("1" (inst - "walk`length") nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct " m") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (skeep) (("3" (case "j=0") (("1" (skeep) (("1" (expand "wgt_walk") (("1" (expand "wgt_aux") (("1" (inst 1 "id") (("1" (ground) (("1" (expand "walk_bounding") (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil) ("2" (expand "<=") (("2" (expand "le") (("2" (propax) nil nil)) nil)) nil) ("3" (expand "walk_bounding") (("3" (expand "member") (("3" (propax) nil nil)) nil)) nil) ("4" (expand "<=") (("4" (expand "le") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (inst -1 "walk^(1, length(walk)-1)") (("1" (ground) (("1" (skeep) (("1" (expand "walk_bounding" 2) (("1" (typepred " list_prod(map(LAMBDA (m1: Measure_Matrix):
                                         m1 * wgt_walk(G, walk ^ (0, 1)))
                                      (cons(id, bs(finseq_appl[T](walk)(0)))),
                                   walk_bounding(walk ^ (1, length(walk) - 1), bs))") (("1" (hide -1) (("1" (inst - "id* wgt_walk(G, walk ^ (0, 1)) " " M") (("1" (ground) (("1" (skeep) (("1" (inst?) (("1" (assert) (("1" (lemma "wgt_walk_decomposed") (("1" (inst - "G" "1" "walk") (("1" (assert) (("1" (lemma "id_is_identity") (("1" (expand "identity?") (("1" (inst -1 " wgt_walk(G, walk ^ (0, 1))") (("1" (flatten) (("1" (replaces -2) (("1" (hide -1) (("1" (lemma "mult_left_preserves_order") (("1" (inst - "wgt_walk(G, walk ^ (0, 1))" "M " " wgt_walk(G, walk ^ (1, length(walk) - 1))") (("1" (assert) (("1" (lemma "matrices_order") (("1" (expand "partial_order?") (("1" (expand "preorder?") (("1" (flatten) (("1" (expand "transitive?") (("1" (inst -2 "M_1" "wgt_walk(G, walk ^ (0, 1)) * M " "       wgt_walk(G, walk ^ (0, 1)) *
                                                    wgt_walk(G, walk ^ (1, length(walk) - 1))") (("1" (assert) nil nil) ("2" (lemma "id_is_identity") (("2" (propax) nil nil)) nil) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "id_is_identity") (("2" (propax) nil nil)) nil) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "id_is_identity") (("2" (propax) nil nil)) nil) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "map") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma "id_is_identity") (("2" (propax) nil nil)) nil) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil nil)) nil) ("4" (lemma "walk?_caret") (("4" (inst?) (("4" (assert) (("4" (expand "^") (("4" (expand "min") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "id_is_identity") (("2" (propax) nil nil)) nil) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil nil)) nil) ("4" (lemma "walk?_caret") (("4" (inst?) (("4" (assert) (("4" (expand "^") (("4" (expand "min") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (typepred "walk") (("5" (expand "walk?") (("5" (expand "verts_in?") (("5" (flatten) (("5" (inst -2 "0") (("5" (expand "vert?") (("5" (assert) (("5" (expand "finseq_appl") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "^") (("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "walk?_caret") (("2" (inst?) (("2" (assert) (("2" (expand "^") (("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (lemma "id_is_identity") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (lemma "measure_matrix_assoc") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (lemma "id_is_identity") (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (lemma "measure_matrix_assoc") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (<= const-decl "bool" measures nil) (walk_bounding def-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (member def-decl "bool" list_props nil) (Walk type-eq-decl nil walks_ digraphs) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (walk? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (T formal-type-decl nil bounding_circuits_defs nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (associative? const-decl "bool" operator_defs nil) (identity? const-decl "bool" operator_defs nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bs skolem-const-decl "[vert[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
      digraph_make](dg(G)) ->
   list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (le const-decl "bool" measures nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (wgt_aux def-decl "Weight" weighted_digraphs_ digraphs) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (verts_in? const-decl "bool" walks_ digraphs) (below type-eq-decl nil naturalnumbers nil) (walk?_caret formula-decl nil walks_ digraphs) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (wgt_walk_decomposed formula-decl nil weighted_digraphs_ digraphs) (matrices_order formula-decl nil measures nil) (preorder? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (measure_matrix_assoc formula-decl nil measures nil) (partial_order? const-decl "bool" orders nil) (mult_left_preserves_order formula-decl nil measures nil) (TRUE const-decl "bool" booleans nil) (id_is_identity formula-decl nil measures nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (< const-decl "bool" reals nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (map adt-def-decl "list[T1]" list_adt_map nil) (list_prod const-decl "{L: list[Measure_Matrix[N]] |
   FORALL (m1, m2: Measure_Matrix):
     member(m1, l1) AND member(m2, l2) IMPLIES
      EXISTS (M: Measure_Matrix): member(M, L) AND M <= m1 * m2}" bounding_circuits_defs nil) (NOT const-decl "[bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (walk skolem-const-decl "Walk[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G))" bounding_circuits_defs nil) (^ const-decl "finseq" finite_sequences nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak) (walk_bounding_has_walk_wgt-1 nil 3661800296 ("" (skolem 1 ("_" "bs")) (("" (case " FORALL (m:posnat, walk: Walk(dg(G))):
              m=walk`length IMPLIES  EXISTS (M: Measure_Matrix):
                 member(M, walk_bounding(walk, bs)) AND M <= wgt_walk(G, walk)") (("1" (skeep) (("1" (inst?) (("1" (inst - "walk`length") nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct " m") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (skeep) (("3" (case "j=0") (("1" (skeep) (("1" (expand "wgt_walk") (("1" (expand "wgt_aux") (("1" (inst 1 "id") (("1" (ground) (("1" (expand "walk_bounding") (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil) ("2" (expand "<=") (("2" (expand "le") (("2" (propax) nil nil)) nil)) nil) ("3" (expand "walk_bounding") (("3" (expand "member") (("3" (propax) nil nil)) nil)) nil) ("4" (expand "<=") (("4" (expand "le") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (inst -1 "walk^(1, length(walk)-1)") (("1" (ground) (("1" (skeep) (("1" (expand "walk_bounding" 2) (("1" (typepred " list_prod(map(LAMBDA (m1: Measure_Matrix):
                                         m1 * wgt_walk(G, walk ^ (0, 1)))
                                      (cons(id, bs(finseq_appl[T](walk)(0)))),
                                   walk_bounding(walk ^ (1, length(walk) - 1), bs))") (("1" (hide -1) (("1" (inst - "id* wgt_walk(G, walk ^ (0, 1)) " " M") (("1" (ground) (("1" (skeep) (("1" (inst?) (("1" (assert) (("1" (lemma "wgt_walk_decomposed") (("1" (inst - "G" "1" "walk") (("1" (assert) (("1" (lemma "id_is_identity") (("1" (expand "identity?") (("1" (inst -1 " wgt_walk(G, walk ^ (0, 1))") (("1" (flatten) (("1" (replaces -2) (("1" (hide -1) (("1" (lemma "mult_left_preserves_order") (("1" (inst - "wgt_walk(G, walk ^ (0, 1))" "M " " wgt_walk(G, walk ^ (1, length(walk) - 1))") (("1" (assert) (("1" (lemma "matrices_order") (("1" (expand "partial_order?") (("1" (expand "preorder?") (("1" (flatten) (("1" (expand "transitive?") (("1" (inst -2 "M_1" "wgt_walk(G, walk ^ (0, 1)) * M " "       wgt_walk(G, walk ^ (0, 1)) *
                                                    wgt_walk(G, walk ^ (1, length(walk) - 1))") (("1" (assert) nil nil) ("2" (lemma "id_is_identity") (("2" (propax) nil nil)) nil) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "id_is_identity") (("2" (propax) nil nil)) nil) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "id_is_identity") (("2" (propax) nil nil)) nil) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "map") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma "id_is_identity") (("2" (propax) nil nil)) nil) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil nil)) nil) ("4" (lemma "walk?_caret") (("4" (inst?) (("4" (assert) (("4" (expand "^") (("4" (expand "min") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "id_is_identity") (("2" (assert) nil nil)) nil) ("3" (lemma "measure_matrix_assoc") (("3" (assert) nil nil)) nil) ("4" (lemma "walk?_caret") (("4" (inst?) (("4" (assert) (("4" (expand "^") (("4" (expand "min") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (typepred "walk") (("5" (expand "walk?") (("5" (expand "verts_in?") (("5" (flatten) (("5" (inst -2 "0") (("5" (expand "vert?") (("5" (assert) (("5" (expand "finseq_appl") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "^") (("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "walk?_caret") (("2" (inst?) (("2" (assert) (("2" (expand "^") (("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (lemma "id_is_identity") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (lemma "measure_matrix_assoc") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (lemma "id_is_identity") (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (lemma "measure_matrix_assoc") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (<= const-decl "bool" measures nil) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (walk? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (le const-decl "bool" measures nil) (wgt_aux def-decl "Weight" weighted_digraphs_ digraphs) (verts_in? const-decl "bool" walks_ digraphs) (walk?_caret formula-decl nil walks_ digraphs) (wgt_walk_decomposed formula-decl nil weighted_digraphs_ digraphs) (matrices_order formula-decl nil measures nil) (measure_matrix_assoc formula-decl nil measures nil) (mult_left_preserves_order formula-decl nil measures nil) (id_is_identity formula-decl nil measures nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (^ const-decl "finseq" finite_sequences nil)) nil)) (walk_list_bounding_TCC1 0 (walk_list_bounding_TCC1-1 nil 3659094121 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-type-decl nil bounding_circuits_defs nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (prewalk type-eq-decl nil walks_ digraphs) (walk? const-decl "bool" walks_ digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (Walk type-eq-decl nil walks_ digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (walk_list_bounding subtype "bounding_circuits_defs.wlist" "(list_adt[walks_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].Walk(dg(bounding_circuits_defs.G))].cons?)"))) (walk_list_bounding_TCC2 0 (walk_list_bounding_TCC2-1 nil 3659094121 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-type-decl nil bounding_circuits_defs nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (prewalk type-eq-decl nil walks_ digraphs) (walk? const-decl "bool" walks_ digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (Walk type-eq-decl nil walks_ digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (walk_list_bounding termination "bounding_circuits_defs.walk_list_bounding(list_adt[walks_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].Walk(dg(bounding_circuits_defs.G))].cdr(bounding_circuits_defs.wlist), bounding_circuits_defs.bs)" "nil"))) (walk_list_bounding_def_TCC1 0 (walk_list_bounding_def_TCC1-1 nil 3661778758 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (vert? const-decl "bool" digraphs_ digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (vert type-eq-decl nil digraphs_ digraphs) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (<= const-decl "bool" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil bounding_circuits_defs nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (walk_list_bounding_def subtype "bounding_circuits_defs.cc" "walks_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].Walk(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(bounding_circuits_defs.G))"))) (walk_list_bounding_def_TCC2 0 (walk_list_bounding_def_TCC2-2 "" 3790335748 ("" (use "measure_matrix_assoc") (("" (assert) nil nil)) nil) ((N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_matrix_assoc formula-decl nil measures nil)) shostak (walk_list_bounding_def subtype "measures[bounding_circuits_defs.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(bounding_circuits_defs.f)}")) (walk_list_bounding_def_TCC2-1 nil 3661778758 ("" (then (use "measure_matrix_assoc") (assert))) ((measure_matrix_assoc formula-decl nil measures nil)) nil (walk_list_bounding_def subtype "measures[bounding_circuits_defs.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(bounding_circuits_defs.f)}"))) (walk_list_bounding_def_TCC3 0 (walk_list_bounding_def_TCC3-2 "" 3790335748 ("" (rewrite "id_is_identity") (("" (assert) nil nil)) nil) ((N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (id_is_identity formula-decl nil measures nil)) shostak (walk_list_bounding_def subtype "measures[bounding_circuits_defs.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[bounding_circuits_defs.N].*)(bounding_circuits_defs.zero)}")) (walk_list_bounding_def_TCC3-1 nil 3661778758 ("" (then (rewrite "id_is_identity") (assert))) ((id_is_identity formula-decl nil measures nil)) shostak (walk_list_bounding_def subtype "measures[bounding_circuits_defs.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[bounding_circuits_defs.N].*)(bounding_circuits_defs.zero)}"))) (walk_list_bounding_def_TCC4 0 (walk_list_bounding_def_TCC4-1 nil 3661778758 ("" (subtype-tcc) nil nil) ((T formal-type-decl nil bounding_circuits_defs nil) (vert const-decl "bool" c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (walk_list_bounding_def subtype "c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].get_wgt" "[[W: wgd_type[T, Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[bounding_circuits_defs.T].digraph_edges(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (walk_list_bounding_def 0 (walk_list_bounding_def-2 nil 3661800896 ("" (skolem 1 ("n" "_" "bs")) (("" (case "identity?(*)(id) AND associative?(*)") (("1" (flatten) (("1" (label "mm" (-1 -2)) (("1" (hide mm) (("1" (case "FORALL (m:nat, wlist: list[Walk(dg(G))]):
                                   m = length(wlist) AND (FORALL (v2: vert(dg(G))):
                                      FORALL (cc: prewalk
                                                  | (circuit_at?(dg(G), cc, v2) AND length(cc) <= n)):
                                        EXISTS (M2: Measure_Matrix):
                                          member(M2, bs(v2)) AND M2 <= wgt_walk(G, cc))
                                    IMPLIES
                                    (FORALL (walk: Walk(dg(G)),
                                             (cd: walk_decomp(dg(G))
                                                  | FORALL (j: below(length(cd))):
                                                      nth(cd, j)`c`length <= n)):
                                       member(walk, wlist) AND drop_circuits(dg(G), cd) = walk IMPLIES
                                        (EXISTS (M: Measure_Matrix):
                                           member(M, walk_list_bounding(wlist, bs)) AND
                                            M <= decomp_weight(cd)))") (("1" (skeep) (("1" (inst?) (("1" (inst -1 " length(wlist)") (("1" (assert) (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (deftactic meas (then (repeat (skeep)) (reveal mm) (flatten) (assert))) (("2" (deftactic vert (then (hide-all-but 1) (repeat (skeep)) (typepred "vc`v") (expand "vert?"))) (("2" (induct "m") (("1" (skeep) (("1" (skeep) (("1" (expand "member") (("1" (lift-if -3) (("1" (ground) (("1" (expand "length") (("1" (ground) nil nil)) nil) ("2" (expand "length") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (deftactic cc (circ) (then (hide-all-but 1) (repeat (skeep)) (typepred circ) (expand "circuit_at?") (expand "circuit?") (expand "pre-circuit?") (ground))) (("2" (inst -1 "cdr(wlist)") (("1" (ground) (("1" (skeep) (("1" (expand "member" -4) (("1" (lift-if -4) (("1" (ground) (("1" (hide -2) (("1" (expand "walk_list_bounding") (("1" (lemma "walk_bounding_def") (("1" (inst - "n" "walk" "bs") (("1" (ground) (("1" (inst -1 "cd") (("1" (assert) (("1" (skeep) (("1" (inst 2 "M") (("1" (assert) (("1" (lemma "member_append_l[Measure_Matrix]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "walk" "cd") (("2" (assert) (("2" (skeep) (("2" (inst + "M") (("2" (expand "walk_list_bounding" 2) (("2" (lemma "member_append_r[Measure_Matrix]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length" -1) (("2" (lift-if -1) (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep* :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (meas) nil nil) ("5" (meas) nil nil) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (typepred "cc") (("6" (expand "circuit_at?") (("6" (expand "circuit?") (("6" (expand "pre_circuit?") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep* :preds? t) (("3" (typepred "vc`v") (("3" (expand "vert?") (("3" (expand "digraph_verts") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) (("4" (reveal mm) (("4" (propax) nil nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (skeep) (("5" (reveal mm) (("5" (propax) nil nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (typepred (cc)) (("6" (expand "circuit_at?") (("6" (expand "circuit?") (("6" (expand "pre_circuit?") (("6" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "id_is_identity") (("2" (lemma "measure_matrix_assoc") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ((associative? const-decl "bool" operator_defs nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (identity? const-decl "bool" operator_defs nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (decomp_weight def-decl "Measure_Matrix" bounding_circuits_defs nil) (walk_list_bounding def-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (drop_circuits const-decl "{W: Walk(G) | length(W) = length(cd)}" circuit_decomp_ digraphs) (nth def-decl "T" list_props nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (walk_decomp type-eq-decl nil circuit_decomp_ digraphs) (map adt-def-decl "list[T1]" list_adt_map nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (vert_circ type-eq-decl nil circuit_decomp_ digraphs) (gen_seq1 const-decl "Seq(G)" walks_ digraphs) (Seq type-eq-decl nil walks_ digraphs) (verts_in? const-decl "bool" walks_ digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (<= const-decl "bool" measures nil) (member def-decl "bool" list_props nil) (<= const-decl "bool" reals nil) (circuit_at? const-decl "bool" circuits_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (finseq type-eq-decl nil finite_sequences nil) (T formal-type-decl nil bounding_circuits_defs nil) (below type-eq-decl nil nat_types nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (vert const-decl "bool" c_digraphs_def digraphs) (TRUE const-decl "bool" booleans nil) (n skolem-const-decl "nat" bounding_circuits_defs nil) (bs skolem-const-decl "[vert[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
      digraph_make](dg(G)) ->
   list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (wlist skolem-const-decl "list[Walk[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
          digraph_make](dg(G))]" bounding_circuits_defs nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (member_append_r formula-decl nil more_list_props structures) (walk_bounding_def formula-decl nil bounding_circuits_defs nil) (member_append_l formula-decl nil more_list_props structures) (walk_bounding def-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (circuit? const-decl "bool" circuits_ digraphs) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pre_circuit? const-decl "bool" circuits_ digraphs) (id_is_identity formula-decl nil measures nil) (measure_matrix_assoc formula-decl nil measures nil)) nil) (walk_list_bounding_def-1 nil 3661799821 ("" (postpone) nil nil) nil shostak)) (walk_list_bounding_has_walk_wgt_TCC1 0 (walk_list_bounding_has_walk_wgt_TCC1-1 nil 3661799159 ("" (subtype-tcc) nil nil) ((id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil bounding_circuits_defs nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (walk_list_bounding_has_walk_wgt subtype "bounding_circuits_defs.walk" "walks_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].Walk(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(bounding_circuits_defs.G))"))) (walk_list_bounding_has_walk_wgt_TCC2 0 (walk_list_bounding_has_walk_wgt_TCC2-2 "" 3790335756 ("" (use "measure_matrix_assoc") (("" (assert) nil nil)) nil) ((N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_matrix_assoc formula-decl nil measures nil)) shostak (walk_list_bounding_has_walk_wgt subtype "measures[bounding_circuits_defs.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(bounding_circuits_defs.f)}")) (walk_list_bounding_has_walk_wgt_TCC2-1 nil 3661799159 ("" (then (use "measure_matrix_assoc") (assert))) ((measure_matrix_assoc formula-decl nil measures nil)) nil (walk_list_bounding_has_walk_wgt subtype "measures[bounding_circuits_defs.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(bounding_circuits_defs.f)}"))) (walk_list_bounding_has_walk_wgt_TCC3 0 (walk_list_bounding_has_walk_wgt_TCC3-2 "" 3790335756 ("" (rewrite "id_is_identity") (("" (assert) nil nil)) nil) ((N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (id_is_identity formula-decl nil measures nil)) shostak (walk_list_bounding_has_walk_wgt subtype "measures[bounding_circuits_defs.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[bounding_circuits_defs.N].*)(bounding_circuits_defs.zero)}")) (walk_list_bounding_has_walk_wgt_TCC3-1 nil 3661799159 ("" (then (rewrite "id_is_identity") (assert))) ((id_is_identity formula-decl nil measures nil)) shostak (walk_list_bounding_has_walk_wgt subtype "measures[bounding_circuits_defs.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[bounding_circuits_defs.N].*)(bounding_circuits_defs.zero)}"))) (walk_list_bounding_has_walk_wgt_TCC4 0 (walk_list_bounding_has_walk_wgt_TCC4-1 nil 3661799159 ("" (subtype-tcc) nil nil) ((T formal-type-decl nil bounding_circuits_defs nil) (vert const-decl "bool" c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (walk_list_bounding_has_walk_wgt subtype "c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].get_wgt" "[[W: wgd_type[T, Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[bounding_circuits_defs.T].digraph_edges(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (walk_list_bounding_has_walk_wgt 0 (walk_list_bounding_has_walk_wgt-1 nil 3661799542 ("" (skolem 1 ("_" "bs" "walk")) (("" (case "FORALL (m:nat, wlist: list[Walk(dg(G))]):
                      m= length(wlist) AND member(walk, wlist) IMPLIES
                       (EXISTS (M: Measure_Matrix):
                          member(M, walk_list_bounding(wlist, bs)) AND
                           M <= wgt_walk(G, walk))") (("1" (skeep) (("1" (inst?) (("1" (inst - " length(wlist)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "m") (("1" (skeep) (("1" (expand "member") (("1" (lift-if -2) (("1" (ground) (("1" (expand "length") (("1" (ground) nil nil)) nil) ("2" (expand "length") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "member" -3) (("2" (lift-if -3) (("2" (ground) (("1" (expand "walk_list_bounding" 2) (("1" (hide -2) (("1" (lemma "walk_bounding_has_walk_wgt") (("1" (inst?) (("1" (skeep) (("1" (inst + "M") (("1" (assert) (("1" (lemma "member_append_l[Measure_Matrix]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "cdr(wlist)") (("2" (assert) (("2" (ground) (("1" (skeep) (("1" (inst + "M") (("1" (assert) (("1" (expand "walk_list_bounding" 2) (("1" (lemma "member_append_r[Measure_Matrix]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length" -) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (lemma "id_is_identity") (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (lemma "measure_matrix_assoc") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (lemma "id_is_identity") (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (lemma "measure_matrix_assoc") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (<= const-decl "bool" measures nil) (walk_list_bounding def-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (member def-decl "bool" list_props nil) (Walk type-eq-decl nil walks_ digraphs) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (walk? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (T formal-type-decl nil bounding_circuits_defs nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (associative? const-decl "bool" operator_defs nil) (identity? const-decl "bool" operator_defs nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (walk skolem-const-decl "Walk[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G))" bounding_circuits_defs nil) (bs skolem-const-decl "[vert[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
      digraph_make](dg(G)) ->
   list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (member_append_r formula-decl nil more_list_props structures) (walk_bounding_has_walk_wgt formula-decl nil bounding_circuits_defs nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (walk_bounding def-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (member_append_l formula-decl nil more_list_props structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (id_is_identity formula-decl nil measures nil) (measure_matrix_assoc formula-decl nil measures nil)) nil)) (bound_circuits_at_def_TCC1 0 (bound_circuits_at_def_TCC1-1 nil 3661777355 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil bounding_circuits_defs nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (get const-decl "Sign3" measures nil) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (le const-decl "bool" measures nil) (<= const-decl "bool" measures nil) (vert const-decl "bool" c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (/= const-decl "boolean" notequal nil) (cycle? const-decl "bool" cycles_ digraphs) (cycle_at? const-decl "bool" cycles_ digraphs) (minimalize const-decl "{L: list[Measure_Matrix[N]] |
   (FORALL ((M: Measure_Matrix | member(M, LM))):
      EXISTS (MM: Measure_Matrix): member(MM, L) AND MM <= M)
    AND (FORALL (m: Measure_Matrix): member(m, L) IMPLIES member(m, LM))}" bounding_circuits_defs nil) (bound_circuits_at const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (bound_circuits_at_def subtype "bounding_circuits_defs.circ" "walks_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].Walk(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(bounding_circuits_defs.G))"))) (bound_circuits_at_def_TCC2 0 (bound_circuits_at_def_TCC2-2 "" 3790335766 ("" (use "measure_matrix_assoc") (("" (assert) nil nil)) nil) ((N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_matrix_assoc formula-decl nil measures nil)) shostak (bound_circuits_at_def subtype "measures[bounding_circuits_defs.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(bounding_circuits_defs.f)}")) (bound_circuits_at_def_TCC2-1 nil 3661777355 ("" (then (use "measure_matrix_assoc") (assert))) ((measure_matrix_assoc formula-decl nil measures nil)) shostak (bound_circuits_at_def subtype "measures[bounding_circuits_defs.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(bounding_circuits_defs.f)}"))) (bound_circuits_at_def_TCC3 0 (bound_circuits_at_def_TCC3-2 "" 3790335766 ("" (rewrite "id_is_identity") (("" (assert) nil nil)) nil) ((N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (id_is_identity formula-decl nil measures nil)) shostak (bound_circuits_at_def subtype "measures[bounding_circuits_defs.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[bounding_circuits_defs.N].*)(bounding_circuits_defs.zero)}")) (bound_circuits_at_def_TCC3-1 nil 3661777355 ("" (then (rewrite "id_is_identity") (assert))) ((id_is_identity formula-decl nil measures nil)) nil (bound_circuits_at_def subtype "measures[bounding_circuits_defs.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[bounding_circuits_defs.N].*)(bounding_circuits_defs.zero)}"))) (bound_circuits_at_def_TCC4 0 (bound_circuits_at_def_TCC4-1 nil 3661777355 ("" (subtype-tcc) nil nil) ((make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil bounding_circuits_defs nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (get const-decl "Sign3" measures nil) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (le const-decl "bool" measures nil) (<= const-decl "bool" measures nil) (vert const-decl "bool" c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (/= const-decl "boolean" notequal nil) (cycle? const-decl "bool" cycles_ digraphs) (cycle_at? const-decl "bool" cycles_ digraphs) (minimalize const-decl "{L: list[Measure_Matrix[N]] |
   (FORALL ((M: Measure_Matrix | member(M, LM))):
      EXISTS (MM: Measure_Matrix): member(MM, L) AND MM <= M)
    AND (FORALL (m: Measure_Matrix): member(m, L) IMPLIES member(m, LM))}" bounding_circuits_defs nil) (bound_circuits_at const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (bound_circuits_at_def subtype "c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].get_wgt" "[[W: wgd_type[T, Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[bounding_circuits_defs.T].digraph_edges(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (bound_circuits_at_def 0 (bound_circuits_at_def-3 nil 3661799009 ("" (skeep) (("" (skeep) (("" (expand "bound_circuits_at") (("" (typepred "minimalize(walk_list_bounding(vc`cycles, bs))") (("" (hide (-1 -3)) (("" (ground) (("1" (lemma "walk_list_bounding_def") (("1" (inst - "n" "vc`cycles" "bs") (("1" (ground) (("1" (lemma "circuit_decomposition") (("1" (inst -1 "dg(G)" "vc`vert" "circ") (("1" (skeep) (("1" (inst -4 "drop_circuits(dg(G), cd)" "cd") (("1" (ground) (("1" (lemma "decomp_weight_def") (("1" (skeep) (("1" (inst -9 "M") (("1" (skeep) (("1" (inst 1 "MM") (("1" (assert) (("1" (lemma "matrices_order") (("1" (expand "partial_order?") (("1" (expand "preorder?") (("1" (expand "transitive?") (("1" (flatten) (("1" (inst -2 "MM" "M" "wgt_walk(G, circ)") (("1" (ground) (("1" (inst -3 "cd") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "id_is_identity") (("2" (propax) nil nil)) nil) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "vc`cycles") (("2" (hide -1) (("2" (inst -1 "drop_circuits(dg(G), cd)") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (skeep) (("2" (inst -3 "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "vc`cycles") (("2" (hide -1) (("2" (inst -1 "circ") (("1" (flatten) (("1" (hide -1) (("1" (assert) (("1" (lemma "walk_list_bounding_has_walk_wgt") (("1" (inst?) (("1" (inst -1 "circ") (("1" (assert) (("1" (skeep) (("1" (inst -5 "M") (("1" (skeep) (("1" (inst 1 "MM") (("1" (assert) (("1" (lemma "matrices_order") (("1" (expand "partial_order?") (("1" (expand "preorder?") (("1" (expand "transitive?") (("1" (flatten) (("1" (inst -2 "MM" "M" "wgt_walk(G, circ)") (("1" (assert) nil nil) ("2" (lemma "id_is_identity") (("2" (propax) nil nil)) nil) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "cycle_at?") (("2" (expand "cycle?") (("2" (expand "circuit?") (("2" (expand "pre_circuit?") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((VertCycles type-eq-decl nil cycles_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (walk_list_bounding def-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (walk? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (finseq type-eq-decl nil finite_sequences nil) (T formal-type-decl nil bounding_circuits_defs nil) (below type-eq-decl nil nat_types nil) (minimalize const-decl "{L: list[Measure_Matrix[N]] |
   (FORALL ((M: Measure_Matrix | member(M, LM))):
      EXISTS (MM: Measure_Matrix): member(MM, L) AND MM <= M)
    AND (FORALL (m: Measure_Matrix): member(m, L) IMPLIES member(m, LM))}" bounding_circuits_defs nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" measures nil) (member def-decl "bool" list_props nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (circuit_decomposition formula-decl nil circuit_decomp_ digraphs) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (partial_order? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (associative? const-decl "bool" operator_defs nil) (identity? const-decl "bool" operator_defs nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (id_is_identity formula-decl nil measures nil) (measure_matrix_assoc formula-decl nil measures nil) (preorder? const-decl "bool" orders nil) (matrices_order formula-decl nil measures nil) (bs skolem-const-decl "[vert[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
      digraph_make](dg(G)) ->
   list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (vc skolem-const-decl "VertCycles
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G))" bounding_circuits_defs nil) (M skolem-const-decl "Measure_Matrix[N]" bounding_circuits_defs nil) (decomp_weight_def formula-decl nil bounding_circuits_defs nil) (cycle_at? const-decl "bool" cycles_ digraphs) (IFF const-decl "[bool, bool -> bool]" booleans nil) (drop_circuits const-decl "{W: Walk(G) | length(W) = length(cd)}" circuit_decomp_ digraphs) (< const-decl "bool" reals nil) (verts_in? const-decl "bool" walks_ digraphs) (Seq type-eq-decl nil walks_ digraphs) (gen_seq1 const-decl "Seq(G)" walks_ digraphs) (vert_circ type-eq-decl nil circuit_decomp_ digraphs) (list2finseq const-decl "finseq[T]" list2finseq nil) (map adt-def-decl "list[T1]" list_adt_map nil) (walk_decomp type-eq-decl nil circuit_decomp_ digraphs) (cd skolem-const-decl "walk_decomp
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G))" bounding_circuits_defs nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (nth def-decl "T" list_props nil) (n skolem-const-decl "nat" bounding_circuits_defs nil) (circuit_at? const-decl "bool" circuits_ digraphs) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (walk_list_bounding_def formula-decl nil bounding_circuits_defs nil) (circuit? const-decl "bool" circuits_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (cycle? const-decl "bool" cycles_ digraphs) (M skolem-const-decl "Measure_Matrix[N]" bounding_circuits_defs nil) (walk_list_bounding_has_walk_wgt formula-decl nil bounding_circuits_defs nil) (circ skolem-const-decl "prewalk
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make]" bounding_circuits_defs nil) (bound_circuits_at const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil)) nil) (bound_circuits_at_def-2 nil 3661778925 ("" (skeep) (("" (skeep) (("" (expand "bound_circuits_at") (("" (typepred "minimalize(walk_list_bounding(vc`cycles, bs))") (("" (hide (-1 -3)) (("" (ground) (("1" (lemma "walk_list_bounding_def") (("1" (inst - "n" "vc`cycles" "bs") (("1" (ground) (("1" (lemma "circuit_decomposition") (("1" (inst -1 "dg(G)" "vc`vert" "circ") (("1" (skeep) (("1" (inst -4 "drop_circuits(dg(G), cd)" "cd") (("1" (ground) (("1" (lemma "decomp_weight_def") (("1" (inst - "G" "cd") (("1" (replace -1 -2) (("1" (replace -3 -2) (("1" (skeep) (("1" (inst -9 "M") (("1" (skeep) (("1" (inst 1 "MM") (("1" (assert) (("1" (lemma "matrices_order") (("1" (expand "partial_order?") (("1" (expand "preorder?") (("1" (expand "transitive?") (("1" (flatten) (("1" (inst -2 "MM" "M" "wgt_walk(G, circ)") (("1" (ground) nil) ("2" (lemma "id_is_identity") (("2" (propax) nil))) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil))))))))))))))))))))))))))))))))) ("2" (typepred "vc`cycles") (("2" (hide -1) (("2" (expand "cycles_at_wdg") (("2" (inst -1 "drop_circuits(dg(G), cd)") (("2" (flatten) (("2" (assert) nil))))))))))))) ("2" (assert) (("2" (skeep) (("2" (inst -3 "j") (("2" (assert) nil))))))))))))))))))))) ("2" (typepred "vc`cycles") (("2" (hide -1) (("2" (expand "cycles_at_wdg") (("2" (inst -1 "circ") (("1" (flatten) (("1" (hide -1) (("1" (assert) (("1" (lemma "walk_list_bounding_has_walk_wgt") (("1" (inst?) (("1" (inst -1 "circ") (("1" (assert) (("1" (skeep) (("1" (inst -5 "M") (("1" (skeep) (("1" (inst 1 "MM") (("1" (assert) (("1" (lemma "matrices_order") (("1" (expand "partial_order?") (("1" (expand "preorder?") (("1" (expand "transitive?") (("1" (flatten) (("1" (inst -2 "MM" "M" "wgt_walk(G, circ)") (("1" (assert) nil) ("2" (lemma "id_is_identity") (("2" (propax) nil))) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil))))))))))))))))))))))))))))))))))))))) ("2" (expand "cycle_at?") (("2" (expand "cycle?") (("2" (expand "circuit?") (("2" (expand "pre_circuit?") (("2" (flatten) nil)))))))))))))))))))))))))))) nil) nil nil) (bound_circuits_at_def-1 nil 3661778599 ("" (skeep) (("" (skeep) (("" (expand "bound_circuits_at") (("" (typepred "minimalize(walk_list_bounding(G, vc`cycles, bs))") (("" (hide (-1 -3)) (("" (ground) (("1" (lemma "walk_list_bounding_def") (("1" (inst - "n" "vc`cycles" "bs") (("1" (ground) (("1" (lemma "circuit_decomposition") (("1" (inst -1 "dg(G)" "vc`vert" "circ") (("1" (skeep) (("1" (inst -4 "drop_circuits(dg(G), cd)" "cd") (("1" (ground) (("1" (lemma "decomp_weight_def") (("1" (inst - "G" "cd") (("1" (replace -1 -2) (("1" (replace -3 -2) (("1" (skeep) (("1" (inst -9 "M") (("1" (skeep) (("1" (inst 1 "MM") (("1" (assert) (("1" (lemma "matrices_order") (("1" (expand "partial_order?") (("1" (expand "preorder?") (("1" (expand "transitive?") (("1" (flatten) (("1" (inst -2 "MM" "M" "wgt_walk(G, circ)") (("1" (ground) nil) ("2" (lemma "id_is_identity") (("2" (propax) nil))) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil))))))))))))))))))))))))))))))))) ("2" (typepred "vc`cycles") (("2" (hide -1) (("2" (expand "cycles_at_wdg") (("2" (inst -1 "drop_circuits(dg(G), cd)") (("2" (flatten) (("2" (assert) nil))))))))))))) ("2" (assert) (("2" (skeep) (("2" (inst -3 "j") (("2" (assert) nil))))))))))))))))))))) ("2" (typepred "vc`cycles") (("2" (hide -1) (("2" (expand "cycles_at_wdg") (("2" (inst -1 "circ") (("1" (flatten) (("1" (hide -1) (("1" (assert) (("1" (lemma "walk_list_bounding_has_walk_wgt") (("1" (inst?) (("1" (inst -1 "circ") (("1" (assert) (("1" (skeep) (("1" (inst -5 "M") (("1" (skeep) (("1" (inst 1 "MM") (("1" (assert) (("1" (lemma "matrices_order") (("1" (expand "partial_order?") (("1" (expand "preorder?") (("1" (expand "transitive?") (("1" (flatten) (("1" (inst -2 "MM" "M" "wgt_walk(G, circ)") (("1" (assert) nil) ("2" (lemma "id_is_identity") (("2" (propax) nil))) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil))))))))))))))))))))))))))))))))))))))) ("2" (expand "cycle_at?") (("2" (expand "cycle?") (("2" (expand "circuit?") (("2" (expand "pre_circuit?") (("2" (flatten) nil)))))))))))))))))))))))))))) nil) nil nil)) (index_of_vert_TCC1 0 (index_of_vert_TCC1-1 nil 3659136927 ("" (skeep) (("" (typepred (VL)) (("" (expand "every") (("" (lift-if -1) (("" (ground) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (vert type-eq-decl nil digraphs_ digraphs) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (T formal-type-decl nil bounding_circuits_defs nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (index_of_vert subtype "bounding_circuits_defs.VL" "(list_adt[bounding_circuits_defs.T].cons?)"))) (index_of_vert_TCC2 0 (index_of_vert_TCC2-2 "" 3790335774 ("" (skeep :preds? t) (("" (expand "nth" 1 1) (("" (assert) (("" (skeep) (("" (case " i=0") (("1" (replaces -1) (("1" (ground) (("1" (skeep) (("1" (inst - "j") (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -5 :dir rl) (("2" (inst -4 "0") (("2" (ground) (("2" (expand "nth" 2 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nth def-decl "T" list_props nil) (TRUE const-decl "bool" booleans nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (T formal-type-decl nil bounding_circuits_defs nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (vert type-eq-decl nil digraphs_ digraphs) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (index_of_vert subtype "0" "{i: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(bounding_circuits_defs.VL)) | booleans.AND(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.VL, i) = bounding_circuits_defs.v, FORALL (j: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(bounding_circuits_defs.VL))): booleans.IMPLIES(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.VL, j) = bounding_circuits_defs.v, i = j))}")) (index_of_vert_TCC2-1 nil 3659136927 ("" (skeep :preds? t) (("" (inst?) (("" (expand "nth" 1 1) (("" (assert) (("" (skeep) (("" (case " i=0") (("1" (replaces -1) (("1" (ground) (("1" (skeep) (("1" (inst - "j") (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -5 :dir rl) (("2" (inst -4 "0") (("2" (ground) (("2" (expand "nth" 2 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list type-decl nil list_adt nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (Sign3 type-eq-decl nil sign3 reals) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (vert type-eq-decl nil digraphs_ digraphs)) nil (index_of_vert subtype "0" "{i: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(bounding_circuits_defs.VL)) | booleans.AND(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.VL, i) = bounding_circuits_defs.v, FORALL (j: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(bounding_circuits_defs.VL))): booleans.IMPLIES(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.VL, j) = bounding_circuits_defs.v, i = j))}"))) (index_of_vert_TCC3 0 (dslfknasldfnasd "asdnflaskdnf" 3659173558 ("" (skeep :preds? t) (("" (skeep) (("" (inst 2 "i-1") (("1" (ground) (("1" (expand "nth" -3) (("1" (lift-if -3) (("1" (ground) nil nil)) nil)) nil) ("2" (skeep) (("2" (inst -5 "j+1") (("1" (expand " nth" -5) (("1" (lift-if -5) (("1" (ground) (("1" (replace -1) (("1" (expand "nth" -5) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred (j)) (("2" (expand " length" 1) (("2" (ground) (("2" (lift-if 1) (("2" (ground) (("2" (typepred (VL)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) (("1" (case "i=0") (("1" (replace -1) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil) ("2" (inst -4 "0") (("2" (ground) nil nil)) nil)) nil) ("2" (typepred (i)) (("2" (expand "length" -1) (("2" (lift-if -1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (j skolem-const-decl "below(length(cdr(VL)))" bounding_circuits_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (vert const-decl "bool" c_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (T formal-type-decl nil bounding_circuits_defs nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (vert type-eq-decl nil digraphs_ digraphs) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (v skolem-const-decl "vert[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G))" bounding_circuits_defs nil) (VL skolem-const-decl "{VL:
   list[vert[T, digraph_type[T], digraph_verts, digraph_edges,
             digraph_size, digraph_make](dg(G))] |
   EXISTS (i: below(length(VL))):
     nth(VL, i) = v AND
      FORALL (j: below(length(VL))): nth(VL, j) = nth(VL, i) IMPLIES j = i}" bounding_circuits_defs nil) (i skolem-const-decl "below(length(VL))" bounding_circuits_defs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (index_of_vert subtype "list_adt[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].cdr(bounding_circuits_defs.VL)" "{VL: list_adt[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].list | EXISTS (i: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(VL))): booleans.AND(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(VL, i) = bounding_circuits_defs.v, FORALL (j: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(VL))): booleans.IMPLIES(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(VL, j) = list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(VL, i), j = i))}")) (index_of_vert_TCC3-1 nil 3659136927 ("" (subtype-tcc) nil nil) nil nil (index_of_vert subtype "list_adt[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].cdr(bounding_circuits_defs.VL)" "{VL: list_adt[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].list | EXISTS (i: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(VL))): booleans.AND(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(VL, i) = bounding_circuits_defs.v, FORALL (j: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(VL))): booleans.IMPLIES(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(VL, j) = list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(VL, i), j = i))}"))) (index_of_vert_TCC4 0 (index_of_vert_TCC4-1 nil 3659136927 ("" (skeep) (("" (expand "length" 2 2) (("" (lift-if 2) (("" (ground) (("" (typepred (VL)) (("" (skeep) (("" (typepred "i") (("" (expand "length") (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil bounding_circuits_defs nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign3 type-eq-decl nil sign3 reals) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (vert type-eq-decl nil digraphs_ digraphs) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil)) nil (index_of_vert termination "bounding_circuits_defs.index_of_vert(bounding_circuits_defs.v, list_adt[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].cdr(bounding_circuits_defs.VL))" "nil"))) (index_of_vert_TCC5 0 (index_of_vert_TCC5-3 nil 3661772729 ("" (skeep) (("" (typepred " v1(v, cdr[vert(dg(G))](VL))") (("1" (ground) (("1" (expand "length" 1) (("1" (lift-if 1) (("1" (ground) (("1" (typepred "VL") (("1" (skeep) (("1" (ground) (("1" (typepred (i)) (("1" (expand "length") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 1 1) (("2" (propax) nil nil)) nil) ("3" (skeep) (("3" (inst -4 "j-1") (("1" (expand "nth" -1) (("1" (lift-if -1) (("1" (ground) nil nil)) nil)) nil) ("2" (typepred "j") (("2" (case "j=0") (("1" (replace -1) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "length" -1) (("2" (lift-if -1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand " length" 1 2) (("2" (lift-if 1) (("2" (ground) (("1" (typepred (VL)) (("1" (skeep) (("1" (typepred (i)) (("1" (expand "length") (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred (VL)) (("2" (skeep) (("2" (typepred (i)) (("2" (expand "length") (("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred (VL)) (("3" (skeep) (("3" (skeep) (("3" (typepred (i)) (("3" (expand "length") (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred (VL)) (("3" (skeep) (("3" (inst + "i-1") (("1" (hide 3) (("1" (ground) (("1" (expand "nth" -) (("1" (lift-if -2) (("1" (ground) nil nil)) nil)) nil) ("2" (skeep) (("2" (inst -4 "j+1") (("1" (expand "nth" -4) (("1" (lift-if -4) (("1" (ground) (("1" (replace -1) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (expand "length" +) (("2" (lift-if 1) (("2" (ground) (("2" (typepred (i)) (("2" (expand "length") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i=0") (("1" (replace -1) (("1" (expand "nth" -) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (typepred (i)) (("2" (expand "length" -1) (("2" (lift-if -1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (vert? const-decl "bool" digraphs_ digraphs) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (vert type-eq-decl nil digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (T formal-type-decl nil bounding_circuits_defs nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (j skolem-const-decl "below(length(VL))" bounding_circuits_defs nil) (VL skolem-const-decl "{VL:
   list[vert[T, digraph_type[T], digraph_verts, digraph_edges,
             digraph_size, digraph_make](dg(G))] |
   EXISTS (i: below(length(VL))):
     nth(VL, i) = v AND
      FORALL (j: below(length(VL))): nth(VL, j) = nth(VL, i) IMPLIES j = i}" bounding_circuits_defs nil) (v skolem-const-decl "vert[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G))" bounding_circuits_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (j skolem-const-decl "below(length(cdr[vert[T, digraph_type[T], digraph_verts, digraph_edges,
                      digraph_size, digraph_make](dg(G))]
                 (VL)))" bounding_circuits_defs nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (i skolem-const-decl "below(length(VL))" bounding_circuits_defs nil)) nil (index_of_vert subtype "(number_fields.+)(1, bounding_circuits_defs.index_of_vert(bounding_circuits_defs.v, list_adt[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].cdr(bounding_circuits_defs.VL)))" "{i: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(bounding_circuits_defs.VL)) | booleans.AND(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.VL, i) = bounding_circuits_defs.v, FORALL (j: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(bounding_circuits_defs.VL))): booleans.IMPLIES(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.VL, j) = bounding_circuits_defs.v, i = j))}")) (index_of_vert_TCC5-2 nil 3659963540 ("" (skeep) (("" (typepred " v1(G, v, cdr[vert(dg(G))](VL))") (("1" (ground) (("1" (expand "length" 1) (("1" (lift-if 1) (("1" (ground) (("1" (typepred "VL") (("1" (skeep) (("1" (ground) (("1" (typepred (i)) (("1" (expand "length") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 1 1) (("2" (propax) nil nil)) nil) ("3" (skeep) (("3" (inst -4 "j-1") (("1" (expand "nth" -1) (("1" (lift-if -1) (("1" (ground) nil nil)) nil)) nil) ("2" (typepred "j") (("2" (case "j=0") (("1" (replace -1) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "length" -1) (("2" (lift-if -1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand " length" 1 2) (("2" (lift-if 1) (("2" (ground) (("1" (typepred (VL)) (("1" (skeep) (("1" (typepred (i)) (("1" (expand "length") (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred (VL)) (("2" (skeep) (("2" (typepred (i)) (("2" (expand "length") (("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred (VL)) (("3" (skeep) (("3" (skeep) (("3" (typepred (i)) (("3" (expand "length") (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred (VL)) (("3" (skeep) (("3" (inst + "i-1") (("1" (hide 3) (("1" (ground) (("1" (expand "nth" -) (("1" (lift-if -2) (("1" (ground) nil nil)) nil)) nil) ("2" (skeep) (("2" (inst -4 "j+1") (("1" (expand "nth" -4) (("1" (lift-if -4) (("1" (ground) (("1" (replace -1) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (expand "length" +) (("2" (lift-if 1) (("2" (ground) (("2" (typepred (i)) (("2" (expand "length") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i=0") (("1" (replace -1) (("1" (expand "nth" -) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (typepred (i)) (("2" (expand "length" -1) (("2" (lift-if -1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((vert? const-decl "bool" digraphs_ digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (vert type-eq-decl nil digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil)) nil (index_of_vert subtype "(number_fields.+)(1, bounding_circuits_defs.index_of_vert(bounding_circuits_defs.v, list_adt[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].cdr(bounding_circuits_defs.VL)))" "{i: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(bounding_circuits_defs.VL)) | booleans.AND(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.VL, i) = bounding_circuits_defs.v, FORALL (j: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(bounding_circuits_defs.VL))): booleans.IMPLIES(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.VL, j) = bounding_circuits_defs.v, i = j))}")) (index_of_vert_TCC5-1 nil 3659136927 ("" (skeep) (("" (typepred " v1(G, v, cdr[vert[T](dg(G))](VL))") (("1" (ground) (("1" (expand "length" 1) (("1" (lift-if 1) (("1" (ground) (("1" (typepred "VL") (("1" (skeep) (("1" (ground) (("1" (typepred (i)) (("1" (expand "length") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 1 1) (("2" (propax) nil nil)) nil) ("3" (skeep) (("3" (inst -4 "j-1") (("1" (expand "nth" -1) (("1" (lift-if -1) (("1" (ground) nil nil)) nil)) nil) ("2" (typepred "j") (("2" (case "j=0") (("1" (replace -1) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "length" -1) (("2" (lift-if -1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand " length" 1 2) (("2" (lift-if 1) (("2" (ground) (("1" (typepred (VL)) (("1" (skeep) (("1" (typepred (i)) (("1" (expand "length") (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred (VL)) (("2" (skeep) (("2" (typepred (i)) (("2" (expand "length") (("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred (VL)) (("3" (skeep) (("3" (skeep) (("3" (typepred (i)) (("3" (expand "length") (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred (VL)) (("3" (skeep) (("3" (inst + "i-1") (("1" (hide 3) (("1" (ground) (("1" (expand "nth" -) (("1" (lift-if -2) (("1" (ground) nil nil)) nil)) nil) ("2" (skeep) (("2" (inst -4 "j+1") (("1" (expand "nth" -4) (("1" (lift-if -4) (("1" (ground) (("1" (replace -1) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (expand "length" +) (("2" (lift-if 1) (("2" (ground) (("2" (typepred (i)) (("2" (expand "length") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i=0") (("1" (replace -1) (("1" (expand "nth" -) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (typepred (i)) (("2" (expand "length" -1) (("2" (lift-if -1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_set type-eq-decl nil finite_sets nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals)) nil (index_of_vert subtype "(number_fields.+)(1, bounding_circuits_defs.index_of_vert(bounding_circuits_defs.v, list_adt[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].cdr(bounding_circuits_defs.VL)))" "{i: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(bounding_circuits_defs.VL)) | booleans.AND(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.VL, i) = bounding_circuits_defs.v, FORALL (j: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(bounding_circuits_defs.VL))): booleans.IMPLIES(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(bounding_circuits_defs.VL, j) = bounding_circuits_defs.v, i = j))}"))) (bound_circuits_list_def_TCC1 0 (bound_circuits_list_def_TCC1-1 nil 3661775835 ("" (subtype-tcc) nil nil) ((VCList type-eq-decl nil cycles_ digraphs) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (VertCycles type-eq-decl nil cycles_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (vert? const-decl "bool" digraphs_ digraphs) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil bounding_circuits_defs nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (get const-decl "Sign3" measures nil) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (le const-decl "bool" measures nil) (<= const-decl "bool" measures nil) (vert const-decl "bool" c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (/= const-decl "boolean" notequal nil) (cycle? const-decl "bool" cycles_ digraphs) (cycle_at? const-decl "bool" cycles_ digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (bound_circuits_list_def subtype "bounding_circuits_defs.vl" "{VL: list_adt[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].list | EXISTS (i: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(VL))): booleans.AND(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(VL, i) = bounding_circuits_defs.v, FORALL (j: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(VL))): booleans.IMPLIES(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(VL, j) = list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(VL, i), j = i))}"))) (bound_circuits_list_def_TCC2 0 (bound_circuits_list_def_TCC2-3 "" 3790335781 ("" (skeep) (("" (skeep) (("" (typepred "index_of_vert(v, vl)") (("" (expand "bound_circuits_list") (("" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("" (typepred "vc_list") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bound_circuits_list const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (VertCycles type-eq-decl nil cycles_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (VCList type-eq-decl nil cycles_ digraphs) (bound_circuits_at const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (map_length formula-decl nil more_map_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (T formal-type-decl nil bounding_circuits_defs nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert type-eq-decl nil digraphs_ digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (vert? const-decl "bool" digraphs_ digraphs) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (index_of_vert def-decl "{i: below(length(VL)) |
   nth(VL, i) = v AND
    FORALL (j: below(length(VL))): nth(VL, j) = v IMPLIES i = j}" bounding_circuits_defs nil) (vert_list const-decl "bool" digraphs_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs)) shostak (bound_circuits_list_def subtype "bounding_circuits_defs.index_of_vert(bounding_circuits_defs.v, bounding_circuits_defs.vl)" "below[length[list[Measure_Matrix[N]]](bound_circuits_list(vl, vc_list, bs))]")) (bound_circuits_list_def_TCC2-2 nil 3661803779 ("" (skeep) (("" (skeep) (("" (typepred "index_of_vert(v, vl)") (("1" (expand "bound_circuits_list") (("1" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("1" (typepred "vc_list") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "vl") (("2" (typepred "v") (("2" (expand "vert_list") (("2" (inst -3 "v") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((VertCycles type-eq-decl nil cycles_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (VCList type-eq-decl nil cycles_ digraphs) (list type-decl nil list_adt nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert type-eq-decl nil digraphs_ digraphs) (Sign3 type-eq-decl nil sign3 reals) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (vert? const-decl "bool" digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs)) nil (bound_circuits_list_def subtype "bounding_circuits_defs.index_of_vert(bounding_circuits_defs.v, bounding_circuits_defs.vl)" "below[length[list[Measure_Matrix[N]]](bound_circuits_list(vl, vc_list, bs))]")) (bound_circuits_list_def_TCC2-1 nil 3661775835 ("" (then (use "measure_matrix_assoc") (assert))) ((measure_matrix_assoc formula-decl nil measures nil)) nil (bound_circuits_list_def subtype "bounding_circuits_defs.index_of_vert(bounding_circuits_defs.v, bounding_circuits_defs.vl)" "below[length[list[Measure_Matrix[N]]](bound_circuits_list(vl, vc_list, bs))]"))) (bound_circuits_list_def_TCC3 0 (bound_circuits_list_def_TCC3-1 nil 3661775835 ("" (subtype-tcc) nil nil) ((VCList type-eq-decl nil cycles_ digraphs) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (VertCycles type-eq-decl nil cycles_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (vert? const-decl "bool" digraphs_ digraphs) (NOT const-decl "[bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil bounding_circuits_defs nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (get const-decl "Sign3" measures nil) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (le const-decl "bool" measures nil) (<= const-decl "bool" measures nil) (vert const-decl "bool" c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (/= const-decl "boolean" notequal nil) (cycle? const-decl "bool" cycles_ digraphs) (cycle_at? const-decl "bool" cycles_ digraphs) (minimalize const-decl "{L: list[Measure_Matrix[N]] |
   (FORALL ((M: Measure_Matrix | member(M, LM))):
      EXISTS (MM: Measure_Matrix): member(MM, L) AND MM <= M)
    AND (FORALL (m: Measure_Matrix): member(m, L) IMPLIES member(m, LM))}" bounding_circuits_defs nil) (bound_circuits_at const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (bound_circuits_list const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak (bound_circuits_list_def subtype "bounding_circuits_defs.circ" "walks_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].Walk(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(bounding_circuits_defs.G))"))) (bound_circuits_list_def_TCC4 0 (bound_circuits_list_def_TCC4-2 "" 3790335782 ("" (use "measure_matrix_assoc") (("" (assert) nil nil)) nil) ((N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_matrix_assoc formula-decl nil measures nil)) shostak (bound_circuits_list_def subtype "measures[bounding_circuits_defs.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(bounding_circuits_defs.f)}")) (bound_circuits_list_def_TCC4-1 nil 3661775835 ("" (then (use "measure_matrix_assoc") (assert))) ((measure_matrix_assoc formula-decl nil measures nil)) nil (bound_circuits_list_def subtype "measures[bounding_circuits_defs.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(bounding_circuits_defs.f)}"))) (bound_circuits_list_def_TCC5 0 (bound_circuits_list_def_TCC5-2 "" 3790335783 ("" (rewrite "id_is_identity") (("" (assert) nil nil)) nil) ((N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (id_is_identity formula-decl nil measures nil)) shostak (bound_circuits_list_def subtype "measures[bounding_circuits_defs.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[bounding_circuits_defs.N].*)(bounding_circuits_defs.zero)}")) (bound_circuits_list_def_TCC5-1 nil 3661775835 ("" (then (rewrite "id_is_identity") (assert))) ((id_is_identity formula-decl nil measures nil)) shostak (bound_circuits_list_def subtype "measures[bounding_circuits_defs.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[bounding_circuits_defs.N].*)(bounding_circuits_defs.zero)}"))) (bound_circuits_list_def_TCC6 0 (bound_circuits_list_def_TCC6-3 "" 3790335783 ("" (use "measure_matrix_assoc") (("" (assert) nil nil)) nil) ((wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign3 type-eq-decl nil sign3 reals) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (T formal-type-decl nil bounding_circuits_defs nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_matrix_assoc formula-decl nil measures nil)) shostak (bound_circuits_list_def subtype "c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].get_wgt" "[[W: wgd_type[T, Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[bounding_circuits_defs.T].digraph_edges(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]")) (bound_circuits_list_def_TCC6-2 nil 3661776461 ("" (then (use "measure_matrix_assoc") (assert))) ((measure_matrix_assoc formula-decl nil measures nil) (edges const-decl "bool" c_digraphs_def digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (list type-decl nil list_adt nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs)) nil (bound_circuits_list_def subtype "c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].get_wgt" "[[W: wgd_type[T, Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[bounding_circuits_defs.T].digraph_edges(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]")) (bound_circuits_list_def_TCC6-1 nil 3661775835 ("" (subtype-tcc) nil nil) nil nil (bound_circuits_list_def subtype "c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].get_wgt" "[[W: wgd_type[T, Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[bounding_circuits_defs.T].digraph_edges(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (bound_circuits_list_def 0 (bound_circuits_list_def-2 nil 3661778006 ("" (skeep) (("" (skeep) (("" (expand "bound_circuits_list" 1) (("" (lemma "map_nth_rw[VertCycles(dg(G)), list[Measure_Matrix]]") (("" (inst?) (("1" (replaces -1) (("1" (typepred "vc_list") (("1" (typepred "index_of_vert(v, vl)") (("1" (lemma "bound_circuits_at_def") (("1" (inst - "n" "nth(vc_list, index_of_vert(v, vl))" "bs") (("1" (label corc -8) (("1" (hide corc) (("1" (ground) (("1" (inst -6 "index_of_vert(v, vl)") (("1" (replace -3 -6) (("1" (replace -6 -1 :dir rl) (("1" (reveal corc) (("1" (inst -2 "circ") (("1" (assert) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (typepred "vl") (("2" (expand "vert_list") (("2" (inst -2 "v") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "index_of_vert(v, vl)") (("2" (typepred "vc_list") (("2" (assert) nil nil)) nil)) nil) ("3" (typepred "vl") (("3" (expand "vert_list") (("3" (inst -2 "v") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((VertCycles type-eq-decl nil cycles_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (vert type-eq-decl nil digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil bounding_circuits_defs nil) (map_nth_rw formula-decl nil more_map_props nil) (TRUE const-decl "bool" booleans nil) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (bound_circuits_at_def formula-decl nil bounding_circuits_defs nil) (NOT const-decl "[bool -> bool]" booleans nil) (bound_circuits_at const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (index_of_vert def-decl "{i: below(length(VL)) |
   nth(VL, i) = v AND
    FORALL (j: below(length(VL))): nth(VL, j) = v IMPLIES i = j}" bounding_circuits_defs nil) (VCList type-eq-decl nil cycles_ digraphs) (vc_list skolem-const-decl "VCList
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G), vl)" bounding_circuits_defs nil) (< const-decl "bool" reals nil) (vert? const-decl "bool" digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs) (vl skolem-const-decl "VertList
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G))" bounding_circuits_defs nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (v skolem-const-decl "vert[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G))" bounding_circuits_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bound_circuits_list const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil)) nil) (bound_circuits_list_def-1 nil 3661776954 ("" (skeep) (("" (skeep) (("" (expand "bound_circuits_list" 1) (("" (lemma "map_nth_rw[VertCycles(dg(G)), list[Measure_Matrix]]") (("" (inst?) (("1" (replaces -1) (("1" (typepred "vc_list") (("1" (expand "vclist") (("1" (typepred "index_of_vert(v, vl)") (("1" (lemma "bound_circuits_at_def") (("1" (inst - "n" "nth(vc_list, index_of_vert(G, v, vl))" "bs") (("1" (label corc -7) (("1" (hide corc) (("1" (ground) (("1" (inst -6 "index_of_vert(v, vl)") (("1" (replace -3 -6) (("1" (replace -6 -1 :dir rl) (("1" (reveal corc) (("1" (inst -2 "circ") (("1" (assert) (("1" (ground) nil))))))))))))))))))) ("2" (assert) nil))))) ("2" (typepred "vl") (("2" (expand "vert_list") (("2" (inst -2 "v") nil))))))))))))) ("2" (typepred "index_of_vert(v, vl)") (("2" (typepred "vc_list") (("2" (expand "vclist") (("2" (assert) nil))))))) ("3" (typepred "vl") (("3" (expand "vert_list") (("3" (inst -2 "v") nil)))))))))))))) nil) nil nil)) (bound_circuits_iter_TCC1 0 (bound_circuits_iter_TCC2-3 nil 3661772785 ("" (skeep) (("" (skeep) (("" (skeep) (("" (typepred "index_of_vert(v, vl)") (("1" (expand "bound_circuits_list") (("1" (typepred "vc_list") (("1" (assert) (("1" (typepred "vl") (("1" (expand "vert_list") (("1" (inst -2 "v") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "vl") (("2" (expand "vert_list") (("2" (inst -2 "v") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((VertList type-eq-decl nil digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (index_of_vert def-decl "{i: below(length(VL)) |
   nth(VL, i) = v AND
    FORALL (j: below(length(VL))): nth(VL, j) = v IMPLIES i = j}" bounding_circuits_defs nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (vert? const-decl "bool" digraphs_ digraphs) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (vert type-eq-decl nil digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (T formal-type-decl nil bounding_circuits_defs nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (VCList type-eq-decl nil cycles_ digraphs) (VertCycles type-eq-decl nil cycles_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bound_circuits_list const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil)) nil (bound_circuits_iter subtype "bounding_circuits_defs.vl" "{VL: list_adt[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].list | EXISTS (i: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(VL))): booleans.AND(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(VL, i) = bounding_circuits_defs.v, FORALL (j: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(VL))): booleans.IMPLIES(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(VL, j) = list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(VL, i), j = i))}")) (bound_circuits_iter_TCC2-2 nil 3661719764 ("" (skeep) (("" (skeep) (("" (skeep) (("" (typepred "index_of_vert(G, v, vl)") (("" (replace -4) (("" (expand "bound_circuits_list") (("" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("" (typepred "vc_list") (("" (assert) (("" (expand "vclist") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((VertCycles type-eq-decl nil cycles_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (wdg type-eq-decl nil matrix_wdg nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert type-eq-decl nil digraphs_ digraphs) (Sign3 type-eq-decl nil sign3 reals) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (vert? const-decl "bool" digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs)) nil (bound_circuits_iter subtype "bounding_circuits_defs.vl" "{VL: list_adt[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].list | EXISTS (i: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(VL))): booleans.AND(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(VL, i) = bounding_circuits_defs.v, FORALL (j: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(VL))): booleans.IMPLIES(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(VL, j) = list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(VL, i), j = i))}")) (bound_circuits_iter_TCC2-1 nil 3659185144 ("" (skeep) (("" (skeep) (("" (skeep) (("" (typepred "index_of_vert(G, v, vl)") (("" (replace -4) (("" (expand "bound_circuits_list") (("" (rewrite "map_length[Vert_Cycles(G), list[Measure_Matrix]]") (("" (typepred "vc_list") (("" (assert) (("" (expand "vclist") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((VertList type-eq-decl nil digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (vert type-eq-decl nil digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil)) nil (bound_circuits_iter subtype "bounding_circuits_defs.vl" "{VL: list_adt[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].list | EXISTS (i: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(VL))): booleans.AND(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(VL, i) = bounding_circuits_defs.v, FORALL (j: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(VL))): booleans.IMPLIES(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(VL, j) = list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(VL, i), j = i))}"))) (bound_circuits_iter_TCC2 0 (bound_circuits_iter_TCC3-1 nil 3659185144 ("" (skeep) (("" (skeep) (("" (skeep) (("" (typepred "index_of_vert(v, vl)") (("" (replace -4) (("" (expand "bound_circuits_list") (("" (rewrite "map_length") (("" (typepred "vc_list") (("" (replace -1) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((VertList type-eq-decl nil digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (index_of_vert def-decl "{i: below(length(VL)) |
   nth(VL, i) = v AND
    FORALL (j: below(length(VL))): nth(VL, j) = v IMPLIES i = j}" bounding_circuits_defs nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (vert? const-decl "bool" digraphs_ digraphs) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (vert type-eq-decl nil digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (T formal-type-decl nil bounding_circuits_defs nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (bound_circuits_list const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (VertCycles type-eq-decl nil cycles_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (VCList type-eq-decl nil cycles_ digraphs) (bound_circuits_at const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (map_length formula-decl nil more_map_props nil)) nil (bound_circuits_iter subtype "bounding_circuits_defs.index_of_vert(bounding_circuits_defs.v, bounding_circuits_defs.vl)" "below[length[list[Measure_Matrix[N]]](bcl)]"))) (bound_circuits_iter_TCC3 0 (bound_circuits_iter_TCC4-1 nil 3659185144 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil bounding_circuits_defs nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (vert type-eq-decl nil digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (VertCycles type-eq-decl nil cycles_ digraphs) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (VCList type-eq-decl nil cycles_ digraphs) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minimalize const-decl "{L: list[Measure_Matrix[N]] |
   (FORALL ((M: Measure_Matrix | member(M, LM))):
      EXISTS (MM: Measure_Matrix): member(MM, L) AND MM <= M)
    AND (FORALL (m: Measure_Matrix): member(m, L) IMPLIES member(m, LM))}" bounding_circuits_defs nil) (bound_circuits_at const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (bound_circuits_list const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (bound_circuits_iter subtype "(number_fields.-)(bounding_circuits_defs.i, 1)" "nat"))) (bound_circuits_iter_TCC4 0 (bound_circuits_iter_TCC5-1 nil 3770219239 ("" (termination-tcc) nil nil) ((minimalize const-decl "{L: list[Measure_Matrix[N]] |
   (FORALL ((M: Measure_Matrix | member(M, LM))):
      EXISTS (MM: Measure_Matrix): member(MM, L) AND MM <= M)
    AND (FORALL (m: Measure_Matrix): member(m, L) IMPLIES member(m, LM))}" bounding_circuits_defs nil) (bound_circuits_at const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (bound_circuits_list const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (bound_circuits_iter termination "bounding_circuits_defs.bound_circuits_iter(bounding_circuits_defs.vl, bounding_circuits_defs.vc_list, bounding_circuits_defs.nbs, (number_fields.-)(bounding_circuits_defs.i, 1))" "nil"))) (bound_circuits_iter_def_TCC1 0 (bound_circuits_iter_def_TCC1-1 nil 3661774396 ("" (subtype-tcc) nil nil) ((VCList type-eq-decl nil cycles_ digraphs) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (VertCycles type-eq-decl nil cycles_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (vert? const-decl "bool" digraphs_ digraphs) (NOT const-decl "[bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil bounding_circuits_defs nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (get const-decl "Sign3" measures nil) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (le const-decl "bool" measures nil) (<= const-decl "bool" measures nil) (vert const-decl "bool" c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (/= const-decl "boolean" notequal nil) (cycle? const-decl "bool" cycles_ digraphs) (cycle_at? const-decl "bool" cycles_ digraphs) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (bound_circuits_iter_def subtype "bounding_circuits_defs.circ" "walks_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].Walk(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(bounding_circuits_defs.G))"))) (bound_circuits_iter_def_TCC2 0 (bound_circuits_iter_def_TCC2-2 "" 3790335797 ("" (use "measure_matrix_assoc") (("" (assert) nil nil)) nil) ((N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_matrix_assoc formula-decl nil measures nil)) shostak (bound_circuits_iter_def subtype "measures[bounding_circuits_defs.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(bounding_circuits_defs.f)}")) (bound_circuits_iter_def_TCC2-1 nil 3661774396 ("" (then (use "measure_matrix_assoc") (assert))) ((measure_matrix_assoc formula-decl nil measures nil)) nil (bound_circuits_iter_def subtype "measures[bounding_circuits_defs.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(bounding_circuits_defs.f)}"))) (bound_circuits_iter_def_TCC3 0 (bound_circuits_iter_def_TCC3-2 "" 3790335797 ("" (rewrite "id_is_identity") (("" (assert) nil nil)) nil) ((N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (id_is_identity formula-decl nil measures nil)) shostak (bound_circuits_iter_def subtype "measures[bounding_circuits_defs.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[bounding_circuits_defs.N].*)(bounding_circuits_defs.zero)}")) (bound_circuits_iter_def_TCC3-1 nil 3661774396 ("" (then (rewrite "id_is_identity") (assert))) ((id_is_identity formula-decl nil measures nil)) shostak (bound_circuits_iter_def subtype "measures[bounding_circuits_defs.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[bounding_circuits_defs.N].*)(bounding_circuits_defs.zero)}"))) (bound_circuits_iter_def_TCC4 0 (bound_circuits_iter_def_TCC4-1 nil 3661774396 ("" (subtype-tcc) nil nil) ((make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil bounding_circuits_defs nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (get const-decl "Sign3" measures nil) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (le const-decl "bool" measures nil) (<= const-decl "bool" measures nil) (vert const-decl "bool" c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (/= const-decl "boolean" notequal nil) (cycle? const-decl "bool" cycles_ digraphs) (cycle_at? const-decl "bool" cycles_ digraphs) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (bound_circuits_iter_def subtype "c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].get_wgt" "[[W: wgd_type[T, Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[bounding_circuits_defs.T].digraph_edges(c_weighted_digraphs_def[bounding_circuits_defs.T, Measure_Matrix[N], measures[bounding_circuits_defs.N].*, measures[bounding_circuits_defs.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (bound_circuits_iter_def 0 (bound_circuits_iter_def-1 nil 3661803032 ("" (skolem 1 ("_" "_" "vl" "vc_list" "_" "_")) (("" (induct "i") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (skeep) (("3" (ground) (("1" (skeep) (("1" (expand "bound_circuits_iter" 1) (("1" (inst -1 "n+1" "v" "LAMBDA
                                                         (v: vert(dg(G))):
                                                         nth
                                                         (bound_circuits_list
                                                          (vl, vc_list, bs),
                                                          index_of_vert(v, vl))") (("1" (ground) (("1" (hide 2) (("1" (lemma "bound_circuits_list_def") (("1" (skeep) (("1" (inst -1 "n" "v2" "vl" "vc_list" "bs") (("1" (ground) (("1" (skeep) (("1" (inst -1 "cc") (("1" (typepred (cc)) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (typepred "index_of_vert(v!1, vl)") (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "vl") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case-replace "j=0") (("1" (hide (-2 1)) (("1" (skeep) (("1" (skeep) (("1" (expand "bound_circuits_iter") (("1" (expand "bound_circuits_iter") (("1" (lemma "bound_circuits_list_def") (("1" (inst?) (("1" (inst -1 "n") (("1" (label corc -4) (("1" (hide corc) (("1" (ground) (("1" (inst - "circ") (("1" (reveal corc) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (lemma "id_is_identity") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (lemma "measure_matrix_assoc") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (skeep) (("6" (skeep) (("6" (expand "cycle_at?") (("6" (expand "cycle?") (("6" (expand "circuit_at?") (("6" (expand "circuit?") (("6" (expand "pre_circuit?") (("6" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (skeep) (("7" (lemma "id_is_identity") (("7" (propax) nil nil)) nil)) nil)) nil)) nil) ("8" (hide 2) (("8" (skeep) (("8" (skeep) (("8" (lemma "measure_matrix_assoc") (("8" (propax) nil nil)) nil)) nil)) nil)) nil) ("9" (hide 2) (("9" (skeep) (("9" (skeep) (("9" (typepred "cc") (("9" (expand "circuit_at?") (("9" (expand "circuit?") (("9" (expand "pre_circuit?") (("9" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (walk? const-decl "bool" walks_ digraphs) (member def-decl "bool" list_props nil) (<= const-decl "bool" reals nil) (circuit_at? const-decl "bool" circuits_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (vert type-eq-decl nil digraphs_ digraphs) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (T formal-type-decl nil bounding_circuits_defs nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (associative? const-decl "bool" operator_defs nil) (identity? const-decl "bool" operator_defs nil) (vc_list skolem-const-decl "VCList
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G), vl)" bounding_circuits_defs nil) (vl skolem-const-decl "VertList
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G))" bounding_circuits_defs nil) (bound_circuits_iter def-decl "[vert(dg(G)) -> list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (VCList type-eq-decl nil cycles_ digraphs) (nth def-decl "T" list_props nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (vert_list const-decl "bool" digraphs_ digraphs) (VertCycles type-eq-decl nil cycles_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs) (cycle_at? const-decl "bool" cycles_ digraphs) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (<= const-decl "bool" measures nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (bound_circuits_at const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (map_length formula-decl nil more_map_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bound_circuits_list_def formula-decl nil bounding_circuits_defs nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (bs skolem-const-decl "[vert[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
      digraph_make](dg(G)) ->
   list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (bound_circuits_list const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (index_of_vert def-decl "{i: below(length(VL)) |
   nth(VL, i) = v AND
    FORALL (j: below(length(VL))): nth(VL, j) = v IMPLIES i = j}" bounding_circuits_defs nil) (id_is_identity formula-decl nil measures nil) (measure_matrix_assoc formula-decl nil measures nil) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (cycle? const-decl "bool" cycles_ digraphs) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (bound_circuits_iter_stable 0 (bound_circuits_iter_stable-1 nil 3661803321 ("" (skolem 1 ("vl" "vc_list" "_" "_")) (("" (induct "i") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (skeep) (("3" (ground) (("1" (skeep) (("1" (expand "bound_circuits_iter" 1) (("1" (inst -1 "LAMBDA (v: vert(dg(G))):
                                         nth(bound_circuits_list(vl, vc_list, bs),
                                             index_of_vert(v, vl))") (("1" (ground) (("1" (replace -1 :dir rl) (("1" (replace -3 1 :dir rl) (("1" (decompose-equality 1) (("1" (typepred "index_of_vert(x!1, vl)") (("1" (lemma " map_nth_rw[vert(dg(G)), list[Measure_Matrix]]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "map_length[vert(dg(G)), list[Measure_Matrix]]") (("2" (skeep) (("2" (typepred "index_of_vert(v, vl)") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "vl") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "list_extensionality[list[Measure_Matrix]]") (("2" (inst?) (("1" (flatten) (("1" (hide -1) (("1" (ground) (("1" (rewrite "map_length[vert(dg(G)), list[Measure_Matrix]]") (("1" (expand "bound_circuits_list") (("1" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("1" (typepred (vc_list)) (("1" (assert) nil nil)) nil) ("2" (hide (2 3)) (("2" (skeep) (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "index_of_vert(v, vl)") (("2" (typepred "vc_list") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred (vl)) (("3" (assert) (("3" (skeep) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (2 3)) (("2" (skeep) (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (typepred "index_of_vert(v, vl)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "vl") (("3" (expand "vert_list") (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (rewrite "map_length[vert(dg(G)), list[Measure_Matrix]]") (("1" (lemma "map_nth_rw[vert(dg(G)), list[Measure_Matrix]]") (("1" (inst?) (("1" (replaces -1) (("1" (case-replace "(LAMBDA (v: vert(dg(G))):
                                                                     nth(bound_circuits_list
                                                                         (vl, vc_list, bs),
                                                                         index_of_vert(v, vl))) = bs") (("1" (decompose-equality 1) (("1" (replace -3 :dir rl) (("1" (typepred "index_of_vert(x!1, vl)") (("1" (lemma "map_nth_rw[vert(dg(G)), list[Measure_Matrix]]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "index_of_vert(v, vl)") (("2" (hide (2 3)) (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "vl") (("3" (expand "vert_list") (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide (2 3)) (("2" (typepred "index_of_vert(v, vl)") (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (2 3)) (("3" (typepred "vl") (("3" (expand "vert_list") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (2 3)) (("2" (skeep) (("2" (typepred "vc_list") (("2" (expand "bound_circuits_list") (("2" (typepred "index_of_vert( v, vl)") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (2 3)) (("3" (typepred "vl") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "index_of_vert(v, vl)") (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "vl") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bound_circuits_list") (("2" (skeep) (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "index_of_vert(v, vl)") (("2" (typepred "vc_list") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (typepred "vl") (("3" (assert) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide 2) (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (typepred "index_of_vert(v, vl)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred (vl)) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "j=0") (("1" (replace -1) (("1" (skeep) (("1" (expand "bound_circuits_iter") (("1" (expand "bound_circuits_iter") (("1" (replace -3 :dir rl) (("1" (decompose-equality 2) (("1" (lemma "map_nth_rw[vert(dg(G)), list[Measure_Matrix]]") (("1" (inst?) (("1" (replace -1) (("1" (typepred "index_of_vert(x!1, vl)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "index_of_vert(v, vl)") (("2" (rewrite "map_length[vert(dg(G)), list[Measure_Matrix]]") nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "vl") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (T formal-type-decl nil bounding_circuits_defs nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (vert type-eq-decl nil digraphs_ digraphs) (map adt-def-decl "list[T1]" list_adt_map nil) (vert_list const-decl "bool" digraphs_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (VertCycles type-eq-decl nil cycles_ digraphs) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (VCList type-eq-decl nil cycles_ digraphs) (bound_circuits_list const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (bound_circuits_iter def-decl "[vert(dg(G)) -> list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (nat_induction formula-decl nil naturalnumbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (map_length formula-decl nil more_map_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (map_nth_rw formula-decl nil more_map_props nil) (list_extensionality formula-decl nil more_list_props structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bound_circuits_at const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (n skolem-const-decl "below(length(map(LAMBDA (v: vert(dg(G))):
                   nth(bound_circuits_list(vl, vc_list, bs),
                       index_of_vert(v, vl)))
                (vl)))" bounding_circuits_defs nil) (TRUE const-decl "bool" booleans nil) (bs skolem-const-decl "[vert[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
      digraph_make](dg(G)) ->
   list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (vc_list skolem-const-decl "VCList
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G), vl)" bounding_circuits_defs nil) (index_of_vert def-decl "{i: below(length(VL)) |
   nth(VL, i) = v AND
    FORALL (j: below(length(VL))): nth(VL, j) = v IMPLIES i = j}" bounding_circuits_defs nil) (vl skolem-const-decl "VertList
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G))" bounding_circuits_defs nil) (bs skolem-const-decl "[vert[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
      digraph_make](dg(G)) ->
   list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil)) nil)) (bound_circuits_TCC1 0 (bound_circuits_TCC1-1 nil 3659198706 ("" (subtype-tcc) nil nil) ((T formal-type-decl nil bounding_circuits_defs nil) (size const-decl "nat" c_digraphs_def digraphs) (^ const-decl "real" exponentiation nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (CircBound const-decl "posnat" matrix_wdg nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (bound_circuits subtype "matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].CircBound(bounding_circuits_defs.G)" "naturalnumbers.upto(matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].CircBound(bounding_circuits_defs.G))"))) (bound_circuits_TCC2 0 (bound_circuits_TCC2-1 nil 3659198706 ("" (subtype-tcc) nil nil) ((minimalize const-decl "{L: list[Measure_Matrix[N]] |
   (FORALL ((M: Measure_Matrix | member(M, LM))):
      EXISTS (MM: Measure_Matrix): member(MM, L) AND MM <= M)
    AND (FORALL (m: Measure_Matrix): member(m, L) IMPLIES member(m, LM))}" bounding_circuits_defs nil) (bound_circuits_at const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (bound_circuits_list const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (MM_list_bool const-decl "bool" bounding_circuits_defs nil) (T formal-type-decl nil bounding_circuits_defs nil) (size const-decl "nat" c_digraphs_def digraphs) (^ const-decl "real" exponentiation nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (CircBound const-decl "posnat" matrix_wdg nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (bound_circuits subtype "matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].CircBound(bounding_circuits_defs.G)" "naturalnumbers.upto(matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].CircBound(bounding_circuits_defs.G))"))) (bound_circuits_TCC3 0 (bound_circuits_TCC3-1 nil 3659198706 ("" (subtype-tcc) nil nil) ((minimalize const-decl "{L: list[Measure_Matrix[N]] |
   (FORALL ((M: Measure_Matrix | member(M, LM))):
      EXISTS (MM: Measure_Matrix): member(MM, L) AND MM <= M)
    AND (FORALL (m: Measure_Matrix): member(m, L) IMPLIES member(m, LM))}" bounding_circuits_defs nil) (bound_circuits_at const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (bound_circuits_list const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (MM_list_bool const-decl "bool" bounding_circuits_defs nil) (T formal-type-decl nil bounding_circuits_defs nil) (size const-decl "nat" c_digraphs_def digraphs) (^ const-decl "real" exponentiation nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (CircBound const-decl "posnat" matrix_wdg nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (bound_circuits subtype "matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].CircBound(bounding_circuits_defs.G)" "naturalnumbers.upto(matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].CircBound(bounding_circuits_defs.G))"))) (bound_circuits_TCC4 0 (bound_circuits_TCC4-4 "" 3804733541 ("" (skeep) (("" (skeep) (("" (lemma "bound_circuits_iter_stable") (("" (inst?) (("" (inst - "CircBound(G) - bs`1") (("1" (assert) (("1" (lemma "bound_circuits_iter_def") (("1" (inst?) (("1" (inst - "bs`1" "_") (("1" (typepred "bs") (("1" (assert) (("1" (skeep) (("1" (inst -2 "v2") (("1" (ground) (("1" (skeep) (("1" (inst -1 "cc") (("1" (typepred (cc)) (("1" (assert) (("1" (ground) (("1" (replace -6 -1 :dir rl) (("1" (expand "MM_list_bool") (("1" (lemma "every_nth[bool]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (skeep) (("1" (inst 1 "M") (("1" (assert) (("1" (replace -12 -1 :dir rl) (("1" (inst -1 "index_of_vert(v2, vl)") (("1" (lemma "map_nth_rw[list[Measure_Matrix], bool]") (("1" (inst?) (("1" (replace -1) (("1" (expand "mm_list_bool" -2) (("1" (lemma "map_nth_rw[vert(dg(G)),list[Measure_Matrix]]") (("1" (inst?) (("1" (replaces -1) (("1" (typepred "index_of_vert(v2, vl)") (("1" (replaces -2) (("1" (lemma "every_nth[Measure_Matrix]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (lemma "member_nth[Measure_Matrix]") (("1" (inst?) (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length[vert(dg(G)), list[Measure_Matrix]]") (("2" (typepred "index_of_vert(v2, vl)") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "index_of_vert(v2, vl)") (("2" (rewrite "map_length[ list[Measure_Matrix], bool]") (("2" (replace -12) (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "vl") (("3" (assert) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -4 "v2") (("2" (inst -4 "cc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst?) (("2" (skeep) (("2" (inst -1 "cc") (("2" (skeep -) (("2" (inst 1 "M2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "bs`1") (("2" (assert) (("2" (case "bs`1 = CircBound(G)") (("1" (typepred "bs") (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (skeep) (("1" (inst?) (("1" (typepred "cc") (("1" (assert) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "bs`1") (("2" (assert) (("2" (case "bs`1 = CircBound(G)") (("1" (typepred "bs") (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (skeep) (("1" (inst?) (("1" (typepred "cc") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (bound_circuits subtype "(matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].CircBound(bounding_circuits_defs.G), booleans.TRUE, bounding_circuits_defs.bs`3)" "matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].BoundingSets(bounding_circuits_defs.G)")) (bound_circuits_TCC4-3 nil 3661773744 ("" (skeep) (("" (skeep) (("" (lemma "bound_circuits_iter_stable") (("" (inst?) (("" (inst - "CircBound(G) - bs`1") (("1" (assert) (("1" (lemma "bound_circuits_iter_def") (("1" (inst?) (("1" (inst - "bs`1" "_") (("1" (typepred "bs") (("1" (assert) (("1" (skeep) (("1" (inst -2 "v2") (("1" (ground) (("1" (skeep) (("1" (inst -1 "cc") (("1" (typepred (cc)) (("1" (assert) (("1" (ground) (("1" (replace -6 -1 :dir rl) (("1" (expand "MM_list_bool") (("1" (lemma "every_nth[bool]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (skeep) (("1" (inst 1 "M") (("1" (assert) (("1" (replace -10 -1 :dir rl) (("1" (inst -1 "index_of_vert(v2, vl)") (("1" (lemma "map_nth_rw[list[Measure_Matrix], bool]") (("1" (inst?) (("1" (replace -1) (("1" (expand "mm_list_bool" -2) (("1" (lemma "map_nth_rw[vert(dg(G)),list[Measure_Matrix]]") (("1" (inst?) (("1" (replaces -1) (("1" (typepred "index_of_vert(v2, vl)") (("1" (replaces -2) (("1" (lemma "every_nth[Measure_Matrix]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (lemma "member_nth[Measure_Matrix]") (("1" (inst?) (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length[vert(dg(G)), list[Measure_Matrix]]") (("2" (typepred "index_of_vert(v2, vl)") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "index_of_vert(v2, vl)") (("2" (rewrite "map_length[ list[Measure_Matrix], bool]") (("2" (replace -14) (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "vl") (("3" (assert) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -4 "v2") (("2" (inst -4 "cc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst?) (("2" (skeep) (("2" (inst -1 "cc") (("2" (skeep -) (("2" (inst 1 "M2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "bs`1") (("2" (assert) (("2" (case "bs`1 = CircBound(G)") (("1" (typepred "bs") (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (skeep) (("1" (inst?) (("1" (typepred "cc") (("1" (assert) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "bs`1") (("2" (assert) (("2" (case "bs`1 = CircBound(G)") (("1" (typepred "bs") (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (skeep) (("1" (inst?) (("1" (typepred "cc") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil bounding_circuits_defs nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (vert type-eq-decl nil digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (VertCycles type-eq-decl nil cycles_ digraphs) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (VCList type-eq-decl nil cycles_ digraphs) (<= const-decl "bool" reals nil) (CircBound const-decl "posnat" matrix_wdg nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (cycle_at? const-decl "bool" cycles_ digraphs) (member def-decl "bool" list_props nil) (positive? const-decl "bool" measures nil) (<= const-decl "bool" measures nil) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (BoundingSets type-eq-decl nil matrix_wdg nil) (v2 skolem-const-decl "vert[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G))" bounding_circuits_defs nil) (cc skolem-const-decl "{cc |
   (circuit_at?
        [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
         digraph_make]
        (dg(G), cc, v2)
     AND length(cc) <= CircBound(G))
    OR
    cycle_at?
        [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
         digraph_make]
        (dg(G), cc, v2)}" bounding_circuits_defs nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (every_nth formula-decl nil list_props nil) (bound_circuits_at const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (bound_circuits_list const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (map_nth_rw formula-decl nil more_map_props nil) (map_length formula-decl nil more_map_props nil) (TRUE const-decl "bool" booleans nil) (member_nth formula-decl nil more_list_props structures) (bound_circ_list skolem-const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (index_of_vert def-decl "{i: below(length(VL)) |
   nth(VL, i) = v AND
    FORALL (j: below(length(VL))): nth(VL, j) = v IMPLIES i = j}" bounding_circuits_defs nil) (v2 skolem-const-decl "vert[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G))" bounding_circuits_defs nil) (vl skolem-const-decl "VertList
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G))" bounding_circuits_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (map adt-def-decl "list[T1]" list_adt_map nil) (mm_list_bool const-decl "bool" bounding_circuits_defs nil) (MM_list_bool const-decl "bool" bounding_circuits_defs nil) (cc skolem-const-decl "{cc |
   (circuit_at?
        [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
         digraph_make]
        (dg(G), cc, v2)
     AND length(cc) <= CircBound(G))
    OR
    cycle_at?
        [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
         digraph_make]
        (dg(G), cc, v2)}" bounding_circuits_defs nil) (v2 skolem-const-decl "vert[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G))" bounding_circuits_defs nil) (bound_circuits_iter_def formula-decl nil bounding_circuits_defs nil) (bs skolem-const-decl "BoundingSets[T, N](G)" bounding_circuits_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bound_circuits_iter_stable formula-decl nil bounding_circuits_defs nil)) nil (bound_circuits subtype "(matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].CircBound(bounding_circuits_defs.G), booleans.TRUE, bounding_circuits_defs.bs`3)" "matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].BoundingSets(bounding_circuits_defs.G)")) (bound_circuits_TCC4-2 nil 3661719997 ("" (skeep) (("" (skeep) (("" (lemma "bound_circuits_iter_stable") (("" (inst?) (("" (inst - "CircBound(G) - bs`1") (("1" (assert) (("1" (lemma "bound_circuits_iter_def") (("1" (inst?) (("1" (inst - "bs`1" "_") (("1" (typepred "bs") (("1" (assert) (("1" (skeep) (("1" (inst -2 "v2") (("1" (ground) (("1" (skeep) (("1" (inst -1 "cc") (("1" (typepred (cc)) (("1" (assert) (("1" (ground) (("1" (replace -6 -1 :dir rl) (("1" (expand "MM_list_bool") (("1" (lemma "every_nth[bool]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (skeep) (("1" (inst 1 "M") (("1" (assert) (("1" (replace -10 -1 :dir rl) (("1" (inst -1 "index_of_vert(G, v2, vl)") (("1" (lemma "map_nth_rw[list[Measure_Matrix], bool]") (("1" (inst?) (("1" (replace -1) (("1" (expand "mm_list_bool" -2) (("1" (lemma "map_nth_rw[vert(dg(G)),list[Measure_Matrix]]") (("1" (inst?) (("1" (replaces -1) (("1" (typepred "index_of_vert(G, v2, vl)") (("1" (replaces -2) (("1" (lemma "every_nth[Measure_Matrix]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (lemma "member_nth[Measure_Matrix]") (("1" (inst?) (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length[vert(dg(G)), list[Measure_Matrix]]") (("2" (typepred "index_of_vert(G, v2, vl)") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "index_of_vert(G, v2, vl)") (("2" (rewrite "map_length[ list[Measure_Matrix], bool]") (("2" (replace -14) (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (assert) (("2" (expand "vclist") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "vl") (("3" (assert) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -4 "v2") (("2" (inst -4 "cc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst?) (("2" (skeep) (("2" (inst -1 "cc") (("2" (skeep -) (("2" (inst 1 "M2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "bs`1") (("2" (assert) (("2" (case "bs`1 = CircBound(G)") (("1" (typepred "bs") (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (skeep) (("1" (inst?) (("1" (typepred "cc") (("1" (assert) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "bs`1") (("2" (assert) (("2" (case "bs`1 = CircBound(G)") (("1" (typepred "bs") (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (skeep) (("1" (inst?) (("1" (typepred "cc") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member_nth formula-decl nil more_list_props structures) (BoundingSets type-eq-decl nil matrix_wdg nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (<= const-decl "bool" measures nil) (positive? const-decl "bool" measures nil) (cycle_at? const-decl "bool" cycles_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (CircBound const-decl "posnat" matrix_wdg nil) (VertCycles type-eq-decl nil cycles_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs)) nil (bound_circuits subtype "(matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].CircBound(bounding_circuits_defs.G), booleans.TRUE, bounding_circuits_defs.bs`3)" "matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].BoundingSets(bounding_circuits_defs.G)")) (bound_circuits_TCC4-1 nil 3659198706 ("" (skeep) (("" (skeep) (("" (lemma "bound_circuits_iter_stable") (("" (inst?) (("" (inst - "CircBound(G) - bs`1") (("1" (assert) (("1" (lemma "bound_circuits_iter_def") (("1" (inst?) (("1" (inst - "bs`1" "_") (("1" (typepred "bs") (("1" (assert) (("1" (skeep) (("1" (inst -2 "v2") (("1" (ground) (("1" (skeep) (("1" (inst -1 "cc") (("1" (typepred (cc)) (("1" (assert) (("1" (ground) (("1" (replace -6 -1 :dir rl) (("1" (expand "MM_list_bool") (("1" (lemma "every_nth[bool]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (skeep) (("1" (inst 1 "M") (("1" (assert) (("1" (replace -10 -1 :dir rl) (("1" (inst -1 "index_of_vert(G, v2, vl)") (("1" (lemma "map_nth_rw[list[Measure_Matrix], bool]") (("1" (inst?) (("1" (replace -1) (("1" (expand "mm_list_bool" -2) (("1" (lemma "map_nth_rw[vert(dg(G)),list[Measure_Matrix]]") (("1" (inst?) (("1" (replaces -1) (("1" (typepred "index_of_vert(G, v2, vl)") (("1" (replaces -2) (("1" (lemma "every_nth[Measure_Matrix]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (lemma "member_nth[Measure_Matrix]") (("1" (inst?) (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length[vert(dg(G)), list[Measure_Matrix]]") (("2" (typepred "index_of_vert(G, v2, vl)") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "index_of_vert(G, v2, vl)") (("2" (rewrite "map_length[ list[Measure_Matrix], bool]") (("2" (replace -14) (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[Vert_Cycles(G), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (assert) (("2" (expand "vclist") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "vl") (("3" (assert) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -4 "v2") (("2" (inst -4 "cc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst?) (("2" (skeep) (("2" (inst -1 "cc") (("2" (skeep -) (("2" (inst 1 "M2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "bs`1") (("2" (assert) (("2" (case "bs`1 = CircBound(G)") (("1" (typepred "bs") (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (skeep) (("1" (inst?) (("1" (typepred "cc") (("1" (assert) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "bs`1") (("2" (assert) (("2" (case "bs`1 = CircBound(G)") (("1" (typepred "bs") (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (skeep) (("1" (inst?) (("1" (typepred "cc") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member_nth formula-decl nil more_list_props structures) (BoundingSets type-eq-decl nil matrix_wdg nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (<= const-decl "bool" measures nil) (positive? const-decl "bool" measures nil) (cycle_at? const-decl "bool" cycles_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (CircBound const-decl "posnat" matrix_wdg nil) (VertList type-eq-decl nil digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs)) nil (bound_circuits subtype "(matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].CircBound(bounding_circuits_defs.G), booleans.TRUE, bounding_circuits_defs.bs`3)" "matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].BoundingSets(bounding_circuits_defs.G)"))) (bound_circuits_TCC5 0 (bound_circuits_TCC5-1 nil 3659198706 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil bounding_circuits_defs nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (vert type-eq-decl nil digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (VertCycles type-eq-decl nil cycles_ digraphs) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (VCList type-eq-decl nil cycles_ digraphs) (<= const-decl "bool" reals nil) (CircBound const-decl "posnat" matrix_wdg nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (cycle_at? const-decl "bool" cycles_ digraphs) (member def-decl "bool" list_props nil) (positive? const-decl "bool" measures nil) (<= const-decl "bool" measures nil) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (BoundingSets type-eq-decl nil matrix_wdg nil) (vert const-decl "bool" c_digraphs_def digraphs) (get const-decl "Sign3" measures nil) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (positive_fun? const-decl "bool" measures nil) (le const-decl "bool" measures nil) (minimalize const-decl "{L: list[Measure_Matrix[N]] |
   (FORALL ((M: Measure_Matrix | member(M, LM))):
      EXISTS (MM: Measure_Matrix): member(MM, L) AND MM <= M)
    AND (FORALL (m: Measure_Matrix): member(m, L) IMPLIES member(m, LM))}" bounding_circuits_defs nil) (bound_circuits_at const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (bound_circuits_list const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (MM_list_bool const-decl "bool" bounding_circuits_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (bound_circuits subtype "bounding_circuits_defs.vl" "{VL: list_adt[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].list | EXISTS (i: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(VL))): booleans.AND(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(VL, i) = bounding_circuits_defs.v, FORALL (j: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(VL))): booleans.IMPLIES(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(VL, j) = list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(VL, i), j = i))}"))) (bound_circuits_TCC6 0 (bound_circuits_TCC6-4 "" 3804738367 ("" (skeep) (("" (skeep) (("" (skeep) (("" (typepred "index_of_vert(v, vl)") (("" (replaces -5) (("" (expand "bound_circuits_list") (("" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("" (typepred "vc_list") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (bound_circuits subtype "bounding_circuits_defs.index_of_vert(bounding_circuits_defs.v, bounding_circuits_defs.vl)" "below[length[list[Measure_Matrix[N]]](bound_circ_list)]")) (bound_circuits_TCC6-3 nil 3661775465 ("" (skeep) (("" (skeep) (("" (skeep) (("" (typepred "index_of_vert(v, vl)") (("" (replaces -6) (("" (expand "bound_circuits_list") (("" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("" (typepred "vc_list") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((VertList type-eq-decl nil digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (index_of_vert def-decl "{i: below(length(VL)) |
   nth(VL, i) = v AND
    FORALL (j: below(length(VL))): nth(VL, j) = v IMPLIES i = j}" bounding_circuits_defs nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (vert? const-decl "bool" digraphs_ digraphs) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (vert type-eq-decl nil digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (T formal-type-decl nil bounding_circuits_defs nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (bound_circuits_list const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (VertCycles type-eq-decl nil cycles_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (VCList type-eq-decl nil cycles_ digraphs) (BoundingSets type-eq-decl nil matrix_wdg nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (<= const-decl "bool" measures nil) (positive? const-decl "bool" measures nil) (member def-decl "bool" list_props nil) (cycle_at? const-decl "bool" cycles_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (CircBound const-decl "posnat" matrix_wdg nil) (<= const-decl "bool" reals nil) (bound_circuits_at const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (map_length formula-decl nil more_map_props nil) (TRUE const-decl "bool" booleans nil)) nil (bound_circuits subtype "bounding_circuits_defs.index_of_vert(bounding_circuits_defs.v, bounding_circuits_defs.vl)" "below[length[list[Measure_Matrix[N]]](bound_circ_list)]")) (bound_circuits_TCC6-2 nil 3661720026 ("" (skeep) (("" (skeep) (("" (skeep) (("" (typepred "index_of_vert(G, v, vl)") (("" (replaces -6) (("" (expand "bound_circuits_list") (("" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("" (typepred "vc_list") (("" (assert) (("" (expand "vclist") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((CircBound const-decl "posnat" matrix_wdg nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (cycle_at? const-decl "bool" cycles_ digraphs) (positive? const-decl "bool" measures nil) (<= const-decl "bool" measures nil) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (BoundingSets type-eq-decl nil matrix_wdg nil) (CyclesAt type-eq-decl nil cycles_ digraphs) (VertCycles type-eq-decl nil cycles_ digraphs) (wdg type-eq-decl nil matrix_wdg nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert type-eq-decl nil digraphs_ digraphs) (Sign3 type-eq-decl nil sign3 reals) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (vert? const-decl "bool" digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs)) nil (bound_circuits subtype "bounding_circuits_defs.index_of_vert(bounding_circuits_defs.v, bounding_circuits_defs.vl)" "below[length[list[Measure_Matrix[N]]](bound_circ_list)]")) (bound_circuits_TCC6-1 nil 3659198706 ("" (skeep) (("" (skeep) (("" (skeep) (("" (typepred "index_of_vert(G, v, vl)") (("" (replaces -6) (("" (expand "bound_circuits_list") (("" (rewrite "map_length[Vert_Cycles(G), list[Measure_Matrix]]") (("" (typepred "vc_list") (("" (assert) (("" (expand "vclist") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((VertList type-eq-decl nil digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (vert type-eq-decl nil digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (BoundingSets type-eq-decl nil matrix_wdg nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (<= const-decl "bool" measures nil) (positive? const-decl "bool" measures nil) (cycle_at? const-decl "bool" cycles_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (CircBound const-decl "posnat" matrix_wdg nil)) nil (bound_circuits subtype "bounding_circuits_defs.index_of_vert(bounding_circuits_defs.v, bounding_circuits_defs.vl)" "below[length[list[Measure_Matrix[N]]](bound_circ_list)]"))) (bound_circuits_TCC7 0 (bound_circuits_TCC7-4 "" 3804786834 ("" (skeep) (("" (skeep) (("" (lemma "bound_circuits_iter_def") (("" (inst -1 "bs`1" "_" "vl" "vc_list" "bs`3" "1") (("" (skeep) (("" (skeep) (("" (inst -1 "v2") (("" (typepred "bs") (("" (assert) (("" (ground) (("1" (skeep) (("1" (inst -1 "cc") (("1" (typepred (cc)) (("1" (ground) (("1" (expand "bound_circuits_iter") (("1" (expand "bound_circuits_iter") (("1" (replace -9 2) (("1" (simplify 2) (("1" (skeep) (("1" (inst 2 "M") (("1" (assert) (("1" (expand "MM_list_bool") (("1" (lemma "every_nth[bool]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (inst -1 "index_of_vert(v2, vl)") (("1" (lemma "map_nth_rw[ list[Measure_Matrix], bool]") (("1" (inst?) (("1" (replaces -1 -2) (("1" (replace -9 -1) (("1" (expand "mm_list_bool") (("1" (lemma "every_nth[Measure_Matrix]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (lemma "member_nth[Measure_Matrix]") (("1" (inst?) (("1" (assert) (("1" (skeep) (("1" (inst -2 "i") (("1" (replace -1 -2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "index_of_vert(v2, vl)") (("2" (replace -12 1) (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length[ list[Measure_Matrix], bool]") (("2" (replace -8 1) (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bound_circuits_iter") (("2" (expand "bound_circuits_iter") (("2" (replace -8 2) (("2" (simplify 2) (("2" (skeep) (("2" (inst 2 "M") (("2" (assert) (("2" (expand "MM_list_bool") (("2" (lemma "every_nth[bool]") (("2" (inst?) (("2" (flatten) (("2" (hide -2) (("2" (assert) (("2" (inst -1 "index_of_vert(v2, vl)") (("1" (lemma "map_nth_rw[ list[Measure_Matrix], bool]") (("1" (inst?) (("1" (replaces -1) (("1" (expand "mm_list_bool") (("1" (lemma "member_nth[Measure_Matrix]") (("1" (inst?) (("1" (assert) (("1" (skeep) (("1" (lemma "every_nth[Measure_Matrix]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "index_of_vert(v2, vl)") (("2" (replace -11 1) (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "index_of_vert(v2, vl)") (("2" (rewrite "map_length[ list[Measure_Matrix], bool]") (("2" (replaces -10 1) (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst?) (("2" (skeep) (("2" (inst? -) (("2" (assert) (("2" (skeep -) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (bound_circuits subtype "(real_defs.min((number_fields.+)(bounding_circuits_defs.bs`1, 1), matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].CircBound(bounding_circuits_defs.G)), booleans.TRUE, bounding_circuits_defs.nbs)" "matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].BoundingSets(bounding_circuits_defs.G)")) (bound_circuits_TCC7-3 nil 3661775527 ("" (skeep) (("" (skeep) (("" (lemma "bound_circuits_iter_def") (("" (inst -1 "bs`1" "_" "vl" "vc_list" "bs`3" "1") (("" (skeep) (("" (skeep) (("" (inst -1 "v2") (("" (typepred "bs") (("" (assert) (("" (ground) (("1" (skeep) (("1" (inst -1 "cc") (("1" (typepred (cc)) (("1" (ground) (("1" (expand "bound_circuits_iter") (("1" (expand "bound_circuits_iter") (("1" (replace -9 2) (("1" (simplify 2) (("1" (skeep) (("1" (inst 2 "M") (("1" (assert) (("1" (expand "MM_list_bool") (("1" (lemma "every_nth[bool]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (inst -1 "index_of_vert(v2, vl)") (("1" (lemma "map_nth_rw[ list[Measure_Matrix], bool]") (("1" (inst?) (("1" (replaces -1 -2) (("1" (replace -10 -1) (("1" (expand "mm_list_bool") (("1" (lemma "every_nth[Measure_Matrix]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (lemma "member_nth[Measure_Matrix]") (("1" (inst?) (("1" (assert) (("1" (skeep) (("1" (inst -2 "i") (("1" (replace -1 -2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "index_of_vert(v2, vl)") (("2" (replace -13 1) (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length[ list[Measure_Matrix], bool]") (("2" (replace -9 1) (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bound_circuits_iter") (("2" (expand "bound_circuits_iter") (("2" (replace -8 2) (("2" (simplify 2) (("2" (skeep) (("2" (inst 2 "M") (("2" (assert) (("2" (expand "MM_list_bool") (("2" (lemma "every_nth[bool]") (("2" (inst?) (("2" (flatten) (("2" (hide -2) (("2" (assert) (("2" (inst -1 "index_of_vert(v2, vl)") (("1" (lemma "map_nth_rw[ list[Measure_Matrix], bool]") (("1" (inst?) (("1" (replaces -1) (("1" (expand "mm_list_bool") (("1" (lemma "member_nth[Measure_Matrix]") (("1" (inst?) (("1" (assert) (("1" (skeep) (("1" (lemma "every_nth[Measure_Matrix]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "index_of_vert(v2, vl)") (("2" (replace -12 1) (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "index_of_vert(v2, vl)") (("2" (rewrite "map_length[ list[Measure_Matrix], bool]") (("2" (replaces -11 1) (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst?) (("2" (skeep) (("2" (inst? -) (("2" (assert) (("2" (skeep -) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (T formal-type-decl nil bounding_circuits_defs nil) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (CircBound const-decl "posnat" matrix_wdg nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (cycle_at? const-decl "bool" cycles_ digraphs) (member def-decl "bool" list_props nil) (positive? const-decl "bool" measures nil) (<= const-decl "bool" measures nil) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (BoundingSets type-eq-decl nil matrix_wdg nil) (vert_list const-decl "bool" digraphs_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (VertCycles type-eq-decl nil cycles_ digraphs) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (VCList type-eq-decl nil cycles_ digraphs) (NOT const-decl "[bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posint_min application-judgement "{k: posint | k <= i AND k <= j}" real_defs nil) (MM_list_bool const-decl "bool" bounding_circuits_defs nil) (mm_list_bool const-decl "bool" bounding_circuits_defs nil) (map adt-def-decl "list[T1]" list_adt_map nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (index_of_vert def-decl "{i: below(length(VL)) |
   nth(VL, i) = v AND
    FORALL (j: below(length(VL))): nth(VL, j) = v IMPLIES i = j}" bounding_circuits_defs nil) (v2 skolem-const-decl "vert[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G))" bounding_circuits_defs nil) (vl skolem-const-decl "VertList
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G))" bounding_circuits_defs nil) (bound_circ_list skolem-const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (member_nth formula-decl nil more_list_props structures) (bound_circuits_list const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (TRUE const-decl "bool" booleans nil) (bound_circuits_at const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (map_length formula-decl nil more_map_props nil) (map_nth_rw formula-decl nil more_map_props nil) (every_nth formula-decl nil list_props nil) (bound_circuits_iter def-decl "[vert(dg(G)) -> list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (bound_circuits_iter_def formula-decl nil bounding_circuits_defs nil)) nil (bound_circuits subtype "(real_defs.min((number_fields.+)(bounding_circuits_defs.bs`1, 1), matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].CircBound(bounding_circuits_defs.G)), booleans.TRUE, bounding_circuits_defs.nbs)" "matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].BoundingSets(bounding_circuits_defs.G)")) (bound_circuits_TCC7-2 nil 3661720043 ("" (skeep) (("" (skeep) (("" (lemma "bound_circuits_iter_def") (("" (inst -1 "G" "bs`1" "_" "vl" "vc_list" "bs`3" "1") (("" (skeep) (("" (skeep) (("" (inst -1 "v2") (("" (typepred "bs") (("" (assert) (("" (ground) (("1" (skeep) (("1" (inst -1 "cc") (("1" (typepred (cc)) (("1" (ground) (("1" (expand "bound_circuits_iter") (("1" (expand "bound_circuits_iter") (("1" (replace -9 2) (("1" (simplify 2) (("1" (skeep) (("1" (inst 2 "M") (("1" (assert) (("1" (expand "MM_list_bool") (("1" (lemma "every_nth[bool]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (inst -1 "index_of_vert(G, v2, vl)") (("1" (lemma "map_nth_rw[ list[Measure_Matrix], bool]") (("1" (inst?) (("1" (replaces -1 -2) (("1" (replace -10 -1) (("1" (expand "mm_list_bool") (("1" (lemma "every_nth[Measure_Matrix]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (lemma "member_nth[Measure_Matrix]") (("1" (inst?) (("1" (assert) (("1" (skeep) (("1" (inst -2 "i") (("1" (replace -1 -2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "index_of_vert(G, v2, vl)") (("2" (replace -13 1) (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (assert) (("2" (expand "vclist") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length[ list[Measure_Matrix], bool]") (("2" (replace -9 1) (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (expand "vclist") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bound_circuits_iter") (("2" (expand "bound_circuits_iter") (("2" (replace -8 2) (("2" (simplify 2) (("2" (skeep) (("2" (inst 2 "M") (("2" (assert) (("2" (expand "MM_list_bool") (("2" (lemma "every_nth[bool]") (("2" (inst?) (("2" (flatten) (("2" (hide -2) (("2" (assert) (("2" (inst -1 "index_of_vert(G, v2, vl)") (("1" (lemma "map_nth_rw[ list[Measure_Matrix], bool]") (("1" (inst?) (("1" (replaces -1) (("1" (expand "mm_list_bool") (("1" (lemma "member_nth[Measure_Matrix]") (("1" (inst?) (("1" (assert) (("1" (skeep) (("1" (lemma "every_nth[Measure_Matrix]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "index_of_vert(G, v2, vl)") (("2" (replace -12 1) (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (assert) (("2" (expand "vclist") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "index_of_vert(G, v2, vl)") (("2" (rewrite "map_length[ list[Measure_Matrix], bool]") (("2" (replaces -11 1) (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (assert) (("2" (expand "vclist") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst?) (("2" (skeep) (("2" (inst? -) (("2" (assert) (("2" (skeep -) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member_nth formula-decl nil more_list_props structures) (VertCycles type-eq-decl nil cycles_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (BoundingSets type-eq-decl nil matrix_wdg nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (<= const-decl "bool" measures nil) (positive? const-decl "bool" measures nil) (cycle_at? const-decl "bool" cycles_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (CircBound const-decl "posnat" matrix_wdg nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs)) nil (bound_circuits subtype "(real_defs.min((number_fields.+)(bounding_circuits_defs.bs`1, 1), matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].CircBound(bounding_circuits_defs.G)), booleans.TRUE, bounding_circuits_defs.nbs)" "matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].BoundingSets(bounding_circuits_defs.G)")) (bound_circuits_TCC7-1 nil 3659198706 ("" (skeep) (("" (skeep) (("" (lemma "bound_circuits_iter_def") (("" (inst -1 "G" "bs`1" "_" "vl" "vc_list" "bs`3" "1") (("" (skeep) (("" (skeep) (("" (inst -1 "v2") (("" (typepred "bs") (("" (assert) (("" (ground) (("1" (skeep) (("1" (inst -1 "cc") (("1" (typepred (cc)) (("1" (ground) (("1" (expand "bound_circuits_iter") (("1" (expand "bound_circuits_iter") (("1" (replace -9 2) (("1" (simplify 2) (("1" (skeep) (("1" (inst 2 "M") (("1" (assert) (("1" (expand "MM_list_bool") (("1" (lemma "every_nth[bool]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (inst -1 "index_of_vert(G, v2, vl)") (("1" (lemma "map_nth_rw[ list[Measure_Matrix], bool]") (("1" (inst?) (("1" (replaces -1 -2) (("1" (replace -10 -1) (("1" (expand "mm_list_bool") (("1" (lemma "every_nth[Measure_Matrix]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (lemma "member_nth[Measure_Matrix]") (("1" (inst?) (("1" (assert) (("1" (skeep) (("1" (inst -2 "i") (("1" (replace -1 -2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "index_of_vert(G, v2, vl)") (("2" (replace -13 1) (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[Vert_Cycles(G), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (assert) (("2" (expand "vclist") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length[ list[Measure_Matrix], bool]") (("2" (replace -9 1) (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[Vert_Cycles(G), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (expand "vclist") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bound_circuits_iter") (("2" (expand "bound_circuits_iter") (("2" (replace -8 2) (("2" (simplify 2) (("2" (skeep) (("2" (inst 2 "M") (("2" (assert) (("2" (expand "MM_list_bool") (("2" (lemma "every_nth[bool]") (("2" (inst?) (("2" (flatten) (("2" (hide -2) (("2" (assert) (("2" (inst -1 "index_of_vert(G, v2, vl)") (("1" (lemma "map_nth_rw[ list[Measure_Matrix], bool]") (("1" (inst?) (("1" (replaces -1) (("1" (expand "mm_list_bool") (("1" (lemma "member_nth[Measure_Matrix]") (("1" (inst?) (("1" (assert) (("1" (skeep) (("1" (lemma "every_nth[Measure_Matrix]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "index_of_vert(G, v2, vl)") (("2" (replace -12 1) (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[Vert_Cycles(G), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (assert) (("2" (expand "vclist") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "index_of_vert(G, v2, vl)") (("2" (rewrite "map_length[ list[Measure_Matrix], bool]") (("2" (replaces -11 1) (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[Vert_Cycles(G), list[Measure_Matrix]]") (("2" (typepred "vc_list") (("2" (assert) (("2" (expand "vclist") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst?) (("2" (skeep) (("2" (inst? -) (("2" (assert) (("2" (skeep -) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((digraph_type type-eq-decl nil c_digraphs_imp digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (Sign3 type-eq-decl nil sign3 reals) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (CircBound const-decl "posnat" matrix_wdg nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (cycle_at? const-decl "bool" cycles_ digraphs) (positive? const-decl "bool" measures nil) (<= const-decl "bool" measures nil) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (BoundingSets type-eq-decl nil matrix_wdg nil) (vert_list const-decl "bool" digraphs_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs) (member_nth formula-decl nil more_list_props structures)) nil (bound_circuits subtype "(real_defs.min((number_fields.+)(bounding_circuits_defs.bs`1, 1), matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].CircBound(bounding_circuits_defs.G)), booleans.TRUE, bounding_circuits_defs.nbs)" "matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].BoundingSets(bounding_circuits_defs.G)"))) (start_bounding_TCC1 0 (start_bounding_TCC1-1 nil 3659269721 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil bounding_circuits_defs nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (vert type-eq-decl nil digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (VertCycles type-eq-decl nil cycles_ digraphs) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (VCList type-eq-decl nil cycles_ digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (minimalize const-decl "{L: list[Measure_Matrix[N]] |
   (FORALL ((M: Measure_Matrix | member(M, LM))):
      EXISTS (MM: Measure_Matrix): member(MM, L) AND MM <= M)
    AND (FORALL (m: Measure_Matrix): member(m, L) IMPLIES member(m, LM))}" bounding_circuits_defs nil) (bound_circuits_at const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (bound_circuits_list const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (start_bounding_list const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (start_bounding subtype "bounding_circuits_defs.vl" "{VL: list_adt[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].list | EXISTS (i: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(VL))): booleans.AND(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(VL, i) = bounding_circuits_defs.v, FORALL (j: naturalnumbers.below(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].length(VL))): booleans.IMPLIES(list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(VL, j) = list_props[digraphs_[bounding_circuits_defs.T, digraph_type[T], c_digraphs_imp[bounding_circuits_defs.T].digraph_verts, c_digraphs_imp[bounding_circuits_defs.T].digraph_edges, c_digraphs_imp[bounding_circuits_defs.T].digraph_size, c_digraphs_imp[bounding_circuits_defs.T].digraph_make].vert(dg(bounding_circuits_defs.G))].nth(VL, i), j = i))}"))) (start_bounding_TCC2 0 (start_bounding_TCC2-3 nil 3661775566 ("" (skeep) (("" (skeep) (("" (typepred "index_of_vert(v, vl)") (("" (replaces -4) (("" (expand "start_bounding_list") (("" (expand "bound_circuits_list") (("" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("" (typepred "vc_list") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (bound_circuits_list const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (VertCycles type-eq-decl nil cycles_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (VCList type-eq-decl nil cycles_ digraphs) (bs0 const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (bound_circuits_at const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (map_length formula-decl nil more_map_props nil) (start_bounding_list const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (T formal-type-decl nil bounding_circuits_defs nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert type-eq-decl nil digraphs_ digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (vert? const-decl "bool" digraphs_ digraphs) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (index_of_vert def-decl "{i: below(length(VL)) |
   nth(VL, i) = v AND
    FORALL (j: below(length(VL))): nth(VL, j) = v IMPLIES i = j}" bounding_circuits_defs nil) (vert_list const-decl "bool" digraphs_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs)) nil (start_bounding subtype "bounding_circuits_defs.index_of_vert(bounding_circuits_defs.v, bounding_circuits_defs.vl)" "below[length[list[Measure_Matrix[N]]](bc1)]")) (start_bounding_TCC2-2 nil 3661720070 ("" (skeep) (("" (skeep) (("" (typepred "index_of_vert(G, v, vl)") (("" (replaces -4) (("" (expand "start_bounding_list") (("" (expand "bound_circuits_list") (("" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("" (typepred "vc_list") (("" (assert) (("" (expand "vclist") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((VertList type-eq-decl nil digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (vert type-eq-decl nil digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (VertCycles type-eq-decl nil cycles_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs)) nil (start_bounding subtype "bounding_circuits_defs.index_of_vert(bounding_circuits_defs.v, bounding_circuits_defs.vl)" "below[length[list[Measure_Matrix[N]]](bc1)]")) (start_bounding_TCC2-1 nil 3659269721 ("" (skeep) (("" (skeep) (("" (typepred "index_of_vert(G, v, vl)") (("" (replaces -4) (("" (expand "start_bounding_list") (("" (expand "bound_circuits_list") (("" (rewrite "map_length[Vert_Cycles(G), list[Measure_Matrix]]") (("" (typepred "vc_list") (("" (assert) (("" (expand "vclist") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((wdg type-eq-decl nil matrix_wdg nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert type-eq-decl nil digraphs_ digraphs) (Sign3 type-eq-decl nil sign3 reals) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (vert? const-decl "bool" digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs)) nil (start_bounding subtype "bounding_circuits_defs.index_of_vert(bounding_circuits_defs.v, bounding_circuits_defs.vl)" "below[length[list[Measure_Matrix[N]]](bc1)]"))) (start_bounding_TCC3 0 (start_bounding_TCC3-1 nil 3659269721 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (vert type-eq-decl nil digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (VertCycles type-eq-decl nil cycles_ digraphs) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (VCList type-eq-decl nil cycles_ digraphs) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minimalize const-decl "{L: list[Measure_Matrix[N]] |
   (FORALL ((M: Measure_Matrix | member(M, LM))):
      EXISTS (MM: Measure_Matrix): member(MM, L) AND MM <= M)
    AND (FORALL (m: Measure_Matrix): member(m, L) IMPLIES member(m, LM))}" bounding_circuits_defs nil) (bound_circuits_at const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (bound_circuits_list const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (start_bounding_list const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (T formal-type-decl nil bounding_circuits_defs nil) (size const-decl "nat" c_digraphs_def digraphs) (^ const-decl "real" exponentiation nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (CircBound const-decl "posnat" matrix_wdg nil) (posint_exp application-judgement "posint" exponentiation nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (start_bounding subtype "1" "naturalnumbers.upto(matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].CircBound(bounding_circuits_defs.G))"))) (start_bounding_TCC4 0 (start_bounding_TCC4-4 "" 3790335977 ("" (skeep) (("" (skeep) (("" (skeep) (("" (skeep) (("" (replace -1 -2) (("" (replace -2 1) (("" (simplify 1) (("" (expand "start_bounding_list" 1) (("" (lemma "bound_circuits_list_def") (("" (inst?) (("" (typepred "cc") (("" (inst -3 "0") (("" (label circ -2) (("" (hide circ) (("" (ground) (("1" (inst -1 "cc") (("1" (reveal circ) (("1" (assert) (("1" (replace -4 -6) (("1" (expand "start_bounding_list" -6) (("1" (expand "MM_list_bool") (("1" (case "(EXISTS (M: Measure_Matrix):
                            member(M,
                                   nth(bound_circuits_list(vl, vc_list, bs0),
                                       index_of_vert(v2, vl)))
                             AND M <= wgt_walk(G, cc))") (("1" (skeep) (("1" (inst 1 "M") (("1" (assert) (("1" (hide (-3 -4)) (("1" (lemma "member_nth[Measure_Matrix]") (("1" (inst?) (("1" (assert) (("1" (skeep) (("1" (lemma "every_nth[bool]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (inst -1 "index_of_vert(v2, vl)") (("1" (lemma "map_nth_rw[list[Measure_Matrix], bool]") (("1" (inst?) (("1" (replaces -1) (("1" (expand "mm_list_bool") (("1" (lemma "every_nth[Measure_Matrix]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length[ list[Measure_Matrix], bool]") (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "index_of_vert(v2, vl)") (("2" (typepred "vc_list") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (lemma "id_is_identity") (("3" (propax) nil nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (skeep) (("4" (lemma "measure_matrix_assoc") (("4" (propax) nil nil)) nil)) nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (skeep) (("5" (expand "cycle_at?") (("5" (expand "cycle?") (("5" (expand "circuit_at?") (("5" (expand "circuit?") (("5" (expand "pre_circuit?") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but 1) (("6" (typepred "index_of_vert(v2, vl)") (("6" (expand "bound_circuits_list") (("6" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("6" (typepred "vc_list") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide-all-but 1) (("7" (typepred "vl") (("7" (assert) (("7" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bound_circuits_list_def formula-decl nil bounding_circuits_defs nil) (NOT const-decl "[bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (<= const-decl "bool" reals nil) (cycle_at? const-decl "bool" cycles_ digraphs) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (MM_list_bool const-decl "bool" bounding_circuits_defs nil) (pre_circuit? const-decl "bool" circuits_ digraphs) (int_minus_int_is_int application-judgement "int" integers nil) (circuit? const-decl "bool" circuits_ digraphs) (cycle? const-decl "bool" cycles_ digraphs) (measure_matrix_assoc formula-decl nil measures nil) (id_is_identity formula-decl nil measures nil) (member_nth formula-decl nil more_list_props structures) (every_nth formula-decl nil list_props nil) (map_length formula-decl nil more_map_props nil) (bound_circuits_at const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (map_nth_rw formula-decl nil more_map_props nil) (TRUE const-decl "bool" booleans nil) (positive? const-decl "bool" measures nil) (vc_list skolem-const-decl "VCList
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G), vl)" bounding_circuits_defs nil) (vl skolem-const-decl "VertList
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G))" bounding_circuits_defs nil) (v2 skolem-const-decl "vert[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G))" bounding_circuits_defs nil) (map adt-def-decl "list[T1]" list_adt_map nil) (mm_list_bool const-decl "bool" bounding_circuits_defs nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (identity? const-decl "bool" operator_defs nil) (associative? const-decl "bool" operator_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (member def-decl "bool" list_props nil) (bound_circuits_list const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil) (index_of_vert def-decl "{i: below(length(VL)) |
   nth(VL, i) = v AND
    FORALL (j: below(length(VL))): nth(VL, j) = v IMPLIES i = j}" bounding_circuits_defs nil) (<= const-decl "bool" measures nil) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (bs0 const-decl "list[Measure_Matrix[N]]" bounding_circuits_defs nil) (VCList type-eq-decl nil cycles_ digraphs) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (VertCycles type-eq-decl nil cycles_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (G formal-const-decl "wdg" bounding_circuits_defs nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" bounding_circuits_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil bounding_circuits_defs nil) (start_bounding_list const-decl "list[list[Measure_Matrix[N]]]" bounding_circuits_defs nil)) shostak (start_bounding subtype "(1, bounding_circuits_defs.MM_list_bool(bounding_circuits_defs.bc1), bounding_circuits_defs.nbs)" "matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].BoundingSets(bounding_circuits_defs.G)")) (start_bounding_TCC4-3 nil 3661776573 ("" (skeep) (("" (skeep) (("" (skeep) (("" (skeep) (("" (replace -1 -2) (("" (replace -2 1) (("" (simplify 1) (("" (expand "start_bounding_list" 1) (("" (lemma "bound_circuits_list_def") (("" (inst?) (("" (typepred "cc") (("" (inst -3 "0") (("" (label circ -2) (("" (hide circ) (("" (ground) (("1" (inst -1 "cc") (("1" (reveal circ) (("1" (assert) (("1" (replace -4 -6) (("1" (expand "start_bounding_list" -6) (("1" (expand "MM_list_bool") (("1" (case "(EXISTS (M: Measure_Matrix):
                            member(M,
                                   nth(bound_circuits_list(vl, vc_list, bs0),
                                       index_of_vert(v2, vl)))
                             AND M <= wgt_walk(G, cc))") (("1" (skeep) (("1" (inst 1 "M") (("1" (assert) (("1" (hide (-3 -4)) (("1" (lemma "member_nth[Measure_Matrix]") (("1" (inst?) (("1" (assert) (("1" (skeep) (("1" (lemma "every_nth[bool]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (inst -1 "index_of_vert(v2, vl)") (("1" (lemma "map_nth_rw[list[Measure_Matrix], bool]") (("1" (inst?) (("1" (replaces -1) (("1" (expand "mm_list_bool") (("1" (lemma "every_nth[Measure_Matrix]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length[ list[Measure_Matrix], bool]") (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "index_of_vert(v2, vl)") (("2" (typepred "vc_list") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (lemma "id_is_identity") (("3" (propax) nil nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (skeep) (("4" (lemma "measure_matrix_assoc") (("4" (propax) nil nil)) nil)) nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (skeep) (("5" (expand "cycle_at?") (("5" (expand "cycle?") (("5" (expand "circuit_at?") (("5" (expand "circuit?") (("5" (expand "pre_circuit?") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but 1) (("6" (typepred "index_of_vert(v2, vl)") (("1" (expand "bound_circuits_list") (("1" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("1" (typepred "vc_list") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "vl") (("2" (expand "vert_list") (("2" (inst -2 "v2") nil nil)) nil)) nil)) nil)) nil) ("7" (hide-all-but 1) (("7" (typepred "vl") (("7" (assert) (("7" (inst?) (("7" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list type-decl nil list_adt nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (Sign3 type-eq-decl nil sign3 reals) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (vert type-eq-decl nil digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (VertCycles type-eq-decl nil cycles_ digraphs) (VCList type-eq-decl nil cycles_ digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (<= const-decl "bool" measures nil) (positive? const-decl "bool" measures nil) (member_nth formula-decl nil more_list_props structures) (id_is_identity formula-decl nil measures nil) (measure_matrix_assoc formula-decl nil measures nil) (cycle? const-decl "bool" cycles_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (cycle_at? const-decl "bool" cycles_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil)) nil (start_bounding subtype "(1, bounding_circuits_defs.MM_list_bool(bounding_circuits_defs.bc1), bounding_circuits_defs.nbs)" "matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].BoundingSets(bounding_circuits_defs.G)")) (start_bounding_TCC4-2 nil 3661720109 ("" (skeep) (("" (skeep) (("" (skeep) (("" (skeep) (("" (replace -1 -2) (("" (replace -2 1) (("" (simplify 1) (("" (expand "start_bounding_list" 1) (("" (lemma "bound_circuits_list_def") (("" (inst?) (("" (typepred "cc") (("" (inst -3 "0") (("" (label circ -2) (("" (hide circ) (("" (ground) (("1" (inst -1 "cc") (("1" (reveal circ) (("1" (assert) (("1" (replace -4 -6) (("1" (expand "start_bounding_list" -6) (("1" (expand "MM_list_bool") (("1" (case "(EXISTS (M: Measure_Matrix):
                   member(M,
                          nth(bound_circuits_list(G, vl, vc_list, bs0(G)),
                              index_of_vert(G, v2, vl)))
                    AND M <= wgt_walk(G, cc))") (("1" (skeep) (("1" (inst 1 "M") (("1" (assert) (("1" (hide (-3 -4)) (("1" (lemma "member_nth[Measure_Matrix]") (("1" (inst?) (("1" (assert) (("1" (skeep) (("1" (lemma "every_nth[bool]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (inst -1 "index_of_vert(G, v2, vl)") (("1" (lemma "map_nth_rw[list[Measure_Matrix], bool]") (("1" (inst?) (("1" (replaces -1) (("1" (expand "mm_list_bool") (("1" (lemma "every_nth[Measure_Matrix]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length[ list[Measure_Matrix], bool]") (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("2" (typepred "index_of_vert(G, v2, vl)") (("2" (typepred "vc_list") (("2" (assert) (("2" (expand "vclist") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (lemma "id_is_identity") (("3" (propax) nil nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (skeep) (("4" (lemma "measure_matrix_assoc") (("4" (propax) nil nil)) nil)) nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (skeep) (("5" (expand "cycle_at?") (("5" (expand "cycle?") (("5" (expand "circuit_at?") (("5" (expand "circuit?") (("5" (expand "pre_circuit?") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but 1) (("6" (typepred "index_of_vert(G, v2, vl)") (("6" (expand "bound_circuits_list") (("6" (rewrite "map_length[VertCycles(dg(G)), list[Measure_Matrix]]") (("6" (typepred "vc_list") (("6" (assert) (("6" (expand "vclist") (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide-all-but 1) (("7" (typepred "vl") (("7" (assert) (("7" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (cycle_at? const-decl "bool" cycles_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (cycle? const-decl "bool" cycles_ digraphs) (measure_matrix_assoc formula-decl nil measures nil) (id_is_identity formula-decl nil measures nil) (member_nth formula-decl nil more_list_props structures) (positive? const-decl "bool" measures nil) (<= const-decl "bool" measures nil) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (VertCycles type-eq-decl nil cycles_ digraphs) (CyclesAt type-eq-decl nil cycles_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs)) nil (start_bounding subtype "(1, bounding_circuits_defs.MM_list_bool(bounding_circuits_defs.bc1), bounding_circuits_defs.nbs)" "matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].BoundingSets(bounding_circuits_defs.G)")) (start_bounding_TCC4-1 nil 3659269721 ("" (skeep) (("" (skeep) (("" (skeep) (("" (skeep) (("" (replace -1 -2) (("" (replace -2 1) (("" (simplify 1) (("" (expand "start_bounding_list" 1) (("" (lemma "bound_circuits_list_def") (("" (inst?) (("" (typepred "cc") (("" (inst -3 "0") (("" (label circ -2) (("" (hide circ) (("" (ground) (("1" (inst -1 "cc") (("1" (reveal circ) (("1" (assert) (("1" (replace -4 -6) (("1" (expand "start_bounding_list" -6) (("1" (expand "MM_list_bool") (("1" (case "(EXISTS (M: Measure_Matrix):
          member(M,
                 nth(bound_circuits_list(G, vl, vc_list, bs0(G)),
                     index_of_vert(G, v2, vl)))
           AND M <= wgt_walk(G, cc))") (("1" (skeep) (("1" (inst 1 "M") (("1" (assert) (("1" (hide (-3 -4)) (("1" (lemma "member_nth[Measure_Matrix]") (("1" (inst?) (("1" (assert) (("1" (skeep) (("1" (lemma "every_nth[bool]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (inst -1 "index_of_vert(G, v2, vl)") (("1" (lemma "map_nth_rw[list[Measure_Matrix], bool]") (("1" (inst?) (("1" (replaces -1) (("1" (expand "mm_list_bool") (("1" (lemma "every_nth[Measure_Matrix]") (("1" (inst?) (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length[ list[Measure_Matrix], bool]") (("2" (expand "bound_circuits_list") (("2" (rewrite "map_length[Vert_Cycles(G), list[Measure_Matrix]]") (("2" (typepred "index_of_vert(G, v2, vl)") (("2" (typepred "vc_list") (("2" (assert) (("2" (expand "vclist") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (lemma "id_is_identity") (("3" (propax) nil nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (skeep) (("4" (lemma "measure_matrix_assoc") (("4" (propax) nil nil)) nil)) nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (skeep) (("5" (expand "cycle_at?") (("5" (expand "cycle?") (("5" (expand "circuit_at?") (("5" (expand "circuit?") (("5" (expand "pre_circuit?") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but 1) (("6" (typepred "index_of_vert(G, v2, vl)") (("6" (expand "bound_circuits_list") (("6" (rewrite "map_length[Vert_Cycles(G), list[Measure_Matrix]]") (("6" (typepred "vc_list") (("6" (assert) (("6" (expand "vclist") (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide-all-but 1) (("7" (typepred "vl") (("7" (assert) (("7" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (cycle_at? const-decl "bool" cycles_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (cycle? const-decl "bool" cycles_ digraphs) (measure_matrix_assoc formula-decl nil measures nil) (id_is_identity formula-decl nil measures nil) (member_nth formula-decl nil more_list_props structures) (positive? const-decl "bool" measures nil) (<= const-decl "bool" measures nil) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (VertList type-eq-decl nil digraphs_ digraphs) (vert_list const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs)) nil (start_bounding subtype "(1, bounding_circuits_defs.MM_list_bool(bounding_circuits_defs.bc1), bounding_circuits_defs.nbs)" "matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].BoundingSets(bounding_circuits_defs.G)"))) (bounding_from_graph_lists_TCC1 0 (bounding_from_graph_lists_TCC1-1 nil 3660126112 ("" (skeep*) (("" (expand "bound_circuits") (("" (lift-if 1) (("" (ground) (("" (typepred "n") (("" (typepred "BS`1") (("" (typepred "BS") (("" (assert) (("" (replaces -2) (("" (hide (-1 -2 -4)) (("" (hide 1) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bound_circuits const-decl "BoundingSets(G)" bounding_circuits_defs nil) (posint_min application-judgement "{k: posint | k <= i AND k <= j}" real_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (BoundingSets type-eq-decl nil matrix_wdg nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (<= const-decl "bool" measures nil) (positive? const-decl "bool" measures nil) (member def-decl "bool" list_props nil) (cycle_at? const-decl "bool" cycles_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (size const-decl "nat" c_digraphs_def digraphs) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil bounding_circuits_defs nil) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" bounding_circuits_defs nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (CircBound const-decl "posnat" matrix_wdg nil) (G formal-const-decl "wdg" bounding_circuits_defs nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (bounding_from_graph_lists subtype "bounding_circuits_defs.bound_circuits(bounding_circuits_defs.vl, bounding_circuits_defs.vc_list)" "matrix_wdg[bounding_circuits_defs.T, bounding_circuits_defs.N].BoundingStepsFun(bounding_circuits_defs.G)"))))
