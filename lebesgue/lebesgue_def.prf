(lebesgue_def
 (open_semi_infinite_is_cal_M 0
  (open_semi_infinite_is_cal_M-1 nil 3471434094
   ("" (skosimp)
    (("" (expand "member")
      (("" (expand "cal_M")
        (("" (lemma "outer_measurable_open_semi_infinite" ("a" "a!1"))
          (("" (expand "lebesgue_measurable")
            (("" (expand "fullset")
              (("" (expand "extend") (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((member const-decl "bool" sets nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (outer_measurable_open_semi_infinite formula-decl nil
     real_lebesgue_scaf nil)
    (fullset const-decl "set" sets nil)
    (extend const-decl "R" extend nil)
    (lebesgue_measurable const-decl "sigma_algebra[real]"
     real_lebesgue_scaf nil)
    (cal_M const-decl "sigma_algebra" lebesgue_def nil))
   shostak))
 (borel_is_cal_M 0
  (borel_is_cal_M-1 nil 3471442368
   ("" (expand "subset?")
    (("" (skosimp)
      (("" (expand "member")
        (("" (expand "cal_M")
          (("" (expand "lebesgue_measurable")
            (("" (expand "fullset")
              (("" (expand "extend")
                (("" (prop)
                  (("" (lemma "borel_is_lebesgue_measurable")
                    (("" (inst - "x!1") nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cal_M const-decl "sigma_algebra" lebesgue_def nil)
    (fullset const-decl "set" sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def
     measure_integration)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def
     measure_integration)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (metric_induced_topology const-decl "setofsets[T]" metric_space_def
     metric_space)
    (borel? const-decl "sigma_algebra" borel measure_integration)
    (borel nonempty-type-eq-decl nil borel measure_integration)
    (x!1 skolem-const-decl "setof[real]" lebesgue_def nil)
    (borel_is_lebesgue_measurable judgement-tcc nil real_lebesgue_scaf
     nil)
    (extend const-decl "R" extend nil)
    (lebesgue_measurable const-decl "sigma_algebra[real]"
     real_lebesgue_scaf nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil))
   shostak))
 (open_interval_is_cal_M 0
  (open_interval_is_cal_M-1 nil 3471443245
   ("" (expand "subset?")
    (("" (skosimp)
      (("" (expand "member")
        (("" (lemma "borel_is_cal_M")
          (("" (expand "subset?")
            (("" (inst - "x!1")
              (("" (assert)
                (("" (hide 2)
                  (("" (expand "borel?")
                    (("" (expand "fullset")
                      (("" (expand "extend")
                        ((""
                          (lemma
                           "generated_sigma_algebra_subset1[real]")
                          ((""
                            (inst - "(LAMBDA (t: setof[real]):
                                IF open?(t) THEN TRUE ELSE FALSE ENDIF)")
                            (("" (expand "subset?")
                              ((""
                                (expand "member")
                                ((""
                                  (inst - "x!1")
                                  ((""
                                    (assert)
                                    ((""
                                      (hide 2)
                                      ((""
                                        (expand "open_interval?")
                                        ((""
                                          (flatten)
                                          ((""
                                            (rewrite "metric_open_def")
                                            (("" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((borel_is_cal_M formula-decl nil lebesgue_def nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (set type-eq-decl nil sets nil) (fullset const-decl "set" sets nil)
    (generated_sigma_algebra_subset1 formula-decl nil
     subset_algebra_def measure_integration)
    (metric_open_def formula-decl nil metric_space metric_space)
    (open_interval? const-decl "bool" real_intervals_aux nil)
    (FALSE const-decl "bool" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (open? const-decl "bool" topology topology)
    (metric_induced_topology const-decl "setofsets[T]" metric_space_def
     metric_space)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (setofsets type-eq-decl nil sets nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (metric_induced_topology_is_second_countable name-judgement
     "second_countable" real_topology metric_space)
    nil nil (extend const-decl "R" extend nil)
    (borel? const-decl "sigma_algebra" borel measure_integration)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil))
   shostak))
 (closed_interval_is_cal_M 0
  (closed_interval_is_cal_M-1 nil 3471443113
   ("" (lemma "borel_is_cal_M")
    (("" (expand "subset?")
      (("" (skosimp)
        (("" (inst - "x!1")
          (("" (expand "member")
            (("" (lemma "closed_is_borel" ("Y" "x!1"))
              (("1" (assert) nil nil)
               ("2" (expand "closed_interval?")
                (("2" (flatten)
                  (("2" (expand "closed?")
                    (("2" (expand "metric_closed?")
                      (("2" (expand "member")
                        (("2" (expand "metric_induced_topology")
                          (("2" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subset? const-decl "bool" sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (set type-eq-decl nil sets nil)
    (metric_induced_topology const-decl "setofsets[T]" metric_space_def
     metric_space)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (setofsets type-eq-decl nil sets nil)
    (closed nonempty-type-eq-decl nil topology topology)
    (closed? const-decl "bool" topology topology)
    (closed_is_borel formula-decl nil borel measure_integration)
    (metric_space_is_hausdorff name-judgement "hausdorff" real_topology
     metric_space)
    (metric_induced_topology_is_second_countable name-judgement
     "second_countable" real_topology metric_space)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (metric_closed? const-decl "bool" metric_space_def metric_space)
    (closed_interval? const-decl "bool" real_intervals_aux nil)
    (member const-decl "bool" sets nil)
    (borel_is_cal_M formula-decl nil lebesgue_def nil))
   shostak))
 (singleton_is_cal_M 0
  (singleton_is_cal_M-1 nil 3471441879
   ("" (skosimp)
    (("" (expand "member")
      (("" (expand "cal_M")
        (("" (expand "lebesgue_measurable")
          (("" (expand "fullset")
            (("" (expand "extend")
              (("" (assert)
                (("" (lemma "borel_is_lebesgue_measurable")
                  (("" (inst - "singleton[real](x!1)")
                    (("1" (assert) nil nil)
                     ("2" (rewrite "singleton_is_borel") nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" countable_setofsets sets_aux)
    (singleton_is_closed application-judgement
     "closed[real, (metric_induced_topology)]" real_topology
     metric_space)
    (singleton_is_compact application-judgement "compact" real_topology
     metric_space)
    (member const-decl "bool" sets nil)
    (lebesgue_measurable const-decl "sigma_algebra[real]"
     real_lebesgue_scaf nil)
    (extend const-decl "R" extend nil)
    (borel_is_lebesgue_measurable judgement-tcc nil real_lebesgue_scaf
     nil)
    (singleton_is_borel formula-decl nil hausdorff_borel
     measure_integration)
    (metric_space_is_hausdorff name-judgement "hausdorff" real_topology
     metric_space)
    (metric_induced_topology_is_second_countable name-judgement
     "second_countable" real_topology metric_space)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (borel nonempty-type-eq-decl nil borel measure_integration)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def
     measure_integration)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def
     measure_integration)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (metric_induced_topology const-decl "setofsets[T]" metric_space_def
     metric_space)
    (borel? const-decl "sigma_algebra" borel measure_integration)
    (set type-eq-decl nil sets nil)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (x!1 skolem-const-decl "real" lebesgue_def nil)
    (fullset const-decl "set" sets nil)
    (cal_M const-decl "sigma_algebra" lebesgue_def nil))
   shostak))
 (ball_is_cal_M 0
  (ball_is_cal_M-1 nil 3471441715
   ("" (skosimp)
    (("" (lemma "open_interval_is_cal_M")
      (("" (expand "subset?")
        (("" (inst - "ball(x!1, r!1)")
          (("" (assert)
            (("" (hide 2)
              (("" (expand "open_interval?")
                (("" (expand "interval?")
                  (("" (skosimp)
                    (("" (typepred "x!2")
                      (("" (typepred "y!1")
                        (("" (expand "ball") (("" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((open_interval_is_cal_M formula-decl nil lebesgue_def nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil) (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ball const-decl "set[T]" metric_space_def metric_space)
    (interval? const-decl "bool" real_topology metric_space)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (open_interval? const-decl "bool" real_intervals_aux nil)
    (member const-decl "bool" sets nil)
    (ball_is_metric_open application-judgement "metric_open"
     real_topology metric_space)
    (subset? const-decl "bool" sets nil))
   shostak))
 (closed_ball_is_cal_M 0
  (closed_ball_is_cal_M-1 nil 3471442240
   ("" (skosimp)
    (("" (expand "member")
      (("" (expand "cal_M")
        (("" (expand "lebesgue_measurable")
          (("" (expand "fullset")
            (("" (expand "extend")
              (("" (lemma "borel_is_lebesgue_measurable")
                (("" (inst - "closed_ball(x!1, nnr!1)")
                  (("1" (assert) nil nil)
                   ("2" (hide 2)
                    (("2"
                      (lemma "closed_is_borel"
                       ("Y" "closed_ball(x!1, nnr!1)"))
                      (("2" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((member const-decl "bool" sets nil)
    (lebesgue_measurable const-decl "sigma_algebra[real]"
     real_lebesgue_scaf nil)
    (extend const-decl "R" extend nil)
    (nnr!1 skolem-const-decl "nnreal" lebesgue_def nil)
    (x!1 skolem-const-decl "real" lebesgue_def nil)
    (closed_ball const-decl "closed" real_topology metric_space)
    (closed nonempty-type-eq-decl nil topology topology)
    (closed? const-decl "bool" topology topology)
    (set type-eq-decl nil sets nil)
    (nnreal type-eq-decl nil real_types nil)
    (borel? const-decl "sigma_algebra" borel measure_integration)
    (metric_induced_topology const-decl "setofsets[T]" metric_space_def
     metric_space)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def
     measure_integration)
    (sigma_algebra? const-decl "bool" subset_algebra_def
     measure_integration)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (borel nonempty-type-eq-decl nil borel measure_integration)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (metric_induced_topology_is_second_countable name-judgement
     "second_countable" real_topology metric_space)
    (metric_space_is_hausdorff name-judgement "hausdorff" real_topology
     metric_space)
    (closed_is_borel formula-decl nil borel measure_integration)
    (borel_is_lebesgue_measurable judgement-tcc nil real_lebesgue_scaf
     nil)
    (fullset const-decl "set" sets nil)
    (cal_M const-decl "sigma_algebra" lebesgue_def nil))
   shostak))
 (lambda__TCC1 0
  (lambda__TCC1-1 nil 3458582664
   ("" (split)
    (("1" (expand "cal_M") (("1" (propax) nil nil)) nil)
     ("2" (typepred "lebesgue_measure")
      (("2" (expand "complete_sigma_finite?")
        (("2" (flatten)
          (("2" (split)
            (("1" (expand "measure?")
              (("1" (flatten)
                (("1" (split)
                  (("1" (expand "measure_empty?")
                    (("1" (propax) nil nil)) nil)
                   ("2" (expand "measure_countably_additive?")
                    (("2" (skosimp)
                      (("2" (inst - "X!1")
                        (("1" (expand "o ")
                          (("1" (expand "cal_M")
                            (("1" (assert) nil nil)) nil))
                          nil)
                         ("2" (hide 2)
                          (("2" (split)
                            (("1" (skosimp)
                              (("1"
                                (typepred "X!1(x1!1)")
                                (("1"
                                  (expand "cal_M")
                                  (("1" (propax) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (typepred "X!1")
                              (("2"
                                (expand "disjoint_indexed_measurable?")
                                (("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand "measure_complete?")
              (("2" (skosimp)
                (("2" (inst - "x!1" "a!1")
                  (("2" (assert)
                    (("2" (expand "cal_M")
                      (("2" (assert)
                        (("2" (expand "lebesgue_measure")
                          (("2" (assert)
                            (("2" (split)
                              (("1" (propax) nil nil)
                               ("2" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (expand "measure_sigma_finite?")
              (("3" (skosimp)
                (("3" (inst + "X!1")
                  (("1" (replace -3) (("1" (propax) nil nil)) nil)
                   ("2" (expand "cal_M")
                    (("2" (typepred "X!1")
                      (("2" (expand "disjoint_indexed_measurable?")
                        (("2" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lebesgue_measure const-decl
     "complete_sigma_finite[real, lebesgue_measurable]"
     real_lebesgue_scaf nil)
    (complete_sigma_finite type-eq-decl nil measure_def
     measure_integration)
    (complete_sigma_finite? const-decl "bool" measure_def
     measure_integration)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (lebesgue_measurable const-decl "sigma_algebra[real]"
     real_lebesgue_scaf nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def
     measure_integration)
    (sigma_algebra? const-decl "bool" subset_algebra_def
     measure_integration)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (measure_sigma_finite? const-decl "bool" measure_def
     measure_integration)
    (X!1 skolem-const-decl
     "disjoint_indexed_measurable[real, lebesgue_measurable]"
     lebesgue_def nil)
    (measure_complete? const-decl "bool" generalized_measure_def
     measure_integration)
    (set type-eq-decl nil sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (measure? const-decl "bool" generalized_measure_def
     measure_integration)
    (measure_empty? const-decl "bool" generalized_measure_def
     measure_integration)
    (O const-decl "T3" function_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (disjoint_indexed_measurable? const-decl "bool"
     generalized_measure_def measure_integration)
    (disjoint_indexed_measurable nonempty-type-eq-decl nil
     generalized_measure_def measure_integration)
    (X!1 skolem-const-decl "disjoint_indexed_measurable[real, cal_M]"
     lebesgue_def nil)
    (measure_countably_additive? const-decl "bool"
     generalized_measure_def measure_integration)
    (cal_M const-decl "sigma_algebra" lebesgue_def nil))
   nil
   (lambda_ subtype "real_lebesgue_scaf.lebesgue_measure"
    "complete_sigma_finite[real, cal_M]")))
 (lambda_singleton_TCC1 0
  (lambda_singleton_TCC1-1 nil 3475933087
   ("" (skosimp)
    (("" (lemma "singleton_is_cal_M" ("x" "x!1"))
      (("" (expand "member") (("" (propax) nil nil)) nil)) nil))
    nil)
   ((real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (singleton_is_cal_M formula-decl nil lebesgue_def nil)
    (member const-decl "bool" sets nil))
   nil
   (lambda_singleton subtype "sets[real].singleton(lebesgue_def.x)"
    "(lebesgue_def.cal_M)")))
 (lambda_singleton 0
  (lambda_singleton-1 nil 3475933229
   ("" (skosimp)
    (("" (expand "lambda_")
      (("" (lemma "lebesgue_outer_measure_singleton" ("x" "x!1"))
        (("" (expand "lebesgue_measure")
          (("" (expand "induced_measure")
            (("" (expand "restrict")
              (("" (expand "x_eq")
                (("" (flatten)
                  (("" (assert) (("" (decompose-equality) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lambda_ const-decl "complete_sigma_finite[real, cal_M]"
     lebesgue_def nil)
    (lebesgue_measure const-decl
     "complete_sigma_finite[real, lebesgue_measurable]"
     real_lebesgue_scaf nil)
    (restrict const-decl "R" restrict nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (set type-eq-decl nil sets nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (outer_measure? const-decl "bool" outer_measure_def
     measure_integration)
    (outer_measure nonempty-type-eq-decl nil outer_measure_def
     measure_integration)
    (lebesgue_outer_measure const-decl "outer_measure"
     real_lebesgue_scaf nil)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" countable_setofsets sets_aux)
    (singleton_is_closed application-judgement
     "closed[real, (metric_induced_topology)]" real_topology
     metric_space)
    (singleton_is_compact application-judgement "compact" real_topology
     metric_space)
    (x_eq const-decl "bool" extended_nnreal extended_nnreal)
    (induced_measure const-decl "complete_measure" outer_measure_props
     measure_integration)
    (lebesgue_outer_measure_singleton formula-decl nil
     real_lebesgue_scaf nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil))
   shostak))
 (lambda_ball_TCC1 0
  (lambda_ball_TCC1-1 nil 3475932807
   ("" (skosimp)
    (("" (lemma "ball_is_cal_M" ("x" "x1!1" "r" "r!1"))
      (("" (expand "member") (("" (propax) nil nil)) nil)) nil))
    nil)
   ((posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (ball_is_cal_M formula-decl nil lebesgue_def nil)
    (member const-decl "bool" sets nil))
   nil
   (lambda_ball subtype
    "metric_space_def[real, (LAMBDA (x, y: reals.real): real_defs.abs((number_fields.-)(x, y)))].ball(lebesgue_def.x, lebesgue_def.r)"
    "(lebesgue_def.cal_M)")))
 (lambda_ball 0
  (lambda_ball-1 nil 3475932807
   ("" (skosimp)
    ((""
      (lemma "lebesgue_outer_measure_bounded_interval"
       ("b" "ball(x!1,r!1)"))
      (("1" (expand "lambda_")
        (("1" (expand "lebesgue_measure")
          (("1" (expand "induced_measure")
            (("1" (expand "restrict")
              (("1" (replace -1)
                (("1" (hide -1)
                  (("1" (decompose-equality)
                    (("1" (expand "ball")
                      (("1"
                        (lemma "length_open_rew"
                         ("a" "x!1-r!1" "b" "x!1+r!1"))
                        (("1"
                          (case-replace
                           "{y: real | abs(x!1 - y) < r!1}={x | x!1 - r!1 < x AND x < x!1 + r!1}")
                          (("1" (assert) nil nil)
                           ("2" (apply-extensionality :hide? t)
                            (("2" (hide-all-but 1)
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (expand "bounded_interval?")
          (("2" (split)
            (("1" (grind) nil nil)
             ("2" (expand "bounded?")
              (("2" (flatten)
                (("2" (expand "nonempty?")
                  (("2" (assert)
                    (("2" (hide 1)
                      (("2" (split)
                        (("1" (expand "above_bounded")
                          (("1" (inst + "x!1+r!1")
                            (("1" (grind) nil nil)) nil))
                          nil)
                         ("2" (expand "below_bounded")
                          (("2" (inst + "x!1-r!1")
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ball const-decl "set[T]" metric_space_def metric_space)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bounded_interval nonempty-type-eq-decl nil real_topology
     metric_space)
    (bounded_interval? const-decl "bool" real_topology metric_space)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (lebesgue_outer_measure_bounded_interval formula-decl nil
     real_lebesgue_scaf nil)
    (ball_is_metric_open application-judgement "metric_open"
     real_topology metric_space)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (lebesgue_measure const-decl
     "complete_sigma_finite[real, lebesgue_measurable]"
     real_lebesgue_scaf nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (length_open_rew formula-decl nil real_intervals_aux nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (TRUE const-decl "bool" booleans nil)
    (length const-decl "nnreal" real_intervals_aux nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (induced_measure const-decl "complete_measure" outer_measure_props
     measure_integration)
    (lambda_ const-decl "complete_sigma_finite[real, cal_M]"
     lebesgue_def nil)
    (bounded? const-decl "bool" real_topology metric_space)
    (nonempty? const-decl "bool" sets nil)
    (below_bounded const-decl "bool" bounded_reals reals)
    (lower_bound const-decl "bool" bound_defs reals)
    (above_bounded const-decl "bool" bounded_reals reals)
    (upper_bound const-decl "bool" bound_defs reals)
    (interval? const-decl "bool" real_topology metric_space)
    (NOT const-decl "[bool -> bool]" booleans nil))
   shostak))
 (lambda_closed_ball_TCC1 0
  (lambda_closed_ball_TCC1-1 nil 3475933226
   ("" (skosimp)
    (("" (lemma "closed_ball_is_cal_M" ("x" "x!1" "nnr" "nnr!1"))
      (("" (expand "member") (("" (propax) nil nil)) nil)) nil))
    nil)
   ((nnreal type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (closed_ball_is_cal_M formula-decl nil lebesgue_def nil)
    (member const-decl "bool" sets nil))
   nil
   (lambda_closed_ball subtype
    "real_topology.closed_ball(lebesgue_def.x, lebesgue_def.nnr)"
    "(lebesgue_def.cal_M)")))
 (lambda_closed_ball 0
  (lambda_closed_ball-1 nil 3475933366
   ("" (skosimp)
    (("" (expand "lambda_")
      (("" (expand "lebesgue_measure")
        (("" (expand "induced_measure")
          (("" (expand "restrict")
            ((""
              (lemma "lebesgue_outer_measure_eq_length"
               ("b" "closed_ball(x!1, nnr!1)"))
              (("1"
                (case-replace
                 "x_length(closed_ball(x!1, nnr!1))=(TRUE, 2 * nnr!1)")
                (("1" (hide -1)
                  (("1" (expand "x_eq")
                    (("1" (flatten)
                      (("1" (assert)
                        (("1" (decompose-equality) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide-all-but 1)
                  (("2" (expand "x_length")
                    (("2" (lift-if)
                      (("2" (assert)
                        (("2" (prop)
                          (("1"
                            (lemma "length_closed_rew"
                             ("a" "x!1-nnr!1" "b" "x!1+nnr!1"))
                            (("1"
                              (case-replace
                               "closed_ball(x!1, nnr!1)={x | x!1 - nnr!1 <= x AND x <= x!1 + nnr!1}")
                              (("1" (assert) nil nil)
                               ("2"
                                (hide-all-but 1)
                                (("2"
                                  (apply-extensionality :hide? t)
                                  (("2"
                                    (expand "closed_ball")
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand "bounded_interval?")
                            (("2" (split)
                              (("1" (grind) nil nil)
                               ("2"
                                (expand "bounded?")
                                (("2"
                                  (expand "nonempty?")
                                  (("2"
                                    (flatten)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (hide 1)
                                        (("2"
                                          (split)
                                          (("1"
                                            (expand "above_bounded")
                                            (("1"
                                              (inst + "x!1+nnr!1")
                                              (("1" (grind) nil nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (expand "below_bounded")
                                            (("2"
                                              (inst + "x!1-nnr!1")
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 2)
                (("2" (expand "bounded_interval?")
                  (("2" (split)
                    (("1" (grind) nil nil)
                     ("2" (expand "bounded?")
                      (("2" (expand "nonempty?")
                        (("2" (flatten)
                          (("2" (assert)
                            (("2" (hide 1)
                              (("2"
                                (split)
                                (("1"
                                  (expand "above_bounded")
                                  (("1"
                                    (inst + "x!1+nnr!1")
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (expand "below_bounded")
                                  (("2"
                                    (inst + "x!1-nnr!1")
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lambda_ const-decl "complete_sigma_finite[real, cal_M]"
     lebesgue_def nil)
    (induced_measure const-decl "complete_measure" outer_measure_props
     measure_integration)
    (closed_ball const-decl "closed" real_topology metric_space)
    (closed nonempty-type-eq-decl nil topology topology)
    (closed? const-decl "bool" topology topology)
    (metric_induced_topology const-decl "setofsets[T]" metric_space_def
     metric_space)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (nnreal type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bounded_interval nonempty-type-eq-decl nil real_topology
     metric_space)
    (bounded_interval? const-decl "bool" real_topology metric_space)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (lebesgue_outer_measure_eq_length formula-decl nil
     real_lebesgue_scaf nil)
    (metric_space_is_hausdorff name-judgement "hausdorff" real_topology
     metric_space)
    (metric_induced_topology_is_second_countable name-judgement
     "second_countable" real_topology metric_space)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (length_closed_rew formula-decl nil real_intervals_aux nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nonempty? const-decl "bool" sets nil)
    (upper_bound const-decl "bool" bound_defs reals)
    (above_bounded const-decl "bool" bounded_reals reals)
    (lower_bound const-decl "bool" bound_defs reals)
    (below_bounded const-decl "bool" bounded_reals reals)
    (bounded? const-decl "bool" real_topology metric_space)
    (outer_measure? const-decl "bool" outer_measure_def
     measure_integration)
    (outer_measure nonempty-type-eq-decl nil outer_measure_def
     measure_integration)
    (lebesgue_outer_measure const-decl "outer_measure"
     real_lebesgue_scaf nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (x_eq const-decl "bool" extended_nnreal extended_nnreal)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (TRUE const-decl "bool" booleans nil)
    (x_length const-decl "extended_nnreal" real_lebesgue_scaf nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (interval nonempty-type-eq-decl nil real_topology metric_space)
    (interval? const-decl "bool" real_topology metric_space)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (restrict const-decl "R" restrict nil)
    (lebesgue_measure const-decl
     "complete_sigma_finite[real, lebesgue_measurable]"
     real_lebesgue_scaf nil))
   shostak))
 (integrable_phi_open 0
  (integrable_phi_open-1 nil 3475932141
   ("" (skosimp)
    (("" (rewrite "isf_is_integrable")
      (("" (hide 2)
        ((""
          (lemma "isf_phi[real, cal_M, lambda_]"
           ("E" "open(a!1, b!1)"))
          (("1" (propax) nil nil)
           ("2" (hide 2)
            (("2"
              (lemma "lambda_ball"
               ("x" "(b!1+a!1)/2" "r" "(b!1-a!1)/2"))
              (("2"
                (lemma "ball_is_cal_M"
                 ("x" "(b!1+a!1)/2" "r" "(b!1-a!1)/2"))
                (("2" (expand "member")
                  (("2" (expand "measurable_set?")
                    (("2"
                      (case-replace
                       "open(a!1, b!1)=ball((b!1 + a!1) / 2, (b!1 - a!1) / 2)")
                      (("1" (assert)
                        (("1" (replace -2)
                          (("1" (expand "mu_fin?")
                            (("1" (replace -3) (("1" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide-all-but 1)
                        (("2" (apply-extensionality :hide? t)
                          (("2" (expand "open")
                            (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((isf_is_integrable judgement-tcc nil integral measure_integration)
    (isf? const-decl "bool" isf measure_integration)
    (isf nonempty-type-eq-decl nil isf measure_integration)
    (set type-eq-decl nil sets nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (phi const-decl "nat" measure_space measure_integration)
    (< const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ball const-decl "set[T]" metric_space_def metric_space)
    (open_interval nonempty-type-eq-decl nil real_topology
     metric_space)
    (open const-decl "open_interval" real_topology metric_space)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def
     measure_integration)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def
     measure_integration)
    (cal_M const-decl "sigma_algebra" lebesgue_def nil)
    (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (complete_sigma_finite? const-decl "bool" measure_def
     measure_integration)
    (complete_sigma_finite type-eq-decl nil measure_def
     measure_integration)
    (lambda_ const-decl "complete_sigma_finite[real, cal_M]"
     lebesgue_def nil)
    (isf_phi judgement-tcc nil isf measure_integration)
    (measurable_set? const-decl "bool" measure_space_def
     measure_integration)
    (measurable_set nonempty-type-eq-decl nil measure_space_def
     measure_integration)
    (mu_fin? const-decl "bool" measure_props measure_integration)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (lambda_ball formula-decl nil lebesgue_def nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (member const-decl "bool" sets nil)
    (ball_is_metric_open application-judgement "metric_open"
     real_topology metric_space)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (ball_is_cal_M formula-decl nil lebesgue_def nil))
   shostak))
 (integrable_phi_closed 0
  (integrable_phi_closed-1 nil 3475934373
   ("" (skosimp)
    ((""
      (case-replace
       "closed(a!1, b!1)=closed_ball((b!1+a!1)/2,(b!1-a!1)/2)")
      (("1" (hide -1)
        (("1"
          (lemma "lambda_closed_ball"
           ("x" "(b!1 + a!1) / 2" "nnr" "(b!1 - a!1) / 2"))
          (("1"
            (lemma "closed_ball_is_cal_M"
             ("x" "(b!1 + a!1) / 2" "nnr" "(b!1 - a!1) / 2"))
            (("1" (expand "member")
              (("1" (rewrite "isf_is_integrable" +)
                (("1" (hide 2)
                  (("1" (rewrite "isf_phi")
                    (("1" (hide 2)
                      (("1" (expand "measurable_set?")
                        (("1" (replace -1)
                          (("1" (expand "mu_fin?")
                            (("1" (replace -2) (("1" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (apply-extensionality :hide? t)
        (("2" (expand "closed") (("2" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_minus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (metric_induced_topology const-decl "setofsets[T]" metric_space_def
     metric_space)
    (closed? const-decl "bool" topology topology)
    (closed nonempty-type-eq-decl nil topology topology)
    (closed_ball const-decl "closed" real_topology metric_space)
    (closed_interval nonempty-type-eq-decl nil real_topology
     metric_space)
    (closed const-decl "closed_interval" real_topology metric_space)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (lambda_closed_ball formula-decl nil lebesgue_def nil)
    (member const-decl "bool" sets nil)
    (isf_phi judgement-tcc nil isf measure_integration)
    (measurable_set? const-decl "bool" measure_space_def
     measure_integration)
    (measurable_set nonempty-type-eq-decl nil measure_space_def
     measure_integration)
    (mu_fin? const-decl "bool" measure_props measure_integration)
    (real_times_real_is_real application-judgement "real" reals nil)
    (lambda_ const-decl "complete_sigma_finite[real, cal_M]"
     lebesgue_def nil)
    (complete_sigma_finite type-eq-decl nil measure_def
     measure_integration)
    (complete_sigma_finite? const-decl "bool" measure_def
     measure_integration)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (cal_M const-decl "sigma_algebra" lebesgue_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def
     measure_integration)
    (sigma_algebra? const-decl "bool" subset_algebra_def
     measure_integration)
    (phi const-decl "nat" measure_space measure_integration)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (isf nonempty-type-eq-decl nil isf measure_integration)
    (isf? const-decl "bool" isf measure_integration)
    (isf_is_integrable judgement-tcc nil integral measure_integration)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (closed_ball_is_cal_M formula-decl nil lebesgue_def nil))
   shostak))
 (integral_phi_open_TCC1 0
  (integral_phi_open_TCC1-1 nil 3475932041
   ("" (skosimp) (("" (rewrite "integrable_phi_open") nil nil)) nil)
   ((integrable_phi_open formula-decl nil lebesgue_def nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (< const-decl "bool" reals nil))
   nil
   (integral_phi_open subtype
    "measure_space[real, lebesgue_def.cal_M].phi(real_topology.open(lebesgue_def.a, lebesgue_def.b))"
    "integrable[real, cal_M, lambda_]")))
 (integral_phi_open 0
  (integral_phi_open-1 nil 3475934094
   ("" (skosimp)
    ((""
      (case-replace
       "open(a!1, b!1)=ball((b!1 + a!1) / 2, (b!1 - a!1) / 2)")
      (("1" (hide -1)
        (("1"
          (lemma "lambda_ball"
           ("x" "(b!1 + a!1) / 2" "r" "(b!1 - a!1) / 2"))
          (("1"
            (lemma "ball_is_cal_M"
             ("x" "(b!1 + a!1) / 2" "r" "(b!1 - a!1) / 2"))
            (("1" (expand "member")
              (("1" (rewrite "integral_phi")
                (("1" (expand "mu")
                  (("1" (replace -2) (("1" (assert) nil nil)) nil))
                  nil)
                 ("2" (expand "measurable_set?")
                  (("2" (replace -1)
                    (("2" (expand "mu_fin?")
                      (("2" (replace -2) (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (apply-extensionality :hide? t)
          (("2" (expand "open") (("2" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (ball_is_metric_open application-judgement "metric_open"
     real_topology metric_space)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ball const-decl "set[T]" metric_space_def metric_space)
    (open_interval nonempty-type-eq-decl nil real_topology
     metric_space)
    (open const-decl "open_interval" real_topology metric_space)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (lambda_ball formula-decl nil lebesgue_def nil)
    (member const-decl "bool" sets nil)
    (mu const-decl "nnreal" measure_props measure_integration)
    (real_times_real_is_real application-judgement "real" reals nil)
    (lambda_ const-decl "complete_sigma_finite[real, cal_M]"
     lebesgue_def nil)
    (complete_sigma_finite type-eq-decl nil measure_def
     measure_integration)
    (complete_sigma_finite? const-decl "bool" measure_def
     measure_integration)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil)
    (cal_M const-decl "sigma_algebra" lebesgue_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def
     measure_integration)
    (sigma_algebra? const-decl "bool" subset_algebra_def
     measure_integration)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (mu_fin? const-decl "bool" measure_props measure_integration)
    (measurable_set nonempty-type-eq-decl nil measure_space_def
     measure_integration)
    (measurable_set? const-decl "bool" measure_space_def
     measure_integration)
    (integral_phi formula-decl nil integral measure_integration)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (ball_is_cal_M formula-decl nil lebesgue_def nil))
   shostak))
 (integral_phi_closed_TCC1 0
  (integral_phi_closed_TCC1-1 nil 3475932041
   ("" (skosimp) (("" (rewrite "integrable_phi_closed") nil nil)) nil)
   ((integrable_phi_closed formula-decl nil lebesgue_def nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (<= const-decl "bool" reals nil))
   nil
   (integral_phi_closed subtype
    "measure_space[real, lebesgue_def.cal_M].phi(real_topology.closed(lebesgue_def.a, lebesgue_def.b))"
    "integrable[real, cal_M, lambda_]")))
 (integral_phi_closed 0
  (integral_phi_closed-1 nil 3475934559
   ("" (skosimp)
    ((""
      (case-replace
       "closed(a!1, b!1)=closed_ball((b!1+a!1)/2,(b!1-a!1)/2)")
      (("1" (hide -1)
        (("1"
          (lemma "lambda_closed_ball"
           ("x" "(b!1 + a!1) / 2" "nnr" "(b!1 - a!1) / 2"))
          (("1"
            (lemma "closed_ball_is_cal_M"
             ("x" "(b!1 + a!1) / 2" "nnr" "(b!1 - a!1) / 2"))
            (("1" (expand "member")
              (("1" (rewrite "integral_phi")
                (("1" (expand "mu")
                  (("1" (replace -2) (("1" (assert) nil nil)) nil))
                  nil)
                 ("2" (expand "mu_fin?")
                  (("2" (replace -2)
                    (("2" (assert)
                      (("2" (expand "measurable_set?")
                        (("2" (replace -1) (("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (apply-extensionality :hide? t)
        (("2" (expand "closed") (("2" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_minus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (metric_induced_topology const-decl "setofsets[T]" metric_space_def
     metric_space)
    (closed? const-decl "bool" topology topology)
    (closed nonempty-type-eq-decl nil topology topology)
    (closed_ball const-decl "closed" real_topology metric_space)
    (closed_interval nonempty-type-eq-decl nil real_topology
     metric_space)
    (closed const-decl "closed_interval" real_topology metric_space)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (lambda_closed_ball formula-decl nil lebesgue_def nil)
    (member const-decl "bool" sets nil)
    (mu const-decl "nnreal" measure_props measure_integration)
    (real_times_real_is_real application-judgement "real" reals nil)
    (lambda_ const-decl "complete_sigma_finite[real, cal_M]"
     lebesgue_def nil)
    (complete_sigma_finite type-eq-decl nil measure_def
     measure_integration)
    (complete_sigma_finite? const-decl "bool" measure_def
     measure_integration)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (cal_M const-decl "sigma_algebra" lebesgue_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def
     measure_integration)
    (sigma_algebra? const-decl "bool" subset_algebra_def
     measure_integration)
    (mu_fin? const-decl "bool" measure_props measure_integration)
    (measurable_set nonempty-type-eq-decl nil measure_space_def
     measure_integration)
    (measurable_set? const-decl "bool" measure_space_def
     measure_integration)
    (integral_phi formula-decl nil integral measure_integration)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (closed_ball_is_cal_M formula-decl nil lebesgue_def nil))
   shostak))
 (I_is_measurable 0
  (I_is_measurable-1 nil 3475936049
   ("" (rewrite "measurable_def2")
    (("" (skosimp)
      (("" (typepred "i!1")
        (("" (skosimp)
          (("" (lemma "ball_is_cal_M" ("x" "x!1" "r" "r!1"))
            (("" (expand "member")
              (("" (case-replace "inverse_image(I[real], i!1)=i!1")
                (("1" (assert) nil nil)
                 ("2" (hide-all-but 1)
                  (("2" (apply-extensionality :hide? t)
                    (("2" (expand "inverse_image")
                      (("2" (expand "member")
                        (("2" (expand "I") (("2" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((member const-decl "bool" sets nil)
    (ball_is_metric_open application-judgement "metric_open"
     real_topology metric_space)
    (I_is_continuous name-judgement
     "continuous[real, metric_induced_topology, real, metric_induced_topology]"
     lebesgue_def nil)
    (id_fun_continuous name-judgement "continuous_fun" integral
     analysis)
    (id_fun_continuous name-judgement "continuous_fun"
     integral_split_scaf analysis)
    (id_fun_continuous name-judgement "continuous_fun" integral_step
     analysis)
    (id_fun_continuous name-judgement "continuous_fun" unif_cont_fun
     analysis)
    (id_fun_continuous name-judgement "continuous_fun"
     continuous_functions analysis)
    (id_fun_continuous name-judgement "continuous_fun"
     indefinite_integral analysis)
    (derivable_id name-judgement "deriv_fun" derivatives analysis)
    (id_fun_continuous name-judgement "continuous_fun"
     lim_of_composition analysis)
    (inverse_image const-decl "set[D]" function_image nil)
    (ball_is_cal_M formula-decl nil lebesgue_def nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ball const-decl "set[T]" metric_space_def metric_space)
    (open_interval nonempty-type-eq-decl nil real_topology
     metric_space)
    (cal_M const-decl "sigma_algebra" lebesgue_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def
     measure_integration)
    (sigma_algebra? const-decl "bool" subset_algebra_def
     measure_integration)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (I const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (measurable_def2 formula-decl nil measure_space_def
     measure_integration))
   nil
   (I_is_measurable subtype "identity[real].I"
    "measurable_function[real, cal_M]")))
 (continuous_is_measurable 0
  (continuous_is_measurable-1 nil 3475936049
   ("" (skolem + "f!1")
    (("" (typepred "f!1")
      (("" (lemma "I_is_measurable")
        (("" (lemma "continuous_is_borel")
          (("" (inst - "f!1")
            ((""
              (lemma "borel_comp_measurable_is_measurable"
               ("phi" "f!1" "g" "I[real]"))
              (("1" (expand "o")
                (("1"
                  (case-replace
                   "(LAMBDA (x: real): f!1(I[real](x)))=f!1")
                  (("1" (hide-all-but 1)
                    (("1" (apply-extensionality :hide? t)
                      (("1" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (propax) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((continuous type-eq-decl nil continuity_def topology)
    (continuous? const-decl "bool" continuity_def topology)
    (metric_induced_topology const-decl "setofsets[T]" metric_space_def
     metric_space)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (metric_induced_topology_is_second_countable name-judgement
     "second_countable" real_topology metric_space)
    (metric_space_is_hausdorff name-judgement "hausdorff" real_topology
     metric_space)
    (continuous_is_borel judgement-tcc nil borel_functions
     measure_integration)
    (id_fun_continuous name-judgement "continuous_fun"
     lim_of_composition analysis)
    (derivable_id name-judgement "deriv_fun" derivatives analysis)
    (id_fun_continuous name-judgement "continuous_fun"
     indefinite_integral analysis)
    (id_fun_continuous name-judgement "continuous_fun"
     continuous_functions analysis)
    (id_fun_continuous name-judgement "continuous_fun" unif_cont_fun
     analysis)
    (id_fun_continuous name-judgement "continuous_fun" integral_step
     analysis)
    (id_fun_continuous name-judgement "continuous_fun"
     integral_split_scaf analysis)
    (id_fun_continuous name-judgement "continuous_fun" integral
     analysis)
    (I_is_measurable name-judgement "measurable_function" lebesgue_def
     nil)
    (I_is_continuous name-judgement
     "continuous[real, metric_induced_topology, real, metric_induced_topology]"
     lebesgue_def nil)
    (borel_comp_measurable_is_measurable judgement-tcc nil
     measure_space measure_integration)
    (measurable_function? const-decl "bool" measure_space_def
     measure_integration)
    (measurable_function nonempty-type-eq-decl nil measure_space_def
     measure_integration)
    (bijective? const-decl "bool" functions nil)
    (I const-decl "(bijective?[T, T])" identity nil)
    (borel_function? const-decl "bool" borel_functions
     measure_integration)
    (borel_function type-eq-decl nil borel_functions
     measure_integration)
    (sigma_algebra? const-decl "bool" subset_algebra_def
     measure_integration)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def
     measure_integration)
    (cal_M const-decl "sigma_algebra" lebesgue_def nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (O const-decl "T3" function_props nil)
    (I_is_measurable judgement-tcc nil lebesgue_def nil))
   nil
   (continuous_is_measurable subtype "lebesgue_def.x"
    "measurable_function[real, cal_M]")))
 (singleton_is_measurable 0
  (singleton_is_measurable-1 nil 3475936361
   ("" (skosimp)
    (("" (expand "measurable_set?")
      (("" (lemma "singleton_is_cal_M" ("x" "x!1"))
        (("" (expand "member") (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((singleton_is_compact application-judgement "compact" real_topology
     metric_space)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[real]" integral_def analysis)
    (singleton_is_closed application-judgement
     "closed[real, (metric_induced_topology)]" real_topology
     metric_space)
    (measurable_set? const-decl "bool" measure_space_def
     measure_integration)
    (member const-decl "bool" sets nil)
    (singleton_is_cal_M formula-decl nil lebesgue_def nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil))
   nil
   (singleton_is_measurable subtype
    "sets[real].singleton(lebesgue_def.x)"
    "measurable_set[real, cal_M]")))
 (open_is_measurable 0
  (open_is_measurable-1 nil 3475936361
   ("" (skosimp)
    (("" (expand "measurable_set?")
      ((""
        (lemma "ball_is_cal_M" ("x" "(b!1+a!1)/2" "r" "(b!1-a!1)/2"))
        (("" (expand "member")
          ((""
            (case-replace
             "open(a!1, b!1)=ball((a!1 + b!1) / 2, (b!1 - a!1) / 2)")
            (("" (hide-all-but 1)
              (("" (apply-extensionality :hide? t)
                (("" (expand "open") (("" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((measurable_set? const-decl "bool" measure_space_def
     measure_integration)
    (member const-decl "bool" sets nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (open const-decl "open_interval" real_topology metric_space)
    (open_interval nonempty-type-eq-decl nil real_topology
     metric_space)
    (ball const-decl "set[T]" metric_space_def metric_space)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (ball_is_metric_open application-judgement "metric_open"
     real_topology metric_space)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (ball_is_cal_M formula-decl nil lebesgue_def nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields
       nil))
   nil
   (open_is_measurable subtype
    "real_topology.open(lebesgue_def.a, lebesgue_def.b)"
    "measurable_set[real, cal_M]")))
 (closed_is_measurable 0
  (closed_is_measurable-1 nil 3475936361
   ("" (skosimp)
    (("" (expand "measurable_set?")
      ((""
        (lemma "closed_ball_is_cal_M"
         ("x" "(b!1+a!1)/2" "nnr" "(b!1-a!1)/2"))
        (("" (expand "member")
          ((""
            (case-replace
             "closed(a!1, b!1)=closed_ball((a!1 + b!1) / 2, (b!1 - a!1) / 2)")
            (("" (apply-extensionality :hide? t)
              (("" (expand "closed") (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((measurable_set? const-decl "bool" measure_space_def
     measure_integration)
    (member const-decl "bool" sets nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (closed const-decl "closed_interval" real_topology metric_space)
    (closed_interval nonempty-type-eq-decl nil real_topology
     metric_space)
    (closed_ball const-decl "closed" real_topology metric_space)
    (closed nonempty-type-eq-decl nil topology topology)
    (closed? const-decl "bool" topology topology)
    (metric_induced_topology const-decl "setofsets[T]" metric_space_def
     metric_space)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (closed_ball_is_cal_M formula-decl nil lebesgue_def nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields
       nil))
   nil
   (closed_is_measurable subtype
    "real_topology.closed(lebesgue_def.a, lebesgue_def.b)"
    "measurable_set[real, cal_M]")))
 (finite_is_measurable 0
  (finite_is_measurable-1 nil 3475936361
   (""
    (case "forall (n:nat,X:finite_set[real]): card(X) <= n =>
        measurable_set?[real, cal_M](X)")
    (("1" (skosimp)
      (("1" (inst - "card(x!1)" "x!1") (("1" (assert) nil nil)) nil))
      nil)
     ("2" (hide 2)
      (("2" (induct "n")
        (("1" (skosimp)
          (("1" (expand "<=")
            (("1" (split)
              (("1" (assert) nil nil)
               ("2" (lemma "card_is_0[real]" ("S" "X!1"))
                (("2" (assert)
                  (("2" (replace -2)
                    (("2" (replace -1)
                      (("2" (hide -1 -2)
                        (("2" (assert)
                          (("2" (expand "measurable_set?")
                            (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skosimp*)
          (("2" (expand "<=" -2)
            (("2" (split -2)
              (("1" (inst - "X!1") (("1" (assert) nil nil)) nil)
               ("2" (lemma "nonempty_card[real]" ("S" "X!1"))
                (("2" (assert)
                  (("2" (copy -1)
                    (("2" (expand "nonempty?" -1)
                      (("2" (lemma "card_rest[real]" ("S" "X!1"))
                        (("2" (assert)
                          (("2" (replace -3)
                            (("2" (assert)
                              (("2"
                                (inst - "rest[real](X!1)")
                                (("2"
                                  (assert)
                                  (("2"
                                    (lemma
                                     "singleton_is_measurable"
                                     ("x" "choose[real](X!1)"))
                                    (("2"
                                      (lemma
                                       "choose_rest[real]"
                                       ("a" "X!1"))
                                      (("2"
                                        (assert)
                                        (("2"
                                          (rewrite "add_as_union")
                                          (("2"
                                            (typepred "cal_M")
                                            (("2"
                                              (lemma
                                               "sigma_algebra_union[real,cal_M]"
                                               ("x"
                                                "rest[real](X!1)"
                                                "y"
                                                "singleton[real](choose[real](X!1))"))
                                              (("1"
                                                (expand "member")
                                                (("1"
                                                  (expand
                                                   "measurable_set?")
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (expand
                                                 "measurable_set?")
                                                (("2"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil)
                                               ("3"
                                                (expand
                                                 "measurable_set?")
                                                (("3"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty? const-decl "bool" sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_rest application-judgement "finite_set[real]" integral_def
     analysis)
    (choose_rest formula-decl nil sets_lemmas nil)
    (add_as_union formula-decl nil sets_lemmas nil)
    (nonempty_finite_union2 application-judgement
     "non_empty_finite_set[real]" integral_def analysis)
    (sigma_algebra_union formula-decl nil sigma_algebra
     measure_integration)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (member const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (singleton_is_compact application-judgement "compact" real_topology
     metric_space)
    (singleton_is_measurable application-judgement "measurable_set"
     lebesgue_def nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[real]" integral_def analysis)
    (singleton_is_closed application-judgement
     "closed[real, (metric_induced_topology)]" real_topology
     metric_space)
    (choose const-decl "(p)" sets nil)
    (singleton_is_measurable judgement-tcc nil lebesgue_def nil)
    (rest const-decl "set" sets nil)
    (card_rest formula-decl nil finite_sets nil)
    (nonempty_card formula-decl nil finite_sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (subset_algebra_emptyset name-judgement "(S)" real_lebesgue_scaf
     nil)
    (subset_algebra_emptyset name-judgement "(S)" real_borel
     measure_integration)
    (subset_algebra_emptyset name-judgement "(S)" real_lebesgue_scaf
     nil)
    (outer_negligible_emptyset name-judgement "outer_negligible"
     real_lebesgue_scaf nil)
    (emptyset_is_clopen name-judgement "clopen" real_topology
     metric_space)
    (emptyset_is_compact name-judgement "compact" real_topology
     metric_space)
    (subset_algebra_emptyset name-judgement "(S)" lebesgue_def nil)
    (null_emptyset name-judgement "null_set" lebesgue_def nil)
    (finite_emptyset name-judgement "finite_set[real]" integral_def
     analysis)
    (finite_emptyset name-judgement "finite_set[T]" step_fun_props
     analysis)
    (finite_emptyset name-judgement "finite_set" countable_setofsets
     sets_aux)
    (finite_emptyset name-judgement "finite_set" countable_props
     sets_aux)
    (finite_emptyset name-judgement "finite_set[T]" bounded_nats
     orders)
    (finite_emptyset name-judgement "finite_set" sigma_countable
     sigma_set)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (card_is_0 formula-decl nil finite_sets nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def
     measure_integration)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def
     measure_integration)
    (cal_M const-decl "sigma_algebra" lebesgue_def nil)
    (measurable_set? const-decl "bool" measure_space_def
     measure_integration))
   nil
   (finite_is_measurable subtype "lebesgue_def.x"
    "measurable_set[real, cal_M]")))
 (countable_is_measurable 0
  (countable_is_measurable-1 nil 3475936581
   ("" (skosimp)
    (("" (typepred "x!1")
      (("" (rewrite "countable_card" -1)
        (("" (split)
          (("1" (lemma "finite_is_measurable")
            (("1" (inst - "x!1") nil nil)) nil)
           ("2" (expand "is_countably_infinite")
            (("2" (skosimp)
              (("2" (typepred "f!1")
                (("2"
                  (lemma "bijective_inverse_exists[(x!1), nat]"
                   ("f" "f!1"))
                  (("2" (expand "exists1")
                    (("2" (flatten)
                      (("2" (skolem - "g!1")
                        (("2"
                          (lemma "measurable_IUnion"
                           ("SS" "singleton[real] o g!1"))
                          (("1"
                            (case-replace
                             "(IUnion[nat, real](singleton[real] o g!1))=x!1")
                            (("1" (apply-extensionality :hide? t)
                              (("1"
                                (expand "o ")
                                (("1"
                                  (expand "singleton")
                                  (("1"
                                    (expand "IUnion")
                                    (("1"
                                      (case-replace "x!1(x!2)")
                                      (("1"
                                        (inst + "f!1(x!2)")
                                        (("1"
                                          (rewrite
                                           "comp_inverse_left_alt[(x!1), nat]")
                                          nil
                                          nil))
                                        nil)
                                       ("2"
                                        (assert)
                                        (("2"
                                          (skosimp)
                                          (("2"
                                            (replace -1)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand "o")
                            (("2" (skosimp)
                              (("2"
                                (rewrite "singleton_is_measurable")
                                nil
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((countable_set nonempty-type-eq-decl nil countability sets_aux)
    (is_countable const-decl "bool" countability sets_aux)
    (set type-eq-decl nil sets nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (x!1 skolem-const-decl "countable_set[real]" lebesgue_def nil)
    (finite_is_measurable judgement-tcc nil lebesgue_def nil)
    (bijective_inverse_exists formula-decl nil function_inverse_def
     nil)
    (cal_M const-decl "sigma_algebra" lebesgue_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def
     measure_integration)
    (sigma_algebra? const-decl "bool" subset_algebra_def
     measure_integration)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (singleton const-decl "(singleton?)" sets nil)
    (O const-decl "T3" function_props nil)
    (singleton? const-decl "bool" sets nil)
    (sequence type-eq-decl nil sequences nil)
    (measurable_set nonempty-type-eq-decl nil measure_space_def
     measure_integration)
    (measurable_set? const-decl "bool" measure_space_def
     measure_integration)
    (measurable_IUnion judgement-tcc nil measure_space_def
     measure_integration)
    (inverse? const-decl "bool" function_inverse_def nil)
    (comp_inverse_left_alt formula-decl nil function_inverse_def nil)
    (x!2 skolem-const-decl "real" lebesgue_def nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IUnion const-decl "set[T]" indexed_sets nil)
    (singleton_is_measurable judgement-tcc nil lebesgue_def nil)
    (singleton_is_closed application-judgement
     "closed[real, (metric_induced_topology)]" real_topology
     metric_space)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[real]" integral_def analysis)
    (singleton_is_compact application-judgement "compact" real_topology
     metric_space)
    (exists1 const-decl "bool" exists1 nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (is_countably_infinite const-decl "bool" countability sets_aux)
    (countable_card formula-decl nil countable_props sets_aux))
   nil
   (countable_is_measurable subtype "lebesgue_def.x"
    "measurable_set[real, cal_M]")))
 (singleton_is_null 0
  (singleton_is_null-1 nil 3475936361
   ("" (skosimp)
    (("" (expand "null_set?")
      (("" (rewrite "singleton_is_measurable")
        (("" (expand "mu_fin?")
          (("" (expand "mu")
            (("" (lemma "lambda_singleton" ("x" "x!1"))
              (("" (replace -1) (("" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((singleton_is_compact application-judgement "compact" real_topology
     metric_space)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[real]" integral_def analysis)
    (singleton_is_closed application-judgement
     "closed[real, (metric_induced_topology)]" real_topology
     metric_space)
    (null_set? const-decl "bool" measure_theory measure_integration)
    (mu_fin? const-decl "bool" measure_props measure_integration)
    (lambda_singleton formula-decl nil lebesgue_def nil)
    (mu const-decl "nnreal" measure_props measure_integration)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (singleton_is_measurable judgement-tcc nil lebesgue_def nil))
   nil
   (singleton_is_null subtype "sets[real].singleton(lebesgue_def.x)"
    "null_set[real, cal_M, lambda_]")))
 (finite_is_null 0
  (finite_is_null-1 nil 3475936361
   (""
    (case "forall (X:finite_set[real],n:nat): card[real](X) <= n => null_set?[real, cal_M, lambda_](X)")
    (("1" (skosimp)
      (("1" (inst - "x!1" "card(x!1)") (("1" (assert) nil nil)) nil))
      nil)
     ("2" (hide 2)
      (("2" (induct "n")
        (("1" (skosimp)
          (("1" (expand "<=")
            (("1" (split)
              (("1" (assert) nil nil)
               ("2" (rewrite "card_is_0")
                (("2" (replace -1)
                  (("2" (hide -1)
                    (("2" (rewrite "null_emptyset") nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skosimp*)
          (("2" (expand "<=" -2)
            (("2" (split)
              (("1" (inst - "X!1") (("1" (assert) nil nil)) nil)
               ("2" (lemma "nonempty_card[real]" ("S" "X!1"))
                (("2" (assert)
                  (("2" (copy -1)
                    (("2" (expand "nonempty?" -1)
                      (("2" (lemma "card_rest[real]" ("S" "X!1"))
                        (("2" (assert)
                          (("2" (replace -3)
                            (("2" (assert)
                              (("2"
                                (inst - "rest[real](X!1)")
                                (("2"
                                  (assert)
                                  (("2"
                                    (lemma
                                     "singleton_is_null"
                                     ("x" "choose[real](X!1)"))
                                    (("2"
                                      (lemma
                                       "choose_rest[real]"
                                       ("a" "X!1"))
                                      (("2"
                                        (assert)
                                        (("2"
                                          (rewrite "add_as_union")
                                          (("2"
                                            (replace -1 2 rl)
                                            (("2"
                                              (lemma
                                               "null_union"
                                               ("N1"
                                                "rest[real](X!1)"
                                                "N2"
                                                "singleton[real](choose[real](X!1))"))
                                              (("2" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty? const-decl "bool" sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_rest application-judgement "finite_set[real]" integral_def
     analysis)
    (choose_rest formula-decl nil sets_lemmas nil)
    (add_as_union formula-decl nil sets_lemmas nil)
    (nonempty_finite_union2 application-judgement
     "non_empty_finite_set[real]" integral_def analysis)
    (null_union judgement-tcc nil measure_theory measure_integration)
    (null_set nonempty-type-eq-decl nil measure_theory
     measure_integration)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (singleton_is_compact application-judgement "compact" real_topology
     metric_space)
    (singleton_is_null application-judgement "null_set" lebesgue_def
     nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[real]" integral_def analysis)
    (singleton_is_closed application-judgement
     "closed[real, (metric_induced_topology)]" real_topology
     metric_space)
    (choose const-decl "(p)" sets nil)
    (singleton_is_null judgement-tcc nil lebesgue_def nil)
    (rest const-decl "set" sets nil)
    (card_rest formula-decl nil finite_sets nil)
    (nonempty_card formula-decl nil finite_sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (null_emptyset judgement-tcc nil measure_theory
     measure_integration)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set" sigma_countable
     sigma_set)
    (finite_emptyset name-judgement "finite_set[T]" bounded_nats
     orders)
    (finite_emptyset name-judgement "finite_set" countable_props
     sets_aux)
    (finite_emptyset name-judgement "finite_set" countable_setofsets
     sets_aux)
    (finite_emptyset name-judgement "finite_set[T]" step_fun_props
     analysis)
    (finite_emptyset name-judgement "finite_set[real]" integral_def
     analysis)
    (null_emptyset name-judgement "null_set" lebesgue_def nil)
    (subset_algebra_emptyset name-judgement "(S)" lebesgue_def nil)
    (emptyset_is_compact name-judgement "compact" real_topology
     metric_space)
    (emptyset_is_clopen name-judgement "clopen" real_topology
     metric_space)
    (outer_negligible_emptyset name-judgement "outer_negligible"
     real_lebesgue_scaf nil)
    (subset_algebra_emptyset name-judgement "(S)" real_lebesgue_scaf
     nil)
    (subset_algebra_emptyset name-judgement "(S)" real_borel
     measure_integration)
    (subset_algebra_emptyset name-judgement "(S)" real_lebesgue_scaf
     nil)
    (card_is_0 formula-decl nil finite_sets nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def
     measure_integration)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def
     measure_integration)
    (cal_M const-decl "sigma_algebra" lebesgue_def nil)
    (nnreal type-eq-decl nil real_types nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (complete_sigma_finite? const-decl "bool" measure_def
     measure_integration)
    (complete_sigma_finite type-eq-decl nil measure_def
     measure_integration)
    (lambda_ const-decl "complete_sigma_finite[real, cal_M]"
     lebesgue_def nil)
    (null_set? const-decl "bool" measure_theory measure_integration))
   nil
   (finite_is_null subtype "lebesgue_def.x"
    "null_set[real, cal_M, lambda_]")))
 (countable_is_null 0
  (countable_is_null-1 nil 3475936361
   ("" (skosimp)
    (("" (typepred "x!1")
      (("" (rewrite "countable_card" -1)
        (("" (split)
          (("1" (rewrite "finite_is_null") nil nil)
           ("2" (expand "is_countably_infinite")
            (("2" (skosimp)
              (("2" (typepred "f!1")
                (("2"
                  (lemma "bijective_inverse_exists[(x!1), nat]"
                   ("f" "f!1"))
                  (("2" (expand "exists1")
                    (("2" (flatten)
                      (("2" (skolem - "g!1")
                        (("2"
                          (lemma "null_IUnion"
                           ("NS" "singleton[real] o g!1"))
                          (("1"
                            (case-replace
                             "(IUnion[nat, real](singleton[real] o g!1))=x!1")
                            (("1" (hide -1 2)
                              (("1"
                                (apply-extensionality :hide? t)
                                (("1"
                                  (expand "o ")
                                  (("1"
                                    (expand "IUnion")
                                    (("1"
                                      (expand "singleton")
                                      (("1"
                                        (case-replace "x!1(x!2)")
                                        (("1"
                                          (inst + "f!1(x!2)")
                                          (("1"
                                            (rewrite
                                             "comp_inverse_left_alt[(x!1), nat]")
                                            nil
                                            nil))
                                          nil)
                                         ("2"
                                          (assert)
                                          (("2"
                                            (skosimp)
                                            (("2"
                                              (replace -1)
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand "o")
                            (("2" (skosimp)
                              (("2"
                                (lemma
                                 "singleton_is_null"
                                 ("x" "g!1(x1!1)"))
                                (("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((countable_set nonempty-type-eq-decl nil countability sets_aux)
    (is_countable const-decl "bool" countability sets_aux)
    (set type-eq-decl nil sets nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_is_null judgement-tcc nil lebesgue_def nil)
    (bijective_inverse_exists formula-decl nil function_inverse_def
     nil)
    (lambda_ const-decl "complete_sigma_finite[real, cal_M]"
     lebesgue_def nil)
    (complete_sigma_finite type-eq-decl nil measure_def
     measure_integration)
    (complete_sigma_finite? const-decl "bool" measure_def
     measure_integration)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil)
    (cal_M const-decl "sigma_algebra" lebesgue_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def
     measure_integration)
    (sigma_algebra? const-decl "bool" subset_algebra_def
     measure_integration)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (singleton const-decl "(singleton?)" sets nil)
    (O const-decl "T3" function_props nil)
    (singleton? const-decl "bool" sets nil)
    (sequence type-eq-decl nil sequences nil)
    (null_set nonempty-type-eq-decl nil measure_theory
     measure_integration)
    (null_set? const-decl "bool" measure_theory measure_integration)
    (null_IUnion judgement-tcc nil measure_theory measure_integration)
    (x!1 skolem-const-decl "countable_set[real]" lebesgue_def nil)
    (x!2 skolem-const-decl "real" lebesgue_def nil)
    (comp_inverse_left_alt formula-decl nil function_inverse_def nil)
    (inverse? const-decl "bool" function_inverse_def nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IUnion const-decl "set[T]" indexed_sets nil)
    (singleton_is_null judgement-tcc nil lebesgue_def nil)
    (singleton_is_closed application-judgement
     "closed[real, (metric_induced_topology)]" real_topology
     metric_space)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[real]" integral_def analysis)
    (singleton_is_compact application-judgement "compact" real_topology
     metric_space)
    (exists1 const-decl "bool" exists1 nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (is_countably_infinite const-decl "bool" countability sets_aux)
    (countable_card formula-decl nil countable_props sets_aux))
   nil
   (countable_is_null subtype "lebesgue_def.x"
    "null_set[real, cal_M, lambda_]")))
 (integrable_singleton 0
  (integrable_singleton-1 nil 3475937385
   ("" (skosimp)
    (("" (lemma "integrable_phi_closed" ("a" "x!1" "b" "x!1"))
      (("" (case-replace "closed(x!1,x!1)=singleton[real](x!1)")
        (("" (hide-all-but 1)
          (("" (apply-extensionality :hide? t) (("" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((<= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (integrable_phi_closed formula-decl nil lebesgue_def nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (metric_space_is_hausdorff name-judgement "hausdorff" real_topology
     metric_space)
    (metric_induced_topology_is_second_countable name-judgement
     "second_countable" real_topology metric_space)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (singleton const-decl "(singleton?)" sets nil)
    (singleton? const-decl "bool" sets nil)
    (closed const-decl "closed_interval" real_topology metric_space)
    (closed_interval nonempty-type-eq-decl nil real_topology
     metric_space)
    (closed_ball const-decl "closed" real_topology metric_space)
    (closed nonempty-type-eq-decl nil topology topology)
    (closed? const-decl "bool" topology topology)
    (metric_induced_topology const-decl "setofsets[T]" metric_space_def
     metric_space)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (nnreal type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (singleton_is_closed application-judgement
     "closed[real, (metric_induced_topology)]" real_topology
     metric_space)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[real]" integral_def analysis)
    (singleton_is_compact application-judgement "compact" real_topology
     metric_space)
    (closed_is_measurable application-judgement "measurable_set"
     lebesgue_def nil))
   shostak))
 (integrable_finite 0
  (integrable_finite-2 nil 3782585500
   (""
    (case "forall (n:nat,X: finite_set[real]): card(X) <= n => integral[reals.real,cal_M,lambda_].integrable?(phi(X))")
    (("1" (skosimp)
      (("1" (inst - "card(X!1)" "X!1") (("1" (assert) nil nil)) nil))
      nil)
     ("2" (hide 2)
      (("2" (induct "n")
        (("1" (skosimp)
          (("1" (expand "<=")
            (("1" (split)
              (("1" (assert) nil nil)
               ("2" (rewrite "card_is_0")
                (("2" (replace -1)
                  (("2" (hide -1)
                    (("2"
                      (case-replace "phi(emptyset[real])=lambda x: 0")
                      (("1" (rewrite "integrable_zero") nil nil)
                       ("2" (apply-extensionality :hide? t)
                        (("2" (expand "emptyset")
                          (("2" (expand "phi")
                            (("2" (expand "member")
                              (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skosimp*)
          (("2" (expand "<=" -2)
            (("2" (split)
              (("1" (inst - "X!1") (("1" (assert) nil nil)) nil)
               ("2" (lemma "nonempty_card[real]" ("S" "X!1"))
                (("2" (assert)
                  (("2" (lemma "card_rest[real]" ("S" "X!1"))
                    (("2" (split)
                      (("1" (inst - "rest[real](X!1)")
                        (("1" (assert)
                          (("1" (lemma "choose_rest[real]" ("a" "X!1"))
                            (("1" (split)
                              (("1"
                                (rewrite "add_as_union")
                                (("1"
                                  (lemma
                                   "integrable_singleton"
                                   ("x" "choose[real](X!1)"))
                                  (("1"
                                    (replace -2 1 rl)
                                    (("1"
                                      (lemma
                                       "integrable_add"
                                       ("f1"
                                        "phi(rest[real](X!1))"
                                        "f2"
                                        "phi(singleton[real](choose[real](X!1)))"))
                                      (("1"
                                        (expand "+" -1)
                                        (("1"
                                          (case-replace
                                           "(LAMBDA (x: real):
                                  phi(rest[real](X!1))(x) +
                                   phi(singleton[real](choose[real](X!1)))(x))=phi(union[real](rest[real](X!1), singleton[real](choose[real](X!1))))")
                                          (("1"
                                            (hide -1 -2 2)
                                            (("1"
                                              (apply-extensionality
                                               :hide?
                                               t)
                                              (("1"
                                                (expand "phi")
                                                (("1"
                                                  (expand "union")
                                                  (("1"
                                                    (expand "member")
                                                    (("1"
                                                      (expand
                                                       "singleton")
                                                      (("1"
                                                        (case-replace
                                                         "rest[real](X!1)(x!1)")
                                                        (("1"
                                                          (lemma
                                                           "choose_not_member[real]"
                                                           ("a" "X!1"))
                                                          (("1"
                                                            (split)
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (expand
                                                               "nonempty?")
                                                              (("2"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (expand "nonempty?")
                                (("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand "nonempty?")
                        (("2" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((phi const-decl "nat" measure_space measure_integration)
    (integrable? const-decl "bool" integral measure_integration)
    (lambda_ const-decl "complete_sigma_finite[real, cal_M]"
     lebesgue_def nil)
    (complete_sigma_finite type-eq-decl nil measure_def
     measure_integration)
    (complete_sigma_finite? const-decl "bool" measure_def
     measure_integration)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil)
    (cal_M const-decl "sigma_algebra" lebesgue_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def
     measure_integration)
    (sigma_algebra? const-decl "bool" subset_algebra_def
     measure_integration)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (isf_phi application-judgement "isf" lebesgue_def nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pred type-eq-decl nil defined_types nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (card_is_0 formula-decl nil finite_sets nil)
    (subset_algebra_emptyset name-judgement "(S)" real_lebesgue_scaf
     nil)
    (subset_algebra_emptyset name-judgement "(S)" real_borel
     measure_integration)
    (subset_algebra_emptyset name-judgement "(S)" real_lebesgue_scaf
     nil)
    (outer_negligible_emptyset name-judgement "outer_negligible"
     real_lebesgue_scaf nil)
    (emptyset_is_clopen name-judgement "clopen" real_topology
     metric_space)
    (emptyset_is_compact name-judgement "compact" real_topology
     metric_space)
    (subset_algebra_emptyset name-judgement "(S)" lebesgue_def nil)
    (null_emptyset name-judgement "null_set" lebesgue_def nil)
    (finite_emptyset name-judgement "finite_set[real]" integral_def
     analysis)
    (finite_emptyset name-judgement "finite_set[T]" step_fun_props
     analysis)
    (finite_emptyset name-judgement "finite_set" countable_setofsets
     sets_aux)
    (finite_emptyset name-judgement "finite_set" countable_props
     sets_aux)
    (finite_emptyset name-judgement "finite_set[T]" bounded_nats
     orders)
    (finite_emptyset name-judgement "finite_set" sigma_countable
     sigma_set)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (member const-decl "bool" sets nil)
    (integrable_zero formula-decl nil integral measure_integration)
    (emptyset const-decl "set" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty_card formula-decl nil finite_sets nil)
    (card_rest formula-decl nil finite_sets nil)
    (finite_rest application-judgement "finite_set[real]" integral_def
     analysis)
    (rest const-decl "set" sets nil)
    (choose_rest formula-decl nil sets_lemmas nil)
    (choose const-decl "(p)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (add_as_union formula-decl nil sets_lemmas nil)
    (singleton_is_closed application-judgement
     "closed[real, (metric_induced_topology)]" real_topology
     metric_space)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[real]" integral_def analysis)
    (singleton_is_compact application-judgement "compact" real_topology
     metric_space)
    (nonempty_finite_union2 application-judgement
     "non_empty_finite_set[real]" integral_def analysis)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (choose_not_member formula-decl nil sets_lemmas nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (union const-decl "set" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (singleton? const-decl "bool" sets nil)
    (integrable nonempty-type-eq-decl nil integral measure_integration)
    (integrable_add judgement-tcc nil integral measure_integration)
    (integrable_singleton formula-decl nil lebesgue_def nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil)
  (integrable_finite-1 nil 3475940248
   (""
    (case "forall (n:nat,X: finite_set[real]): card(X) <= n => integrable?(phi(X))")
    (("1" (skosimp)
      (("1" (inst - "card(X!1)" "X!1") (("1" (assert) nil nil)) nil))
      nil)
     ("2" (hide 2)
      (("2" (induct "n")
        (("1" (skosimp)
          (("1" (expand "<=")
            (("1" (split)
              (("1" (assert) nil nil)
               ("2" (rewrite "card_is_0")
                (("2" (replace -1)
                  (("2" (hide -1)
                    (("2"
                      (case-replace "phi(emptyset[real])=lambda x: 0")
                      (("1" (rewrite "integrable_zero") nil nil)
                       ("2" (apply-extensionality :hide? t)
                        (("2" (expand "emptyset")
                          (("2" (expand "phi")
                            (("2" (expand "member")
                              (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skosimp*)
          (("2" (expand "<=" -2)
            (("2" (split)
              (("1" (inst - "X!1") (("1" (assert) nil nil)) nil)
               ("2" (lemma "nonempty_card[real]" ("S" "X!1"))
                (("2" (assert)
                  (("2" (lemma "card_rest[real]" ("S" "X!1"))
                    (("2" (split)
                      (("1" (inst - "rest[real](X!1)")
                        (("1" (assert)
                          (("1" (lemma "choose_rest[real]" ("a" "X!1"))
                            (("1" (split)
                              (("1"
                                (rewrite "add_as_union")
                                (("1"
                                  (lemma
                                   "integrable_singleton"
                                   ("x" "choose[real](X!1)"))
                                  (("1"
                                    (replace -2 1 rl)
                                    (("1"
                                      (lemma
                                       "integrable_add"
                                       ("f1"
                                        "phi(rest[real](X!1))"
                                        "f2"
                                        "phi(singleton[real](choose[real](X!1)))"))
                                      (("1"
                                        (expand "+" -1)
                                        (("1"
                                          (case-replace
                                           "(LAMBDA (x: real):
                    phi(rest[real](X!1))(x) +
                     phi(singleton[real](choose[real](X!1)))(x))=phi(union[real](rest[real](X!1), singleton[real](choose[real](X!1))))")
                                          (("1"
                                            (hide -1 -2 2)
                                            (("1"
                                              (apply-extensionality
                                               :hide?
                                               t)
                                              (("1"
                                                (expand "phi")
                                                (("1"
                                                  (expand "union")
                                                  (("1"
                                                    (expand "member")
                                                    (("1"
                                                      (expand
                                                       "singleton")
                                                      (("1"
                                                        (case-replace
                                                         "rest[real](X!1)(x!1)")
                                                        (("1"
                                                          (lemma
                                                           "choose_not_member[real]"
                                                           ("a" "X!1"))
                                                          (("1"
                                                            (split)
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (expand
                                                               "nonempty?")
                                                              (("2"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (expand "nonempty?")
                                (("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand "nonempty?")
                        (("2" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (integrable_singleton formula-decl nil lebesgue_def nil)
    (integrable_add judgement-tcc nil integral measure_integration)
    (integrable nonempty-type-eq-decl nil integral measure_integration)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (union const-decl "set" sets nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (choose_not_member formula-decl nil sets_lemmas nil)
    (+ const-decl "[T -> real]" real_fun_ops reals) nil nil
    (singleton_is_null application-judgement "null_set" lebesgue_def
     nil)
    nil nil (add_as_union formula-decl nil sets_lemmas nil)
    (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (choose_rest formula-decl nil sets_lemmas nil)
    (rest const-decl "set" sets nil) nil
    (card_rest formula-decl nil finite_sets nil)
    (nonempty_card formula-decl nil finite_sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (emptyset const-decl "set" sets nil) nil
    (integrable_zero formula-decl nil integral measure_integration)
    (member const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil) nil
    nil nil nil nil nil nil nil nil nil nil nil nil nil
    (card_is_0 formula-decl nil finite_sets nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def
     measure_integration)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def
     measure_integration)
    (cal_M const-decl "sigma_algebra" lebesgue_def nil)
    (nnreal type-eq-decl nil real_types nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (complete_sigma_finite? const-decl "bool" measure_def
     measure_integration)
    (complete_sigma_finite type-eq-decl nil measure_def
     measure_integration)
    (lambda_ const-decl "complete_sigma_finite[real, cal_M]"
     lebesgue_def nil)
    (integrable? const-decl "bool" integral measure_integration)
    (phi const-decl "nat" measure_space measure_integration))
   shostak))
 (integrable_countable 0
  (integrable_countable-1 nil 3475940817
   ("" (skosimp)
    (("" (lemma "countable_is_null")
      (("" (inst - "C!1")
        (("" (expand "null_set?")
          (("" (flatten)
            (("" (rewrite "isf_is_integrable")
              (("" (rewrite "isf_phi") nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((countable_is_null judgement-tcc nil lebesgue_def nil)
    (null_set? const-decl "bool" measure_theory measure_integration)
    (isf_phi application-judgement "isf" lebesgue_def nil)
    (isf_is_integrable judgement-tcc nil integral measure_integration)
    (isf? const-decl "bool" isf measure_integration)
    (isf nonempty-type-eq-decl nil isf measure_integration)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (phi const-decl "nat" measure_space measure_integration)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def
     measure_integration)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def
     measure_integration)
    (cal_M const-decl "sigma_algebra" lebesgue_def nil)
    (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (complete_sigma_finite? const-decl "bool" measure_def
     measure_integration)
    (complete_sigma_finite type-eq-decl nil measure_def
     measure_integration)
    (lambda_ const-decl "complete_sigma_finite[real, cal_M]"
     lebesgue_def nil)
    (countable_set nonempty-type-eq-decl nil countability sets_aux)
    (is_countable const-decl "bool" countability sets_aux)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (integral_singleton 0
  (integral_singleton-1 nil 3475941153
   ("" (skosimp)
    (("" (lemma "integral_phi_closed" ("a" "x!1" "b" "x!1"))
      (("" (case-replace "closed(x!1, x!1)=singleton[real](x!1)")
        (("1" (assert) nil nil)
         ("2" (apply-extensionality :hide? t)
          (("2" (expand "closed")
            (("2" (hide-all-but 1)
              (("2" (expand "singleton")
                (("2" (expand "closed_ball") (("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((<= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (integral_phi_closed formula-decl nil lebesgue_def nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (metric_induced_topology_is_second_countable name-judgement
     "second_countable" real_topology metric_space)
    (metric_space_is_hausdorff name-judgement "hausdorff" real_topology
     metric_space)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (isf_phi application-judgement "isf" lebesgue_def nil)
    (singleton const-decl "(singleton?)" sets nil)
    (singleton? const-decl "bool" sets nil)
    (closed const-decl "closed_interval" real_topology metric_space)
    (closed_interval nonempty-type-eq-decl nil real_topology
     metric_space)
    (closed_ball const-decl "closed" real_topology metric_space)
    (closed nonempty-type-eq-decl nil topology topology)
    (closed? const-decl "bool" topology topology)
    (metric_induced_topology const-decl "setofsets[T]" metric_space_def
     metric_space)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (nnreal type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (singleton_is_closed application-judgement
     "closed[real, (metric_induced_topology)]" real_topology
     metric_space)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[real]" integral_def analysis)
    (singleton_is_compact application-judgement "compact" real_topology
     metric_space)
    (closed_is_measurable application-judgement "measurable_set"
     lebesgue_def nil))
   shostak))
 (integral_finite 0
  (integral_finite-1 nil 3475945770
   ("" (skosimp)
    (("" (lemma "finite_is_null")
      (("" (inst - "X!1")
        (("" (expand "null_set?")
          (("" (flatten) (("" (rewrite "integral_phi") nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_is_null judgement-tcc nil lebesgue_def nil)
    (null_set? const-decl "bool" measure_theory measure_integration)
    (integral_phi formula-decl nil integral measure_integration)
    (measurable_set? const-decl "bool" measure_space_def
     measure_integration)
    (measurable_set nonempty-type-eq-decl nil measure_space_def
     measure_integration)
    (mu_fin? const-decl "bool" measure_props measure_integration)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def
     measure_integration)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def
     measure_integration)
    (cal_M const-decl "sigma_algebra" lebesgue_def nil)
    (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (complete_sigma_finite? const-decl "bool" measure_def
     measure_integration)
    (complete_sigma_finite type-eq-decl nil measure_def
     measure_integration)
    (lambda_ const-decl "complete_sigma_finite[real, cal_M]"
     lebesgue_def nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (integral_countable 0
  (integral_countable-1 nil 3475945816
   ("" (skosimp)
    (("" (lemma "countable_is_null")
      (("" (inst - "C!1")
        (("" (expand "null_set?")
          (("" (flatten) (("" (rewrite "integral_phi") nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((countable_is_null judgement-tcc nil lebesgue_def nil)
    (null_set? const-decl "bool" measure_theory measure_integration)
    (integral_phi formula-decl nil integral measure_integration)
    (measurable_set? const-decl "bool" measure_space_def
     measure_integration)
    (measurable_set nonempty-type-eq-decl nil measure_space_def
     measure_integration)
    (mu_fin? const-decl "bool" measure_props measure_integration)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def
     measure_integration)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def
     measure_integration)
    (cal_M const-decl "sigma_algebra" lebesgue_def nil)
    (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (complete_sigma_finite? const-decl "bool" measure_def
     measure_integration)
    (complete_sigma_finite type-eq-decl nil measure_def
     measure_integration)
    (lambda_ const-decl "complete_sigma_finite[real, cal_M]"
     lebesgue_def nil)
    (countable_set nonempty-type-eq-decl nil countability sets_aux)
    (is_countable const-decl "bool" countability sets_aux)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (nonempty_bounded_open_interval_prop 0
  (nonempty_bounded_open_interval_prop-1 nil 3475946220
   ("" (skosimp)
    (("" (typepred "b!1")
      (("" (expand "bounded_open_interval?")
        (("" (expand "bounded_interval?")
          (("" (expand "bounded?")
            (("" (flatten)
              (("" (assert)
                (("" (split)
                  (("1" (expand "nonempty?") (("1" (propax) nil nil))
                    nil)
                   ("2" (flatten)
                    (("2" (name "SUP" "sup(b!1)")
                      (("1" (name "INF" "inf(b!1)")
                        (("1" (typepred "inf(b!1)")
                          (("1" (typepred "sup(b!1)")
                            (("1" (replace -3)
                              (("1"
                                (replace -4)
                                (("1"
                                  (hide -3 -4 -5 -6)
                                  (("1"
                                    (expand "least_upper_bound")
                                    (("1"
                                      (expand "greatest_lower_bound")
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (expand "lower_bound")
                                          (("1"
                                            (expand "upper_bound")
                                            (("1"
                                              (case
                                               "FORALL (z: (b!1)): z < SUP")
                                              (("1"
                                                (case
                                                 "FORALL (z: (b!1)): INF<z")
                                                (("1"
                                                  (case "SUP>INF")
                                                  (("1"
                                                    (inst
                                                     +
                                                     "(SUP+INF)/2"
                                                     "(SUP-INF)/2")
                                                    (("1"
                                                      (apply-extensionality
                                                       :hide?
                                                       t)
                                                      (("1"
                                                        (case-replace
                                                         "b!1(x!1)")
                                                        (("1"
                                                          (inst
                                                           -
                                                           "x!1")
                                                          (("1"
                                                            (inst
                                                             -
                                                             "x!1")
                                                            (("1"
                                                              (hide-all-but
                                                               (-1
                                                                -2
                                                                -3
                                                                -4
                                                                1))
                                                              (("1"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (assert)
                                                          (("2"
                                                            (case
                                                             "INF<x!1& x!1<SUP")
                                                            (("1"
                                                              (hide -2)
                                                              (("1"
                                                                (flatten)
                                                                (("1"
                                                                  (inst
                                                                   -7
                                                                   "x!1")
                                                                  (("1"
                                                                    (assert)
                                                                    (("1"
                                                                      (skosimp)
                                                                      (("1"
                                                                        (inst
                                                                         -8
                                                                         "x!1")
                                                                        (("1"
                                                                          (assert)
                                                                          (("1"
                                                                            (skosimp)
                                                                            (("1"
                                                                              (expand
                                                                               "interval?")
                                                                              (("1"
                                                                                (inst
                                                                                 -8
                                                                                 "z!2"
                                                                                 "z!1"
                                                                                 "x!1")
                                                                                (("1"
                                                                                  (assert)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (hide-all-but
                                                               (-1
                                                                -2
                                                                1))
                                                              (("2"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (expand
                                                     "nonempty?")
                                                    (("2"
                                                      (expand "empty?")
                                                      (("2"
                                                        (skosimp)
                                                        (("2"
                                                          (assert)
                                                          (("2"
                                                            (inst
                                                             -
                                                             "x!1")
                                                            (("2"
                                                              (inst
                                                               -
                                                               "x!1")
                                                              (("2"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (hide-all-but
                                                   (1 -4 -7))
                                                  (("2"
                                                    (skosimp)
                                                    (("2"
                                                      (inst-cp - "z!1")
                                                      (("2"
                                                        (expand
                                                         "<="
                                                         -2)
                                                        (("2"
                                                          (split -2)
                                                          (("1"
                                                            (propax)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (expand
                                                             "metric_open?")
                                                            (("2"
                                                              (inst
                                                               -3
                                                               "z!1")
                                                              (("2"
                                                                (assert)
                                                                (("2"
                                                                  (skosimp)
                                                                  (("2"
                                                                    (expand
                                                                     "subset?")
                                                                    (("2"
                                                                      (expand
                                                                       "member")
                                                                      (("2"
                                                                        (expand
                                                                         "ball")
                                                                        (("2"
                                                                          (inst
                                                                           -3
                                                                           "z!1-r!1/2")
                                                                          (("2"
                                                                            (assert)
                                                                            (("2"
                                                                              (expand
                                                                               "abs")
                                                                              (("2"
                                                                                (inst
                                                                                 -
                                                                                 "z!1-r!1/2")
                                                                                (("2"
                                                                                  (assert)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (skosimp)
                                                (("2"
                                                  (typepred "z!1")
                                                  (("2"
                                                    (inst-cp - "z!1")
                                                    (("2"
                                                      (expand "<=" -3)
                                                      (("2"
                                                        (split -3)
                                                        (("1"
                                                          (propax)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (hide
                                                           1
                                                           2
                                                           -5
                                                           -6)
                                                          (("2"
                                                            (expand
                                                             "metric_open?")
                                                            (("2"
                                                              (inst
                                                               -6
                                                               "z!1")
                                                              (("2"
                                                                (assert)
                                                                (("2"
                                                                  (skosimp)
                                                                  (("2"
                                                                    (expand
                                                                     "subset?")
                                                                    (("2"
                                                                      (expand
                                                                       "member")
                                                                      (("2"
                                                                        (expand
                                                                         "ball")
                                                                        (("2"
                                                                          (inst
                                                                           -6
                                                                           "z!1+r!1/2")
                                                                          (("2"
                                                                            (assert)
                                                                            (("2"
                                                                              (rewrite
                                                                               "abs_mult")
                                                                              (("2"
                                                                                (rewrite
                                                                                 "abs_neg")
                                                                                (("2"
                                                                                  (expand
                                                                                   "abs")
                                                                                  (("2"
                                                                                    (inst
                                                                                     -
                                                                                     "r!1/2+z!1")
                                                                                    (("2"
                                                                                      (assert)
                                                                                      nil
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (propax) nil nil))
                        nil)
                       ("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((bounded_open_interval nonempty-type-eq-decl nil real_topology
     metric_space)
    (bounded_open_interval? const-decl "bool" real_topology
     metric_space)
    (set type-eq-decl nil sets nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bounded_interval? const-decl "bool" real_topology metric_space)
    (nonempty? const-decl "bool" sets nil)
    (sup const-decl "{x | least_upper_bound(<=)(x, Su)}" bounded_reals
         reals)
    (above_bounded const-decl "bool" bounded_reals reals)
    (setof type-eq-decl nil defined_types nil)
    (<= const-decl "bool" reals nil)
    (least_upper_bound const-decl "bool" bound_defs reals)
    (pred type-eq-decl nil defined_types nil)
    (sup_set type-eq-decl nil bounded_reals reals)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (lower_bound const-decl "bool" bound_defs reals)
    (< const-decl "bool" reals nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (r!1 skolem-const-decl "posreal" lebesgue_def nil)
    (z!1 skolem-const-decl "(b!1)" lebesgue_def nil)
    (subset? const-decl "bool" sets nil)
    (metric_open? const-decl "bool" metric_space_def metric_space)
    (> const-decl "bool" reals nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (ball const-decl "set[T]" metric_space_def metric_space)
    (ball_is_metric_open application-judgement "metric_open"
     real_topology metric_space)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (interval? const-decl "bool" real_topology metric_space)
    (x!1 skolem-const-decl "real" lebesgue_def nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (INF skolem-const-decl "{x | greatest_lower_bound(<=)(x, b!1)}"
     lebesgue_def nil)
    (SUP skolem-const-decl "{x | least_upper_bound(<=)(x, b!1)}"
     lebesgue_def nil)
    (b!1 skolem-const-decl "bounded_open_interval" lebesgue_def nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (>= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (abs_mult formula-decl nil real_props nil)
    (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}"
     real_defs nil)
    (nzint_abs_is_pos application-judgement "{j: posint | j >= i}"
     real_defs nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (r!1 skolem-const-decl "posreal" lebesgue_def nil)
    (z!1 skolem-const-decl "(b!1)" lebesgue_def nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (upper_bound const-decl "bool" bound_defs reals)
    (inf const-decl "{x | greatest_lower_bound(<=)(x, Sl)}"
         bounded_reals reals)
    (below_bounded const-decl "bool" bounded_reals reals)
    (greatest_lower_bound const-decl "bool" bound_defs reals)
    (inf_set type-eq-decl nil bounded_reals reals)
    (bounded? const-decl "bool" real_topology metric_space))
   shostak))
 (bounded_open_interval_is_measurable 0
  (bounded_open_interval_is_measurable-1 nil 3475937691
   ("" (skolem + "b!1")
    (("" (lemma "nonempty_bounded_open_interval_prop" ("b" "b!1"))
      (("" (typepred "b!1")
        (("" (expand "bounded_open_interval?")
          (("" (expand "bounded_interval?")
            (("" (flatten)
              (("" (expand "bounded?")
                (("" (split)
                  (("1" (rewrite "emptyset_is_empty?")
                    (("1" (replace -1)
                      (("1" (rewrite "measurable_emptyset") nil nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (assert)
                      (("2" (skosimp)
                        (("2" (replace -6)
                          (("2"
                            (lemma "ball_is_cal_M"
                             ("x" "x!1" "r" "r!1"))
                            (("2" (expand "member")
                              (("2"
                                (expand "measurable_set?")
                                (("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((bounded_open_interval nonempty-type-eq-decl nil real_topology
     metric_space)
    (bounded_open_interval? const-decl "bool" real_topology
     metric_space)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nonempty_bounded_open_interval_prop formula-decl nil lebesgue_def
     nil)
    (measurable_emptyset judgement-tcc nil measure_space_def
     measure_integration)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def
     measure_integration)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def
     measure_integration)
    (cal_M const-decl "sigma_algebra" lebesgue_def nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set" sigma_countable
     sigma_set)
    (finite_emptyset name-judgement "finite_set[T]" bounded_nats
     orders)
    (finite_emptyset name-judgement "finite_set" countable_props
     sets_aux)
    (finite_emptyset name-judgement "finite_set" countable_setofsets
     sets_aux)
    (finite_emptyset name-judgement "finite_set[T]" step_fun_props
     analysis)
    (finite_emptyset name-judgement "finite_set[real]" integral_def
     analysis)
    (null_emptyset name-judgement "null_set" lebesgue_def nil)
    (subset_algebra_emptyset name-judgement "(S)" lebesgue_def nil)
    (emptyset_is_compact name-judgement "compact" real_topology
     metric_space)
    (emptyset_is_clopen name-judgement "clopen" real_topology
     metric_space)
    (outer_negligible_emptyset name-judgement "outer_negligible"
     real_lebesgue_scaf nil)
    (subset_algebra_emptyset name-judgement "(S)" real_lebesgue_scaf
     nil)
    (subset_algebra_emptyset name-judgement "(S)" real_borel
     measure_integration)
    (subset_algebra_emptyset name-judgement "(S)" real_lebesgue_scaf
     nil)
    (emptyset_is_empty? formula-decl nil sets_lemmas nil)
    (member const-decl "bool" sets nil)
    (measurable_set? const-decl "bool" measure_space_def
     measure_integration)
    (ball_is_metric_open application-judgement "metric_open"
     real_topology metric_space)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (ball_is_cal_M formula-decl nil lebesgue_def nil)
    (bounded? const-decl "bool" real_topology metric_space)
    (bounded_interval? const-decl "bool" real_topology metric_space)
    (NOT const-decl "[bool -> bool]" booleans nil))
   nil
   (bounded_open_interval_is_measurable subtype "lebesgue_def.x"
    "measurable_set[real, cal_M]")))
 (lebesgue_measurable_intervals_TCC1 0
  (lebesgue_measurable_intervals_TCC1-1 nil 3475937691
   ("" (skosimp*)
    (("" (lemma "measurable_IUnion" ("SS" "I!1"))
      (("" (expand "measurable_set?")
        ((""
          (case "FORALL (n):
        cal_M(IUnion[real](n, I!1))")
          (("1" (inst - "n!1")
            (("1" (assert)
              (("1" (expand "mu_fin?")
                (("1"
                  (lemma "m_monotone"
                   ("a" "IUnion[real](n!1, I!1)" "b" "IUnion(I!1)"))
                  (("1" (expand "x_le")
                    (("1" (assert)
                      (("1" (hide-all-but 1)
                        (("1" (expand "IUnion")
                          (("1" (expand "image")
                            (("1" (expand "Union")
                              (("1"
                                (expand "subset?")
                                (("1"
                                  (expand "member")
                                  (("1"
                                    (skosimp*)
                                    (("1"
                                      (typepred "a!1")
                                      (("1"
                                        (skolem - "i!1")
                                        (("1"
                                          (inst + "i!1")
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand "measurable_set?")
                    (("2" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (hide 2 -1)
            (("2" (induct "n")
              (("1" (rewrite "IUnion_0_def")
                (("1" (assert)
                  (("1" (lemma "bounded_open_interval_is_measurable")
                    (("1" (inst - "I!1(0)")
                      (("1" (expand "measurable_set?")
                        (("1" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skosimp)
                (("2" (rewrite "IUnion_n_def")
                  (("2"
                    (lemma "measurable_union"
                     ("a" "IUnion(j!1, I!1)" "b" "I!1(1 + j!1)"))
                    (("1" (expand "measurable_set?")
                      (("1" (propax) nil nil)) nil)
                     ("2" (expand "measurable_set?")
                      (("2" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cal_M const-decl "sigma_algebra" lebesgue_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def
     measure_integration)
    (sigma_algebra? const-decl "bool" subset_algebra_def
     measure_integration)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (bounded_open_interval nonempty-type-eq-decl nil real_topology
     metric_space)
    (bounded_open_interval? const-decl "bool" real_topology
     metric_space)
    (sequence type-eq-decl nil sequences nil)
    (measurable_set nonempty-type-eq-decl nil measure_space_def
     measure_integration)
    (measurable_set? const-decl "bool" measure_space_def
     measure_integration)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (measurable_IUnion judgement-tcc nil measure_space_def
     measure_integration)
    (IUnion const-decl "set[T]" nat_indexed_sets sets_aux)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (measurable_IUnion application-judgement
     "measurable_set[real, cal_M]" lebesgue_def nil)
    (lambda_ const-decl "complete_sigma_finite[real, cal_M]"
     lebesgue_def nil)
    (complete_sigma_finite type-eq-decl nil measure_def
     measure_integration)
    (complete_sigma_finite? const-decl "bool" measure_def
     measure_integration)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil)
    (IUnion const-decl "set[T]" indexed_sets nil)
    (m_monotone formula-decl nil measure_props measure_integration)
    (Union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (subset? const-decl "bool" sets nil)
    (image const-decl "set[R]" function_image nil)
    (x_le const-decl "bool" extended_nnreal extended_nnreal)
    (mu_fin? const-decl "bool" measure_props measure_integration)
    (pred type-eq-decl nil defined_types nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (bounded_open_interval_is_measurable judgement-tcc nil lebesgue_def
     nil)
    (IUnion_0_def formula-decl nil nat_indexed_sets sets_aux)
    (IUnion_n_def formula-decl nil nat_indexed_sets sets_aux)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (measurable_union judgement-tcc nil measure_space_def
     measure_integration)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (lebesgue_measurable_intervals subtype
    "nat_indexed_sets[real].IUnion(lebesgue_def.n, lebesgue_def.I)"
    "{m: (lebesgue_def.cal_M) | measure_props[real, lebesgue_def.cal_M, lebesgue_def.lambda_].mu_fin?(m)}")))
 (lebesgue_measurable_intervals_TCC2 0
  (lebesgue_measurable_intervals_TCC2-1 nil 3475937691
   ("" (skosimp)
    (("" (lemma "measurable_IUnion" ("SS" "I!1"))
      (("" (expand "measurable_set?") (("" (propax) nil nil)) nil))
      nil))
    nil)
   ((cal_M const-decl "sigma_algebra" lebesgue_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def
     measure_integration)
    (sigma_algebra? const-decl "bool" subset_algebra_def
     measure_integration)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (bounded_open_interval nonempty-type-eq-decl nil real_topology
     metric_space)
    (bounded_open_interval? const-decl "bool" real_topology
     metric_space)
    (sequence type-eq-decl nil sequences nil)
    (measurable_set nonempty-type-eq-decl nil measure_space_def
     measure_integration)
    (measurable_set? const-decl "bool" measure_space_def
     measure_integration)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (measurable_IUnion judgement-tcc nil measure_space_def
     measure_integration))
   nil
   (lebesgue_measurable_intervals subtype
    "indexed_sets[nat, real].IUnion(lebesgue_def.I)"
    "{m: (lebesgue_def.cal_M) | measure_props[real, lebesgue_def.cal_M, lebesgue_def.lambda_].mu_fin?(m)}")))
 (lebesgue_measurable_intervals_TCC3 0
  (lebesgue_measurable_intervals_TCC3-1 nil 3475937691
   ("" (skosimp)
    (("" (typepred "E!1")
      (("" (expand "measurable_set?") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((mu_fin? const-decl "bool" measure_props measure_integration)
    (lambda_ const-decl "complete_sigma_finite[real, cal_M]"
     lebesgue_def nil)
    (complete_sigma_finite type-eq-decl nil measure_def
     measure_integration)
    (complete_sigma_finite? const-decl "bool" measure_def
     measure_integration)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (measurable_set nonempty-type-eq-decl nil measure_space_def
     measure_integration)
    (measurable_set? const-decl "bool" measure_space_def
     measure_integration)
    (cal_M const-decl "sigma_algebra" lebesgue_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def
     measure_integration)
    (sigma_algebra? const-decl "bool" subset_algebra_def
     measure_integration)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (set type-eq-decl nil sets nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (measurable_IUnion application-judgement
     "measurable_set[real, cal_M]" lebesgue_def nil))
   nil
   (lebesgue_measurable_intervals subtype "lebesgue_def.E"
    "{m: (lebesgue_def.cal_M) | measure_props[real, lebesgue_def.cal_M, lebesgue_def.lambda_].mu_fin?(m)}")))
 (lebesgue_measurable_intervals 0
  (lebesgue_measurable_intervals-1 nil 3475946203
   ("" (skosimp)
    (("" (typepred "E!1")
      (("" (expand "mu_fin?")
        (("" (expand "mu")
          (("" (name "MU_E" "lambda_(E!1)")
            (("" (replace -1)
              (("" (expand "lambda_" -1)
                (("" (expand "lebesgue_measure" -1)
                  (("" (expand "induced_measure" -1)
                    (("" (expand "restrict")
                      (("" (expand "lebesgue_outer_measure")
                        (("" (expand "x_inf")
                          (("" (lift-if -1)
                            (("" (assert)
                              ((""
                                (prop)
                                ((""
                                  (skosimp)
                                  ((""
                                    (case
                                     "nonempty?({z_1: real |
              EXISTS (x:extended_nnreal):
                (EXISTS I:
                   x_le(x_sum(x_length o I), x) AND
                    subset?[real](E!1, IUnion(I)))
                 AND x`1 AND x`2 = z_1})")
                                    (("1"
                                      (case
                                       "bounded_below?({z_1: real |
              EXISTS (x:extended_nnreal):
                (EXISTS I:
                   x_le(x_sum(x_length o I), x) AND
                    subset?[real](E!1, IUnion(I)))
                 AND x`1 AND x`2 = z_1})")
                                      (("1"
                                        (typepred
                                         "glb({z_1: real |
              EXISTS (x:extended_nnreal):
                (EXISTS I:
                   x_le(x_sum(x_length o I), x) AND
                    subset?[real](E!1, IUnion(I)))
                 AND x`1 AND x`2 = z_1})")
                                        (("1"
                                          (name-replace
                                           "GLB"
                                           "glb({z_1: real |
              EXISTS (x:extended_nnreal):
                (EXISTS I:
                   x_le(x_sum(x_length o I), x) AND
                    subset?[real](E!1, IUnion(I)))
                 AND x`1 AND x`2 = z_1})")
                                          (("1"
                                            (hide -2 -3)
                                            (("1"
                                              (replace -3 * rl)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (hide -3 -2 -5)
                                                  (("1"
                                                    (expand
                                                     "greatest_lower_bound?")
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (expand
                                                         "lower_bound?")
                                                        (("1"
                                                          (inst
                                                           -2
                                                           "GLB+r!1/2")
                                                          (("1"
                                                            (assert)
                                                            (("1"
                                                              (skosimp)
                                                              (("1"
                                                                (typepred
                                                                 "s!1")
                                                                (("1"
                                                                  (skosimp)
                                                                  (("1"
                                                                    (skosimp)
                                                                    (("1"
                                                                      (case
                                                                       "x!2`2<r!1 / 2 + GLB")
                                                                      (("1"
                                                                        (hide
                                                                         -5
                                                                         1)
                                                                        (("1"
                                                                          (inst
                                                                           +
                                                                           "I!1")
                                                                          (("1"
                                                                            (assert)
                                                                            (("1"
                                                                              (case
                                                                               "x_le(lambda_(IUnion(I!1)), x_sum(lambda_ o I!1))")
                                                                              (("1"
                                                                                (lemma
                                                                                 "x_sum_le"
                                                                                 ("S"
                                                                                  "lambda_ o I!1"
                                                                                  "T"
                                                                                  "x_length o I!1"))
                                                                                (("1"
                                                                                  (split
                                                                                   -1)
                                                                                  (("1"
                                                                                    (expand
                                                                                     "x_le"
                                                                                     (-1
                                                                                      -2
                                                                                      -4))
                                                                                    (("1"
                                                                                      (flatten)
                                                                                      (("1"
                                                                                        (assert)
                                                                                        (("1"
                                                                                          (flatten)
                                                                                          (("1"
                                                                                            (assert)
                                                                                            (("1"
                                                                                              (flatten)
                                                                                              (("1"
                                                                                                (assert)
                                                                                                (("1"
                                                                                                  (lemma
                                                                                                   "increasing_IUnion"
                                                                                                   ("A"
                                                                                                    "I!1"))
                                                                                                  (("1"
                                                                                                    (skosimp)
                                                                                                    (("1"
                                                                                                      (case
                                                                                                       "forall n: IUnion(n, I!1)=B!1(n)")
                                                                                                      (("1"
                                                                                                        (case
                                                                                                         "forall n: measurable_set?(B!1(n))")
                                                                                                        (("1"
                                                                                                          (replace
                                                                                                           -6
                                                                                                           1)
                                                                                                          (("1"
                                                                                                            (case-replace
                                                                                                             "(LAMBDA n: lambda_(IUnion(n, I!1))`2)=LAMBDA n: lambda_(B!1(n))`2")
                                                                                                            (("1"
                                                                                                              (hide
                                                                                                               -1)
                                                                                                              (("1"
                                                                                                                (lemma
                                                                                                                 "m_increasing_convergence"
                                                                                                                 ("E"
                                                                                                                  "B!1"))
                                                                                                                (("1"
                                                                                                                  (assert)
                                                                                                                  (("1"
                                                                                                                    (expand
                                                                                                                     "x_converges?")
                                                                                                                    (("1"
                                                                                                                      (prop)
                                                                                                                      (("1"
                                                                                                                        (name-replace
                                                                                                                         "LIMIT"
                                                                                                                         "lambda_(IUnion(B!1))`2")
                                                                                                                        (("1"
                                                                                                                          (expand
                                                                                                                           "o ")
                                                                                                                          (("1"
                                                                                                                            (name-replace
                                                                                                                             "FF"
                                                                                                                             "(LAMBDA (i:nat): lambda_(B!1(i))`2)")
                                                                                                                            (("1"
                                                                                                                              (lemma
                                                                                                                               "convergence_sequences.limit_lemma"
                                                                                                                               ("v"
                                                                                                                                "FF"))
                                                                                                                              (("1"
                                                                                                                                (replace
                                                                                                                                 -4
                                                                                                                                 -1
                                                                                                                                 rl)
                                                                                                                                (("1"
                                                                                                                                  (hide-all-but
                                                                                                                                   (-1
                                                                                                                                    1))
                                                                                                                                  (("1"
                                                                                                                                    (expand
                                                                                                                                     "convergence")
                                                                                                                                    (("1"
                                                                                                                                      (rewrite
                                                                                                                                       "metric_convergence_def")
                                                                                                                                      (("1"
                                                                                                                                        (expand
                                                                                                                                         "metric_converges_to")
                                                                                                                                        (("1"
                                                                                                                                          (skosimp)
                                                                                                                                          (("1"
                                                                                                                                            (inst
                                                                                                                                             -
                                                                                                                                             "r!2")
                                                                                                                                            (("1"
                                                                                                                                              (skosimp)
                                                                                                                                              (("1"
                                                                                                                                                (inst
                                                                                                                                                 +
                                                                                                                                                 "n!1")
                                                                                                                                                (("1"
                                                                                                                                                  (skosimp)
                                                                                                                                                  (("1"
                                                                                                                                                    (inst
                                                                                                                                                     -
                                                                                                                                                     "i!1")
                                                                                                                                                    (("1"
                                                                                                                                                      (assert)
                                                                                                                                                      (("1"
                                                                                                                                                        (expand
                                                                                                                                                         "ball")
                                                                                                                                                        (("1"
                                                                                                                                                          (grind)
                                                                                                                                                          nil
                                                                                                                                                          nil))
                                                                                                                                                        nil))
                                                                                                                                                      nil))
                                                                                                                                                    nil))
                                                                                                                                                  nil))
                                                                                                                                                nil))
                                                                                                                                              nil))
                                                                                                                                            nil))
                                                                                                                                          nil))
                                                                                                                                        nil))
                                                                                                                                      nil))
                                                                                                                                    nil))
                                                                                                                                  nil))
                                                                                                                                nil))
                                                                                                                              nil)
                                                                                                                             ("2"
                                                                                                                              (expand
                                                                                                                               "measurable_set?")
                                                                                                                              (("2"
                                                                                                                                (propax)
                                                                                                                                nil
                                                                                                                                nil))
                                                                                                                              nil))
                                                                                                                            nil))
                                                                                                                          nil))
                                                                                                                        nil))
                                                                                                                      nil))
                                                                                                                    nil))
                                                                                                                  nil)
                                                                                                                 ("2"
                                                                                                                  (propax)
                                                                                                                  nil
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil)
                                                                                                             ("2"
                                                                                                              (hide
                                                                                                               2)
                                                                                                              (("2"
                                                                                                                (apply-extensionality
                                                                                                                 :hide?
                                                                                                                 t)
                                                                                                                (("1"
                                                                                                                  (inst
                                                                                                                   -2
                                                                                                                   "x!3")
                                                                                                                  (("1"
                                                                                                                    (replace
                                                                                                                     -2)
                                                                                                                    (("1"
                                                                                                                      (propax)
                                                                                                                      nil
                                                                                                                      nil))
                                                                                                                    nil))
                                                                                                                  nil)
                                                                                                                 ("2"
                                                                                                                  (expand
                                                                                                                   "measurable_set?")
                                                                                                                  (("2"
                                                                                                                    (propax)
                                                                                                                    nil
                                                                                                                    nil))
                                                                                                                  nil)
                                                                                                                 ("3"
                                                                                                                  (skosimp)
                                                                                                                  (("3"
                                                                                                                    (inst
                                                                                                                     -
                                                                                                                     "n!1")
                                                                                                                    (("3"
                                                                                                                      (inst
                                                                                                                       -
                                                                                                                       "n!1")
                                                                                                                      (("3"
                                                                                                                        (expand
                                                                                                                         "measurable_set?")
                                                                                                                        (("3"
                                                                                                                          (assert)
                                                                                                                          nil
                                                                                                                          nil))
                                                                                                                        nil))
                                                                                                                      nil))
                                                                                                                    nil))
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil)
                                                                                                             ("3"
                                                                                                              (expand
                                                                                                               "measurable_set?")
                                                                                                              (("3"
                                                                                                                (propax)
                                                                                                                nil
                                                                                                                nil))
                                                                                                              nil)
                                                                                                             ("4"
                                                                                                              (expand
                                                                                                               "measurable_set?")
                                                                                                              (("4"
                                                                                                                (skosimp)
                                                                                                                (("4"
                                                                                                                  (inst
                                                                                                                   -
                                                                                                                   "n!1")
                                                                                                                  (("4"
                                                                                                                    (inst
                                                                                                                     -
                                                                                                                     "n!1")
                                                                                                                    (("4"
                                                                                                                      (assert)
                                                                                                                      nil
                                                                                                                      nil))
                                                                                                                    nil))
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil)
                                                                                                         ("2"
                                                                                                          (hide-all-but
                                                                                                           (-3
                                                                                                            -4
                                                                                                            1))
                                                                                                          (("2"
                                                                                                            (induct
                                                                                                             "n")
                                                                                                            (("1"
                                                                                                              (typepred
                                                                                                               "I!1(0)")
                                                                                                              (("1"
                                                                                                                (lemma
                                                                                                                 "bounded_open_interval_is_measurable")
                                                                                                                (("1"
                                                                                                                  (inst
                                                                                                                   -
                                                                                                                   "I!1(0)")
                                                                                                                  (("1"
                                                                                                                    (assert)
                                                                                                                    nil
                                                                                                                    nil))
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil)
                                                                                                             ("2"
                                                                                                              (skosimp)
                                                                                                              (("2"
                                                                                                                (inst
                                                                                                                 -
                                                                                                                 "j!1")
                                                                                                                (("2"
                                                                                                                  (replace
                                                                                                                   -3)
                                                                                                                  (("2"
                                                                                                                    (rewrite
                                                                                                                     "measurable_union")
                                                                                                                    nil
                                                                                                                    nil))
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil)
                                                                                                       ("2"
                                                                                                        (hide-all-but
                                                                                                         (-2
                                                                                                          -3
                                                                                                          1))
                                                                                                        (("2"
                                                                                                          (induct
                                                                                                           "n")
                                                                                                          (("1"
                                                                                                            (rewrite
                                                                                                             "IUnion_0_def")
                                                                                                            (("1"
                                                                                                              (assert)
                                                                                                              nil
                                                                                                              nil))
                                                                                                            nil)
                                                                                                           ("2"
                                                                                                            (skosimp)
                                                                                                            (("2"
                                                                                                              (rewrite
                                                                                                               "IUnion_n_def")
                                                                                                              (("2"
                                                                                                                (inst
                                                                                                                 -
                                                                                                                 "j!1")
                                                                                                                (("2"
                                                                                                                  (replace
                                                                                                                   -3)
                                                                                                                  (("2"
                                                                                                                    (replace
                                                                                                                     -1)
                                                                                                                    (("2"
                                                                                                                      (assert)
                                                                                                                      nil
                                                                                                                      nil))
                                                                                                                    nil))
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil)
                                                                                   ("2"
                                                                                    (hide-all-but
                                                                                     (-1
                                                                                      -2
                                                                                      -3
                                                                                      -5
                                                                                      1))
                                                                                    (("2"
                                                                                      (skosimp)
                                                                                      (("2"
                                                                                        (expand
                                                                                         "o ")
                                                                                        (("2"
                                                                                          (expand
                                                                                           "lambda_")
                                                                                          (("2"
                                                                                            (expand
                                                                                             "lebesgue_measure")
                                                                                            (("2"
                                                                                              (expand
                                                                                               "induced_measure")
                                                                                              (("2"
                                                                                                (expand
                                                                                                 "restrict")
                                                                                                (("2"
                                                                                                  (lemma
                                                                                                   "lebesgue_outer_measure_le_length"
                                                                                                   ("b"
                                                                                                    "I!1(i!1)"))
                                                                                                  (("1"
                                                                                                    (propax)
                                                                                                    nil
                                                                                                    nil)
                                                                                                   ("2"
                                                                                                    (typepred
                                                                                                     "I!1(i!1)")
                                                                                                    (("2"
                                                                                                      (expand
                                                                                                       "bounded_open_interval?")
                                                                                                      (("2"
                                                                                                        (flatten)
                                                                                                        nil
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil)
                                                                               ("2"
                                                                                (hide
                                                                                 2)
                                                                                (("2"
                                                                                  (expand
                                                                                   "lambda_")
                                                                                  (("2"
                                                                                    (expand
                                                                                     "lebesgue_measure")
                                                                                    (("2"
                                                                                      (expand
                                                                                       "induced_measure")
                                                                                      (("2"
                                                                                        (expand
                                                                                         "restrict")
                                                                                        (("2"
                                                                                          (expand
                                                                                           "o ")
                                                                                          (("2"
                                                                                            (typepred
                                                                                             "lebesgue_outer_measure")
                                                                                            (("2"
                                                                                              (expand
                                                                                               "outer_measure?")
                                                                                              (("2"
                                                                                                (flatten)
                                                                                                (("2"
                                                                                                  (expand
                                                                                                   "om_countably_subadditive?")
                                                                                                  (("2"
                                                                                                    (inst
                                                                                                     -3
                                                                                                     "I!1")
                                                                                                    (("2"
                                                                                                      (expand
                                                                                                       "o ")
                                                                                                      (("2"
                                                                                                        (propax)
                                                                                                        nil
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil)
                                                                               ("3"
                                                                                (skosimp)
                                                                                (("3"
                                                                                  (typepred
                                                                                   "I!1(x1!1)")
                                                                                  (("3"
                                                                                    (lemma
                                                                                     "bounded_open_interval_is_measurable"
                                                                                     ("x"
                                                                                      "I!1(x1!1)"))
                                                                                    (("3"
                                                                                      (expand
                                                                                       "measurable_set?")
                                                                                      (("3"
                                                                                        (propax)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil)
                                                                               ("4"
                                                                                (lemma
                                                                                 "measurable_IUnion"
                                                                                 ("SS"
                                                                                  "I!1"))
                                                                                (("4"
                                                                                  (expand
                                                                                   "measurable_set?")
                                                                                  (("4"
                                                                                    (propax)
                                                                                    nil
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (assert)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (assert) nil nil))
                                        nil)
                                       ("2"
                                        (hide-all-but (-2 1))
                                        (("2"
                                          (expand "bounded_below?")
                                          (("2"
                                            (inst + "0")
                                            (("2"
                                              (expand "lower_bound?")
                                              (("2"
                                                (skosimp)
                                                (("2"
                                                  (typepred "s!1")
                                                  (("2"
                                                    (skosimp)
                                                    (("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("3" (propax) nil nil))
                                      nil)
                                     ("2"
                                      (hide 2)
                                      (("2"
                                        (expand "nonempty?")
                                        (("2"
                                          (expand "empty?")
                                          (("2"
                                            (expand "member")
                                            (("2"
                                              (inst - "x!1`2")
                                              (("2"
                                                (inst + "x!1")
                                                (("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("3"
                                      (skosimp)
                                      (("3"
                                        (skosimp)
                                        (("3"
                                          (typepred "I!1(x1!1)")
                                          (("3"
                                            (expand
                                             "bounded_open_interval?")
                                            (("3"
                                              (expand
                                               "bounded_interval?")
                                              (("3" (flatten) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((mu_fin? const-decl "bool" measure_props measure_integration)
    (lambda_ const-decl "complete_sigma_finite[real, cal_M]"
     lebesgue_def nil)
    (complete_sigma_finite type-eq-decl nil measure_def
     measure_integration)
    (complete_sigma_finite? const-decl "bool" measure_def
     measure_integration)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (measurable_set nonempty-type-eq-decl nil measure_space_def
     measure_integration)
    (measurable_set? const-decl "bool" measure_space_def
     measure_integration)
    (cal_M const-decl "sigma_algebra" lebesgue_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def
     measure_integration)
    (sigma_algebra? const-decl "bool" subset_algebra_def
     measure_integration)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (set type-eq-decl nil sets nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (mu const-decl "nnreal" measure_props measure_integration)
    (lebesgue_measure const-decl
     "complete_sigma_finite[real, lebesgue_measurable]"
     real_lebesgue_scaf nil)
    (restrict const-decl "R" restrict nil) nil
    (empty? const-decl "bool" sets nil)
    (bounded_below? const-decl "bool" bounded_real_defs nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (increasing_IUnion formula-decl nil nat_indexed_sets sets_aux)
    (IUnion const-decl "set[T]" nat_indexed_sets sets_aux)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (measurable_union judgement-tcc nil measure_space_def
     measure_integration)
    (bounded_open_interval_is_measurable judgement-tcc nil lebesgue_def
     nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil) nil nil
    (limit_lemma formula-decl nil convergence_sequences analysis)
    (convergent? const-decl "bool" convergence_sequences analysis)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (metric_convergence_def formula-decl nil metric_space metric_space)
    nil
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (member const-decl "bool" sets nil)
    (ball const-decl "set[T]" metric_space_def metric_space)
    (metric_converges_to const-decl "bool" metric_space_def
     metric_space)
    (convergence const-decl "bool" convergence_sequences analysis)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (x_converges? const-decl "bool" extended_nnreal extended_nnreal)
    (m_increasing_convergence formula-decl nil measure_props
     measure_integration)
    (IUnion_0_def formula-decl nil nat_indexed_sets sets_aux)
    (IUnion_n_def formula-decl nil nat_indexed_sets sets_aux)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lebesgue_outer_measure_le_length formula-decl nil
     real_lebesgue_scaf nil)
    (bounded_interval? const-decl "bool" real_topology metric_space)
    (bounded_interval nonempty-type-eq-decl nil real_topology
     metric_space)
    (x_sum_le formula-decl nil extended_nnreal extended_nnreal)
    (om_countably_subadditive? const-decl "bool" outer_measure_def
     measure_integration)
    (outer_measure nonempty-type-eq-decl nil outer_measure_def
     measure_integration)
    (outer_measure? const-decl "bool" outer_measure_def
     measure_integration)
    (measurable_IUnion judgement-tcc nil measure_space_def
     measure_integration)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    nil
    (posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    nil
    (glb const-decl "{x | greatest_lower_bound?(x, SB)}"
     bounded_real_defs nil)
    nil (nonempty? const-decl "bool" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (bounded_open_interval? const-decl "bool" real_topology
     metric_space)
    (bounded_open_interval nonempty-type-eq-decl nil real_topology
     metric_space)
    (sequence type-eq-decl nil sequences nil)
    (x_le const-decl "bool" extended_nnreal extended_nnreal) nil
    (interval? const-decl "bool" real_topology metric_space)
    (interval nonempty-type-eq-decl nil real_topology metric_space)
    (O const-decl "T3" function_props nil)
    (x_length const-decl "extended_nnreal" real_lebesgue_scaf nil)
    (subset? const-decl "bool" sets nil)
    (IUnion const-decl "set[T]" indexed_sets nil)
    (lebesgue_outer_measure const-decl "outer_measure"
     real_lebesgue_scaf nil)
    (induced_measure const-decl "complete_measure" outer_measure_props
     measure_integration)
    (= const-decl "[T, T -> boolean]" equalities nil))
   shostak)))

