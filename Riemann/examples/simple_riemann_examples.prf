(simple_riemann_examples
 (expcos_cont_fun 0
  (expcos_cont_fun-1 nil 3662298441
   ("" (expand "expcos")
    (("" (cont-mult)
      (("" (assert)
        (("" (split)
          (("1" (lemma-conts-step exp_continuous) nil nil)
           ("2" (lemma-conts-step cos_cont_fun) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((cos_cont_fun formula-decl nil sincos "trig/")
    (exp_continuous formula-decl nil ln_exp "lnexp_fnd/")
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (continuous? const-decl "bool" continuous_functions "analysis/")
    (cos const-decl "real" sincos_def "trig/")
    (exp const-decl "{py | x = ln(py)}" ln_exp "lnexp_fnd/")
    (ln const-decl "real" ln_exp "lnexp_fnd/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (prod_cont_fun formula-decl nil continuous_functions "analysis/")
    (expcos const-decl "[real -> real]" simple_riemann_examples
     nil))
   shostak))
 (ExpCos_inclusion 0
  (ExpCos_inclusion-1 nil 3662681937
   ("" (skosimp*)
    (("" (expand "ExpCos" 1)
      (("" (expand "expcos" 1)
        (("" (expand "*" 1)
          (("" (lemma "Mult_inclusion")
            (("" (inst? -1)
              (("" (lemma "Exp_inclusion")
                (("" (inst? -1)
                  (("" (lemma "Cos_inclusion")
                    (("" (inst? -1) (("" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ExpCos const-decl "Interval" simple_riemann_examples nil)
    (* const-decl "[T -> real]" real_fun_ops "reals/")
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Pos? const-decl "bool" interval "interval_arith/")
    (Exp const-decl "(Pos?)" interval_lnexp "interval_arith/")
    (Cos const-decl "Interval" interval_trig "interval_arith/")
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ln const-decl "real" ln_exp "lnexp_fnd/")
    (exp const-decl "{py | x = ln(py)}" ln_exp "lnexp_fnd/")
    (cos const-decl "real" sincos_def "trig/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (cos_range application-judgement "real_abs_le1" sincos "trig/")
    (Exp_Fundamental application-judgement "(Fundamental?(PreTrue))"
     interval_expr_lnexp "interval_arith/")
    (Exp_Inclusion application-judgement
     "(Inclusion?(PreTrue, exp_safe))" interval_expr_lnexp
     "interval_arith/")
    (Cos_Fundamental application-judgement "(Fundamental?(PreTrue))"
     interval_expr_trig "interval_arith/")
    (Cos_Inclusion application-judgement "(Inclusion?(PreTrue, cos))"
     interval_expr_trig "interval_arith/")
    (Cos_inclusion formula-decl nil interval_trig "interval_arith/")
    (Exp_inclusion formula-decl nil interval_lnexp "interval_arith/")
    (Mult_inclusion formula-decl nil interval "interval_arith/")
    (expcos const-decl "[real -> real]" simple_riemann_examples
     nil))
   shostak))
 (ExpCos_bounds 0
  (ExpCos_bounds-1 nil 3666563961
   ("" (skosimp*)
    (("" (expand "expcos")
      (("" (expand "*") (("" (interval) nil nil)) nil)) nil))
    nil)
   ((expcos const-decl "[real -> real]" simple_riemann_examples nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (realorder? const-decl "bool" real_orders "reals/")
    (RealOrder type-eq-decl nil real_orders "reals/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (brel? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (BREL adt-constructor-decl
     "[[RealOrder, RealExpr, RealExpr] -> (brel?)]" IntervalExpr_adt
     "interval_arith/")
    (MULT adt-constructor-decl "[[RealExpr, RealExpr] -> (mult?)]"
     IntervalExpr_adt "interval_arith/")
    (FUN adt-constructor-decl
     "[[pre: (Precondition?), opf: [real -> real],
  {F: [Interval -> Interval] |
           Inclusion?(pre, opf)(F) AND Fundamental?(pre)(F)},
  RealExpr] ->
   (fun?)]" IntervalExpr_adt "interval_arith/")
    (X const-decl "RealExpr" interval_expr "interval_arith/")
    (r2E const-decl "RealExpr" interval_expr "interval_arith/")
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Cos_Inclusion application-judgement "(Inclusion?(PreTrue, cos))"
     interval_expr_trig "interval_arith/")
    (Cos_Fundamental application-judgement "(Fundamental?(PreTrue))"
     interval_expr_trig "interval_arith/")
    (Exp_Inclusion application-judgement
     "(Inclusion?(PreTrue, exp_safe))" interval_expr_lnexp
     "interval_arith/")
    (Exp_Fundamental application-judgement "(Fundamental?(PreTrue))"
     interval_expr_lnexp "interval_arith/")
    (Cos const-decl "Interval" interval_trig "interval_arith/")
    (cos const-decl "real" sincos_def "trig/")
    (Fundamental? const-decl "bool" interval "interval_arith/")
    (Exp const-decl "(Pos?)" interval_lnexp "interval_arith/")
    (Pos? const-decl "bool" interval "interval_arith/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (exp_safe const-decl "posreal" interval_expr_lnexp
     "interval_arith/")
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (PreTrue const-decl "(Precondition?)" interval_expr
     "interval_arith/")
    (Precondition? const-decl "bool" interval "interval_arith/")
    (Inclusion? const-decl "bool" interval "interval_arith/")
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (real nonempty-type-from-decl nil reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (interval_soundness formula-decl nil interval_bandb
     "interval_arith/")
    (sound? const-decl "bool" interval_bandb "interval_arith/")
    (Env type-eq-decl nil box "interval_arith/")
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (list2array def-decl "T" array2list "structures/")
    (beval def-decl "bool" interval_bexpr "interval_arith/")
    (eval def-decl "real" interval_expr "interval_arith/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    nil (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (vars_in_box formula-decl nil box "interval_arith/")
    (length_singleton formula-decl nil more_list_props "structures/")
    (vars_in_box_rec def-decl
     "{b: bool | b = (FORALL (k: subrange(i, n - 1)): vs(k) ## nth(box, k - i))}"
     box "interval_arith/")
    (FALSE const-decl "bool" booleans nil)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (alt_max const-decl "DirVar" gbandb_boolexpr "interval_arith/")
    (interval const-decl "Output" interval_bandb "interval_arith/")
    (Output type-eq-decl nil branch_and_bound "structures/")
    (DirVarSelector type-eq-decl nil branch_and_bound "structures/")
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (length def-decl "nat" list_props nil)
    (stack type-eq-decl nil stack "structures/")
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (ProperBox type-eq-decl nil box "interval_arith/")
    (ProperBox? const-decl "bool" box "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (IntervalOutput type-eq-decl nil gbandb_boolexpr "interval_arith/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (BoolExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (bletin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bite? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bimplies? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bor? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (band? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bnot? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bconst? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (list type-decl nil list_adt nil)
    (Maybe type-decl nil Maybe "structures/")
    (listn_0 name-judgement "listn[real](0)" simple_bandb
     "interval_arith/")
    (listn_0 name-judgement "listn[Interval](0)"
     Riemann_integ_interval_approx nil))
   shostak))
 (expcos_test1_TCC1 0
  (expcos_test1_TCC1-1 nil 3662426340
   ("" (lemma "fundamental_indef[real]")
    (("1"
      (invoke (inst -1 "%1" "%2" "%3")
       (? 1 "integrable?[real](%1,%2,%3 )"))
      (("1" (lemma expcos_cont_fun)
        (("1" (assert)
          (("1" (ground)
            (("1" (expand "Integrable?") (("1" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (lemma expcos_cont_fun)
      (("2" (assert)
        (("2" (expand 'connected? '1) (("2" (propax) nil nil)) nil))
        nil))
      nil))
    nil)
   ((expcos const-decl "[real -> real]" simple_riemann_examples nil)
    (expcos_cont_fun formula-decl nil simple_riemann_examples nil)
    (Integrable? const-decl "bool" integral_def "analysis/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil))
   nil))
 (expcos_test1 0
  (expcos_test1-1 nil 3662426340
   ("" (lemma "Simple_Riemann_Soundness")
    (("" (inst -1 "[|0, 1|]" "expcos" "12" "2")
      (("1" (assert)
        (("1" (inst -1 "ExpCos")
          (("1" (eval-step) nil nil)
           ("2" (inclus-fun ExpCos_inclusion) nil nil))
          nil))
        nil)
       ("2" (soundness1 ExpCos_inclusion expcos_cont_fun) nil nil)
       ("3" (expand "StrictInterval?") (("3" (ground) nil nil)) nil))
      nil))
    nil)
   (([\|\|] const-decl "Interval" interval "interval_arith/")
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (real nonempty-type-from-decl nil reals nil)
    (expcos const-decl "[real -> real]" simple_riemann_examples nil)
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (ExpCos const-decl "Interval" simple_riemann_examples nil)
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (partition type-eq-decl nil integral_def "analysis/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (below type-eq-decl nil nat_types nil)
    (above nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx nil)
    (subrange type-eq-decl nil integers nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (R const-decl "Interval" Riemann_integ_interval_approx nil)
    (RiemannSum_R2I def-decl "Interval" Riemann_integ_interval_approx
     nil)
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx nil)
    (subrange type-eq-decl nil subrange_type nil)
    (<< const-decl "bool" interval "interval_arith/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (integral? const-decl "bool" integral_def "analysis/")
    (integral const-decl "{S: real | integral?(a, b, ff, S)}"
     integral_def "analysis/")
    (Incl_Member formula-decl nil interval "interval_arith/")
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (ExpCos_inclusion formula-decl nil simple_riemann_examples nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ub_interval formula-decl nil interval "interval_arith/")
    (lb_interval formula-decl nil interval "interval_arith/")
    (posint_exp application-judgement "posint" exponentiation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (Integrable? const-decl "bool" integral_def "analysis/")
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (expcos_cont_fun formula-decl nil simple_riemann_examples nil)
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx nil))
   shostak))
 (atan_deriv_fun_TCC1 0
  (atan_deriv_fun_TCC1-1 nil 3664732700
   ("" (skolem! 1 "x!1")
    (("" (typepred "x!1")
      (("" (case "x!1=0")
        (("1" (ground) nil nil)
         ("2" (case "x!1>0")
          (("1" (hide 1)
            (("1" (case "1+x!1*x!1 > 0")
              (("1" (ground) (("1" (assert) nil nil)) nil)
               ("2" (field 1) nil nil))
              nil))
            nil)
           ("2" (case "x!1 < 0 ")
            (("1" (case "1+x!1*x!1 > 0")
              (("1" (assert) (("1" (ground) nil nil)) nil)
               ("2" (field 1) nil nil))
              nil)
             ("2" (assert) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (TRUE const-decl "bool" booleans nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (< const-decl "bool" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   nil))
 (atan_deriv_fun_bounds 0
  (atan_deriv_fun_bounds-1 nil 3664785806
   ("" (skosimp*)
    (("" (case "x!1 = 0")
      (("1" (ground)
        (("1" (rewrite -1)
          (("1" (expand "atan_deriv_fun") (("1" (ground) nil nil))
            nil))
          nil)
         ("2" (grind) nil nil))
        nil)
       ("2" (case "x!1<0")
        (("1" (expand "atan_deriv_fun")
          (("1" (grind) (("1" (field) nil nil) ("2" (field) nil nil))
            nil))
          nil)
         ("2" (case "x!1>0")
          (("1" (grind) (("1" (field) nil nil) ("2" (field) nil nil))
            nil)
           ("2" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (atan_deriv_fun const-decl "real" simple_riemann_examples nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (> const-decl "bool" reals nil)
    (div_mult_pos_lt2 formula-decl nil real_props nil)
    (div_mult_pos_le1 formula-decl nil real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (< const-decl "bool" reals nil))
   shostak))
 (atan_deriv_strict_decreasing 0
  (atan_deriv_strict_decreasing-1 nil 3664762523
   ("" (skosimp*)
    (("" (expand "atan_deriv_fun") (("" (field) nil nil)) nil)) nil)
   ((atan_deriv_fun const-decl "real" simple_riemann_examples nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (/= const-decl "boolean" notequal nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (TRUE const-decl "bool" booleans nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (>= const-decl "bool" reals nil)
    (FDX_18 skolem-const-decl "real" simple_riemann_examples nil)
    (FDX_19 skolem-const-decl "real" simple_riemann_examples nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props
     nil)
    (lt_times_lt_pos2 formula-decl nil real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (both_sides_plus_lt2 formula-decl nil real_props nil)
    (> const-decl "bool" reals nil))
   shostak))
 (atan_deriv_strict_increasing 0
  (atan_deriv_strict_increasing-1 nil 3664762928
   ("" (skosimp*)
    (("" (expand "atan_deriv_fun") (("" (field) nil nil)) nil)) nil)
   ((atan_deriv_fun const-decl "real" simple_riemann_examples nil)
    (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (/= const-decl "boolean" notequal nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (TRUE const-decl "bool" booleans nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (>= const-decl "bool" reals nil)
    (FDX_20 skolem-const-decl "real" simple_riemann_examples nil)
    (FDX_21 skolem-const-decl "real" simple_riemann_examples nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (both_sides_times_pos_le1_imp formula-decl nil extra_real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (gt_times_gt_neg2 formula-decl nil real_props nil)
    (both_sides_plus_gt2 formula-decl nil real_props nil))
   shostak))
 (atan_deriv_cont 0
  (atan_deriv_cont-1 nil 3664732701
   ("" (expand "atan_deriv_fun")
    (("" (expand "continuous?")
      (("" (skolem 1 ("x"))
        (("" (lemma "identity_continuous[real]" ("x0" "x"))
          (("" (expand "I")
            ((""
              (lemma "prod_continuous[real]"
               ("f1" "LAMBDA(x:real):x" "f2" "LAMBDA(x:real):x" "x0"
                "x"))
              (("" (assert)
                ((""
                  (lemma "const_continuous[real]" ("u" "1" "x0" "x"))
                  (("" (expand "const_fun")
                    (("" (expand "*")
                      ((""
                        (lemma "sum_continuous[real]"
                         ("f1" "LAMBDA(x:real):1" "f2"
                          "LAMBDA(x:real):x*x" "x0" "x"))
                        (("" (assert)
                          (("" (expand "+")
                            ((""
                              (lemma "inv_continuous[real]"
                               ("g" "LAMBDA(x:real):1+x*x" "x0" "x"))
                              (("1"
                                (assert)
                                (("1"
                                  (expand "/")
                                  (("1" (propax) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (hide-all-but 1)
                                (("2"
                                  (skosimp*)
                                  (("2"
                                    (lemma "sq_pos" ("a" "x!1"))
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (continuous? const-decl "bool" continuous_functions "analysis/")
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (identity_continuous formula-decl nil continuous_functions
     "analysis/")
    (prod_continuous formula-decl nil continuous_functions "analysis/")
    (const_continuous formula-decl nil continuous_functions
     "analysis/")
    (* const-decl "[T -> real]" real_fun_ops "reals/")
    (inv_continuous formula-decl nil continuous_functions "analysis/")
    (/= const-decl "boolean" notequal nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/ const-decl "[T -> real]" real_fun_ops "reals/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (sq const-decl "nonneg_real" sq "reals/")
    (sq_pos formula-decl nil sq "reals/")
    (+ const-decl "[T -> real]" real_fun_ops "reals/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (sum_continuous formula-decl nil continuous_functions "analysis/")
    (const_fun const-decl "[T -> real]" real_fun_ops "reals/")
    (I const-decl "(bijective?[T, T])" identity nil)
    (atan_deriv_fun const-decl "real" simple_riemann_examples nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil))
   shostak))
 (Atan_Deriv_TCC1 0
  (Atan_Deriv_TCC1-1 nil 3664735854
   ("" (skolem! 1 "Y!1")
    (("" (lemma "atan_deriv_fun_bounds")
      (("" (lemma "atan_deriv_fun_bounds")
        (("" (inst -1 "lb(Y!1)")
          (("" (inst -2 "ub(Y!1)")
            (("" (expand "atan_deriv_fun")
              (("" (assert)
                (("" (case "1+lb(Y!1)*lb(Y!1) > 0")
                  (("1" (case "1+ub(Y!1)*ub(Y!1) /= 0")
                    (("1" (ground) nil nil)
                     ("2" (case "1+ub(Y!1)*ub(Y!1) > 0")
                      (("1" (ground) (("1" (assert) nil nil)) nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((atan_deriv_fun_bounds formula-decl nil simple_riemann_examples
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (atan_deriv_fun const-decl "real" simple_riemann_examples nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (/= const-decl "boolean" notequal nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil))
   nil))
 (Atan_Deriv_TCC2 0
  (Atan_Deriv_TCC2-1 nil 3664735854
   ("" (skolem! 1 "Y!1")
    (("" (lemma "atan_deriv_fun_bounds")
      (("" (lemma "atan_deriv_fun_bounds")
        (("" (inst -1 "lb(Y!1)")
          (("" (inst -2 "ub(Y!1)")
            (("" (expand "atan_deriv_fun")
              (("" (assert)
                (("" (case "1+lb(Y!1)*lb(Y!1) > 0")
                  (("1" (case "1+ub(Y!1)*ub(Y!1) /= 0")
                    (("1" (ground)
                      (("1" (case "1+ub(Y!1)*ub(Y!1) > 0")
                        (("1" (ground) nil nil) ("2" (assert) nil nil))
                        nil))
                      nil)
                     ("2" (case "1+ub(Y!1)*ub(Y!1) /= 0")
                      (("1" (propax) nil nil)
                       ("2" (assert)
                        (("2" (ground) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((atan_deriv_fun_bounds formula-decl nil simple_riemann_examples
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (atan_deriv_fun const-decl "real" simple_riemann_examples nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (/= const-decl "boolean" notequal nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil))
   nil))
 (Atan_Deriv_TCC3 0
  (Atan_Deriv_TCC3-1 nil 3664744275
   ("" (skolem! 1 "Y!1")
    (("" (lemma "atan_deriv_fun_bounds")
      (("" (lemma "atan_deriv_fun_bounds")
        (("" (inst -1 "lb(Y!1)")
          (("" (inst -2 "ub(Y!1)")
            (("" (expand "atan_deriv_fun")
              (("" (assert)
                (("" (case "1+lb(Y!1)*lb(Y!1) > 0")
                  (("1" (case "1+ub(Y!1)*ub(Y!1) /= 0")
                    (("1" (ground)
                      (("1" (case "1+ub(Y!1)*ub(Y!1) > 0")
                        (("1" (ground) nil nil) ("2" (assert) nil nil))
                        nil))
                      nil)
                     ("2" (assert)
                      (("2" (case "1+ub(Y!1)*ub(Y!1) /= 0")
                        (("1" (propax) nil nil)
                         ("2" (ground) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((atan_deriv_fun_bounds formula-decl nil simple_riemann_examples
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (atan_deriv_fun const-decl "real" simple_riemann_examples nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (/= const-decl "boolean" notequal nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil))
   nil))
 (Atan_Deriv_TCC4 0
  (Atan_Deriv_TCC4-1 nil 3664744275
   ("" (skolem! 1 "Y!1")
    (("" (lemma "atan_deriv_fun_bounds")
      (("" (lemma "atan_deriv_fun_bounds")
        (("" (assert)
          (("" (inst -1 "lb(Y!1)")
            (("" (inst -2 "ub(Y!1)")
              (("" (expand "atan_deriv_fun")
                (("" (assert)
                  (("" (case "1+lb(Y!1)*lb(Y!1) > 0")
                    (("1" (case "1+ub(Y!1)*ub(Y!1) /= 0")
                      (("1" (ground) nil nil)
                       ("2" (case "1+ub(Y!1)*ub(Y!1) > 0")
                        (("1" (ground) (("1" (assert) nil nil)) nil)
                         ("2" (case "1+ub(Y!1)*ub(Y!1) /= 0")
                          (("1" (propax) nil nil)
                           ("2" (assert 2) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (assert 1) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((atan_deriv_fun_bounds formula-decl nil simple_riemann_examples
     nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (/= const-decl "boolean" notequal nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (atan_deriv_fun const-decl "real" simple_riemann_examples nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (Atan_Deriv_TCC5 0
  (Atan_Deriv_TCC5-1 nil 3664744275 ("" (cond-disjoint-tcc) nil nil)
   ((lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (Atan_Deriv_inclusion 0
  (Atan_Deriv_inclusion-1 nil 3664744275
   ("" (skosimp*)
    (("" (expand "atan_deriv_fun")
      (("" (expand "Atan_Deriv")
        (("" (expand "atan_deriv_fun")
          (("" (ground)
            (("" (expand "##")
              (("" (musimp)
                (("1" (grind)
                  (("1" (field) nil nil) ("2" (field) nil nil)
                   ("3" (field) nil nil)
                   ("4" (case "x!1=0")
                    (("1" (rewrite -1) (("1" (ground) nil nil)) nil)
                     ("2" (case "x!1<0")
                      (("1" (lemma "atan_deriv_strict_increasing")
                        (("1" (case "x!1 = ub(Y!1)")
                          (("1" (ground) nil nil)
                           ("2" (case "x!1 < ub(Y!1)")
                            (("1" (ground) (("1" (field) nil nil)) nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (field) nil nil))
                      nil))
                    nil)
                   ("5" (lemma " atan_deriv_fun_bounds")
                    (("5" (inst -1 "x!1")
                      (("5" (ground)
                        (("5" (lemma "atan_deriv_strict_increasing")
                          (("5" (case "x!1<ub(Y!1)")
                            (("1" (grind) nil nil)
                             ("2" (case "x!1=ub(Y!1)")
                              (("1" (grind) nil nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("6" (lemma " atan_deriv_fun_bounds")
                    (("6" (inst -1 "x!1") (("6" (ground) nil nil))
                      nil))
                    nil)
                   ("7" (field) nil nil))
                  nil)
                 ("2" (grind)
                  (("1" (field) nil nil) ("2" (field) nil nil)
                   ("3" (case "x!1=lb(Y!1)")
                    (("1" (rewrite -1) (("1" (grind) nil nil)) nil)
                     ("2" (case "lb(Y!1)< x!1")
                      (("1" (lemma "atan_deriv_strict_increasing")
                        (("1" (case " x!1=0")
                          (("1" (grind) nil nil)
                           ("2" (inst -1 "lb(Y!1)" "x!1")
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil)
                   ("4" (case "x!1=ub(Y!1)")
                    (("1" (rewrite -1) (("1" (grind) nil nil)) nil)
                     ("2" (case "x!1<ub(Y!1)")
                      (("1" (case "x!1=0")
                        (("1" (ground) nil nil)
                         ("2" (case "x!1 > 0")
                          (("1" (lemma "atan_deriv_strict_decreasing")
                            (("1" (grind) nil nil)) nil)
                           ("2" (case "x!1<0")
                            (("1" (case "lb(Y!1)=x!1")
                              (("1"
                                (rewrite -1)
                                (("1" (assert) nil nil))
                                nil)
                               ("2"
                                (case "lb(Y!1) < x!1")
                                (("1"
                                  (lemma
                                   "atan_deriv_strict_increasing")
                                  (("1"
                                    (case "lb(Y!1) < 0")
                                    (("1"
                                      (case "0 > ub(Y!1)")
                                      (("1"
                                        (inst -3 "lb(Y!1)" "x!1")
                                        (("1" (grind) nil nil))
                                        nil)
                                       ("2"
                                        (case "0 < ub(Y!1)")
                                        (("1" (propax) nil nil)
                                         ("2"
                                          (assert)
                                          (("2"
                                            (inst -2 "lb(Y!1)" "x!1")
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil)
                   ("5" (case "x!1=0")
                    (("1" (grind) nil nil)
                     ("2" (case "x!1=ub(Y!1)")
                      (("1" (grind) nil nil)
                       ("2" (case "x!1<ub(Y!1)")
                        (("1" (case "x!1>0")
                          (("1" (lemma "atan_deriv_strict_decreasing")
                            (("1" (grind) nil nil)) nil)
                           ("2" (case "0 > x!1")
                            (("1" (case "x!1=lb(Y!1)")
                              (("1" (grind) nil nil)
                               ("2"
                                (case "lb(Y!1)< x!1")
                                (("1"
                                  (lemma
                                   "atan_deriv_strict_increasing")
                                  (("1" (grind) nil nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil)
                         ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil)
                   ("6" (case "lb(Y!1)=x!1")
                    (("1" (rewrite -1) (("1" (grind) nil nil)) nil)
                     ("2" (case "lb(Y!1) < x!1")
                      (("1" (lemma "atan_deriv_strict_increasing")
                        (("1" (case "0 > x!1")
                          (("1" (inst -2 "lb(Y!1)" "x!1")
                            (("1" (ground -2) nil nil)
                             ("2" (case "ub(Y!1)=x!1")
                              (("1" (grind) nil nil)
                               ("2"
                                (case "x!1<ub(Y!1)")
                                (("1"
                                  (lemma
                                   "atan_deriv_strict_decreasing")
                                  (("1"
                                    (case "ub(Y!1)<0 ")
                                    (("1" (propax) nil nil)
                                     ("2"
                                      (inst -1 "x!1" "ub(Y!1)")
                                      (("1" (grind) nil nil)
                                       ("2" (assert) nil nil)
                                       ("3" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (field) nil nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil)
                   ("7" (case "x!1=0")
                    (("1" (grind) nil nil)
                     ("2" (case "x!1=ub(Y!1)")
                      (("1" (grind)
                        (("1" (lemma "atan_deriv_strict_increasing")
                          (("1" (inst -1 "lb(Y!1)" "ub(Y!1)")
                            (("1" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (case "x!1<ub(Y!1)")
                        (("1" (case "x!1>0")
                          (("1" (lemma "atan_deriv_strict_decreasing")
                            (("1" (grind) nil nil)) nil)
                           ("2" (case "0 > x!1")
                            (("1" (case "x!1=lb(Y!1)")
                              (("1" (grind) nil nil)
                               ("2"
                                (case "lb(Y!1)< x!1")
                                (("1"
                                  (lemma
                                   "atan_deriv_strict_increasing")
                                  (("1"
                                    (inst -1 "lb(Y!1)" "x!1")
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil)
                         ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil)
                   ("8" (case "x!1=0")
                    (("1" (grind)
                      (("1" (lemma "atan_deriv_fun_bounds")
                        (("1" (grind) nil nil)) nil))
                      nil)
                     ("2" (case "x!1=ub(Y!1)")
                      (("1" (grind) nil nil)
                       ("2" (case "x!1<ub(Y!1)")
                        (("1" (case "x!1>0")
                          (("1" (lemma "atan_deriv_strict_decreasing")
                            (("1" (grind) nil nil)) nil)
                           ("2" (case "0 > x!1")
                            (("1" (case "x!1=lb(Y!1)")
                              (("1" (grind) nil nil)
                               ("2"
                                (case "lb(Y!1)< x!1")
                                (("1"
                                  (lemma
                                   "atan_deriv_strict_increasing")
                                  (("1"
                                    (inst -1 "lb(Y!1)" "x!1")
                                    (("1" (grind) nil nil)
                                     ("2" (assert) nil nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil)
                         ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((atan_deriv_fun const-decl "real" simple_riemann_examples nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (FDX_24 skolem-const-decl "real" simple_riemann_examples nil)
    (FDX_25 skolem-const-decl "real" simple_riemann_examples nil)
    (div_mult_pos_le2 formula-decl nil real_props nil)
    (atan_deriv_strict_decreasing formula-decl nil
     simple_riemann_examples nil)
    (Y!1 skolem-const-decl "Interval" simple_riemann_examples nil)
    (x!1 skolem-const-decl "real" simple_riemann_examples nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (real nonempty-type-from-decl nil reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (/= const-decl "boolean" notequal nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (FDX_22 skolem-const-decl "real" simple_riemann_examples nil)
    (FDX_23 skolem-const-decl "real" simple_riemann_examples nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (both_sides_times_pos_le1 formula-decl nil real_props nil)
    (le_times_le_pos formula-decl nil real_props nil)
    (le_plus_le formula-decl nil real_props nil)
    (> const-decl "bool" reals nil)
    (div_mult_pos_le1 formula-decl nil real_props nil)
    (le_div_le_pos formula-decl nil real_props nil)
    (le_times_le_neg formula-decl nil real_props nil)
    (both_sides_plus_le2 formula-decl nil real_props nil)
    (< const-decl "bool" reals nil)
    (atan_deriv_strict_increasing formula-decl nil
     simple_riemann_examples nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (atan_deriv_fun_bounds formula-decl nil simple_riemann_examples
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (Atan_Deriv const-decl "Interval" simple_riemann_examples nil))
   shostak))
 (atan_approx_at_1_test1_TCC1 0
  (atan_approx_at_1_test1_TCC1-1 nil 3664731208
   ("" (conts-integ-[real] atan_deriv_cont)
    (("" (Integ-integ-exp) nil nil)) nil)
   ((Integrable? const-decl "bool" integral_def "analysis/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (atan_deriv_fun const-decl "real" simple_riemann_examples nil)
    (atan_deriv_cont formula-decl nil simple_riemann_examples nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (bool nonempty-type-eq-decl nil booleans nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/"))
   nil))
 (atan_approx_at_1_test1 0
  (atan_approx_at_1_test1-1 nil 3664731209
   (""
    (conts-numerical-Riemann ("Atan_Deriv") Atan_Deriv_inclusion
     atan_deriv_cont "[|0,1|]" "atan_deriv_fun" "13" "2")
    nil nil)
   ((Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (atan_deriv_cont formula-decl nil simple_riemann_examples nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (Atan_Deriv_inclusion formula-decl nil simple_riemann_examples
     nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (Incl_Member formula-decl nil interval "interval_arith/")
    (integral const-decl "{S: real | integral?(a, b, ff, S)}"
     integral_def "analysis/")
    (integral? const-decl "bool" integral_def "analysis/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (<< const-decl "bool" interval "interval_arith/")
    (subrange type-eq-decl nil subrange_type nil)
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx nil)
    (RiemannSum_R2I def-decl "Interval" Riemann_integ_interval_approx
     nil)
    (R const-decl "Interval" Riemann_integ_interval_approx nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (subrange type-eq-decl nil integers nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx nil)
    (< const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil nat_types nil)
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def "analysis/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (Atan_Deriv const-decl "Interval" simple_riemann_examples nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx nil)
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     nil)
    (atan_deriv_fun const-decl "real" simple_riemann_examples nil)
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/"))
   shostak))
 (atan_approx_at_1_on_239_TCC1 0
  (atan_approx_at_1_on_239_TCC1-1 nil 3668256204
   ("" (conts-integ-[real] atan_deriv_cont)
    (("" (Integ-integ-exp) nil nil)) nil)
   ((Integrable? const-decl "bool" integral_def "analysis/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (atan_deriv_fun const-decl "real" simple_riemann_examples nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (atan_deriv_cont formula-decl nil simple_riemann_examples nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (bool nonempty-type-eq-decl nil booleans nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/"))
   nil))
 (atan_approx_at_1_on_239 0
  (atan_approx_at_1_on_239-1 nil 3668256586
   (""
    (conts-numerical-Riemann ("Atan_Deriv") Atan_Deriv_inclusion
     atan_deriv_cont "[|0,1/239|]" "atan_deriv_fun" "13" "2")
    nil nil)
   ((Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (atan_deriv_cont formula-decl nil simple_riemann_examples nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (Atan_Deriv_inclusion formula-decl nil simple_riemann_examples
     nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (Incl_Member formula-decl nil interval "interval_arith/")
    (integral const-decl "{S: real | integral?(a, b, ff, S)}"
     integral_def "analysis/")
    (integral? const-decl "bool" integral_def "analysis/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (<< const-decl "bool" interval "interval_arith/")
    (subrange type-eq-decl nil subrange_type nil)
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx nil)
    (RiemannSum_R2I def-decl "Interval" Riemann_integ_interval_approx
     nil)
    (R const-decl "Interval" Riemann_integ_interval_approx nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (^ const-decl "real" exponentiation nil)
    (subrange type-eq-decl nil integers nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx nil)
    (< const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil nat_types nil)
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def "analysis/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (Atan_Deriv const-decl "Interval" simple_riemann_examples nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     nil)
    (atan_deriv_fun const-decl "real" simple_riemann_examples nil)
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil))
   shostak))
 (atan_approx_at_1_on_5_TCC1 0
  (atan_approx_at_1_on_5_TCC1-1 nil 3668263985
   ("" (conts-integ-[real] atan_deriv_cont)
    (("" (Integ-integ-exp) nil nil)) nil)
   ((Integrable? const-decl "bool" integral_def "analysis/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (atan_deriv_fun const-decl "real" simple_riemann_examples nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (atan_deriv_cont formula-decl nil simple_riemann_examples nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (bool nonempty-type-eq-decl nil booleans nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/"))
   nil))
 (atan_approx_at_1_on_5 0
  (atan_approx_at_1_on_5-1 nil 3668263986
   (""
    (conts-numerical-Riemann ("Atan_Deriv") Atan_Deriv_inclusion
     atan_deriv_cont "[|0,1/5|]" "atan_deriv_fun" "13" "2")
    nil nil)
   ((Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (atan_deriv_cont formula-decl nil simple_riemann_examples nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (Atan_Deriv_inclusion formula-decl nil simple_riemann_examples
     nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (Incl_Member formula-decl nil interval "interval_arith/")
    (integral const-decl "{S: real | integral?(a, b, ff, S)}"
     integral_def "analysis/")
    (integral? const-decl "bool" integral_def "analysis/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (<< const-decl "bool" interval "interval_arith/")
    (subrange type-eq-decl nil subrange_type nil)
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx nil)
    (RiemannSum_R2I def-decl "Interval" Riemann_integ_interval_approx
     nil)
    (R const-decl "Interval" Riemann_integ_interval_approx nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (^ const-decl "real" exponentiation nil)
    (subrange type-eq-decl nil integers nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx nil)
    (< const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil nat_types nil)
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def "analysis/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (Atan_Deriv const-decl "Interval" simple_riemann_examples nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     nil)
    (atan_deriv_fun const-decl "real" simple_riemann_examples nil)
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil))
   shostak))
 (atan_approx_at_1_on_30_TCC1 0
  (atan_approx_at_1_on_30_TCC1-1 nil 3664818928
   ("" (conts-integ-[real] atan_deriv_cont)
    (("" (Integ-integ-exp) nil nil)) nil)
   ((Integrable? const-decl "bool" integral_def "analysis/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (atan_deriv_fun const-decl "real" simple_riemann_examples nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (atan_deriv_cont formula-decl nil simple_riemann_examples nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (bool nonempty-type-eq-decl nil booleans nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/"))
   nil))
 (atan_approx_at_1_on_30 0
  (atan_approx_at_1_on_30-1 nil 3664818953
   (""
    (conts-numerical-Riemann ("Atan_Deriv") Atan_Deriv_inclusion
     atan_deriv_cont "[|0,1/30|]" "atan_deriv_fun" "13" "2")
    nil nil)
   ((Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (atan_deriv_cont formula-decl nil simple_riemann_examples nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (Atan_Deriv_inclusion formula-decl nil simple_riemann_examples
     nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (Incl_Member formula-decl nil interval "interval_arith/")
    (integral const-decl "{S: real | integral?(a, b, ff, S)}"
     integral_def "analysis/")
    (integral? const-decl "bool" integral_def "analysis/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (<< const-decl "bool" interval "interval_arith/")
    (subrange type-eq-decl nil subrange_type nil)
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx nil)
    (RiemannSum_R2I def-decl "Interval" Riemann_integ_interval_approx
     nil)
    (R const-decl "Interval" Riemann_integ_interval_approx nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (^ const-decl "real" exponentiation nil)
    (subrange type-eq-decl nil integers nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx nil)
    (< const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil nat_types nil)
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def "analysis/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (Atan_Deriv const-decl "Interval" simple_riemann_examples nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     nil)
    (atan_deriv_fun const-decl "real" simple_riemann_examples nil)
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil))
   shostak))
 (atan_approx_at_1_on_230_TCC1 0
  (atan_approx_at_1_on_230_TCC1-1 nil 3665614409
   ("" (conts-integ-[real] atan_deriv_cont)
    (("" (Integ-integ-exp) nil nil)) nil)
   ((Integrable? const-decl "bool" integral_def "analysis/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (atan_deriv_fun const-decl "real" simple_riemann_examples nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (atan_deriv_cont formula-decl nil simple_riemann_examples nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (bool nonempty-type-eq-decl nil booleans nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/"))
   nil))
 (atan_approx_at_1_on_230 0
  (atan_approx_at_1_on_230-1 nil 3665614515
   (""
    (conts-numerical-Riemann ("Atan_Deriv") Atan_Deriv_inclusion
     atan_deriv_cont "[|0,1/230|]" "atan_deriv_fun" "13" "2")
    nil nil)
   ((Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (atan_deriv_cont formula-decl nil simple_riemann_examples nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (Atan_Deriv_inclusion formula-decl nil simple_riemann_examples
     nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (Incl_Member formula-decl nil interval "interval_arith/")
    (integral const-decl "{S: real | integral?(a, b, ff, S)}"
     integral_def "analysis/")
    (integral? const-decl "bool" integral_def "analysis/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (<< const-decl "bool" interval "interval_arith/")
    (subrange type-eq-decl nil subrange_type nil)
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx nil)
    (RiemannSum_R2I def-decl "Interval" Riemann_integ_interval_approx
     nil)
    (R const-decl "Interval" Riemann_integ_interval_approx nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (^ const-decl "real" exponentiation nil)
    (subrange type-eq-decl nil integers nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx nil)
    (< const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil nat_types nil)
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def "analysis/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (Atan_Deriv const-decl "Interval" simple_riemann_examples nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     nil)
    (atan_deriv_fun const-decl "real" simple_riemann_examples nil)
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil))
   shostak))
 (atan_approx_at_89_test1_TCC1 0
  (atan_approx_at_89_test1_TCC1-1 nil 3668434820
   ("" (conts-integ-[real] atan_deriv_cont)
    (("" (Integ-integ-exp) nil nil)) nil)
   ((Integrable? const-decl "bool" integral_def "analysis/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (atan_deriv_fun const-decl "real" simple_riemann_examples nil)
    (atan_deriv_cont formula-decl nil simple_riemann_examples nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (bool nonempty-type-eq-decl nil booleans nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/"))
   nil))
 (atan_approx_at_89_test1 0
  (atan_approx_at_89_test1-1 nil 3668434822
   (""
    (conts-numerical-Riemann ("Atan_Deriv") Atan_Deriv_inclusion
     atan_deriv_cont "[|0,89|]" "atan_deriv_fun" "13" "2")
    nil nil)
   ((Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (atan_deriv_cont formula-decl nil simple_riemann_examples nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (Atan_Deriv_inclusion formula-decl nil simple_riemann_examples
     nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (Incl_Member formula-decl nil interval "interval_arith/")
    (integral const-decl "{S: real | integral?(a, b, ff, S)}"
     integral_def "analysis/")
    (integral? const-decl "bool" integral_def "analysis/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (<< const-decl "bool" interval "interval_arith/")
    (subrange type-eq-decl nil subrange_type nil)
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx nil)
    (RiemannSum_R2I def-decl "Interval" Riemann_integ_interval_approx
     nil)
    (R const-decl "Interval" Riemann_integ_interval_approx nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (subrange type-eq-decl nil integers nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx nil)
    (< const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil nat_types nil)
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def "analysis/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (Atan_Deriv const-decl "Interval" simple_riemann_examples nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx nil)
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     nil)
    (atan_deriv_fun const-decl "real" simple_riemann_examples nil)
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/"))
   shostak))
 (cos_test_TCC1 0
  (cos_test_TCC1-1 nil 3662682866
   ("" (conts-integ-[real] cos_cont_fun)
    (("" (Integ-integ-exp) nil nil)) nil)
   ((Integrable? const-decl "bool" integral_def "analysis/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (cos const-decl "real" sincos_def "trig/")
    (cos_cont_fun formula-decl nil sincos "trig/")
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (bool nonempty-type-eq-decl nil booleans nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/"))
   nil))
 (cos_test 0
  (cos_test-1 nil 3662682867
   (""
    (conts-numerical-Riemann ("Cos") Cos_inclusion cos_cont_fun
     "[|0,1|]" "cos" "9" "2")
    nil nil)
   ((Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (cos_cont_fun formula-decl nil sincos "trig/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (cos_range application-judgement "real_abs_le1" sincos "trig/")
    (Cos_Fundamental application-judgement "(Fundamental?(PreTrue))"
     interval_expr_trig "interval_arith/")
    (Cos_Inclusion application-judgement "(Inclusion?(PreTrue, cos))"
     interval_expr_trig "interval_arith/")
    (Cos_inclusion formula-decl nil interval_trig "interval_arith/")
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (Incl_Member formula-decl nil interval "interval_arith/")
    (integral const-decl "{S: real | integral?(a, b, ff, S)}"
     integral_def "analysis/")
    (integral? const-decl "bool" integral_def "analysis/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (<< const-decl "bool" interval "interval_arith/")
    (subrange type-eq-decl nil subrange_type nil)
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx nil)
    (RiemannSum_R2I def-decl "Interval" Riemann_integ_interval_approx
     nil)
    (R const-decl "Interval" Riemann_integ_interval_approx nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (subrange type-eq-decl nil integers nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx nil)
    (< const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil nat_types nil)
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def "analysis/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (Cos const-decl "Interval" interval_trig "interval_arith/")
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx nil)
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     nil)
    (cos const-decl "real" sincos_def "trig/")
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/"))
   shostak))
 (cos_test1 0
  (cos_test1-1 nil 3662678561
   (""
    (conts-numerical-Riemann ("Cos") Cos_inclusion cos_cont_fun
     "[|0,1|]" "cos" "12" "2")
    nil nil)
   ((Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (cos_cont_fun formula-decl nil sincos "trig/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (cos_range application-judgement "real_abs_le1" sincos "trig/")
    (Cos_Fundamental application-judgement "(Fundamental?(PreTrue))"
     interval_expr_trig "interval_arith/")
    (Cos_Inclusion application-judgement "(Inclusion?(PreTrue, cos))"
     interval_expr_trig "interval_arith/")
    (Cos_inclusion formula-decl nil interval_trig "interval_arith/")
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (Incl_Member formula-decl nil interval "interval_arith/")
    (integral const-decl "{S: real | integral?(a, b, ff, S)}"
     integral_def "analysis/")
    (integral? const-decl "bool" integral_def "analysis/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (<< const-decl "bool" interval "interval_arith/")
    (subrange type-eq-decl nil subrange_type nil)
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx nil)
    (RiemannSum_R2I def-decl "Interval" Riemann_integ_interval_approx
     nil)
    (R const-decl "Interval" Riemann_integ_interval_approx nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (subrange type-eq-decl nil integers nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx nil)
    (< const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil nat_types nil)
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def "analysis/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (Cos const-decl "Interval" interval_trig "interval_arith/")
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx nil)
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     nil)
    (cos const-decl "real" sincos_def "trig/")
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/"))
   shostak))
 (cos_test5_TCC1 0
  (cos_test5_TCC1-1 nil 3669320423
   ("" (conts-integ-[real] cos_cont_fun)
    (("" (Integ-integ-exp) nil nil)) nil)
   ((Integrable? const-decl "bool" integral_def "analysis/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (cos const-decl "real" sincos_def "trig/")
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (cos_cont_fun formula-decl nil sincos "trig/")
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (bool nonempty-type-eq-decl nil booleans nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/"))
   nil))
 (cos_test5 0
  (cos_test5-1 nil 3669320423
   (""
    (conts-numerical-Riemann ("Cos") Cos_inclusion cos_cont_fun
     "[|0,1/230|]" "cos" "13" "7")
    nil nil)
   ((Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (cos_cont_fun formula-decl nil sincos "trig/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (cos_range application-judgement "real_abs_le1" sincos "trig/")
    (Cos_Fundamental application-judgement "(Fundamental?(PreTrue))"
     interval_expr_trig "interval_arith/")
    (Cos_Inclusion application-judgement "(Inclusion?(PreTrue, cos))"
     interval_expr_trig "interval_arith/")
    (Cos_inclusion formula-decl nil interval_trig "interval_arith/")
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (Incl_Member formula-decl nil interval "interval_arith/")
    (integral const-decl "{S: real | integral?(a, b, ff, S)}"
     integral_def "analysis/")
    (integral? const-decl "bool" integral_def "analysis/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (<< const-decl "bool" interval "interval_arith/")
    (subrange type-eq-decl nil subrange_type nil)
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx nil)
    (RiemannSum_R2I def-decl "Interval" Riemann_integ_interval_approx
     nil)
    (R const-decl "Interval" Riemann_integ_interval_approx nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (^ const-decl "real" exponentiation nil)
    (subrange type-eq-decl nil integers nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx nil)
    (< const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil nat_types nil)
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def "analysis/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (Cos const-decl "Interval" interval_trig "interval_arith/")
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     nil)
    (cos const-decl "real" sincos_def "trig/")
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil))
   shostak))
 (sin_test1_TCC1 0
  (sin_test1_TCC1-1 nil 3661509926
   ("" (lemma "fundamental_indef[real]")
    (("1"
      (invoke (inst -1 "%1" "%2" "%3")
       (? 1 "integrable?[real](%1,%2,%3 )"))
      (("1" (lemma sin_cont_fun)
        (("1" (assert) (("1" (Integ-integ-exp) nil nil)) nil)) nil))
      nil)
     ("2" (lemma sin_cont_fun)
      (("2" (assert)
        (("2" (expand 'connected? '1) (("2" (propax) nil nil)) nil))
        nil))
      nil))
    nil)
   ((sin const-decl "real" sincos_def "trig/")
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (Integrable? const-decl "bool" integral_def "analysis/")
    (sin_cont_fun formula-decl nil sincos "trig/")
    (bool nonempty-type-eq-decl nil booleans nil)
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil))
   nil))
 (sin_test1 0
  (sin_test1-1 nil 3661509927
   (""
    (conts-numerical-Riemann ("Sin") Sin_inclusion sin_cont_fun
     "[|0, 1.4142135|]" "sin" "12" "3")
    nil nil)
   ((Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (sin_cont_fun formula-decl nil sincos "trig/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (sin_range application-judgement "real_abs_le1" sincos "trig/")
    (Sin_Fundamental application-judgement "(Fundamental?(PreTrue))"
     interval_expr_trig "interval_arith/")
    (Sin_Inclusion application-judgement "(Inclusion?(PreTrue, sin))"
     interval_expr_trig "interval_arith/")
    (Sin_inclusion formula-decl nil interval_trig "interval_arith/")
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (Incl_Member formula-decl nil interval "interval_arith/")
    (integral const-decl "{S: real | integral?(a, b, ff, S)}"
     integral_def "analysis/")
    (integral? const-decl "bool" integral_def "analysis/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (<< const-decl "bool" interval "interval_arith/")
    (subrange type-eq-decl nil subrange_type nil)
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx nil)
    (RiemannSum_R2I def-decl "Interval" Riemann_integ_interval_approx
     nil)
    (R const-decl "Interval" Riemann_integ_interval_approx nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (^ const-decl "real" exponentiation nil)
    (subrange type-eq-decl nil integers nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx nil)
    (< const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil nat_types nil)
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def "analysis/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (Sin const-decl "Interval" interval_trig "interval_arith/")
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     nil)
    (sin const-decl "real" sincos_def "trig/")
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil))
   shostak))
 (sin_test_TCC1 0
  (sin_test_TCC1-1 nil 3665617131
   ("" (conts-integ-[real] sin_cont_fun)
    (("" (Integ-integ-exp) nil nil)) nil)
   ((Integrable? const-decl "bool" integral_def "analysis/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (sin const-decl "real" sincos_def "trig/")
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (sin_cont_fun formula-decl nil sincos "trig/")
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (bool nonempty-type-eq-decl nil booleans nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/"))
   nil))
 (sin_test 0
  (sin_test-1 nil 3665617132
   (""
    (conts-numerical-Riemann ("Sin") Sin_inclusion sin_cont_fun
     "[|0,1/30|]" "sin" "13" "4")
    nil nil)
   ((Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (sin_cont_fun formula-decl nil sincos "trig/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (sin_range application-judgement "real_abs_le1" sincos "trig/")
    (Sin_Fundamental application-judgement "(Fundamental?(PreTrue))"
     interval_expr_trig "interval_arith/")
    (Sin_Inclusion application-judgement "(Inclusion?(PreTrue, sin))"
     interval_expr_trig "interval_arith/")
    (Sin_inclusion formula-decl nil interval_trig "interval_arith/")
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (Incl_Member formula-decl nil interval "interval_arith/")
    (integral const-decl "{S: real | integral?(a, b, ff, S)}"
     integral_def "analysis/")
    (integral? const-decl "bool" integral_def "analysis/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (<< const-decl "bool" interval "interval_arith/")
    (subrange type-eq-decl nil subrange_type nil)
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx nil)
    (RiemannSum_R2I def-decl "Interval" Riemann_integ_interval_approx
     nil)
    (R const-decl "Interval" Riemann_integ_interval_approx nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (^ const-decl "real" exponentiation nil)
    (subrange type-eq-decl nil integers nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx nil)
    (< const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil nat_types nil)
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def "analysis/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (Sin const-decl "Interval" interval_trig "interval_arith/")
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     nil)
    (sin const-decl "real" sincos_def "trig/")
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil))
   shostak))
 (sin_test2_TCC1 0
  (sin_test2_TCC1-1 nil 3664812301
   ("" (conts-integ-[real] sin_cont_fun)
    (("" (Integ-integ-exp) nil nil)) nil)
   ((Integrable? const-decl "bool" integral_def "analysis/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (sin const-decl "real" sincos_def "trig/")
    (sin_cont_fun formula-decl nil sincos "trig/")
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (bool nonempty-type-eq-decl nil booleans nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/"))
   nil))
 (sin_test2 0
  (sin_test2-1 nil 3662677995
   (""
    (conts-numerical-Riemann ("Sin") Sin_inclusion sin_cont_fun
     "[|0,2|]" "sin" "12" "2")
    nil nil)
   ((Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (sin_cont_fun formula-decl nil sincos "trig/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (sin_range application-judgement "real_abs_le1" sincos "trig/")
    (Sin_Fundamental application-judgement "(Fundamental?(PreTrue))"
     interval_expr_trig "interval_arith/")
    (Sin_Inclusion application-judgement "(Inclusion?(PreTrue, sin))"
     interval_expr_trig "interval_arith/")
    (Sin_inclusion formula-decl nil interval_trig "interval_arith/")
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (Incl_Member formula-decl nil interval "interval_arith/")
    (integral const-decl "{S: real | integral?(a, b, ff, S)}"
     integral_def "analysis/")
    (integral? const-decl "bool" integral_def "analysis/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (<< const-decl "bool" interval "interval_arith/")
    (subrange type-eq-decl nil subrange_type nil)
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx nil)
    (RiemannSum_R2I def-decl "Interval" Riemann_integ_interval_approx
     nil)
    (R const-decl "Interval" Riemann_integ_interval_approx nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (subrange type-eq-decl nil integers nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx nil)
    (< const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil nat_types nil)
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def "analysis/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (Sin const-decl "Interval" interval_trig "interval_arith/")
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx nil)
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     nil)
    (sin const-decl "real" sincos_def "trig/")
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/"))
   shostak))
 (sin_test4_TCC1 0
  (sin_test4_TCC1-1 nil 3662920970
   ("" (conts-integ-[real] sin_cont_fun)
    (("" (Integ-integ-exp) nil nil)) nil)
   ((Integrable? const-decl "bool" integral_def "analysis/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (sin const-decl "real" sincos_def "trig/")
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (sin_cont_fun formula-decl nil sincos "trig/")
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (bool nonempty-type-eq-decl nil booleans nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/"))
   nil))
 (sin_test4 0
  (sin_test4-2 "" 3662994091
   (""
    (conts-numerical-Riemann ("Sin") Sin_inclusion sin_cont_fun
     "[|-1.5, 1|]" "sin" "12" "2")
    nil nil)
   ((Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (sin_range application-judgement "real_abs_le1" sincos "trig/")
    (Sin_Fundamental application-judgement "(Fundamental?(PreTrue))"
     interval_expr_trig "interval_arith/")
    (Sin_Inclusion application-judgement "(Inclusion?(PreTrue, sin))"
     interval_expr_trig "interval_arith/")
    (Sin_inclusion formula-decl nil interval_trig "interval_arith/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (<< const-decl "bool" interval "interval_arith/")
    (subrange type-eq-decl nil subrange_type nil)
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx nil)
    (RiemannSum_R2I def-decl "Interval" Riemann_integ_interval_approx
     nil)
    (R const-decl "Interval" Riemann_integ_interval_approx nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (Incl_Member formula-decl nil interval "interval_arith/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (integral const-decl "{S: real | integral?(a, b, ff, S)}"
     integral_def "analysis/")
    (integral? const-decl "bool" integral_def "analysis/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (sin_cont_fun formula-decl nil sincos "trig/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (^ const-decl "real" exponentiation nil)
    (subrange type-eq-decl nil integers nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx nil)
    (< const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil nat_types nil)
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def "analysis/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (Sin const-decl "Interval" interval_trig "interval_arith/")
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     nil)
    (sin const-decl "real" sincos_def "trig/")
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil))
   shostak)
  (sin_test4-1 nil 3662920971
   ("" (lemma "Simple_Riemann_Soundness")
    (("" (inst -1 "[|-1.5,1|]" "sin" "13" "2")
      (("1" (assert)
        (("1" (inst -1 "Sin")
          (("1" (eval-step)
            (("1" (conts-integ-[real] sin_cont_fun)
              (("1" (Integ-integ-exp) nil nil)) nil))
            nil)
           ("2" (inclus-fun Sin_inclusion) nil nil))
          nil))
        nil)
       ("2" (soundness1 Sin_inclusion sin_cont_fun) nil nil)
       ("3" (expand "StrictInterval?") (("3" (ground) nil nil)) nil))
      nil))
    nil)
   ((StrictInterval? const-decl "bool" interval "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (sin const-decl "real" sincos_def "trig/")
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     nil)
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx nil)
    (Sin const-decl "Interval" interval_trig "interval_arith/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (partition type-eq-decl nil integral_def "analysis/")
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (sin_cont_fun formula-decl nil sincos "trig/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (integral? const-decl "bool" integral_def "analysis/")
    (integral const-decl "{S: real | integral?(a, b, ff, S)}"
     integral_def "analysis/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (Incl_Member formula-decl nil interval "interval_arith/")
    (R const-decl "Interval" Riemann_integ_interval_approx nil)
    (RiemannSum_R2I def-decl "Interval" Riemann_integ_interval_approx
     nil)
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx nil)
    (<< const-decl "bool" interval "interval_arith/")
    (Sin_inclusion formula-decl nil interval_trig "interval_arith/")
    (Sin_Inclusion application-judgement "(Inclusion?(PreTrue, sin))"
     interval_expr_trig "interval_arith/")
    (Sin_Fundamental application-judgement "(Fundamental?(PreTrue))"
     interval_expr_trig "interval_arith/")
    nil (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (|##| const-decl "bool" interval "interval_arith/")
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (lb_interval formula-decl nil interval "interval_arith/")
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx nil))
   shostak))
 (exp_test3_TCC1 0
  (exp_test3_TCC1-1 nil 3662683494
   ("" (conts-integ-[real] exp_continuous)
    (("" (Integ-integ-exp) nil nil)) nil)
   ((Integrable? const-decl "bool" integral_def "analysis/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (exp const-decl "{py | x = ln(py)}" ln_exp "lnexp_fnd/")
    (ln const-decl "real" ln_exp "lnexp_fnd/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (exp_continuous formula-decl nil ln_exp "lnexp_fnd/")
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (bool nonempty-type-eq-decl nil booleans nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/"))
   nil))
 (exp_test3 0
  (exp_test3-1 nil 3662677444
   (""
    (conts-numerical-Riemann ("Exp") Exp_inclusion exp_continuous
     "[|0,3|]" "exp" "12" "3")
    nil nil)
   ((Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (exp_continuous formula-decl nil ln_exp "lnexp_fnd/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (Exp_Fundamental application-judgement "(Fundamental?(PreTrue))"
     interval_expr_lnexp "interval_arith/")
    (Exp_Inclusion application-judgement
     "(Inclusion?(PreTrue, exp_safe))" interval_expr_lnexp
     "interval_arith/")
    (Exp_inclusion formula-decl nil interval_lnexp "interval_arith/")
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (Incl_Member formula-decl nil interval "interval_arith/")
    (integral const-decl "{S: real | integral?(a, b, ff, S)}"
     integral_def "analysis/")
    (integral? const-decl "bool" integral_def "analysis/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (<< const-decl "bool" interval "interval_arith/")
    (subrange type-eq-decl nil subrange_type nil)
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx nil)
    (RiemannSum_R2I def-decl "Interval" Riemann_integ_interval_approx
     nil)
    (R const-decl "Interval" Riemann_integ_interval_approx nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (subrange type-eq-decl nil integers nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx nil)
    (< const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil nat_types nil)
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def "analysis/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (Pos? const-decl "bool" interval "interval_arith/")
    (Exp const-decl "(Pos?)" interval_lnexp "interval_arith/")
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx nil)
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ln const-decl "real" ln_exp "lnexp_fnd/")
    (exp const-decl "{py | x = ln(py)}" ln_exp "lnexp_fnd/")
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/"))
   shostak)))

