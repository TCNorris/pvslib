(riemann_examples
 (expcos_TCC1 0
  (expcos_TCC1-2 "" 3783339808 ("" (prove-integrable?) nil nil)
   ((COS adt-constructor-decl "(cos?)" RiemannExpr_adt "Riemann/")
    (cos? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (EXP adt-constructor-decl "(exp?)" RiemannExpr_adt "Riemann/")
    (exp? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (MULT adt-constructor-decl
     "[[RiemannExpr, RiemannExpr] -> (mult?)]" RiemannExpr_adt
     "Riemann/")
    (mult? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (Eval_real def-decl "[real -> real]" riemann_expr_eval "Riemann/")
    (RiemannExpr type-decl nil RiemannExpr_adt "Riemann/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (< const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (Integrable? const-decl "bool" integral_def "analysis/")
    (Eval_cont_fun formula-decl nil riemann_expr_eval "Riemann/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element_real formula-decl nil deriv_domain "analysis/"))
   shostak)
  (expcos_TCC1-1 nil 3679760494
   ("" (lemma "fundamental_indef[real]")
    (("1" (inst -1 "0" "1" "*[real](exp, cos)")
      (("1" (split -1)
        (("1" (ground)
          (("1" (expand "Integrable?") (("1" (propax) nil nil)) nil))
          nil)
         ("2" (lemma "prod_cont_fun")
          (("2" (inst -1 "exp" "cos")
            (("2" (assert)
              (("2" (split)
                (("1" (lemma "exp_continuous") (("1" (propax) nil nil))
                  nil)
                 ("2" (lemma "cos_cont_fun") (("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (expand "connected?") (("2" (propax) nil nil)) nil))
    nil)
   ((real_minus_real_is_real application-judgement "real" reals nil)
    (Integrable? const-decl "bool" integral_def "analysis/")
    (Eval_cont_fun formula-decl nil riemann_expr_eval "Riemann/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (< const-decl "bool" reals nil)
    (integrable? const-decl "bool" integral_def "analysis/")
    (RiemannExpr type-decl nil RiemannExpr_adt "Riemann/")
    (Eval_real def-decl "[real -> real]" riemann_expr_eval "Riemann/")
    (mult? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (MULT adt-constructor-decl
     "[[RiemannExpr, RiemannExpr] -> (mult?)]" RiemannExpr_adt
     "Riemann/")
    (exp? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (EXP adt-constructor-decl "(exp?)" RiemannExpr_adt "Riemann/")
    (cos? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (COS adt-constructor-decl "(cos?)" RiemannExpr_adt "Riemann/"))
   nil))
 (expcos 0
  (expcos-7 "" 3781543852 ("" (riemann-numerical) nil nil)
   (([\|\|] const-decl "Interval" interval "interval_arith/")
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (real nonempty-type-from-decl nil reals nil)
    (COS adt-constructor-decl "(cos?)" RiemannExpr_adt "Riemann/")
    (cos? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (EXP adt-constructor-decl "(exp?)" RiemannExpr_adt "Riemann/")
    (exp? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (MULT adt-constructor-decl
     "[[RiemannExpr, RiemannExpr] -> (mult?)]" RiemannExpr_adt
     "Riemann/")
    (mult? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (Eval_real def-decl "[real -> real]" riemann_expr_eval "Riemann/")
    (RiemannExpr type-decl nil RiemannExpr_adt "Riemann/")
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     "Riemann/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx "Riemann/")
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (Eval def-decl "[Interval -> Interval]" riemann_expr_eval
     "Riemann/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (partition type-eq-decl nil integral_def "analysis/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (below type-eq-decl nil nat_types nil)
    (above nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx
     "Riemann/")
    (subrange type-eq-decl nil integers nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Eval_inclusion formula-decl nil riemann_expr_eval "Riemann/")
    (f_bound_determines_locally_proper_results formula-decl nil
     Riemann_integ_interval_approx_perf "Riemann/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (R__ const-decl "Interval" Riemann_integ_interval_approx_perf
     "Riemann/")
    (RiemannSum_R2I_tr const-decl "Interval"
     Riemann_integ_interval_approx_perf "Riemann/")
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx
     "Riemann/")
    (subrange type-eq-decl nil subrange_type nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (* const-decl "[T -> real]" real_fun_ops "reals/")
    (ln const-decl "real" ln_exp "lnexp_fnd/")
    (exp const-decl "{py | x = ln(py)}" ln_exp "lnexp_fnd/")
    (cos const-decl "real" sincos_def "trig/")
    (|##| const-decl "bool" interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (locallyProper? const-decl "bool"
     Riemann_integ_interval_approx_perf "Riemann/")
    (integral const-decl "{S: real | integral?(a, b, ff, S)}"
     integral_def "analysis/")
    (integral? const-decl "bool" integral_def "analysis/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (LocallyProper type-eq-decl nil Riemann_integ_interval_approx_perf
     "Riemann/")
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (tr_Riemann_correctness formula-decl nil
     Riemann_integ_interval_approx_perf "Riemann/")
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ub_interval formula-decl nil interval "interval_arith/")
    (lb_interval formula-decl nil interval "interval_arith/")
    (posint_exp application-judgement "posint" exponentiation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (Eval_cont_fun formula-decl nil riemann_expr_eval "Riemann/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx "Riemann/"))
   shostak)
  (expcos-6 "" 3781362685
   ("" (lemma "Simple_Riemann_Soundness")
    ((""
      (inst -1 "[|0,1|]" "riemann_expr_eval.Eval_real(MULT(EXP, COS))"
       "12" "1")
      (("1" (assert)
        (("1" (inst -1 "riemann_expr_eval.Eval(MULT(EXP, COS))")
          (("1"
            (use "faster_Riemann_correctness"
                 ("epsilon" "((1-0)/(2^(12*8)))"))
            (("1" (assert)
              (("1" (hide -2)
                (("1" (invoke (eval-expr "%1") (! -1 2))
                  (("1" (replace -1 :hide? t)
                    (("1"
                      (case "riemann_expr_eval.Eval_real(MULT(EXP, COS)) = exp * cos")
                      (("1" (replace -1 :hide? t)
                        (("1" (postpone) nil nil)) nil)
                       ("2" (expand "Eval_real")
                        (("2" (expand "Eval_real")
                          (("2" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide-all-but 1)
              (("2" (expand "locallyProper?")
                (("2" (skeep)
                  (("2"
                    (lemma "f_bound_determines_locally_proper_results")
                    (("2" (inst? -1 :subst ("a" "0" "b" "1"))
                      (("2" (assert)
                        (("2" (inst? -1 :where 1)
                          (("2"
                            (inst -1
                             "riemann_expr_eval.Eval_real(MULT(EXP, COS))")
                            (("2" (assert)
                              (("2"
                                (hide-all-but 1)
                                (("2"
                                  (inclus-fun "Eval_inclusion")
                                  nil
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (eval-formula) nil nil))
            nil)
           ("2" (expand "F_Bound?")
            (("2" (skosimp*)
              (("2" (lemma "Eval_inclusion")
                (("2" (inst?)
                  (("2" (inclus-fun "Eval_inclusion") nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (splt-tcs)
        (("1" (conts-Integ "Eval_cont_fun")
          (("1" (inst? -1) (("1" (Integ-integ-exp) nil nil)) nil)) nil)
         ("2" (lemma "Eval_inclusion")
          (("2" (inst? -1 :where 1)
            (("2"
              (invoke (inst? -1 ("p" "%1") :where 1) (? 1 "F(%1)(%2)"))
              (("2" (assert)
                (("2" (inst? -1 :where 1)
                  (("2" (inst? 1)
                    (("2" (skosimp*)
                      (("2" (inst -1 "x!1")
                        (("2" (typepred "x!1")
                          (("2" (expand "##") (("2" (propax) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (expand "StrictInterval?") (("3" (ground) nil nil)) nil))
      nil))
    nil)
   ((Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx "Riemann/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (Eval_cont_fun formula-decl nil riemann_expr_eval "Riemann/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (subrange type-eq-decl nil subrange_type nil)
    (integrable? const-decl "bool" integral_def "analysis/")
    (integral? const-decl "bool" integral_def "analysis/")
    (integral const-decl "{S: real | integral?(a, b, ff, S)}"
     integral_def "analysis/")
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (cos const-decl "real" sincos_def "trig/")
    (exp const-decl "{py | x = ln(py)}" ln_exp "lnexp_fnd/")
    (ln const-decl "real" ln_exp "lnexp_fnd/")
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx
     "Riemann/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (Eval_inclusion formula-decl nil riemann_expr_eval "Riemann/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (subrange type-eq-decl nil integers nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx
     "Riemann/")
    (< const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil nat_types nil)
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def "analysis/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (Eval def-decl "[Interval -> Interval]" riemann_expr_eval
     "Riemann/")
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx "Riemann/")
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     "Riemann/")
    (RiemannExpr type-decl nil RiemannExpr_adt "Riemann/")
    (Eval_real def-decl "[real -> real]" riemann_expr_eval "Riemann/")
    (mult? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (MULT adt-constructor-decl
     "[[RiemannExpr, RiemannExpr] -> (mult?)]" RiemannExpr_adt
     "Riemann/")
    (exp? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (EXP adt-constructor-decl "(exp?)" RiemannExpr_adt "Riemann/")
    (cos? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (COS adt-constructor-decl "(cos?)" RiemannExpr_adt "Riemann/")
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil))
   shostak)
  (expcos-5 "" 3781361134
   ("" (lemma "Simple_Riemann_Soundness")
    ((""
      (inst -1 "[|0, 1|]" "riemann_expr_eval.Eval_real(MULT(EXP, COS))"
       "12" "4")
      (("1" (assert)
        (("1" (inst -1 "riemann_expr_eval.Eval(MULT(EXP, COS))")
          (("1"
            (use "faster_Riemann_correctness" ("epsilon" "1/2^(12*8)"))
            (("1" (assert)
              (("1" (hide -2)
                (("1" (invoke (eval-expr "%1") (! -1 2))
                  (("1" (replace -1 :hide? t)
                    (("1"
                      (invoke (case "%1 = %2")
                       "riemann_expr_eval.Eval_real(MULT(EXP, COS))"
                       "exp * cos")
                      (("1" (replace -1 :hide? t)
                        (("1" (expand "##")
                          (("1" (flatten) (("1" (assert) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand "Eval_real")
                        (("2" (expand "Eval_real")
                          (("2" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (inclus-fun "Eval_inclusion") nil nil))
          nil))
        nil)
       ("2" (soundness1 "Eval_inclusion" "Eval_cont_fun") nil nil)
       ("3" (expand "StrictInterval?") (("3" (ground) nil nil)) nil))
      nil))
    nil)
   ((real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (real nonempty-type-from-decl nil reals nil)
    (COS adt-constructor-decl "(cos?)" RiemannExpr_adt "Riemann/")
    (cos? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (EXP adt-constructor-decl "(exp?)" RiemannExpr_adt "Riemann/")
    (exp? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (MULT adt-constructor-decl
     "[[RiemannExpr, RiemannExpr] -> (mult?)]" RiemannExpr_adt
     "Riemann/")
    (mult? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (Eval_real def-decl "[real -> real]" riemann_expr_eval "Riemann/")
    (RiemannExpr type-decl nil RiemannExpr_adt "Riemann/")
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     "Riemann/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx "Riemann/")
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (Eval def-decl "[Interval -> Interval]" riemann_expr_eval
     "Riemann/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (partition type-eq-decl nil integral_def "analysis/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (below type-eq-decl nil nat_types nil)
    (above nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx
     "Riemann/")
    (subrange type-eq-decl nil integers nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx
     "Riemann/")
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (ln const-decl "real" ln_exp "lnexp_fnd/")
    (exp const-decl "{py | x = ln(py)}" ln_exp "lnexp_fnd/")
    (cos const-decl "real" sincos_def "trig/")
    (|##| const-decl "bool" interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (integral const-decl "{S: real | integral?(a, b, ff, S)}"
     integral_def "analysis/")
    (integral? const-decl "bool" integral_def "analysis/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (subrange type-eq-decl nil subrange_type nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Eval_inclusion formula-decl nil riemann_expr_eval "Riemann/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (ub_interval formula-decl nil interval "interval_arith/")
    (lb_interval formula-decl nil interval "interval_arith/")
    (posint_exp application-judgement "posint" exponentiation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (Eval_cont_fun formula-decl nil riemann_expr_eval "Riemann/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx "Riemann/"))
   shostak)
  (expcos-4 "" 3781281278
   ("" (riemann-numerical "exp * cos" "[|0, 1|]" :precision 4) nil nil)
   ((real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (real nonempty-type-from-decl nil reals nil)
    (COS adt-constructor-decl "(cos?)" RiemannExpr_adt "Riemann/")
    (cos? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (EXP adt-constructor-decl "(exp?)" RiemannExpr_adt "Riemann/")
    (exp? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (MULT adt-constructor-decl
     "[[RiemannExpr, RiemannExpr] -> (mult?)]" RiemannExpr_adt
     "Riemann/")
    (mult? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (Eval_real def-decl "[real -> real]" riemann_expr_eval "Riemann/")
    (RiemannExpr type-decl nil RiemannExpr_adt "Riemann/")
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     "Riemann/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx "Riemann/")
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (Eval def-decl "[Interval -> Interval]" riemann_expr_eval
     "Riemann/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (partition type-eq-decl nil integral_def "analysis/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (below type-eq-decl nil nat_types nil)
    (above nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx
     "Riemann/")
    (subrange type-eq-decl nil integers nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx
     "Riemann/")
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (cos const-decl "real" sincos_def "trig/")
    (exp const-decl "{py | x = ln(py)}" ln_exp "lnexp_fnd/")
    (ln const-decl "real" ln_exp "lnexp_fnd/")
    (posreal nonempty-type-eq-decl nil real_types nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (integral const-decl "{S: real | integral?(a, b, ff, S)}"
     integral_def "analysis/")
    (integral? const-decl "bool" integral_def "analysis/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (subrange type-eq-decl nil subrange_type nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Eval_inclusion formula-decl nil riemann_expr_eval "Riemann/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ub_interval formula-decl nil interval "interval_arith/")
    (lb_interval formula-decl nil interval "interval_arith/")
    (posint_exp application-judgement "posint" exponentiation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (Eval_cont_fun formula-decl nil riemann_expr_eval "Riemann/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx "Riemann/"))
   shostak)
  (expcos-3 "" 3781280751
   ("" (lemma "Simple_Riemann_Soundness")
    ((""
      (inst -1 "[|0, 1|]" "riemann_expr_eval.Eval_real(MULT(EXP, COS))"
       "12" "4")
      (("1" (assert)
        (("1" (inst -1 "riemann_expr_eval.Eval(MULT(EXP, COS))")
          (("1" (invoke (eval-expr "%1") (! -1 2))
            (("1" (replace -1 :hide? t)
              (("1"
                (invoke (case "%1 = %2")
                 "riemann_expr_eval.Eval_real(MULT(EXP, COS))"
                 "exp * cos")
                (("1" (replace -1 :hide? t)
                  (("1" (expand "##")
                    (("1" (flatten) (("1" (assert) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (expand "Eval_real")
                  (("2" (expand "Eval_real") (("2" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (inclus-fun "Eval_inclusion") nil nil))
          nil))
        nil)
       ("2" (soundness1 "Eval_inclusion" "Eval_cont_fun") nil nil)
       ("3" (expand "StrictInterval?") (("3" (ground) nil nil)) nil))
      nil))
    nil)
   ((Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx "Riemann/")
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (Eval_cont_fun formula-decl nil riemann_expr_eval "Riemann/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Eval_inclusion formula-decl nil riemann_expr_eval "Riemann/")
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (R const-decl "Interval" Riemann_integ_interval_approx "Riemann/")
    (RiemannSum_R2I def-decl "Interval" Riemann_integ_interval_approx
     "Riemann/")
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx
     "Riemann/")
    (subrange type-eq-decl nil subrange_type nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (ln const-decl "real" ln_exp "lnexp_fnd/")
    (exp const-decl "{py | x = ln(py)}" ln_exp "lnexp_fnd/")
    (cos const-decl "real" sincos_def "trig/")
    (|##| const-decl "bool" interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (subrange type-eq-decl nil integers nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx
     "Riemann/")
    (< const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil nat_types nil)
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def "analysis/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (Eval def-decl "[Interval -> Interval]" riemann_expr_eval
     "Riemann/")
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx "Riemann/")
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     "Riemann/")
    (RiemannExpr type-decl nil RiemannExpr_adt "Riemann/")
    (Eval_real def-decl "[real -> real]" riemann_expr_eval "Riemann/")
    (mult? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (MULT adt-constructor-decl
     "[[RiemannExpr, RiemannExpr] -> (mult?)]" RiemannExpr_adt
     "Riemann/")
    (exp? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (EXP adt-constructor-decl "(exp?)" RiemannExpr_adt "Riemann/")
    (cos? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (COS adt-constructor-decl "(cos?)" RiemannExpr_adt "Riemann/")
    (real nonempty-type-from-decl nil reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil))
   shostak)
  (expcos-2 "" 3780938038
   ("" (lemma "Simple_Riemann_Soundness")
    ((""
      (inst -1 "[|0, 1|]" "riemann_expr_eval.Eval_real(MULT(EXP, COS))"
       "12" "4")
      (("1" (assert)
        (("1" (inst -1 "riemann_expr_eval.Eval(MULT(EXP, COS))")
          (("1"
            (invoke (eval-expr "best_rational(%1`lb - 1/2^%2, %1`lb)")
             (! -1 2) "16")
            (("1"
              (invoke
               (eval-expr "best_rational(%1`ub, %1`ub + 1/2^%2)")
               (! -2 2) "16")
              (("1" (invoke (name "r_38" "%1") (! -3 2))
                (("1" (replaces -1)
                  (("1"
                    (invoke (case "%1 ## [|%2, %3|]") (! -3 1) (! -2 1)
                     (! -1 1))
                    (("1" (replaces -2)
                      (("1" (replaces -2)
                        (("1" (delete -2)
                          (("1"
                            (invoke (case "%1 = %2")
                             "riemann_expr_eval.Eval_real(MULT(EXP, COS))"
                             "exp * cos")
                            (("1" (replaces -1)
                              (("1" (postpone) nil nil)) nil)
                             ("2" (expand "Eval_real")
                              (("2"
                                (expand "Eval_real")
                                (("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (invoke (typepred "%1") (! -1 1))
                      (("2" (invoke (typepred "%1") (! -4 1))
                        (("2" (delete (-1 -4))
                          (("2" (expand "##")
                            (("2" (flatten) (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (inclus-fun "Eval_inclusion") nil nil))
          nil))
        nil)
       ("2" (soundness1 "Eval_inclusion" "Eval_cont_fun") nil nil)
       ("3" (expand "StrictInterval?") (("3" (ground) nil nil)) nil))
      nil))
    nil)
   ((real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (real nonempty-type-from-decl nil reals nil)
    (COS adt-constructor-decl "(cos?)" RiemannExpr_adt "Riemann/")
    (cos? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (EXP adt-constructor-decl "(exp?)" RiemannExpr_adt "Riemann/")
    (exp? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (MULT adt-constructor-decl
     "[[RiemannExpr, RiemannExpr] -> (mult?)]" RiemannExpr_adt
     "Riemann/")
    (mult? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (Eval_real def-decl "[real -> real]" riemann_expr_eval "Riemann/")
    (RiemannExpr type-decl nil RiemannExpr_adt "Riemann/")
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     "Riemann/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx "Riemann/")
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (Eval def-decl "[Interval -> Interval]" riemann_expr_eval
     "Riemann/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (partition type-eq-decl nil integral_def "analysis/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (below type-eq-decl nil nat_types nil)
    (above nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx
     "Riemann/")
    (subrange type-eq-decl nil integers nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (ln const-decl "real" ln_exp "lnexp_fnd/")
    (exp const-decl "{py | x = ln(py)}" ln_exp "lnexp_fnd/")
    (cos const-decl "real" sincos_def "trig/")
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (subrange type-eq-decl nil subrange_type nil)
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx
     "Riemann/")
    (RiemannSum_R2I def-decl "Interval" Riemann_integ_interval_approx
     "Riemann/")
    (R const-decl "Interval" Riemann_integ_interval_approx "Riemann/")
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (Eval_inclusion formula-decl nil riemann_expr_eval "Riemann/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ub_interval formula-decl nil interval "interval_arith/")
    (lb_interval formula-decl nil interval "interval_arith/")
    (posint_exp application-judgement "posint" exponentiation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (Eval_cont_fun formula-decl nil riemann_expr_eval "Riemann/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx "Riemann/"))
   shostak)
  (expcos-1 nil 3679760497
   (""
    (then (riemann-numerical "exp * cos" "[|0, 1|]" :precision 4)
     (expand "##") (flatten) (assert))
    nil nil)
   ((cos const-decl "real" sincos_def "trig/")
    (exp const-decl "{py | x = ln(py)}" ln_exp "lnexp_fnd/")
    (ln const-decl "real" ln_exp "lnexp_fnd/")
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (integral const-decl "{S: real | integral?(a, b, ff, S)}"
     integral_def "analysis/")
    (integral? const-decl "bool" integral_def "analysis/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (real_plus_real_is_real application-judgement "real" reals nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (R const-decl "Interval" Riemann_integ_interval_approx "Riemann/")
    (RiemannSum_R2I def-decl "Interval" Riemann_integ_interval_approx
     "Riemann/")
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx
     "Riemann/")
    (subrange type-eq-decl nil subrange_type nil)
    (best_rational const-decl "{q: rat | r1 <= q AND q <= r2}"
     best_rational "reals/")
    (rat nonempty-type-eq-decl nil rationals nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (partition type-eq-decl nil integral_def "analysis/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (above nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx
     "Riemann/")
    (subrange type-eq-decl nil integers nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (Eval def-decl "[Interval -> Interval]" riemann_expr_eval
     "Riemann/")
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (Eval_inclusion formula-decl nil riemann_expr_eval "Riemann/")
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (Eval_cont_fun formula-decl nil riemann_expr_eval "Riemann/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (real nonempty-type-from-decl nil reals nil)
    (COS adt-constructor-decl "(cos?)" RiemannExpr_adt "Riemann/")
    (cos? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (EXP adt-constructor-decl "(exp?)" RiemannExpr_adt "Riemann/")
    (exp? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (MULT adt-constructor-decl
     "[[RiemannExpr, RiemannExpr] -> (mult?)]" RiemannExpr_adt
     "Riemann/")
    (mult? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (Eval_real def-decl "[real -> real]" riemann_expr_eval "Riemann/")
    (RiemannExpr type-decl nil RiemannExpr_adt "Riemann/")
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     "Riemann/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx "Riemann/")
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx "Riemann/"))
   shostak))
 (sin_half_period_TCC1 0
  (sin_half_period_TCC1-1 nil 3679909982 ("" (prove-integrable?))
   ((SIN adt-constructor-decl "(sin?)" RiemannExpr_adt "Riemann/")
    (sin? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (Eval_real def-decl "[real -> real]" riemann_expr_eval "Riemann/")
    (RiemannExpr type-decl nil RiemannExpr_adt "Riemann/")
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (integrable? const-decl "bool" integral_def "analysis/")
    (< const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (Integrable? const-decl "bool" integral_def "analysis/")
    (Eval_cont_fun formula-decl nil riemann_expr_eval "Riemann/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element_real formula-decl nil deriv_domain "analysis/"))
   nil))
 (sin_half_period 0
  (sin_half_period-1 nil 3679909983 ("" (riemann-numerical) nil nil)
   ((posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (real nonempty-type-from-decl nil reals nil)
    (SIN adt-constructor-decl "(sin?)" RiemannExpr_adt "Riemann/")
    (sin? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (Eval_real def-decl "[real -> real]" riemann_expr_eval "Riemann/")
    (RiemannExpr type-decl nil RiemannExpr_adt "Riemann/")
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     "Riemann/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx "Riemann/")
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (Eval def-decl "[Interval -> Interval]" riemann_expr_eval
     "Riemann/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (partition type-eq-decl nil integral_def "analysis/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (below type-eq-decl nil nat_types nil)
    (above nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx
     "Riemann/")
    (subrange type-eq-decl nil integers nil)
    (^ const-decl "real" exponentiation nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Eval_inclusion formula-decl nil riemann_expr_eval "Riemann/")
    (f_bound_determines_locally_proper_results formula-decl nil
     Riemann_integ_interval_approx_perf "Riemann/")
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (R__ const-decl "Interval" Riemann_integ_interval_approx_perf
     "Riemann/")
    (RiemannSum_R2I_tr const-decl "Interval"
     Riemann_integ_interval_approx_perf "Riemann/")
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx
     "Riemann/")
    (subrange type-eq-decl nil subrange_type nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (sin const-decl "real" sincos_def "trig/")
    (|##| const-decl "bool" interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (locallyProper? const-decl "bool"
     Riemann_integ_interval_approx_perf "Riemann/")
    (integral const-decl "{S: real | integral?(a, b, ff, S)}"
     integral_def "analysis/")
    (integral? const-decl "bool" integral_def "analysis/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (LocallyProper type-eq-decl nil Riemann_integ_interval_approx_perf
     "Riemann/")
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (tr_Riemann_correctness formula-decl nil
     Riemann_integ_interval_approx_perf "Riemann/")
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ub_interval formula-decl nil interval "interval_arith/")
    (lb_interval formula-decl nil interval "interval_arith/")
    (posint_exp application-judgement "posint" exponentiation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (Eval_cont_fun formula-decl nil riemann_expr_eval "Riemann/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx "Riemann/"))
   shostak))
 (square_TCC1 0
  (square_TCC1-1 nil 3679931280 ("" (prove-integrable?))
   ((ID adt-constructor-decl "(id?)" RiemannExpr_adt "Riemann/")
    (id? adt-recognizer-decl "[RiemannExpr -> boolean]" RiemannExpr_adt
     "Riemann/")
    (POW adt-constructor-decl "[[RiemannExpr, nat] -> (pow?)]"
     RiemannExpr_adt "Riemann/")
    (pow? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (CONST adt-constructor-decl "[rat -> (const?)]" RiemannExpr_adt
     "Riemann/")
    (const? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (rat nonempty-type-eq-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (MULT adt-constructor-decl
     "[[RiemannExpr, RiemannExpr] -> (mult?)]" RiemannExpr_adt
     "Riemann/")
    (mult? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (Eval_real def-decl "[real -> real]" riemann_expr_eval "Riemann/")
    (RiemannExpr type-decl nil RiemannExpr_adt "Riemann/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (< const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (* const-decl "[T -> real]" real_fun_ops "reals/")
    (* const-decl "[T -> real]" real_fun_ops "reals/")
    (idr const-decl "real" riemann_expr_eval "Riemann/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (Integrable? const-decl "bool" integral_def "analysis/")
    (Eval_cont_fun formula-decl nil riemann_expr_eval "Riemann/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element_real formula-decl nil deriv_domain "analysis/"))
   nil))
 (square 0
  (square-1 nil 3679931281 ("" (riemann-numerical) nil nil)
   (([\|\|] const-decl "Interval" interval "interval_arith/")
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (real nonempty-type-from-decl nil reals nil)
    (ID adt-constructor-decl "(id?)" RiemannExpr_adt "Riemann/")
    (id? adt-recognizer-decl "[RiemannExpr -> boolean]" RiemannExpr_adt
     "Riemann/")
    (POW adt-constructor-decl "[[RiemannExpr, nat] -> (pow?)]"
     RiemannExpr_adt "Riemann/")
    (pow? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (CONST adt-constructor-decl "[rat -> (const?)]" RiemannExpr_adt
     "Riemann/")
    (const? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (rat nonempty-type-eq-decl nil rationals nil)
    (MULT adt-constructor-decl
     "[[RiemannExpr, RiemannExpr] -> (mult?)]" RiemannExpr_adt
     "Riemann/")
    (mult? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (Eval_real def-decl "[real -> real]" riemann_expr_eval "Riemann/")
    (RiemannExpr type-decl nil RiemannExpr_adt "Riemann/")
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     "Riemann/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx "Riemann/")
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (Eval def-decl "[Interval -> Interval]" riemann_expr_eval
     "Riemann/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (partition type-eq-decl nil integral_def "analysis/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (below type-eq-decl nil nat_types nil)
    (above nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx
     "Riemann/")
    (subrange type-eq-decl nil integers nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (int_times_even_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Eval_inclusion formula-decl nil riemann_expr_eval "Riemann/")
    (f_bound_determines_locally_proper_results formula-decl nil
     Riemann_integ_interval_approx_perf "Riemann/")
    (even_minus_even_is_even application-judgement "even_int" integers
     nil)
    (R__ const-decl "Interval" Riemann_integ_interval_approx_perf
     "Riemann/")
    (RiemannSum_R2I_tr const-decl "Interval"
     Riemann_integ_interval_approx_perf "Riemann/")
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx
     "Riemann/")
    (subrange type-eq-decl nil subrange_type nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (* const-decl "[T -> real]" real_fun_ops "reals/")
    (^ const-decl "[T -> real]" real_fun_ops "reals/")
    (idr const-decl "real" riemann_expr_eval "Riemann/")
    (|##| const-decl "bool" interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (* const-decl "[T -> real]" real_fun_ops "reals/")
    (locallyProper? const-decl "bool"
     Riemann_integ_interval_approx_perf "Riemann/")
    (integral const-decl "{S: real | integral?(a, b, ff, S)}"
     integral_def "analysis/")
    (integral? const-decl "bool" integral_def "analysis/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (LocallyProper type-eq-decl nil Riemann_integ_interval_approx_perf
     "Riemann/")
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (tr_Riemann_correctness formula-decl nil
     Riemann_integ_interval_approx_perf "Riemann/")
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ub_interval formula-decl nil interval "interval_arith/")
    (lb_interval formula-decl nil interval "interval_arith/")
    (posint_exp application-judgement "posint" exponentiation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (Eval_cont_fun formula-decl nil riemann_expr_eval "Riemann/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx "Riemann/"))
   shostak))
 (comp_TCC1 0
  (comp_TCC1-1 nil 3679931847 ("" (prove-integrable?))
   ((COS adt-constructor-decl "(cos?)" RiemannExpr_adt "Riemann/")
    (cos? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (EXP adt-constructor-decl "(exp?)" RiemannExpr_adt "Riemann/")
    (exp? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (COMP adt-constructor-decl
     "[[RiemannExpr, RiemannExpr] -> (comp?)]" RiemannExpr_adt
     "Riemann/")
    (comp? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (Eval_real def-decl "[real -> real]" riemann_expr_eval "Riemann/")
    (RiemannExpr type-decl nil RiemannExpr_adt "Riemann/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (< const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (Integrable? const-decl "bool" integral_def "analysis/")
    (Eval_cont_fun formula-decl nil riemann_expr_eval "Riemann/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (not_one_element_real formula-decl nil deriv_domain "analysis/"))
   nil))
 (comp 0
  (comp-1 nil 3679931848 ("" (riemann-numerical) nil nil)
   (([\|\|] const-decl "Interval" interval "interval_arith/")
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (StrictInterval? const-decl "bool" interval "interval_arith/")
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (real nonempty-type-from-decl nil reals nil)
    (COS adt-constructor-decl "(cos?)" RiemannExpr_adt "Riemann/")
    (cos? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (EXP adt-constructor-decl "(exp?)" RiemannExpr_adt "Riemann/")
    (exp? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (COMP adt-constructor-decl
     "[[RiemannExpr, RiemannExpr] -> (comp?)]" RiemannExpr_adt
     "Riemann/")
    (comp? adt-recognizer-decl "[RiemannExpr -> boolean]"
     RiemannExpr_adt "Riemann/")
    (Eval_real def-decl "[real -> real]" riemann_expr_eval "Riemann/")
    (RiemannExpr type-decl nil RiemannExpr_adt "Riemann/")
    (integ_inclus_fun? const-decl "bool" Riemann_integ_interval_approx
     "Riemann/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (StrictInterval type-eq-decl nil interval "interval_arith/")
    (Integ_Inclusion_fun nonempty-type-eq-decl nil
     Riemann_integ_interval_approx "Riemann/")
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (Eval def-decl "[Interval -> Interval]" riemann_expr_eval
     "Riemann/")
    (eq_partition const-decl "partition(a, b)" integral_def
     "analysis/")
    (partition type-eq-decl nil integral_def "analysis/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (closed_interval type-eq-decl nil intervals_real "reals/")
    (below type-eq-decl nil nat_types nil)
    (above nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (F_Bound? const-decl "bool" Riemann_integ_interval_approx
     "Riemann/")
    (subrange type-eq-decl nil integers nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Eval_inclusion formula-decl nil riemann_expr_eval "Riemann/")
    (f_bound_determines_locally_proper_results formula-decl nil
     Riemann_integ_interval_approx_perf "Riemann/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (R__ const-decl "Interval" Riemann_integ_interval_approx_perf
     "Riemann/")
    (RiemannSum_R2I_tr const-decl "Interval"
     Riemann_integ_interval_approx_perf "Riemann/")
    (Riem_sec_r2i type-eq-decl nil Riemann_integ_interval_approx
     "Riemann/")
    (subrange type-eq-decl nil subrange_type nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (O const-decl "T3" function_props nil)
    (ln const-decl "real" ln_exp "lnexp_fnd/")
    (exp const-decl "{py | x = ln(py)}" ln_exp "lnexp_fnd/")
    (cos const-decl "real" sincos_def "trig/")
    (|##| const-decl "bool" interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (locallyProper? const-decl "bool"
     Riemann_integ_interval_approx_perf "Riemann/")
    (integral const-decl "{S: real | integral?(a, b, ff, S)}"
     integral_def "analysis/")
    (integral? const-decl "bool" integral_def "analysis/")
    (integrable? const-decl "bool" integral_def "analysis/")
    (LocallyProper type-eq-decl nil Riemann_integ_interval_approx_perf
     "Riemann/")
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (tr_Riemann_correctness formula-decl nil
     Riemann_integ_interval_approx_perf "Riemann/")
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ub_interval formula-decl nil interval "interval_arith/")
    (lb_interval formula-decl nil interval "interval_arith/")
    (posint_exp application-judgement "posint" exponentiation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (not_one_element_real formula-decl nil deriv_domain "analysis/")
    (not_one_element? const-decl "bool" deriv_domain_def "analysis/")
    (connected? const-decl "bool" deriv_domain_def "analysis/")
    (fundamental_indef formula-decl nil indefinite_integral
     "analysis/")
    (Eval_cont_fun formula-decl nil riemann_expr_eval "Riemann/")
    (Integrable? const-decl "bool" integral_def "analysis/")
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Simple_Riemann_Soundness formula-decl nil
     Riemann_integ_interval_approx "Riemann/"))
   shostak)))

