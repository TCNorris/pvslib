(replacement (replaceTerm_TCC1 0 (replaceTerm_TCC1-2 "" 3790333368 ("" (skosimp*) nil nil) nil shostak (replaceTerm subtype "replacement.p" "not_empty_seq[posnat]")) (replaceTerm_TCC1-1 nil 3389903609 ("" (skosimp*) (("" (lemma "not_var") (("" (inst -1 "first(p!1)" "p!1" "rest(p!1)" "s!1") (("1" (typepred "p!1") (("1" (assert) (("1" (lemma "finite_sequences_extras[posnat].seq_first_rest") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) nil nil (replaceTerm subtype "replacement.p" "not_empty_seq[posnat]"))) (replaceTerm_TCC2 0 (replaceTerm_TCC2-1 nil 3389903609 ("" (skosimp*) (("" (typepred "p!1") (("" (expand "positionsOF") (("" (lift-if) (("" (prop) (("1" (expand "only_empty_seq") (("1" (rewrite "empty_0") nil nil)) nil) ("2" (expand "only_empty_seq") (("2" (rewrite "empty_0") nil nil)) nil) ("3" (expand "only_empty_seq") (("3" (hide -1) (("3" (rewrite "empty_0") nil nil)) nil)) nil) ("4" (expand "only_empty_seq") (("4" (hide -1) (("4" (rewrite "empty_0") nil nil)) nil)) nil) ("5" (assert) nil nil) ("6" (replaces -2) (("6" (expand* "union" "member") (("6" (prop) (("1" (expand "only_empty_seq") (("1" (rewrite "empty_0") nil nil)) nil) ("2" (expand "IUnion") (("2" (skolem * "j") (("2" (expand "catenate") (("2" (skolem * "p1") (("2" (flatten) (("2" (hide -1) (("2" (lemma "fsepn.seq_first_rest") (("2" (inst?) (("2" (assert) (("2" (replace -1 -2) (("2" (hide -1) (("2" (lemma "fsepn.first_equal") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (first_equal formula-decl nil seq_extras structures) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (<= const-decl "bool" reals nil) (first const-decl "T" seq_extras structures) (not_empty_seq type-eq-decl nil seq_extras structures) (/= const-decl "boolean" notequal nil) (rest const-decl "finseq" seq_extras structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (seq_first_rest formula-decl nil seq_extras structures) (catenate const-decl "positions" positions nil) (IUnion const-decl "set[T]" indexed_sets nil) (union const-decl "set" sets nil) (member const-decl "bool" sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (only_empty_seq const-decl "positions" positions nil) (finseq type-eq-decl nil finite_sequences nil) (empty_0 formula-decl nil seq_extras structures)) nil (replaceTerm subtype "(number_fields.-)(replacement.i, 1)" "below[length(st)]"))) (replaceTerm_TCC3 0 (replaceTerm_TCC3-1 nil 3389903609 ("" (skosimp*) (("" (typepred "p!1") (("" (expand "positionsOF" -1) (("" (lift-if) (("" (prop) (("1" (expand "only_empty_seq") (("1" (rewrite "empty_0") nil nil)) nil) ("2" (expand "only_empty_seq") (("2" (rewrite "empty_0") nil nil)) nil) ("3" (expand* "union" "member") (("3" (prop) (("1" (expand "only_empty_seq") (("1" (rewrite "empty_0") nil nil)) nil) ("2" (expand "IUnion") (("2" (skolem * "i1") (("2" (expand "catenate") (("2" (skolem * "y1") (("2" (expand "member") (("2" (flatten) (("2" (lemma "fsepn.first_equal") (("2" (inst -1 "q!1" "y1" "i!1" "i1") (("2" (prop) (("1" (replaces -1) (("1" (replaces -1) (("1" (replaces -3) nil nil)) nil)) nil) ("2" (lemma "fsepn.seq_first_rest") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (IUnion const-decl "set[T]" indexed_sets nil) (catenate const-decl "positions" positions nil) (first_equal formula-decl nil seq_extras structures) (TRUE const-decl "bool" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (seq_first_rest formula-decl nil seq_extras structures) (<= const-decl "bool" reals nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (only_empty_seq const-decl "positions" positions nil) (finseq type-eq-decl nil finite_sequences nil) (empty_0 formula-decl nil seq_extras structures)) nil (replaceTerm subtype "replacement.q" "positions[replacement.variable, replacement.symbol, replacement.arity].positions?(finite_sequences[term_adt[replacement.variable, replacement.symbol, replacement.arity].term].finseq_appl(replacement.st)((number_fields.-)(replacement.i, 1)))"))) (replaceTerm_TCC4 0 (replaceTerm_TCC4-1 nil 3389903609 ("" (skosimp*) (("" (replaces -3) (("" (rewrite "length_rest") nil nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length_rest formula-decl nil seq_extras structures)) nil (replaceTerm termination "replacement.replaceTerm(finite_sequences[term_adt[replacement.variable, replacement.symbol, replacement.arity].term].finseq_appl(replacement.st)((number_fields.-)(replacement.i, 1)), replacement.t, replacement.q)" "nil"))) (replaceTerm_TCC5 0 (replaceTerm_TCC5-1 nil 3389903609 ("" (termination-tcc) nil nil) ((positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (below type-eq-decl nil nat_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (only_empty_seq const-decl "positions" positions nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (first const-decl "T" seq_extras structures) (empty_seq const-decl "finseq" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (^ const-decl "finseq" finite_sequences nil) (rest const-decl "finseq" seq_extras structures) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (replace const-decl "finseq" seq_extras structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (replaceTerm subtype "replacement.s" "(term_adt[replacement.variable, replacement.symbol, replacement.arity].app?)"))) (replaceTerm_TCC6 0 (replaceTerm_TCC6-1 nil 3389903609 ("" (termination-tcc) nil nil) ((positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (below type-eq-decl nil nat_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (first const-decl "T" seq_extras structures) (empty_seq const-decl "finseq" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (^ const-decl "finseq" finite_sequences nil) (rest const-decl "finseq" seq_extras structures) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (replace const-decl "finseq" seq_extras structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (replaceTerm subtype "replacement.rst" "{args: finite_sequences[term_adt[replacement.variable, replacement.symbol, replacement.arity].term].finite_sequence | args`length = replacement.arity(term_adt[replacement.variable, replacement.symbol, replacement.arity].f(replacement.s))}"))) (replaceTerm_TCC7 0 (replaceTerm_TCC7-1 nil 3516386077 ("" (skosimp*) (("" (lemma "not_var") (("" (inst -1 "first(p!1)" "p!1" "rest(p!1)" "s!1") (("1" (typepred "p!1") (("1" (assert) (("1" (lemma "seq_extras[posnat].seq_first_rest") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((arity formal-const-decl "[symbol -> nat]" replacement nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (not_var formula-decl nil positions nil) (NOT const-decl "[bool -> bool]" booleans nil) (seq_first_rest formula-decl nil seq_extras structures) (rest const-decl "finseq" seq_extras structures) (first const-decl "T" seq_extras structures) (not_empty_seq type-eq-decl nil seq_extras structures) (finseq type-eq-decl nil finite_sequences nil) (/= const-decl "boolean" notequal nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (s!1 skolem-const-decl "term" replacement nil) (positions? type-eq-decl nil positions nil) (p!1 skolem-const-decl "positions?[variable, symbol, arity](s!1)" replacement nil)) nil (replaceTerm subtype "replacement.s" "(term_adt[replacement.variable, replacement.symbol, replacement.arity].app?)"))) (replace_preserv_pos 0 (replace_preserv_pos-1 nil 3432995634 ("" (measure-induct+ "length(p)" "p") (("" (skeep) (("" (name-replace "rp" "replaceTerm(s, t, x!1)" :hide? nil) (("" (expand "replaceTerm" -1) (("" (lift-if) (("" (prop) (("1" (hide -3) (("1" (expand "positionsOF" 1) (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (rewrite "empty_0") nil nil)) nil) ("2" (expand "only_empty_seq") (("2" (rewrite "empty_0") nil nil)) nil) ("3" (expand* "union" "member") (("3" (prop) (("3" (expand "only_empty_seq") (("3" (rewrite "empty_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (copy -1) (("2" (decompose-equality -1) (("2" (hide (-1 -2)) (("2" (expand "positionsOF" 2) (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (expand "replace" -2) (("2" (lift-if) (("2" (prop) (("1" (hide-all-but (-1 -6 1 2)) (("1" (expand "positionsOF") (("1" (lift-if) (("1" (prop) nil nil)) nil)) nil)) nil) ("2" (decompose-equality -1) (("2" (hide (-2 -4)) (("2" (expand "positionsOF" -4) (("2" (lift-if) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand* "union" "member") (("3" (prop) (("3" (expand "only_empty_seq") (("3" (expand "finseq_appl") (("3" (inst -3 "rest(x!1)") (("3" (inst -3 "args(s)(first(x!1) - 1)" "t") (("1" (prop) (("1" (hide -3) (("1" (expand "IUnion") (("1" (inst 3 "first(x!1)") (("1" (expand "catenate") (("1" (inst 3 "rest(x!1)") (("1" (prop) (("1" (expand "member") (("1" (replace -2 1 rl) (("1" (hide -2) (("1" (lemma "fset.nth_x") (("1" (inst -1 "args(s)" "replaceTerm(args(s)(first(x!1) - 1), t, rest(x!1))" "first(x!1) - 1") (("1" (expand "finseq_appl") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 5)) (("2" (lemma "fsepn.seq_first_rest") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "replace") (("2" (lift-if) (("2" (prop) (("1" (expand "positionsOF") (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (propax) nil nil)) nil) ("2" (expand "only_empty_seq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality) (("2" (hide -2) (("2" (replace -1 2 rl) (("2" (hide -1) (("2" (expand "positionsOF") (("2" (lift-if) (("2" (prop) (("1" (expand "only_empty_seq") (("1" (propax) nil nil)) nil) ("2" (expand "only_empty_seq") (("2" (expand* "union" "member") (("2" (prop) (("2" (expand "IUnion") (("2" (skolem * "i1") (("2" (expand "catenate") (("2" (skolem * "y1") (("2" (expand "member") (("2" (flatten) (("2" (hide -1) (("2" (typepred "i1") (("2" (lemma "fsepn.first_equal") (("2" (inst -1 "rest(x!1)" "y1" "first(x!1)" "i1") (("2" (assert) (("2" (hide-all-but (-3 1 7)) (("2" (lemma "fsepn.seq_first_rest") (("2" (inst -1 "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1 3)) (("2" (expand "positionsOF" -1) (("2" (lift-if) (("2" (prop) (("1" (expand "only_empty_seq") (("1" (propax) nil nil)) nil) ("2" (expand "only_empty_seq") (("2" (propax) nil nil)) nil) ("3" (expand* "union" "member") (("3" (prop) (("1" (expand "only_empty_seq") (("1" (propax) nil nil)) nil) ("2" (expand "IUnion") (("2" (skolem * "i1") (("2" (expand "catenate") (("2" (skolem * "y1") (("2" (expand "member") (("2" (flatten) (("2" (lemma "fsepn.first_equal") (("2" (inst -1 "rest(x!1)" "y1" "first(x!1)" "i1") (("2" (prop) (("1" (assert) nil nil) ("2" (hide-all-but (-2 1 5)) (("2" (lemma "fsepn.seq_first_rest") (("2" (inst -1 "x!1") (("2" (assert) (("2" (prop) (("2" (rewrite "empty_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 6)) (("3" (rewrite "length_rest") nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq type-eq-decl nil finite_sequences nil) (empty_0 formula-decl nil seq_extras structures) (only_empty_seq const-decl "positions" positions nil) (union const-decl "set" sets nil) (member const-decl "bool" sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (replace const-decl "finseq" seq_extras structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (/= const-decl "boolean" notequal nil) (not_empty_seq type-eq-decl nil seq_extras structures) (first const-decl "T" seq_extras structures) (rest const-decl "finseq" seq_extras structures) (IFF const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (x!1 skolem-const-decl "position[variable, symbol, arity]" replacement nil) (length_rest formula-decl nil seq_extras structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (<= const-decl "bool" reals nil) (rp skolem-const-decl "term" replacement nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (seq_first_rest formula-decl nil seq_extras structures) (nth_x formula-decl nil seq_extras structures) (catenate const-decl "positions" positions nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (first_equal formula-decl nil seq_extras structures) (IUnion const-decl "set[T]" indexed_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (replaceTerm def-decl "term" replacement nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (term type-decl nil term_adt nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (replace_compose_pos 0 (replace_compose_pos-2 "" 3790333373 ("" (measure-induct+ "length(p)" "p") (("" (skeep) (("" (expand "positionsOF" -3) (("" (lift-if) (("" (prop) (("1" (hide -3) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.empty_0") (("1" (inst -1 "x!1") (("1" (assert) (("1" (expand "replaceTerm") (("1" (replaces -3) (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3) (("2" (expand "only_empty_seq") (("2" (lemma "fsepn.empty_0") (("2" (inst -1 "x!1") (("2" (assert) (("2" (expand "replaceTerm") (("2" (replaces -3) (("2" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand* "union" "member") (("3" (prop) (("1" (hide -2) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.empty_0") (("1" (inst -1 "x!1") (("1" (assert) (("1" (expand "replaceTerm") (("1" (replaces -2) (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name-replace "rp" "replaceTerm(s, t, x!1)" :hide? nil) (("2" (expand "replaceTerm" -1) (("2" (lift-if) (("2" (prop) (("1" (hide (-3 -4)) (("1" (rewrite "empty_0") (("1" (replaces -1) (("1" (replaces -1) (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil) ("2" (expand "IUnion") (("2" (skolem * "i1") (("2" (expand "catenate") (("2" (skolem * "y1") (("2" (expand "member") (("2" (flatten) (("2" (inst -4 "rest(x!1)") (("2" (inst -4 "q" "args(s)(first(x!1) - 1)" "t") (("1" (rewrite "length_rest") (("1" (assert) (("1" (lemma "fsepn.seq_first_rest") (("1" (inst?) (("1" (assert) (("1" (replace -1 -4) (("1" (lemma "fsepn.first_equal") (("1" (inst -1 "rest(x!1)" "y1" "first(x!1)" "i1") (("1" (assert) (("1" (flatten) (("1" (hide -6) (("1" (replace -1 * rl) (("1" (replace -2 * rl) (("1" (hide (-1 -2)) (("1" (decompose-equality -2) (("1" (hide -1) (("1" (copy -1) (("1" (expand "replace" -1) (("1" (decompose-equality -1) (("1" (hide -2) (("1" (expand "positionsOF" 4) (("1" (prop) (("1" (assert) nil nil) ("2" (hide -2) (("2" (expand* "union" "member") (("2" (prop) (("2" (expand "IUnion") (("2" (inst 3 "first(x!1)") (("1" (expand "catenate") (("1" (inst 3 "rest(x!1) o q") (("1" (prop) (("1" (expand "member") (("1" (replace -2 * rl) (("1" (lemma "fset.nth_x") (("1" (inst -1 "args(s)" "replaceTerm(args(s)(first(x!1) - 1), t, rest(x!1))" "first(x!1) - 1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 4)) (("2" (lemma "fsepn.add_first_compo") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -1) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (reveal -4) (("2" (typepred "i1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (union const-decl "set" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (IUnion const-decl "set[T]" indexed_sets nil) (catenate const-decl "positions" positions nil) (rest const-decl "finseq" seq_extras structures) (length_rest formula-decl nil seq_extras structures) (seq_first_rest formula-decl nil seq_extras structures) (first_equal formula-decl nil seq_extras structures) (replace const-decl "finseq" seq_extras structures) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rp skolem-const-decl "term" replacement nil) (add_first_compo formula-decl nil seq_extras structures) (nth_x formula-decl nil seq_extras structures) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (<= const-decl "bool" reals nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (x!1 skolem-const-decl "position[variable, symbol, arity]" replacement nil) (first const-decl "T" seq_extras structures) (not_empty_seq type-eq-decl nil seq_extras structures) (/= const-decl "boolean" notequal nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (empty_0 formula-decl nil seq_extras structures) (TRUE const-decl "bool" booleans nil) (empty_o_seq formula-decl nil seq_extras structures) (only_empty_seq const-decl "positions" positions nil) (O const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (replaceTerm def-decl "term" replacement nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (term type-decl nil term_adt nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak) (replace_compose_pos-1 nil 3432997519 ("" (measure-induct+ "length(p)" "p") (("" (skeep) (("" (expand "positionsOF" -3) (("" (lift-if) (("" (prop) (("1" (hide -3) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.empty_0") (("1" (inst -1 "x!1") (("1" (assert) (("1" (expand "replaceTerm") (("1" (replaces -5) (("1" (replaces -3) (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3) (("2" (expand "only_empty_seq") (("2" (lemma "fsepn.empty_0") (("2" (inst -1 "x!1") (("2" (assert) (("2" (expand "replaceTerm") (("2" (replaces -5) (("2" (replaces -3) (("2" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand* "union" "member") (("3" (prop) (("1" (hide -2) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.empty_0") (("1" (inst -1 "x!1") (("1" (assert) (("1" (expand "replaceTerm") (("1" (replaces -5) (("1" (replaces -4) (("1" (replaces -2) (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name-replace "rp" "replaceTerm(s, t, x!1)" :hide? nil) (("2" (expand "replaceTerm" -1) (("2" (lift-if) (("2" (prop) (("1" (hide (-3 -4)) (("1" (rewrite "empty_0") (("1" (replaces -1) (("1" (replaces -1) (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil) ("2" (expand "IUnion") (("2" (skolem * "i1") (("2" (expand "catenate") (("2" (skolem * "y1") (("2" (expand "member") (("2" (flatten) (("2" (inst -4 "rest(x!1)") (("2" (inst -4 "q" "args(s)(first(x!1) - 1)" "t") (("1" (rewrite "length_rest") (("1" (assert) (("1" (lemma "fsepn.seq_first_rest") (("1" (inst?) (("1" (assert) (("1" (replace -1 -4) (("1" (lemma "fsepn.first_equal") (("1" (inst -1 "rest(x!1)" "y1" "first(x!1)" "i1") (("1" (assert) (("1" (flatten) (("1" (hide -6) (("1" (replace -1 * rl) (("1" (replace -2 * rl) (("1" (hide (-1 -2)) (("1" (decompose-equality -2) (("1" (hide -1) (("1" (copy -1) (("1" (expand "replace" -1) (("1" (decompose-equality -1) (("1" (hide -2) (("1" (expand "positionsOF" 4) (("1" (prop) (("1" (assert) nil nil) ("2" (hide -2) (("2" (expand* "union" "member") (("2" (prop) (("2" (expand "IUnion") (("2" (inst 3 "first(x!1)") (("1" (expand "catenate") (("1" (inst 3 "rest(x!1) o q") (("1" (prop) (("1" (expand "member") (("1" (replace -2 * rl) (("1" (lemma "fset.nth_x") (("1" (inst -1 "args(s)" "replaceTerm(args(s)(first(x!1) - 1), t, rest(x!1))" "first(x!1) - 1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 4)) (("2" (lemma "fsepn.add_first_compo") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -1) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (reveal -4) (("2" (typepred "i1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((catenate const-decl "positions" positions nil) (rest const-decl "finseq" seq_extras structures) (length_rest formula-decl nil seq_extras structures) (seq_first_rest formula-decl nil seq_extras structures) (first_equal formula-decl nil seq_extras structures) (replace const-decl "finseq" seq_extras structures) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (add_first_compo formula-decl nil seq_extras structures) (nth_x formula-decl nil seq_extras structures) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (first const-decl "T" seq_extras structures) (not_empty_seq type-eq-decl nil seq_extras structures) (empty_0 formula-decl nil seq_extras structures) (empty_o_seq formula-decl nil seq_extras structures) (only_empty_seq const-decl "positions" positions nil) (O const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil)) shostak)) (replace_preserv_parallel_pos 0 (replace_preserv_parallel_pos-1 nil 3432999380 ("" (measure-induct+ "length(q)" "q") (("" (skeep) (("" (name-replace "rp" "replaceTerm(s, t, p)" :hide? nil) (("" (case "first(x!1)=first(p)") (("1" (expand "positionsOF" 1) (("1" (lift-if) (("1" (prop) (("1" (lemma "replace_preserv_pos") (("1" (inst?) (("1" (assert) (("1" (replaces -4) (("1" (hide-all-but (-1 -2 -7)) (("1" (expand "positionsOF") (("1" (expand "only_empty_seq") (("1" (expand "parallel") (("1" (expand "<=") (("1" (prop) (("1" (replaces -1) (("1" (inst 1 "x!1") (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "replace_preserv_pos") (("2" (inst?) (("2" (assert) (("2" (replaces -4) (("2" (hide-all-but (-1 -2 -7)) (("2" (expand "positionsOF") (("2" (expand "only_empty_seq") (("2" (expand "parallel") (("2" (expand "<=") (("2" (prop) (("2" (replaces -1) (("2" (inst 1 "x!1") (("2" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand* "union" "member" "only_empty_seq") (("3" (prop) (("3" (expand "IUnion") (("3" (inst 3 "first(p)") (("1" (expand "catenate") (("1" (inst 3 "rest(x!1)") (("1" (expand "member") (("1" (prop) (("1" (expand "finseq_appl") (("1" (expand "replaceTerm" -2) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but (-1 -7)) (("1" (expand* "parallel" "<=") (("1" (prop) (("1" (rewrite "empty_0") (("1" (replaces -1) (("1" (inst 1 "x!1") (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality -1) (("2" (replace -3 2 rl) (("2" (lemma "fset.nth_x") (("2" (name-replace "RT" "replaceTerm(args(s)(first(p) - 1), t, rest(p))") (("1" (inst -1 "args(s)" "RT" "first(p) - 1") (("1" (expand "finseq_appl") (("1" (replaces -1) (("1" (expand "RT") (("1" (inst -5 "rest(x!1)") (("1" (inst -5 "rest(p)" "args(s)(first(p) - 1)" "t") (("1" (rewrite "length_rest") (("1" (lemma "rest_of_positions") (("1" (inst -1 "x!1" "s") (("1" (lemma "rest_of_positions") (("1" (inst -1 "p" "s") (("1" (prop) (("1" (expand "finseq_appl") (("1" (replaces -6) nil nil)) nil) ("2" (rewrite "rest_parallel") (("2" (hide-all-but (1 6)) (("2" (prop) (("2" (rewrite "empty_0") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 5)) (("3" (rewrite "empty_0") nil nil)) nil) ("4" (hide-all-but (-1 5)) (("4" (rewrite "empty_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 5)) (("2" (prop) (("2" (rewrite "empty_0") nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 1 rl) (("2" (hide-all-but (1 3)) (("2" (rewrite "seq_first_rest") (("2" (prop) (("2" (rewrite "empty_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 1 rl) (("2" (typepred "args(rp)") (("2" (decompose-equality -3) (("2" (prop) (("2" (expand "replaceTerm" -3) (("2" (lift-if) (("2" (prop) (("1" (hide-all-but (-1 -11)) (("1" (expand* "parallel" "<=") (("1" (prop) (("1" (rewrite "empty_0") (("1" (replaces -1) (("1" (inst 1 "x!1") (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -6 -8 2 4)) (("2" (expand "positionsOF") (("2" (lift-if) (("2" (prop) (("1" (expand "only_empty_seq") (("1" (propax) nil nil)) nil) ("2" (expand "only_empty_seq") (("2" (propax) nil nil)) nil) ("3" (expand* "union" "member" "only_empty_seq") (("3" (prop) (("3" (expand "IUnion") (("3" (skolem * "j") (("3" (expand "catenate") (("3" (skolem * "y") (("3" (expand "member") (("3" (flatten) (("3" (typepred "j") (("3" (hide -3) (("3" (lemma "fsepn.seq_first_rest") (("3" (inst -1 "x!1") (("3" (prop) (("1" (replaces -1 -4) (("1" (lemma "fsepn.first_equal") (("1" (inst -1 "rest(x!1)" "y" "first(x!1)" "j") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "empty_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "parallel") (("2" (expand "<=") (("2" (prop) (("2" (expand "positionsOF" (-3 4)) (("2" (lift-if) (("2" (prop) (("1" (hide-all-but (-2 6)) (("1" (expand "only_empty_seq") (("1" (replaces -1) (("1" (inst 1 "p") (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 7)) (("2" (expand "only_empty_seq") (("2" (replaces -1) (("2" (inst 1 "p") (("2" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil) ("3" (lemma "replace_preserv_pos") (("3" (inst?) (("3" (assert) (("3" (replaces -4) (("3" (hide-all-but (-1 -2 5)) (("3" (expand "positionsOF") (("3" (expand "only_empty_seq") (("3" (replaces -1) (("3" (inst 1 "x!1") (("3" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "replace_preserv_pos") (("4" (inst?) (("4" (assert) (("4" (hide-all-but (-1 -2 6)) (("4" (expand "positionsOF") (("4" (expand "only_empty_seq") (("4" (replaces -1) (("4" (inst 1 "x!1") (("4" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand* "union" "member" "only_empty_seq") (("5" (prop) (("5" (expand "IUnion") (("5" (skolem * "i1") (("5" (inst 3 "i1") (("1" (expand "catenate") (("1" (skolem * "y") (("1" (inst 3 "y") (("1" (expand "member") (("1" (prop) (("1" (case-replace "args(rp)(i1 - 1) = args(s)(i1 - 1)") (("1" (hide (-4 2)) (("1" (expand "replaceTerm") (("1" (lift-if) (("1" (prop) (("1" (hide-all-but (-1 8)) (("1" (rewrite "empty_0") (("1" (replaces -1) (("1" (inst 1 "x!1") (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality -1) (("2" (expand "finseq_appl") (("2" (replace -3 2 rl) (("2" (expand "replace") (("2" (lift-if) (("2" (prop) (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil) ("2" (hide-all-but (-1 -6 5 9)) (("2" (lemma "fsepn.seq_first_rest") (("2" (inst -1 "x!1") (("2" (prop) (("1" (replaces -1 -3) (("1" (lemma "fsepn.first_equal") (("1" (inst -1 "rest(x!1)" "y" "first(x!1)" "i1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "empty_0") nil nil)) nil)) nil)) nil)) nil) ("3" (expand "finseq_appl") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "args(rp)") (("2" (decompose-equality -3) (("2" (prop) (("2" (expand "replaceTerm" -3) (("2" (lift-if) (("2" (prop) (("1" (hide-all-but (-1 8)) (("1" (rewrite "empty_0") (("1" (replaces -1) (("1" (inst 1 "x!1") (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-5 1)) (("3" (expand "parallel") (("3" (expand "<=") (("3" (prop) (("3" (rewrite "empty_0") (("3" (replaces -1) (("3" (inst 1 "x!1") (("3" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-5 1)) (("4" (expand "parallel") (("4" (expand "<=") (("4" (prop) (("4" (rewrite "empty_0") (("4" (replaces -1) (("4" (inst 2 "p") (("4" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq type-eq-decl nil finite_sequences nil) (/= const-decl "boolean" notequal nil) (not_empty_seq type-eq-decl nil seq_extras structures) (first const-decl "T" seq_extras structures) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (IUnion const-decl "set[T]" indexed_sets nil) (v adt-accessor-decl "[(vars?) -> variable]" term_adt nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (first_equal formula-decl nil seq_extras structures) (NOT const-decl "[bool -> bool]" booleans nil) (catenate const-decl "positions" positions nil) (seq_first_rest formula-decl nil seq_extras structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (replace const-decl "finseq" seq_extras structures) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (nth_x formula-decl nil seq_extras structures) (length_rest formula-decl nil seq_extras structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rest_parallel formula-decl nil positions nil) (rest_of_positions formula-decl nil positions nil) (RT skolem-const-decl "term" replacement nil) (empty_0 formula-decl nil seq_extras structures) (rest const-decl "finseq" seq_extras structures) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (rp skolem-const-decl "term" replacement nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (p skolem-const-decl "position[variable, symbol, arity]" replacement nil) (<= const-decl "bool" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (replace_preserv_pos formula-decl nil replacement nil) (only_empty_seq const-decl "positions" positions nil) (<= const-decl "bool" positions nil) (empty_o_seq formula-decl nil seq_extras structures) (TRUE const-decl "bool" booleans nil) (i1 skolem-const-decl "upto?[position[variable, symbol, arity]](length(args(s)))" replacement nil) (s skolem-const-decl "term" replacement nil) (= const-decl "[T, T -> boolean]" equalities nil) (replaceTerm def-decl "term" replacement nil) (positions? type-eq-decl nil positions nil) (parallel const-decl "bool" positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (term type-decl nil term_adt nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (preserv_unchanged_pos 0 (preserv_unchanged_pos-1 nil 3433002525 ("" (induct "s") (("1" (skeep) (("1" (skeep) (("1" (expand "positionsOF" (-1 1)) (("1" (expand "only_empty_seq") (("1" (expand "replaceTerm") (("1" (rewrite "empty_0") (("1" (assert) (("1" (expand "positionsOF") (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (propax) nil nil)) nil) ("2" (expand "only_empty_seq") (("2" (propax) nil nil)) nil) ("3" (expand* "union" "member") (("3" (prop) (("1" (expand "only_empty_seq") (("1" (propax) nil nil)) nil) ("2" (expand "IUnion") (("2" (skosimp*) (("2" (expand "catenate") (("2" (skosimp*) (("2" (expand "member") (("2" (expand "finseq_appl") (("2" (expand* "parallel" "<=") (("2" (flatten) (("2" (inst 3 "add_first(i!1, x!1)") (("2" (replaces -3) (("2" (hide-all-but (-2 3)) (("2" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "positionsOF" 1) (("2" (prop) (("1" (hide -2) (("1" (expand "positionsOF" -2) (("1" (assert) (("1" (expand "only_empty_seq") (("1" (expand "replaceTerm") (("1" (rewrite "empty_0") (("1" (assert) (("1" (expand "positionsOF") (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (propax) nil nil)) nil) ("2" (expand "only_empty_seq") (("2" (propax) nil nil)) nil) ("3" (expand* "union" "member") (("3" (expand "IUnion") (("3" (skosimp*) (("3" (expand "catenate") (("3" (skosimp*) (("3" (expand "member") (("3" (expand "finseq_appl") (("3" (expand* "parallel" "<=") (("3" (flatten) (("3" (inst 4 "add_first(i!1, x!1)") (("3" (replaces -4) (("3" (hide-all-but (-2 4)) (("3" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "union" "member") (("2" (flatten) (("2" (expand "IUnion") (("2" (expand "finseq_appl") (("2" (expand "positionsOF" -3) (("2" (lift-if) (("2" (prop) (("2" (expand* "union" "member") (("2" (assert) (("2" (expand "IUnion") (("2" (skosimp*) (("2" (expand "catenate") (("2" (skosimp*) (("2" (expand "member") (("2" (expand "finseq_appl") (("2" (expand "positionsOF" -4) (("2" (expand* "union" "member") (("2" (prop) (("1" (expand* "parallel" "<=") (("1" (flatten) (("1" (hide-all-but (-1 -3 6)) (("1" (expand "only_empty_seq") (("1" (inst 1 "add_first(i!1, x!1)") (("1" (replaces -1) (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "IUnion") (("2" (skosimp*) (("2" (expand "catenate") (("2" (skosimp*) (("2" (expand "member") (("2" (expand "finseq_appl") (("2" (case-replace "i!1 = i!2") (("1" (inst -6 "i!2 - 1") (("1" (inst -6 "x!2" "x!1" "t") (("1" (assert) (("1" (prop) (("1" (inst 5 "i!2") (("1" (inst 5 "x!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 6) (("2" (expand "replaceTerm" -4) (("2" (expand "finseq_appl") (("2" (prop) (("1" (hide-all-but (-1 -5)) (("1" (grind) nil nil)) nil) ("2" (expand "replace") (("2" (lemma "fsepn.first_add") (("2" (inst -1 "x!2" "i!2") (("2" (replace -5 -1 rl) (("2" (assert) (("2" (lemma "fsepn.rest_add_first") (("2" (inst -1 "x!2" "i!2") (("2" (replace -6 -1 rl) (("2" (replaces -1) (("2" (replaces -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "rest_parallel") (("3" (inst -1 "p" "q") (("3" (hide-all-but (-1 -4 -6 -7 1 5)) (("3" (lemma "fsepn.first_add") (("3" (copy -1) (("3" (inst -1 "x!2" "i!2") (("3" (inst -2 "x!1" "i!2") (("3" (lemma "fsepn.rest_add_first") (("3" (copy -1) (("3" (inst -1 "x!2" "i!2") (("3" (inst -2 "x!1" "i!2") (("3" (replace -6 (-1 -3) rl) (("3" (replace -7 (-2 -4) rl) (("3" (assert) (("3" (prop) (("1" (hide-all-but (-1 -7 -8)) (("1" (expand* "parallel" "<=") (("1" (flatten) (("1" (rewrite "empty_0") (("1" (inst 1 "add_first(i!2, x!1)") (("1" (replaces -1) (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "empty_0") (("2" (expand "only_empty_seq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -5) (("2" (inst 6 "i!1") (("1" (inst 6 "x!1") (("1" (assert) (("1" (case-replace "args(replaceTerm(app(app1_var, app2_var), t, p))`seq(i!1 - 1) = app2_var`seq(i!1 - 1)") (("1" (hide (-3 7)) (("1" (expand "replaceTerm" 1) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but (-1 -4 -5)) (("1" (expand* "parallel" "<=") (("1" (flatten) (("1" (rewrite "empty_0") (("1" (inst 1 "add_first(i!1, x!1)") (("1" (replaces -1) (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "fsepn.first_add") (("2" (inst -1 "x!2" "i!2") (("2" (lemma "fsepn.rest_add_first") (("2" (inst -1 "x!2" "i!2") (("2" (replace -4 (-1 -2) rl) (("2" (replaces -1) (("2" (replaces -1) (("2" (expand "replace") (("2" (expand "finseq_appl") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i!1") (("2" (hide (-3 -5)) (("2" (expand "replaceTerm" -2) (("2" (lift-if) (("2" (rewrite "empty_0") (("2" (prop) (("1" (hide-all-but (-1 -5 -6)) (("1" (expand* "parallel" "<=") (("1" (flatten) (("1" (inst 1 "add_first(i!1, x!1)") (("1" (replaces -1) (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "replace") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (insert? const-decl "finseq" seq_extras structures) (first_add formula-decl nil seq_extras structures) (rest_add_first formula-decl nil seq_extras structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (replace const-decl "finseq" seq_extras structures) (rest_parallel formula-decl nil positions nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (app1_var skolem-const-decl "symbol" replacement nil) (app2_var skolem-const-decl "{args: finite_sequence[term[variable, symbol, arity]] |
   args`length = arity(app1_var)}" replacement nil) (t skolem-const-decl "term" replacement nil) (p skolem-const-decl "position[variable, symbol, arity]" replacement nil) (i!1 skolem-const-decl "upto?[position[variable, symbol, arity]](length
                                         (args
                                          (replaceTerm
                                           (app(app1_var, app2_var),
                                            t,
                                            p))))" replacement nil) (NOT const-decl "[bool -> bool]" booleans nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (IUnion const-decl "set[T]" indexed_sets nil) (catenate const-decl "positions" positions nil) (<= const-decl "bool" positions nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (<= const-decl "bool" reals nil) (add_first const-decl "finseq" seq_extras structures) (empty_o_seq formula-decl nil seq_extras structures) (TRUE const-decl "bool" booleans nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (empty_0 formula-decl nil seq_extras structures) (finseq type-eq-decl nil finite_sequences nil) (only_empty_seq const-decl "positions" positions nil) (term_induction formula-decl nil term_adt nil) (variable formal-nonempty-type-decl nil replacement nil) (symbol formal-nonempty-type-decl nil replacement nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (parallel const-decl "bool" positions nil) (replaceTerm def-decl "term" replacement nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (term type-decl nil term_adt nil)) shostak)) (subterm_of_replace_TCC1 0 (subterm_of_replace_TCC1-1 nil 3433002823 ("" (skosimp*) (("" (lemma "replace_preserv_pos") (("" (inst -1 "p!1" "s!1" "t!1") (("" (assert) nil nil)) nil)) nil)) nil) ((replace_preserv_pos formula-decl nil replacement nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (subterm_of_replace subtype "replacement.p" "positions[replacement.variable, replacement.symbol, replacement.arity].positions?(replacement.replaceTerm(replacement.s, replacement.t, replacement.p))"))) (subterm_of_replace 0 (subterm_of_replace-2 "" 3804433289 ("" (measure-induct+ "length(p)" "p") (("1" (skeep) (("1" (expand "subtermOF" 1) (("1" (lift-if) (("1" (prop) (("1" (expand "replaceTerm" 1) (("1" (assert) nil nil)) nil) ("2" (expand "replaceTerm" 2) (("2" (lift-if) (("2" (prop) (("2" (lemma "fset.nth_x") (("2" (inst -1 "args(s)" "replaceTerm(args(s)(first(x!1) - 1), t, rest(x!1))" "first(x!1) - 1") (("1" (replaces -1) (("1" (inst -1 "rest(x!1)") (("1" (inst -1 "args(s)(first(x!1) - 1)" "t") (("1" (prop) (("1" (hide (2 3)) (("1" (expand "positionsOF" -1) (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (rewrite "empty_0") nil nil)) nil) ("2" (expand "only_empty_seq") (("2" (rewrite "empty_0") nil nil)) nil) ("3" (expand* "union" "member") (("3" (prop) (("1" (expand "only_empty_seq") (("1" (rewrite "empty_0") nil nil)) nil) ("2" (expand "IUnion") (("2" (skolem * "i1") (("2" (expand "catenate") (("2" (skolem * "y1") (("2" (flatten) (("2" (expand "member") (("2" (lemma "fsepn.seq_first_rest") (("2" (inst -1 "x!1") (("2" (assert) (("2" (replaces -1 -3) (("2" (lemma "fsepn.first_equal") (("2" (inst -1 "rest(x!1)" "y1" "first(x!1)" "i1") (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_rest") nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -3 2)) (("2" (lemma "replace_preserv_pos") (("2" (inst -1 "y!1" "s!1" "t!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "replace_preserv_pos") (("3" (inst -1 "p!1" "s!1" "t!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) nil shostak) (subterm_of_replace-1 nil 3433002825 ("" (measure-induct+ "length(p)" "p") (("1" (skeep) (("1" (expand "subtermOF" 1) (("1" (lift-if) (("1" (prop) (("1" (expand "replaceTerm" 1) (("1" (assert) nil nil)) nil) ("2" (expand "replaceTerm" 2) (("2" (lift-if) (("2" (prop) (("2" (lemma "fset.nth_x") (("2" (inst -1 "args(s)" "replaceTerm(args(s)(first(x!1) - 1), t, rest(x!1))" "first(x!1) - 1") (("1" (replaces -1) (("1" (inst -1 "rest(x!1)") (("1" (inst -1 "args(s)(first(x!1) - 1)" "t") (("1" (prop) (("1" (hide (2 3)) (("1" (expand "positionsOF" -1) (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (rewrite "empty_0") nil nil)) nil) ("2" (expand "only_empty_seq") (("2" (rewrite "empty_0") nil nil)) nil) ("3" (expand* "union" "member") (("3" (prop) (("1" (expand "only_empty_seq") (("1" (rewrite "empty_0") nil nil)) nil) ("2" (expand "IUnion") (("2" (skolem * "i1") (("2" (expand "catenate") (("2" (skolem * "y1") (("2" (flatten) (("2" (expand "member") (("2" (lemma "fsepn.seq_first_rest") (("2" (inst -1 "x!1") (("2" (assert) (("2" (replaces -1 -3) (("2" (lemma "fsepn.first_equal") (("2" (inst -1 "rest(x!1)" "y1" "first(x!1)" "i1") (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_rest") nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 -3 2)) (("2" (lemma "replace_preserv_pos") (("2" (inst -1 "y!1" "s!1" "t!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "replace_preserv_pos") (("3" (inst -1 "p!1" "s!1" "t!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ((replace_preserv_pos formula-decl nil replacement nil) (length_rest formula-decl nil seq_extras structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (<= const-decl "bool" reals nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (first_equal formula-decl nil seq_extras structures) (seq_first_rest formula-decl nil seq_extras structures) (catenate const-decl "positions" positions nil) (IUnion const-decl "set[T]" indexed_sets nil) (union const-decl "set" sets nil) (member const-decl "bool" sets nil) (empty_0 formula-decl nil seq_extras structures) (only_empty_seq const-decl "positions" positions nil) (TRUE const-decl "bool" booleans nil) (rest const-decl "finseq" seq_extras structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (x!1 skolem-const-decl "position[variable, symbol, arity]" replacement nil) (first const-decl "T" seq_extras structures) (not_empty_seq type-eq-decl nil seq_extras structures) (/= const-decl "boolean" notequal nil) (finseq type-eq-decl nil finite_sequences nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nth_x formula-decl nil seq_extras structures) (AND const-decl "[bool, bool -> bool]" booleans nil) (subtermOF def-decl "term" subterm nil) (= const-decl "[T, T -> boolean]" equalities nil) (term type-decl nil term_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (replaceTerm def-decl "term" replacement nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (equality_replaceTerm 0 (equality_replaceTerm-1 nil 3673478772 ("" (skeep) (("" (prop) (("1" (replace -1 1) (("1" (propax) nil nil)) nil) ("2" (lemma subterm_of_replace) (("2" (copy -1) (("2" (inst -1 p s t1) (("2" (inst -2 p s t2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (subterm_of_replace formula-decl nil replacement nil)) shostak)) (replace_subterm_of_term 0 (replace_subterm_of_term-1 nil 3433002925 ("" (measure-induct+ "length(p)" "p") (("" (skeep) (("" (expand "replaceTerm" 1) (("" (lift-if) (("" (prop) (("1" (expand "subtermOF" 1) (("1" (assert) nil nil)) nil) ("2" (decompose-equality 2) (("2" (expand "subtermOF" 1) (("2" (inst -1 "rest(x!1)") (("2" (inst -1 "args(s)(first(x!1) - 1)") (("2" (lemma "fsepn.length_rest") (("2" (inst?) (("2" (lemma "rest_of_positions") (("2" (inst?) (("2" (assert) (("2" (replace -3 1) (("2" (lemma "fset.replace_nth") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (finseq type-eq-decl nil finite_sequences nil) (/= const-decl "boolean" notequal nil) (not_empty_seq type-eq-decl nil seq_extras structures) (first const-decl "T" seq_extras structures) (x!1 skolem-const-decl "position[variable, symbol, arity]" replacement nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (replace const-decl "finseq" seq_extras structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (rest const-decl "finseq" seq_extras structures) (term_app_extensionality formula-decl nil term_adt nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (length_rest formula-decl nil seq_extras structures) (rest_of_positions formula-decl nil positions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (replace_nth formula-decl nil seq_extras structures) (subtermOF def-decl "term" subterm nil) (replaceTerm def-decl "term" replacement nil) (positions? type-eq-decl nil positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (term type-decl nil term_adt nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (replace_embedding_TCC1 0 (replace_embedding_TCC1-1 nil 3433003094 ("" (skosimp*) (("" (lemma "replace_compose_pos") (("" (inst -1 "p!1" "q!1" "s!1" "t!1") (("" (assert) nil nil)) nil)) nil)) nil) ((replace_compose_pos formula-decl nil replacement nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (replace_embedding subtype "finite_sequences[posnat].o(replacement.p, replacement.q)" "positions[replacement.variable, replacement.symbol, replacement.arity].positions?(replacement.replaceTerm(replacement.s, replacement.t, replacement.p))"))) (replace_embedding 0 (replace_embedding-1 nil 3433003095 ("" (skeep) (("" (lemma "pos_subterm") (("" (inst -1 "p" "q" "replaceTerm(s, t, p)") (("" (prop) (("1" (lemma "subterm_of_replace") (("1" (inst -1 "p" "s" "t") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "replace_compose_pos") (("2" (inst -1 "p" "q" "s" "t") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((arity formal-const-decl "[symbol -> nat]" replacement nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (pos_subterm formula-decl nil subterm nil) (subterm_of_replace formula-decl nil replacement nil) (replace_compose_pos formula-decl nil replacement nil) (replaceTerm def-decl "term" replacement nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil)) shostak)) (replace_associativity 0 (replace_associativity-2 "" 3804433344 ("" (measure-induct+ "length(p)" "p") (("1" (skeep) (("1" (case "length(x!1) = 0") (("1" (hide (-2 -3 -4)) (("1" (lemma "fsepn.empty_0") (("1" (inst?) (("1" (assert) (("1" (expand "replaceTerm" 1 (2 3)) (("1" (replaces -1) (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "replaceTerm" 2 1) (("2" (lift-if) (("2" (prop) (("1" (hide-all-but (-1 2)) (("1" (rewrite "empty_0" -1) (("1" (lemma "fsepn.seq_empty") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "first_compo") (("2" (rewrite "rest_compo") (("2" (expand "replaceTerm" 2 5) (("2" (lift-if) (("2" (prop) (("2" (decompose-equality 2) (("1" (expand "replaceTerm" 1) (("1" (propax) nil nil)) nil) ("2" (expand "replaceTerm" 1 2) (("2" (lemma "fset.nth_x") (("2" (name-replace "Rtns" "replaceTerm(args(s)(first(x!1) - 1), t, rest(x!1))") (("2" (inst -1 "args(s)" "Rtns" "first(x!1) - 1") (("2" (replaces -1) (("2" (inst -1 "rest(x!1)") (("2" (inst -1 "q" "r" "args(s)(first(x!1) - 1)" "t") (("2" (rewrite "length_rest") (("2" (prop) (("1" (expand "Rtns") (("1" (replaces -1) (("1" (name-replace "RTR" "replaceTerm(args(s)(first(x!1) - 1), replaceTerm(t, r, q), rest(x!1))") (("1" (expand "replaceTerm" 1) (("1" (lemma "fset.replace_n2") (("1" (inst -1 "args(s)" "RTR" "replaceTerm(args(s)(first(x!1) - 1), t, rest(x!1))") (("1" (prop) (("1" (inst -1 "first(x!1) - 1") nil nil) ("2" (hide-all-but (-1 -2 2)) (("2" (expand "positionsOF") (("2" (lift-if) (("2" (assert) (("2" (expand "only_empty_seq") (("2" (rewrite "empty_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "rest_of_positions") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -4 2)) (("2" (lemma "replace_compose_pos") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (lemma "replace_compose_pos") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil) nil shostak) (replace_associativity-1 nil 3433003239 ("" (measure-induct+ "length(p)" "p") (("1" (skeep) (("1" (case "length(x!1) = 0") (("1" (hide (-2 -3 -4)) (("1" (lemma "fsepn.empty_0") (("1" (inst?) (("1" (assert) (("1" (expand "replaceTerm" 1 (2 3)) (("1" (replaces -1) (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "replaceTerm" 2 1) (("2" (lift-if) (("2" (prop) (("1" (hide-all-but (-1 2)) (("1" (rewrite "empty_0" -1) (("1" (lemma "fsepn.seq_empty") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "first_compo") (("2" (rewrite "rest_compo") (("2" (expand "replaceTerm" 2 5) (("2" (lift-if) (("2" (prop) (("2" (decompose-equality 2) (("1" (expand "replaceTerm" 1) (("1" (propax) nil nil)) nil) ("2" (expand "replaceTerm" 1 2) (("2" (lemma "fset.nth_x") (("2" (name-replace "Rtns" "replaceTerm(args(s)(first(x!1) - 1), t, rest(x!1))") (("2" (inst -1 "args(s)" "Rtns" "first(x!1) - 1") (("2" (replaces -1) (("2" (inst -1 "rest(x!1)") (("2" (inst -1 "q" "r" "args(s)(first(x!1) - 1)" "t") (("2" (rewrite "length_rest") (("2" (prop) (("1" (expand "Rtns") (("1" (replaces -1) (("1" (name-replace "RTR" "replaceTerm(args(s)(first(x!1) - 1), replaceTerm(t, r, q), rest(x!1))") (("1" (expand "replaceTerm" 1) (("1" (lemma "fset.replace_n2") (("1" (inst -1 "args(s)" "RTR" "replaceTerm(args(s)(first(x!1) - 1), t, rest(x!1))") (("1" (prop) (("1" (inst -1 "first(x!1) - 1") nil nil) ("2" (hide-all-but (-1 -2 2)) (("2" (expand "positionsOF") (("2" (lift-if) (("2" (assert) (("2" (expand "only_empty_seq") (("2" (rewrite "empty_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "rest_of_positions") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-3 -4 2)) (("2" (lemma "replace_compose_pos") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (lemma "replace_compose_pos") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil) ((replace_compose_pos formula-decl nil replacement nil) (rest_of_positions formula-decl nil positions nil) (only_empty_seq const-decl "positions" positions nil) (replace_n2 formula-decl nil seq_extras structures) (Rtns skolem-const-decl "term" replacement nil) (length_rest formula-decl nil seq_extras structures) (nth_x formula-decl nil seq_extras structures) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (term_app_extensionality formula-decl nil term_adt nil) (rest const-decl "finseq" seq_extras structures) (first const-decl "T" seq_extras structures) (not_empty_seq type-eq-decl nil seq_extras structures) (/= const-decl "boolean" notequal nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (replace const-decl "finseq" seq_extras structures) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rest_compo formula-decl nil seq_extras structures) (int_minus_int_is_int application-judgement "int" integers nil) (first_compo formula-decl nil seq_extras structures) (seq_empty formula-decl nil seq_extras structures) (empty_o_seq formula-decl nil seq_extras structures) (TRUE const-decl "bool" booleans nil) (empty_0 formula-decl nil seq_extras structures) (= const-decl "[T, T -> boolean]" equalities nil) (term type-decl nil term_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (replaceTerm def-decl "term" replacement nil) (finseq type-eq-decl nil finite_sequences nil) (O const-decl "finseq" finite_sequences nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (replace_distributivity_TCC1 0 (replace_distributivity_TCC1-1 nil 3433003327 ("" (skosimp*) (("" (lemma "replace_preserv_pos") (("" (inst -1 "p!1 o q!1" "s!1" "t!1") (("" (assert) (("" (lemma "closed_positions") (("" (inst -1 "p!1" "p!1 o q!1" "replaceTerm(s!1, t!1, o[posnat](p!1, q!1))") (("" (assert) (("" (expand "<=") (("" (inst 1 "q!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((replace_preserv_pos formula-decl nil replacement nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (replaceTerm def-decl "term" replacement nil) (<= const-decl "bool" positions nil) (closed_positions formula-decl nil positions nil) (term type-decl nil term_adt nil) (O const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (replace_distributivity subtype "replacement.p" "positions[replacement.variable, replacement.symbol, replacement.arity].positions?(replacement.replaceTerm(replacement.s, replacement.t, finite_sequences[posnat].o(replacement.p, replacement.q)))"))) (replace_distributivity_TCC2 0 (replace_distributivity_TCC2-1 nil 3433003327 ("" (skosimp*) (("" (lemma "pos_ax") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil) ((arity formal-const-decl "[symbol -> nat]" replacement nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (pos_ax formula-decl nil positions nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil)) nil (replace_distributivity subtype "replacement.p" "positions[replacement.variable, replacement.symbol, replacement.arity].positions?(replacement.s)"))) (replace_distributivity_TCC3 0 (replace_distributivity_TCC3-1 nil 3433003327 ("" (skosimp*) (("" (lemma "pos_subterm_ax") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil) ((arity formal-const-decl "[symbol -> nat]" replacement nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (pos_subterm_ax formula-decl nil subterm nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil)) nil (replace_distributivity subtype "replacement.q" "positions[replacement.variable, replacement.symbol, replacement.arity].positions?(subterm[replacement.variable, replacement.symbol, replacement.arity].subtermOF(replacement.s, replacement.p))"))) (replace_distributivity 0 (replace_distributivity-2 "" 3804434972 ("" (measure-induct+ "length(p)" "p") (("1" (skeep) (("1" (expand "subtermOF" 1) (("1" (lift-if) (("1" (prop) (("1" (rewrite "empty_0") (("1" (replace -1 1) (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil) ("2" (expand "replaceTerm" 2 1) (("2" (lift-if) (("2" (prop) (("1" (hide-all-but (-1 2)) (("1" (rewrite "empty_0") (("1" (lemma "fsepn.seq_empty") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "fsepn.first_compo") (("2" (inst?) (("2" (assert) (("2" (replaces -1) (("2" (lemma "fsepn.rest_compo") (("2" (inst?) (("2" (assert) (("2" (replaces -1) (("2" (name-replace "RT" "replaceTerm(args(s)(first(x!1) - 1), t, rest(x!1) o q)") (("2" (lemma "fset.nth_x") (("2" (inst -1 "args(s)" "RT" "first(x!1) - 1") (("2" (replaces -1) (("2" (expand "RT") (("2" (inst -1 "rest(x!1)") (("2" (inst -1 "q" "args(s)(first(x!1) - 1)" "t") (("2" (prop) (("1" (lemma "fsepn.rest_compo") (("1" (inst -1 "x!1" "q") (("1" (prop) (("1" (replace -1 1 rl) (("1" (hide (-1 3 4)) (("1" (lemma "rest_of_positions") (("1" (inst -1 "x!1 o q" "s") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 4)) (("2" (rewrite "length_rest") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (rewrite "pos_subterm_ax") nil nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (lemma "pos_ax") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (-2 1)) (("4" (lemma "replace_preserv_pos") (("4" (inst -1 "y!1 o q!1" "s!1" "t!1") (("4" (assert) (("4" (lemma "pos_ax") (("4" (inst -1 "y!1" "q!1" "replaceTerm(s!1, t!1, y!1 o q!1)") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (lemma "pos_subterm_ax") (("5" (inst -1 "p!1" "q!1" "s!1") (("5" (assert) nil nil)) nil)) nil) ("6" (lemma "pos_ax") (("6" (inst -1 "p!1" "q!1" "s!1") (("6" (assert) nil nil)) nil)) nil) ("7" (hide 2) (("7" (lemma "replace_preserv_pos") (("7" (inst -1 "p!1 o q!1" "s!1" "t!1") (("7" (assert) (("7" (lemma "pos_ax") (("7" (inst -1 "p!1" "q!1" "replaceTerm(s!1, t!1, p!1 o q!1)") (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (replace_distributivity-1 nil 3433003328 ("" (measure-induct+ "length(p)" "p") (("1" (skeep) (("1" (expand "subtermOF" 1) (("1" (lift-if) (("1" (prop) (("1" (rewrite "empty_0") (("1" (replace -1 1) (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil) ("2" (expand "replaceTerm" 2 1) (("2" (lift-if) (("2" (prop) (("1" (hide-all-but (-1 2)) (("1" (rewrite "empty_0") (("1" (lemma "fsepn.seq_empty") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "fsepn.first_compo") (("2" (inst?) (("2" (assert) (("2" (replaces -1) (("2" (lemma "fsepn.rest_compo") (("2" (inst?) (("2" (assert) (("2" (replaces -1) (("2" (name-replace "RT" "replaceTerm(args(s)(first(x!1) - 1), t, rest(x!1) o q)") (("2" (lemma "fset.nth_x") (("2" (inst -1 "args(s)" "RT" "first(x!1) - 1") (("2" (replaces -1) (("2" (expand "RT") (("2" (inst -1 "rest(x!1)") (("2" (inst -1 "q" "args(s)(first(x!1) - 1)" "t") (("2" (prop) (("1" (lemma "fsepn.rest_compo") (("1" (inst -1 "x!1" "q") (("1" (prop) (("1" (replace -1 1 rl) (("1" (hide (-1 3 4)) (("1" (lemma "rest_of_positions") (("1" (inst -1 "x!1 o q" "s") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 4)) (("2" (rewrite "length_rest") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (rewrite "pos_subterm_ax") nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (lemma "pos_ax") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (lemma "replace_preserv_pos") (("4" (inst -1 "y!1 o q!1" "s!1" "t!1") (("4" (assert) (("4" (lemma "pos_ax") (("4" (inst -1 "y!1" "q!1" "replaceTerm(s!1, t!1, y!1 o q!1)") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (lemma "pos_subterm_ax") (("5" (inst -1 "p!1" "q!1" "s!1") (("5" (assert) nil nil)) nil)) nil) ("6" (lemma "pos_ax") (("6" (inst -1 "p!1" "q!1" "s!1") (("6" (assert) nil nil)) nil)) nil) ("7" (hide 2) (("7" (lemma "replace_preserv_pos") (("7" (inst -1 "p!1 o q!1" "s!1" "t!1") (("7" (assert) (("7" (lemma "pos_ax") (("7" (inst -1 "p!1" "q!1" "replaceTerm(s!1, t!1, p!1 o q!1)") (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((replace_preserv_pos formula-decl nil replacement nil) (pos_ax formula-decl nil positions nil) (pos_subterm_ax formula-decl nil subterm nil) (length_rest formula-decl nil seq_extras structures) (rest_of_positions formula-decl nil positions nil) (RT skolem-const-decl "term" replacement nil) (nth_x formula-decl nil seq_extras structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (/= const-decl "boolean" notequal nil) (not_empty_seq type-eq-decl nil seq_extras structures) (first const-decl "T" seq_extras structures) (rest const-decl "finseq" seq_extras structures) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rest_compo formula-decl nil seq_extras structures) (TRUE const-decl "bool" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (first_compo formula-decl nil seq_extras structures) (seq_empty formula-decl nil seq_extras structures) (empty_o_seq formula-decl nil seq_extras structures) (empty_0 formula-decl nil seq_extras structures) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (subtermOF def-decl "term" subterm nil) (term type-decl nil term_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (finseq type-eq-decl nil finite_sequences nil) (O const-decl "finseq" finite_sequences nil) (positions? type-eq-decl nil positions nil) (replaceTerm def-decl "term" replacement nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (replace_dominance 0 (replace_dominance-2 "" 3804435057 ("" (measure-induct+ "length(p)" "p") (("1" (skeep) (("1" (expand "replaceTerm" 1) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but (-1 2)) (("1" (rewrite "empty_0") (("1" (lemma "fsepn.seq_empty") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 2) (("2" (lemma "fsepn.first_compo") (("2" (inst?) (("2" (assert) (("2" (replace -1 1) (("2" (lemma "fsepn.rest_compo") (("2" (inst?) (("2" (assert) (("2" (replace -1 1) (("2" (name-replace "z" "args(s)(first(x!1) - 1)") (("2" (name-replace "w" "replaceTerm(z, t, rest(x!1) o q)") (("2" (lemma "fset.nth_x") (("2" (inst -1 "args(s)" "w" "first(x!1) - 1") (("2" (replaces -1 1) (("2" (lemma "fset.replace_n2") (("2" (inst -1 "args(s)" "replaceTerm(w, r, rest(x!1))" "w") (("2" (prop) (("1" (inst -1 "first(x!1) - 1") (("1" (replaces -1) (("1" (inst -3 "rest(x!1)") (("1" (expand* "w" "z") (("1" (inst -3 "q" "r" "args(s)(first(x!1) - 1)" "t") (("1" (prop) (("1" (assert) nil nil) ("2" (replace -1 1 rl) (("2" (hide-all-but (-3 1 3)) (("2" (lemma "rest_of_positions") (("2" (inst -1 "x!1 o q" "s") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 4)) (("3" (lemma "fsepn.length_rest") (("3" (inst?) (("3" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -5 3)) (("2" (expand "positionsOF") (("2" (lift-if) (("2" (prop) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.seq_empty") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "only_empty_seq") (("2" (lemma "fsepn.seq_empty") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (lemma "pos_ax") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide (-1 -3 2)) (("3" (lemma "replace_preserv_pos") (("3" (inst -1 "y!1 o q!1" "s!1" "t!1") (("3" (assert) (("3" (lemma "pos_ax") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "pos_ax") (("4" (inst?) (("4" (assert) nil nil)) nil)) nil) ("5" (lemma "replace_preserv_pos") (("5" (inst -1 "p!1 o q!1" "s!1" "t!1") (("5" (assert) (("5" (lemma "pos_ax") (("5" (inst?) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (replace_dominance-1 nil 3433003587 ("" (measure-induct+ "length(p)" "p") (("1" (skeep) (("1" (expand "replaceTerm" 1) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but (-1 2)) (("1" (rewrite "empty_0") (("1" (lemma "fsepn.seq_empty") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 2) (("2" (lemma "fsepn.first_compo") (("2" (inst?) (("2" (assert) (("2" (replace -1 1) (("2" (lemma "fsepn.rest_compo") (("2" (inst?) (("2" (assert) (("2" (replace -1 1) (("2" (name-replace "z" "args(s)(first(x!1) - 1)") (("2" (name-replace "w" "replaceTerm(z, t, rest(x!1) o q)") (("2" (lemma "fset.nth_x") (("2" (inst -1 "args(s)" "w" "first(x!1) - 1") (("2" (replaces -1 1) (("2" (lemma "fset.replace_n2") (("2" (inst -1 "args(s)" "replaceTerm(w, r, rest(x!1))" "w") (("2" (prop) (("1" (inst -1 "first(x!1) - 1") (("1" (replaces -1) (("1" (inst -3 "rest(x!1)") (("1" (expand* "w" "z") (("1" (inst -3 "q" "r" "args(s)(first(x!1) - 1)" "t") (("1" (prop) (("1" (assert) nil nil) ("2" (replace -1 1 rl) (("2" (hide-all-but (-3 1 3)) (("2" (lemma "rest_of_positions") (("2" (inst -1 "x!1 o q" "s") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 4)) (("3" (lemma "fsepn.length_rest") (("3" (inst?) (("3" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -5 3)) (("2" (expand "positionsOF") (("2" (lift-if) (("2" (prop) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.seq_empty") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "only_empty_seq") (("2" (lemma "fsepn.seq_empty") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (lemma "pos_ax") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide (-2 -3 2)) (("3" (lemma "replace_preserv_pos") (("3" (inst -1 "y!1 o q!1" "s!1" "t!1") (("3" (assert) (("3" (lemma "pos_ax") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "pos_ax") (("4" (inst?) (("4" (assert) nil nil)) nil)) nil) ("5" (lemma "replace_preserv_pos") (("5" (inst -1 "p!1 o q!1" "s!1" "t!1") (("5" (assert) (("5" (lemma "pos_ax") (("5" (inst?) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((replace_preserv_pos formula-decl nil replacement nil) (pos_ax formula-decl nil positions nil) (only_empty_seq const-decl "positions" positions nil) (length_rest formula-decl nil seq_extras structures) (rest_of_positions formula-decl nil positions nil) (w skolem-const-decl "term" replacement nil) (z skolem-const-decl "term[variable, symbol, arity]" replacement nil) (replace_n2 formula-decl nil seq_extras structures) (TRUE const-decl "bool" booleans nil) (nth_x formula-decl nil seq_extras structures) (rest_compo formula-decl nil seq_extras structures) (first_compo formula-decl nil seq_extras structures) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (term_app_extensionality formula-decl nil term_adt nil) (rest const-decl "finseq" seq_extras structures) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (replace const-decl "finseq" seq_extras structures) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (q skolem-const-decl "position[variable, symbol, arity]" replacement nil) (x!1 skolem-const-decl "position[variable, symbol, arity]" replacement nil) (first const-decl "T" seq_extras structures) (not_empty_seq type-eq-decl nil seq_extras structures) (/= const-decl "boolean" notequal nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (seq_empty formula-decl nil seq_extras structures) (empty_0 formula-decl nil seq_extras structures) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (term type-decl nil term_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (finseq type-eq-decl nil finite_sequences nil) (O const-decl "finseq" finite_sequences nil) (positions? type-eq-decl nil positions nil) (replaceTerm def-decl "term" replacement nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (replace_persistence_TCC1 0 (replace_persistence_TCC1-1 nil 3433003734 ("" (skosimp*) (("" (lemma "replace_preserv_parallel_pos") (("" (inst -1 "p!1" "q!1" "s!1" "t!1") (("" (assert) nil nil)) nil)) nil)) nil) ((replace_preserv_parallel_pos formula-decl nil replacement nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (replace_persistence subtype "replacement.q" "positions[replacement.variable, replacement.symbol, replacement.arity].positions?(replacement.replaceTerm(replacement.s, replacement.t, replacement.p))"))) (replace_persistence 0 (replace_persistence-2 "" 3804435109 ("" (measure-induct+ "length(q)" "q") (("1" (skeep) (("1" (case "first(p)=first(x!1)") (("1" (expand "subtermOF" 1) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but (-1 -6)) (("1" (expand* "parallel" "<=") (("1" (prop) (("1" (rewrite "empty_0") (("1" (replaces -1) (("1" (inst 2 "p") (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "replaceTerm" 2) (("2" (lift-if) (("2" (prop) (("1" (hide-all-but (-1 -6)) (("1" (expand* "parallel" "<=") (("1" (prop) (("1" (rewrite "empty_0") (("1" (replaces -1) (("1" (inst 1 "x!1") (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 2) (("2" (name-replace "RT" "replaceTerm(args(s)(first(x!1) - 1), t, rest(p))") (("1" (lemma "fset.nth_x") (("1" (inst -1 "args(s)" "RT" "first(x!1) - 1") (("1" (replaces -1) (("1" (expand "RT") (("1" (inst -2 "rest(x!1)") (("1" (inst -2 "rest(p)" "args(s)(first(x!1) - 1)" "t") (("1" (rewrite "length_rest") (("1" (prop) (("1" (replace -1 1 rl) (("1" (lemma "rest_of_positions") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "rest_of_positions") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil) ("3" (lemma "rest_parallel") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand* "parallel" "<=") (("2" (prop) (("2" (expand "subtermOF") (("2" (lift-if) (("2" (prop) (("1" (rewrite "empty_0") (("1" (replaces -1) (("1" (inst 4 "p") (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil) ("2" (case-replace "args(replaceTerm(s, t, p))(first(x!1) - 1) = args(s)(first(x!1) - 1)") (("1" (hide 3) (("1" (expand "replaceTerm") (("1" (lift-if) (("1" (prop) (("1" (rewrite "empty_0") (("1" (replaces -1) (("1" (inst 4 "x!1") (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (expand "replace") (("2" (lift-if) (("2" (prop) (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil) ("2" (assert) nil nil) ("3" (expand "finseq_appl") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (expand* "parallel" "<=") (("3" (prop) (("3" (rewrite "empty_0") (("3" (replaces -1) (("3" (inst 2 "p") (("3" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (expand* "parallel" "<=") (("4" (prop) (("4" (rewrite "empty_0") (("4" (replaces -1) (("4" (inst 1 "x!1") (("4" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -5 2)) (("2" (lemma "replace_preserv_parallel_pos") (("2" (inst -1 "p!1" "y!1" "s!1" "t!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "replace_preserv_parallel_pos") (("3" (inst -1 "p!1" "q!1" "s!1" "t!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) nil shostak) (replace_persistence-1 nil 3433003735 ("" (measure-induct+ "length(q)" "q") (("1" (skeep) (("1" (case "first(p)=first(x!1)") (("1" (expand "subtermOF" 1) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but (-1 -6)) (("1" (expand* "parallel" "<=") (("1" (prop) (("1" (rewrite "empty_0") (("1" (replaces -1) (("1" (inst 2 "p") (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "replaceTerm" 2) (("2" (lift-if) (("2" (prop) (("1" (hide-all-but (-1 -6)) (("1" (expand* "parallel" "<=") (("1" (prop) (("1" (rewrite "empty_0") (("1" (replaces -1) (("1" (inst 1 "x!1") (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 2) (("2" (name-replace "RT" "replaceTerm(args(s)(first(x!1) - 1), t, rest(p))") (("1" (lemma "fset.nth_x") (("1" (inst -1 "args(s)" "RT" "first(x!1) - 1") (("1" (replaces -1) (("1" (expand "RT") (("1" (inst -2 "rest(x!1)") (("1" (inst -2 "rest(p)" "args(s)(first(x!1) - 1)" "t") (("1" (rewrite "length_rest") (("1" (prop) (("1" (replace -1 1 rl) (("1" (lemma "rest_of_positions") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "rest_of_positions") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil) ("3" (lemma "rest_parallel") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand* "parallel" "<=") (("2" (prop) (("2" (expand "subtermOF") (("2" (lift-if) (("2" (prop) (("1" (rewrite "empty_0") (("1" (replaces -1) (("1" (inst 4 "p") (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil) ("2" (case-replace "args(replaceTerm(s, t, p))(first(x!1) - 1) = args(s)(first(x!1) - 1)") (("1" (hide 3) (("1" (expand "replaceTerm") (("1" (lift-if) (("1" (prop) (("1" (rewrite "empty_0") (("1" (replaces -1) (("1" (inst 4 "x!1") (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (expand "replace") (("2" (lift-if) (("2" (prop) (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil) ("2" (assert) nil nil) ("3" (expand "finseq_appl") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (expand* "parallel" "<=") (("3" (prop) (("3" (rewrite "empty_0") (("3" (replaces -1) (("3" (inst 2 "p") (("3" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (expand* "parallel" "<=") (("4" (prop) (("4" (rewrite "empty_0") (("4" (replaces -1) (("4" (inst 1 "x!1") (("4" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-4 -5 2)) (("2" (lemma "replace_preserv_parallel_pos") (("2" (inst -1 "p!1" "y!1" "s!1" "t!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "replace_preserv_parallel_pos") (("3" (inst -1 "p!1" "q!1" "s!1" "t!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ((replace_preserv_parallel_pos formula-decl nil replacement nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (replace const-decl "finseq" seq_extras structures) (rest_parallel formula-decl nil positions nil) (rest_of_positions formula-decl nil positions nil) (length_rest formula-decl nil seq_extras structures) (RT skolem-const-decl "term" replacement nil) (x!1 skolem-const-decl "position[variable, symbol, arity]" replacement nil) (nth_x formula-decl nil seq_extras structures) (int_minus_int_is_int application-judgement "int" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rest const-decl "finseq" seq_extras structures) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (empty_o_seq formula-decl nil seq_extras structures) (TRUE const-decl "bool" booleans nil) (empty_0 formula-decl nil seq_extras structures) (<= const-decl "bool" positions nil) (first const-decl "T" seq_extras structures) (not_empty_seq type-eq-decl nil seq_extras structures) (/= const-decl "boolean" notequal nil) (finseq type-eq-decl nil finite_sequences nil) (subtermOF def-decl "term" subterm nil) (= const-decl "[T, T -> boolean]" equalities nil) (term type-decl nil term_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (parallel const-decl "bool" positions nil) (positions? type-eq-decl nil positions nil) (replaceTerm def-decl "term" replacement nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (replace_commutativity_TCC1 0 (replace_commutativity_TCC1-1 nil 3433003908 ("" (skosimp*) (("" (lemma "replace_preserv_parallel_pos") (("" (inst -1 "q!1" "p!1" "s!1" "r!1") (("" (assert) (("" (rewrite "parallel_comm") nil nil)) nil)) nil)) nil)) nil) ((replace_preserv_parallel_pos formula-decl nil replacement nil) (parallel_comm formula-decl nil positions nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (replace_commutativity subtype "replacement.p" "positions[replacement.variable, replacement.symbol, replacement.arity].positions?(replacement.replaceTerm(replacement.s, replacement.r, replacement.q))"))) (replace_commutativity 0 (replace_commutativity-2 "" 3804435166 ("" (measure-induct+ "length(q)" "q") (("1" (skeep) (("1" (case "first(p)=first(x!1)") (("1" (expand "replaceTerm" 1) (("1" (lift-if) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but (-2 -7)) (("1" (expand* "parallel" "<=") (("1" (prop) (("1" (rewrite "empty_0") (("1" (replaces -1) (("1" (inst 2 "p") (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -6)) (("2" (expand* "parallel" "<=") (("2" (prop) (("2" (rewrite "empty_0") (("2" (replaces -1) (("2" (inst 2 "p") (("2" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -6)) (("3" (expand* "parallel" "<=") (("3" (prop) (("3" (rewrite "empty_0") (("3" (replaces -1) (("3" (inst 1 "x!1") (("3" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (decompose-equality 2) (("4" (replace -1 1) (("4" (name-replace "w" "replaceTerm(args(s)(first(x!1) - 1), t, rest(p))") (("4" (name-replace "w1" "replaceTerm(args(s)(first(x!1) - 1), r, rest(x!1))") (("4" (lemma "fset.nth_x") (("4" (inst -1 "args(s)" "w" "first(x!1) - 1") (("4" (lemma "fset.nth_x") (("4" (inst -1 "args(s)" "w1" "first(x!1) - 1") (("4" (case "length(args(s)) /= 0") (("1" (assert) (("1" (replaces -2) (("1" (replaces -2) (("1" (lemma "fset.replace_n2") (("1" (inst -1 "args(s)" "replaceTerm(w, r, rest(x!1))" "w") (("1" (lemma "fset.replace_n2") (("1" (inst -1 "args(s)" "replaceTerm(w1, t, rest(p))" "w1") (("1" (assert) (("1" (inst -2 "first(x!1) - 1") (("1" (inst -1 "first(x!1) - 1") (("1" (replaces -1) (("1" (replaces -1) (("1" (case-replace "replaceTerm(w, r, rest(x!1)) = replaceTerm(w1, t, rest(p))") (("1" (hide 2) (("1" (inst -3 "rest(x!1)") (("1" (expand* "w" "w1") (("1" (inst -3 "rest(p)" "r" "args(s)(first(x!1) - 1)" "t") (("1" (prop) (("1" (hide 2) (("1" (replace -1 1 rl) (("1" (lemma "rest_of_positions") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "rest_of_positions") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "rest_parallel") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (lemma "fsepn.length_rest") (("4" (inst?) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1 4)) (("2" (expand "positionsOF") (("2" (lift-if) (("2" (prop) (("1" (expand "only_empty_seq") (("1" (rewrite "empty_0") nil nil)) nil) ("2" (expand "only_empty_seq") (("2" (rewrite "empty_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand* "parallel" "<=") (("2" (prop) (("2" (expand "replaceTerm") (("2" (lift-if) (("2" (lift-if) (("2" (prop) (("1" (rewrite "empty_0" -2) (("1" (replaces -2) (("1" (inst 4 "p") (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil) ("2" (hide (1 2 3)) (("2" (rewrite "empty_0") (("2" (replaces -1) (("2" (inst 2 "p") (("2" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil) ("3" (hide (1 2 3)) (("3" (rewrite "empty_0") (("3" (replaces -1) (("3" (inst 1 "x!1") (("3" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil) ("4" (decompose-equality 2) (("4" (decompose-equality 1) (("1" (expand "replace") (("1" (propax) nil nil)) nil) ("2" (decompose-equality 1) (("2" (expand "replace") (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (prop) (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (lift-if) (("1" (prop) nil nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil) ("3" (expand "finseq_appl") (("3" (lift-if) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (expand "finseq_appl") (("4" (lift-if) (("4" (assert) nil nil)) nil)) nil) ("5" (expand "finseq_appl") (("5" (lift-if) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (expand* "parallel" "<=") (("3" (prop) (("3" (rewrite "empty_0") (("3" (replaces -1) (("3" (inst 2 "p") (("3" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (expand* "parallel" "<=") (("4" (prop) (("4" (rewrite "empty_0") (("4" (replaces -1) (("4" (inst 1 "x!1") (("4" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -5 2)) (("2" (lemma "replace_preserv_parallel_pos") (("2" (inst -1 "y!1" "p!1" "s!1" "r!1") (("2" (assert) (("2" (rewrite "parallel_comm") nil nil)) nil)) nil)) nil)) nil) ("3" (hide (-1 -5 2)) (("3" (lemma "replace_preserv_parallel_pos") (("3" (inst -1 "p!1" "y!1" "s!1" "t!1") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (lemma "replace_preserv_parallel_pos") (("4" (inst -1 "q!1" "p!1" "s!1" "r!1") (("4" (assert) (("4" (rewrite "parallel_comm") nil nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (lemma "replace_preserv_parallel_pos") (("5" (inst -1 "p!1" "q!1" "s!1" "t!1") (("5" (assert) nil nil)) nil)) nil)) nil)) nil) nil shostak) (replace_commutativity-1 nil 3433003909 ("" (measure-induct+ "length(q)" "q") (("1" (skeep) (("1" (case "first(p)=first(x!1)") (("1" (expand "replaceTerm" 1) (("1" (lift-if) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but (-2 -7)) (("1" (expand* "parallel" "<=") (("1" (prop) (("1" (rewrite "empty_0") (("1" (replaces -1) (("1" (inst 2 "p") (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -6)) (("2" (expand* "parallel" "<=") (("2" (prop) (("2" (rewrite "empty_0") (("2" (replaces -1) (("2" (inst 2 "p") (("2" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -6)) (("3" (expand* "parallel" "<=") (("3" (prop) (("3" (rewrite "empty_0") (("3" (replaces -1) (("3" (inst 1 "x!1") (("3" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (decompose-equality 2) (("4" (replace -1 1) (("4" (name-replace "w" "replaceTerm(args(s)(first(x!1) - 1), t, rest(p))") (("4" (name-replace "w1" "replaceTerm(args(s)(first(x!1) - 1), r, rest(x!1))") (("4" (lemma "fset.nth_x") (("4" (inst -1 "args(s)" "w" "first(x!1) - 1") (("4" (lemma "fset.nth_x") (("4" (inst -1 "args(s)" "w1" "first(x!1) - 1") (("4" (case "length(args(s)) /= 0") (("1" (assert) (("1" (replaces -2) (("1" (replaces -2) (("1" (lemma "fset.replace_n2") (("1" (inst -1 "args(s)" "replaceTerm(w, r, rest(x!1))" "w") (("1" (lemma "fset.replace_n2") (("1" (inst -1 "args(s)" "replaceTerm(w1, t, rest(p))" "w1") (("1" (assert) (("1" (inst -2 "first(x!1) - 1") (("1" (inst -1 "first(x!1) - 1") (("1" (replaces -1) (("1" (replaces -1) (("1" (case-replace "replaceTerm(w, r, rest(x!1)) = replaceTerm(w1, t, rest(p))") (("1" (hide 2) (("1" (inst -3 "rest(x!1)") (("1" (expand* "w" "w1") (("1" (inst -3 "rest(p)" "r" "args(s)(first(x!1) - 1)" "t") (("1" (prop) (("1" (hide 2) (("1" (replace -1 1 rl) (("1" (lemma "rest_of_positions") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "rest_of_positions") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "rest_parallel") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (lemma "fsepn.length_rest") (("4" (inst?) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1 4)) (("2" (expand "positionsOF") (("2" (lift-if) (("2" (prop) (("1" (expand "only_empty_seq") (("1" (rewrite "empty_0") nil nil)) nil) ("2" (expand "only_empty_seq") (("2" (rewrite "empty_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand* "parallel" "<=") (("2" (prop) (("2" (expand "replaceTerm") (("2" (lift-if) (("2" (lift-if) (("2" (prop) (("1" (rewrite "empty_0" -2) (("1" (replaces -2) (("1" (inst 4 "p") (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil) ("2" (hide (1 2 3)) (("2" (rewrite "empty_0") (("2" (replaces -1) (("2" (inst 2 "p") (("2" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil) ("3" (hide (1 2 3)) (("3" (rewrite "empty_0") (("3" (replaces -1) (("3" (inst 1 "x!1") (("3" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil) ("4" (decompose-equality 2) (("4" (decompose-equality 1) (("1" (expand "replace") (("1" (propax) nil nil)) nil) ("2" (decompose-equality 1) (("2" (expand "replace") (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (prop) (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (lift-if) (("1" (prop) nil nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil) ("3" (expand "finseq_appl") (("3" (lift-if) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (expand "finseq_appl") (("4" (lift-if) (("4" (assert) nil nil)) nil)) nil) ("5" (expand "finseq_appl") (("5" (lift-if) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (expand* "parallel" "<=") (("3" (prop) (("3" (rewrite "empty_0") (("3" (replaces -1) (("3" (inst 2 "p") (("3" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (expand* "parallel" "<=") (("4" (prop) (("4" (rewrite "empty_0") (("4" (replaces -1) (("4" (inst 1 "x!1") (("4" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-4 -5 2)) (("2" (lemma "replace_preserv_parallel_pos") (("2" (inst -1 "y!1" "p!1" "s!1" "r!1") (("2" (assert) (("2" (rewrite "parallel_comm") nil nil)) nil)) nil)) nil)) nil) ("3" (hide (-4 -5 2)) (("3" (lemma "replace_preserv_parallel_pos") (("3" (inst -1 "p!1" "y!1" "s!1" "t!1") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (lemma "replace_preserv_parallel_pos") (("4" (inst -1 "q!1" "p!1" "s!1" "r!1") (("4" (assert) (("4" (rewrite "parallel_comm") nil nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (lemma "replace_preserv_parallel_pos") (("5" (inst -1 "p!1" "q!1" "s!1" "t!1") (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ((parallel_comm formula-decl nil positions nil) (replace_preserv_parallel_pos formula-decl nil replacement nil) (only_empty_seq const-decl "positions" positions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length_rest formula-decl nil seq_extras structures) (rest_parallel formula-decl nil positions nil) (rest_of_positions formula-decl nil positions nil) (w skolem-const-decl "term" replacement nil) (w1 skolem-const-decl "term" replacement nil) (replace_n2 formula-decl nil seq_extras structures) (nth_x formula-decl nil seq_extras structures) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (term_app_extensionality formula-decl nil term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (replace const-decl "finseq" seq_extras structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (rest const-decl "finseq" seq_extras structures) (p skolem-const-decl "position[variable, symbol, arity]" replacement nil) (x!1 skolem-const-decl "position[variable, symbol, arity]" replacement nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (empty_o_seq formula-decl nil seq_extras structures) (TRUE const-decl "bool" booleans nil) (empty_0 formula-decl nil seq_extras structures) (<= const-decl "bool" positions nil) (first const-decl "T" seq_extras structures) (not_empty_seq type-eq-decl nil seq_extras structures) (/= const-decl "boolean" notequal nil) (finseq type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (term type-decl nil term_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (parallel const-decl "bool" positions nil) (positions? type-eq-decl nil positions nil) (replaceTerm def-decl "term" replacement nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (pos_replaces_is_subset 0 (pos_replaces_is_subset-1 nil 3414553266 ("" (induct "t") (("1" (skosimp*) (("1" (expand* "subset?" "member") (("1" (skosimp*) (("1" (typepred "p!1") (("1" (expand "positionsOF" -1) (("1" (expand* "only_empty_seq" "replaceTerm") (("1" (rewrite "empty_0") (("1" (assert) (("1" (typepred "x!1") (("1" (expand "V") (("1" (expand "positionsOF") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand* "subset?" "member") (("2" (skosimp*) (("2" (expand "positionsOF" (-2 1)) (("2" (lift-if) (("2" (prop) (("1" (expand* "union" "member") (("1" (prop) nil nil)) nil) ("2" (expand* "union" "member") (("2" (prop) nil nil)) nil) ("3" (hide (-2 -3)) (("3" (expand "replaceTerm" 2) (("3" (lift-if) (("3" (prop) (("1" (expand "replaceTerm" 3) (("1" (lift-if) (("1" (assert) (("1" (typepred "x!1") (("1" (expand "V") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "replace") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand* "union" "member") (("4" (prop) (("4" (expand "IUnion") (("4" (skosimp*) (("4" (expand "catenate") (("4" (skosimp*) (("4" (expand "member") (("4" (expand "finseq_appl") (("4" (inst 3 "i!1") (("1" (inst 3 "x!3") (("1" (prop) (("1" (expand "replaceTerm" -1) (("1" (prop) (("1" (hide-all-but (-1 5)) (("1" (expand "replaceTerm") (("1" (lift-if) (("1" (prop) (("1" (typepred "x!1") (("1" (expand "V") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (expand "replace") (("2" (prop) (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil) ("2" (inst -4 "i!1 - 1") (("2" (inst -4 "x!1" "rest(p!1)") (("1" (inst -4 "x!3") (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide (-2 2 5 8 9)) (("2" (typepred "p!1") (("2" (expand "positionsOF" -1) (("2" (assert) (("2" (expand* "union" "member") (("2" (prop) (("1" (expand "only_empty_seq") (("1" (rewrite "empty_0") nil nil)) nil) ("2" (expand "IUnion") (("2" (skosimp*) (("2" (expand "catenate") (("2" (skosimp*) (("2" (expand "member") (("2" (expand "finseq_appl") (("2" (replace -2 1) (("2" (rewrite "rest_add_first") (("2" (replace -2 -3) (("2" (rewrite "first_add") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "finseq_appl") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i!1") (("2" (hide (-3 -5 4)) (("2" (expand "replaceTerm") (("2" (lift-if) (("2" (prop) (("1" (typepred "x!1") (("1" (expand "V") (("1" (propax) nil nil)) nil)) nil) ("2" (hide 2) (("2" (expand "replace") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((IUnion const-decl "set[T]" indexed_sets nil) (catenate const-decl "positions" positions nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (i!1 skolem-const-decl "upto?[position[variable, symbol, arity]](length
                                         (args
                                          (replaceTerm
                                           (app(app1_var!1, app2_var!1),
                                            x!1,
                                            p!1))))" replacement nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (p!1 skolem-const-decl "positions?[variable, symbol, arity](app(app1_var!1, app2_var!1))" replacement nil) (x!1 skolem-const-decl "(V)" replacement nil) (app2_var!1 skolem-const-decl "{args: finite_sequence[term[variable, symbol, arity]] |
   args`length = arity(app1_var!1)}" replacement nil) (app1_var!1 skolem-const-decl "symbol" replacement nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (<= const-decl "bool" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (first_add formula-decl nil seq_extras structures) (rest_add_first formula-decl nil seq_extras structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (rest const-decl "finseq" seq_extras structures) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (replace const-decl "finseq" seq_extras structures) (union const-decl "set" sets nil) (finseq type-eq-decl nil finite_sequences nil) (empty_0 formula-decl nil seq_extras structures) (only_empty_seq const-decl "positions" positions nil) (vars adt-constructor-decl "[variable -> (vars?)]" term_adt nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (member const-decl "bool" sets nil) (term_induction formula-decl nil term_adt nil) (variable formal-nonempty-type-decl nil replacement nil) (symbol formal-nonempty-type-decl nil replacement nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (replaceTerm def-decl "term" replacement nil) (subset? const-decl "bool" sets nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil)) shostak)) (pos_occ_var_replace 0 (pos_occ_var_replace-1 nil 3414515459 ("" (skolem-typepred) (("" (expand "V") (("" (flatten) (("" (decompose-equality 2) (("" (iff) (("" (prop) (("1" (expand* "remove" "Pos_var" "extend") (("1" (prop) (("1" (lemma "subterm_of_replace") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "member") (("2" (prop) (("1" (lemma "subterm_of_replace") (("1" (inst -1 "p!1" "t!1" "y!1") (("1" (assert) (("1" (lemma "variable_positions_parallel") (("1" (inst -1 "replaceTerm(t!1, y!1, p!1)" "y!1" "x!1" "p!1" "x!2") (("1" (assert) (("1" (lemma "replace_persistence") (("1" (inst -1 "p!1" "x!2" "t!1" "y!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "pos_replaces_is_subset") (("2" (inst?) (("2" (expand* "subset?" "member") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "remove" "Pos_var") (("2" (expand "extend") (("2" (prop) (("1" (expand "member") (("1" (prop) (("1" (lemma "variable_positions") (("1" (inst?) (("1" (inst -1 "x!1") (("1" (assert) (("1" (expand* "member" "Pos_var") (("1" (expand "extend") (("1" (lemma "replace_persistence") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member") (("2" (prop) (("2" (lemma "variable_positions") (("2" (inst?) (("2" (inst -1 "x!1") (("2" (assert) (("2" (expand* "member" "Pos_var") (("2" (expand "extend") (("2" (lemma "replace_preserv_parallel_pos") (("2" (inst -1 "p!1" "x!2" "t!1" "y!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Pos_var const-decl "positions" subterm nil) (replaceTerm def-decl "term" replacement nil) (remove const-decl "set" sets nil) (subterm_of_replace formula-decl nil replacement nil) (variable_positions_parallel formula-decl nil subterm nil) (replace_persistence formula-decl nil replacement nil) (subset? const-decl "bool" sets nil) (pos_replaces_is_subset formula-decl nil replacement nil) (member const-decl "bool" sets nil) (extend const-decl "R" extend nil) (replace_preserv_parallel_pos formula-decl nil replacement nil) (variable_positions formula-decl nil subterm nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (pos_occ_var_replace_as_diff 0 (pos_occ_var_replace_as_diff-1 nil 3414642772 ("" (skosimp*) (("" (lemma "sets_lemmas[position].remove_as_difference") (("" (inst -1 "Pos_var(t!1, x!1)" "p!1") (("" (lemma "pos_occ_var_replace") (("" (inst?) (("" (assert) (("" (replaces -2) (("" (expand "difference") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" replacement nil) (symbol formal-nonempty-type-decl nil replacement nil) (variable formal-nonempty-type-decl nil replacement nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (remove_as_difference formula-decl nil sets_lemmas nil) (pos_occ_var_replace formula-decl nil replacement nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[position[variable, symbol, arity]]" replacement nil) (difference const-decl "set" sets nil) (singleton const-decl "(singleton?)" sets nil) (member const-decl "bool" sets nil) (extend const-decl "R" extend nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (TRUE const-decl "bool" booleans nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (Pos_var const-decl "positions" subterm nil) (positions type-eq-decl nil positions nil) (V const-decl "set[term]" variables_term nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil)) shostak)))
