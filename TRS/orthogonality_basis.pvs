%%-------------------** Term Rewriting System (TRS) **------------------------
%%                                                                          
%% Authors         : Ana Cristina Rocha Oliveira, Andre Galdino and
%%                   Mauricio Ayala Rincon  
%%                   Universidade de BrasÃ­lia - Brasil
%%
%% Last Modified On: Jun 3, 2016                                 
%%                                                                          
%%--------------------------------------------------------------------------
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Orthogonality_basis contains specification of notions related to orthogonal
%% rewriting systems and parallel rewriting such as linear, left- and righ-
%% linear, ambiguous, non-trivial critical pairs, orthogonal TRSs etc. Parallel
%% rewriting is specified using sequences of positions, rules and substitutions.
%% This theory is imported by two theories orthogonality.pvs and orthogonality_sets.pvs.
%% The former formalizes the theorem of confluence of orthogonal TRSs using directly
%% the data structure of sequences, while the latter explores translations of 
%% sequences into sets in order to simplify the formalization. 
%% Orthogonality_basis includes the formalization of confluence of left- and 
%% right-linear non-ambiguous TRSs as well as the formalization of the 
%% Parallel Moves Lemma, which is the basis of Rosen's style proof of confluence 
%% of orthogonal TRSs, and is used in both the theories orthogonality.pvs and 
%% orthogonality_sets.pvs to prove confluence of orthogonal TRSs. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

orthogonality_basis[variable:TYPE+, symbol: TYPE+, arity: [symbol -> nat]]: THEORY

 BEGIN

   ASSUMING
 
     IMPORTING 
               variables_term[variable, symbol, arity],
               sets_aux@countability[term],
               sets_aux@countable_props[term]
 
     var_countable: ASSUMPTION is_countably_infinite(V)
      

   ENDASSUMING


    IMPORTING critical_pairs[variable,symbol,arity],
              predicate_fseq2set[term],      
              predicate_fseq2set[position],
              predicate_fseq2set[rewrite_rule],
              predicate_fseq2set[Sub]
                                       
                                      n: VAR nat
                           s, t, t1, t2: VAR term 
          sigma, sg1, sg2, delta, theta: VAR Sub
                       p, q, p1, p2, p3: VAR position
                        rho, rho1, rho2: VAR Ren 
          e, e1o, e2o, e1, e1p, e2, e2p: VAR rewrite_rule
                                      E: VAR set[rewrite_rule]
                                      R: VAR pred[[term, term]]
                                   x, y: VAR (V)
                   fsq, fsp, fsp1, fsp2: VAR finseq[position]
                        fse, fse1, fse2: VAR finseq[rewrite_rule]
                        fss, fss1, fss2: VAR finseq[Sub]
                        fst, fst1, fst2: VAR finseq[term]

%%%% Some constructors %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

complement_pos(p, fsp): RECURSIVE finseq[position] =    
           IF length(fsp) = 0 THEN empty_seq
           ELSIF nonempty?(complement_pos_set(<=, o)(p, fsp`seq(0)))
              THEN add_first(choose(complement_pos_set(<=, o)(p, fsp`seq(0))),
                             complement_pos(p, rest(fsp)))
              ELSE complement_pos(p, rest(fsp))
           ENDIF
       MEASURE(length(fsp))

 comp_pos(p,fsp): finseq[position] = (# length := fsp`length,
                                            seq := (LAMBDA (i: below[fsp`length]): p o fsp(i)) #);
 
 C(e, sigma, s, t, (p|positionsOF(s)(p) AND positionsOF(t)(p))): bool = 
        subtermOF(s, p) = ext(sigma)(lhs(e)) AND
        subtermOF(t, p) = ext(sigma)(rhs(e))

 D(s, t, (fsp|SPP?(s)(fsp) AND SPP?(t)(fsp)), E)(i:below[fsp`length], e): bool =
           member(e, E) AND
            EXISTS sigma : C(e, sigma, s, t, fsp`seq(i))

 G(s, t, (fsp|SPP?(s)(fsp) AND SPP?(t)(fsp)),E)(i:below[fsp`length], sigma): bool =
            EXISTS (e|member(e, E)) : C(e, sigma, s, t, fsp`seq(i))

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% ntCP? is the predicate for non trivially generated CPs                   %%%%%%%%%%%%%%%%%%%
%%%%% This in contrast with CP? excludes all CPs generated by sobreposition of %%%%%%%%%%%%%%%%%%%
%%%%% a rule with itself at root position and is used to define ambiguity.     %%%%%%%%%%%%%%%%%%%
%%%%% The necessity of this notion was gently pointed out by Rene Thiemann.    %%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  ntCP?(E)(t1, t2): bool = 
    EXISTS (sigma, rho, (e1 | member(e1, E)), (e2p | member(e2p, E)), (p: positions?(lhs(e1)))):
            NOT (e1 = e2p AND p = empty_seq)                                    AND
            LET e2 = (# lhs := ext(rho)(lhs(e2p)), rhs := ext(rho)(rhs(e2p)) #) IN
            disjoint?(Vars(lhs(e1)),Vars(lhs(e2)))                              AND
            NOT vars?(subtermOF(lhs(e1), p))                                    AND
            mgu(sigma)(subtermOF(lhs(e1), p), lhs(e2))                          AND
            t1 = ext(sigma)(rhs(e1))                                            AND
            t2 = replaceTerm(ext(sigma)(lhs(e1)), ext(sigma)(rhs(e2)), p)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Basic specific definitions and definitions on orthogonality and parallel reduction %%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 Ambiguous?(E): bool =  EXISTS (t1, t2) : ntCP?(E)(t1, t2)

 linear?(t): bool = FORALL (x | member(x,Vars(t))) : Card[position](Pos_var(t, x)) = 1

 Right_Linear?(E): bool = FORALL (e1 | member(e1, E)) : linear?(rhs(e1))

 Left_Linear?(E): bool = FORALL (e1 | member(e1, E)) : linear?(lhs(e1)) 

 Linear?(E): bool = Left_Linear?(E) AND Right_Linear?(E)

 Orthogonal?(E): bool =  Left_Linear?(E) AND NOT Ambiguous?(E)

 Orthogonal: TYPE = (Orthogonal?)

 replace_par_pos(s, (fsp : SPP(s)), fst | fst`length = fsp`length): RECURSIVE
    term =
      IF length(fsp) = 0
       THEN 
        s
       ELSE
        replace_par_pos(replaceTerm(s, fst(0), fsp(0)), rest(fsp), rest(fst))
      ENDIF
   MEASURE length(fsp)

 sigma_rhs(fss, (fse | fse`length = fss`length)): finseq[term] =
     IF fss`length = 0 THEN empty_seq[term]
     ELSE
          (# length := fss`length,
                seq := (LAMBDA (i: below[fss`length]): ext(fss(i))(rhs(fse(i)))) #)
     ENDIF

 sigma_lhs(fss, (fse | fse`length = fss`length)): finseq[term] =
     IF fss`length = 0 THEN empty_seq[term]
     ELSE
          (# length := fss`length,
                seq := (LAMBDA (i: below[fss`length]): ext(fss(i))(lhs(fse(i)))) #)
     ENDIF

 subtermsOF(t, (fsp:SP(t))): finseq[term] =
     (# length := fsp`length,
           seq := (LAMBDA (i: below[fsp`length]): subtermOF(t,fsp(i))) #);

 parallel_reduction_fix?(E)(s, t, (fsp: SPP(s))): bool =
     EXISTS ((fse | subset?(fse, E)), fss):
           fsp`length = fse`length                 AND
	   fsp`length = fss`length                 AND
	   subtermsOF(s,fsp) = sigma_lhs(fss, fse) AND
	   t = replace_par_pos(s, fsp, sigma_rhs(fss, fse))

 parallel_reduction?(E)(s,t): bool = EXISTS (fsp: SPP(s)): parallel_reduction_fix?(E)(s, t, fsp)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


 complement_pos_character: LEMMA
                             seq2set(complement_pos(p, fsp))(p1)
                               IMPLIES
				 EXISTS (i: below[fsp`length]): fsp`seq(i) = p o p1

 complement_pos_is_PP: LEMMA
     PP?(fsp) IMPLIES PP?(complement_pos(p,fsp))

 complement_pos_empty: LEMMA
   PP?(add_first(p, fsp)) IMPLIES complement_pos(p,fsp)`length = 0

 comp_pos_rest: LEMMA
     comp_pos(p,rest(fsp)) = rest(comp_pos(p,fsp))

 comp_pos_preservs_length: LEMMA
     comp_pos(p, fsp)`length=fsp`length

 comp_pos_character: LEMMA
     FORALL(i:below[fsp`length]):
     comp_pos(p,fsp)`seq(i)= p o fsp`seq(i)

 comp_pos_is_PP: LEMMA
     PP?(fsp) IMPLIES PP?(comp_pos(p,fsp))

 comp_pos_in_PP_preservs_PP: LEMMA
    PP?(fsp) AND PP?(fsp1) AND fsp`length > 0 IMPLIES
     PP?(comp_pos(fsp`seq(0), fsp1) o rest(fsp))

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Lemmas about sequences of positions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Auxiliary lemma on sigma_rhs.

 sigma_rhs_rest: LEMMA
     fse`length = fss`length 
        IMPLIES rest(sigma_rhs(fss, fse)) = sigma_rhs(rest(fss), rest(fse))

%% Auxiliary lemma on sigma_rhs.

 sigma_rhs_o: LEMMA
   fse1`length = fss1`length AND fse2`length = fss2`length
     IMPLIES
       sigma_rhs(fss1 o fss2, fse1 o fse2) = sigma_rhs(fss1, fse1) o sigma_rhs(fss2, fse2)

%% Auxiliary lemma on subtermsOF.

 subtermsOF_rest: LEMMA
     SP?(t)(fsp) IMPLIES rest(subtermsOF(t,fsp)) = subtermsOF(t, rest(fsp))

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Some Lemmas to prove that linearity and non-ambiguity imply confluence %%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 ntCP_lemma_aux1: LEMMA
   FORALL E, (p: position), (e1 | member(e1, E)), (e2 | member(e2, E)):
    ( ( positionsOF(lhs(e1))(p) AND
       NOT vars?(subtermOF(lhs(e1), p))                                     AND
       ext(sg1)(subtermOF(lhs(e1), p)) = ext(sg2)(lhs(e2)) )                AND
       NOT (e1 = e2 AND p = empty_seq) )
          IMPLIES
           EXISTS t1, t2, delta:
             ntCP?(E)(t1, t2)                                               AND
             ext(delta)(t1) = ext(sg1)(rhs(e1))                             AND
             ext(delta)(t2) = replaceTerm(ext(sg1)(lhs(e1)), ext(sg2)(rhs(e2)), p)
 
 
 Orth_lemma_aux: LEMMA
     LET e1o = (# lhs := ext(rho1)(lhs(e1p)), rhs := ext(rho1)(rhs(e1p)) #) IN
       LET e2o = (# lhs := ext(rho2)(lhs(e2p)), rhs := ext(rho2)(rhs(e2p)) #) IN
       member(e1p,E) AND 
       member(e2p,E) AND
       positionsOF(t)(p1) AND
       positionsOF(t)(p3) AND
       NOT Ambiguous?(E) AND
       p3 = p1 o p2 AND
       Linear?(E) AND
         subtermOF(t, p1) = ext(sg1)(lhs(e1o)) AND 
         t1 = replaceTerm(t, ext(sg1)(rhs(e1o)), p1) AND
         subtermOF(t, p3) = ext(sg2)(lhs(e2o)) AND
         t2 = replaceTerm(t, ext(sg2)(rhs(e2o)), p3) AND
         disjoint?(Vars(lhs(e1o)),Vars(t))AND
         disjoint?(Vars(lhs(e2o)),Vars(t))
   IMPLIES
     EXISTS s:  (RC(reduction?(E))(t1, s) AND RC(reduction?(E))(t2, s))

 Linear_and_Non_ambiguous_implies_sub_comm: LEMMA
  FORALL (E) :  
    (Linear?(E) AND NOT Ambiguous?(E) ) IMPLIES
     sub_commutative?(reduction?(E))

 Linear_and_Non_ambiguous_implies_confluent: LEMMA
  FORALL (E) :  
    ((Linear?(E) AND NOT Ambiguous?(E) ) IMPLIES
     confluent?(reduction?(E)))

%% Lemma of inclusions of the rewriting relation in the parallel rewriting relation
%% and the latter in the reflexive-transitive closure of the former relation.

 parallel_reduction_inclusion: LEMMA 
  subset?(reduction?(E), parallel_reduction?(E)) 
   AND subset?(parallel_reduction?(E), RTC(reduction?(E)))

%% The reflexive-transitive clousures of the rewriting and the parallel 
%% rewriting relations are equivalent.

 parallel_reduction_RTC: LEMMA
  RTC(reduction?(E)) = RTC(parallel_reduction?(E))

%% Once you rewrite in parallel at positions fsp which are
%% parallel to position p ("p || fsp"), a term in which position p is 
%% preserved is obtained.

 replace_par_pos_preservs_pos: LEMMA
  SPP?(t)(add_first(p,fsp)) AND fst`length = fsp`length
        IMPLIES positionsOF(replace_par_pos(t, fsp, fst))(p)

%% When you replace the subterms at the positions in fsp,
%% those positions are preserved in the resulting term.

  replace_par_pos_preservs_PP: LEMMA
   SPP?(t)(fsp) AND fst`length = fsp`length
      IMPLIES (FORALL (i : below[fsp`length]) : positionsOF(replace_par_pos(t, fsp, fst))(fsp(i)))

%% Same of replace_par_pos_preserv_pos but instead for
%% a unique position p || fsp for a sequence of positions fsq || fsp.

 replace_par_pos_preservs_PP_o_PP: LEMMA
  SPP?(t)(fsp o fsq ) AND fst`length = fsp`length
      IMPLIES (FORALL (i : below[fsq`length]) : positionsOF(replace_par_pos(t, fsp, fst))(fsq(i)))

%% If you replace the first parallel position firstly or lastly,
%% that does not change the resulting term.

 replace_par_pos_equivalence: LEMMA
  SPP?(s)(fsp) AND fsp`length /= 0 AND fst`length = fsp`length
    IMPLIES replace_par_pos(replaceTerm(s, fst(0), fsp(0)), rest(fsp), rest(fst)) = 
            replaceTerm(replace_par_pos(s, rest(fsp), rest(fst)), fst(0), fsp(0))

%% Generalization of the previous result: you can pick up any position to start to work
%% with replace_par_pos and that does not change the result.

 replace_par_pos_equivalence1: LEMMA
  SPP?(s)(fsp) AND fsp`length /= 0 AND fst`length = fsp`length AND n < fsp`length
    IMPLIES replace_par_pos(replaceTerm(s, fst(n), fsp(n)), delete(fsp,n), delete[term](fst,n)) = 
            replace_par_pos(s,fsp,fst)

%% If you apply replace_par_pos in positions fsp, then the subterm
%% at any position p || fsp is preserved.

 replace_par_pos_preservs_subterm: LEMMA
  SPP?(t)(add_first(p,fsp)) AND fst`length = fsp`length
        IMPLIES subtermOF(replace_par_pos(t, fsp, fst), p) = subtermOF(t, p)

%% When one rewrites in parallel at fsp, the subterms of the resulting term
%% at fsp are exatly the terms in fst.

 replace_par_pos_subterm: LEMMA
  SPP?(t)(fsp) AND fst`length = fsp`length
    IMPLIES (FORALL (i: below[fsp`length]): subtermOF(replace_par_pos(t,fsp,fst),fsp(i)) = fst(i))

%% If you replace the subterms at a composition of sequences 'fsp1 o fsp2',
%% that are parallel, it is the same that doing it separately.

 replace_par_pos_comp: LEMMA
  SPP?(t)(fsp1 o fsp2) AND fst1`length = fsp1`length
                       AND fst2`length = fsp2`length
         IMPLIES replace_par_pos(t, fsp1 o fsp2, fst1 o fst2) =
                        replace_par_pos(replace_par_pos(t, fsp1, fst1),fsp2, fst2)

%% In general, applying replace_par_pos at a parallel composition of sequences
%% fsp1 o fsp2 is commutative.

 replace_par_pos_comp_commute: LEMMA
    SPP?(t)(fsp1 o fsp2) AND fst1`length = fsp1`length AND fst2`length = fsp2`length
      IMPLIES 
        replace_par_pos(t, fsp1 o fsp2, fst1 o fst2) = 
                                              replace_par_pos(t, fsp2 o fsp1, fst2 o fst1)

%% Replacing at the position q of t by the result of replacing in parallel at positions fsp of s
%% gives as result the same as replacing at positions q o fsp of t[q<-s].

 replace_replace_par_pos: LEMMA
    positionsOF(t)(q) AND SPP?(s)(fsp) AND fst`length = fsp`length
      IMPLIES
        replaceTerm(t, replace_par_pos(s,fsp,fst), q) =
		                         replace_par_pos(replaceTerm(t,s,q), comp_pos(q,fsp), fst)

  comp_pos_in_SP_preservs_SP_in_replace: LEMMA
    SPP?(t)(fsp) AND SP?(s)(fsp1) AND fsp`length > 0 IMPLIES
     SP?(replaceTerm(t, s, fsp`seq(0)))(comp_pos(fsp`seq(0), fsp1) o rest(fsp))

  comp_pos_in_SPP_preservs_SPP_in_replace: LEMMA
    SPP?(t)(fsp) AND SPP?(s)(fsp1) AND fsp`length > 0 IMPLIES
     SPP?(replaceTerm(t, s, fsp`seq(0)))(comp_pos(fsp`seq(0), fsp1) o rest(fsp))

  comp_pos_in_SPP_preservs_SPP_in_replace_par_pos: LEMMA
    SPP?(t)(fsp) AND fsp`length=fst`length AND fsp`length /= 0 AND
    SPP?(fst`seq(0))(fsp1) AND
    SPP?(replace_par_pos(t, fsp, fst))(fsp2) AND
    PP?(add_first(fsp`seq(0),fsp2)) IMPLIES
     SPP?(replace_par_pos(t, fsp, fst))(comp_pos(fsp`seq(0), fsp1) o fsp2)

  parallel_reduction_reflexive: LEMMA reflexive?(parallel_reduction?(E))

  non_ambiguous_implies_same_term: LEMMA
       NOT Ambiguous?(E) AND positionsOF(s)(p) AND
       reduction_fix?(E)(s,t1,p) AND
       reduction_fix?(E)(s,t2,p)
         IMPLIES t1 = t2

  parallel_reduction_context_aux: LEMMA   
   SPP?(t)(fsp) AND fst1`length = fsp`length AND fst2`length = fsp`length AND
    (FORALL (i: below[fsp`length]): parallel_reduction?(E)(fst1(i),fst2(i)))
      IMPLIES EXISTS (fsq: SPP(replace_par_pos(t, fsp, fst1))):
        parallel_reduction_fix?(E)(replace_par_pos(t, fsp, fst1),replace_par_pos(t,fsp,fst2), fsq)
         AND (FORALL(p:positions?(t)): PP?(add_first(p,fsp)) IMPLIES PP?(add_first(p,fsq)))

  parallel_reduction_context: LEMMA
    SPP?(t)(fsp) AND fst1`length = fsp`length AND fst2`length = fsp`length AND
    (FORALL (i : below[fsp`length]): parallel_reduction?(E)(fst1(i),fst2(i)))
        IMPLIES 
           parallel_reduction?(E)(replace_par_pos(t, fsp, fst1),replace_par_pos(t, fsp, fst2))

  replace_par_pos_of_app_is_app: LEMMA
    app?(t) AND SPP?(t)(fsp) AND fst`length = fsp`length IMPLIES
     fsp = #(empty_seq) OR
          app?(replace_par_pos(t, fsp, fst))

  replace_par_pos_preservs_f: LEMMA
    app?(t) AND SPP?(t)(fsp) AND fst`length = fsp`length IMPLIES
     fsp = #(empty_seq) OR
       f(t) = f(replace_par_pos(t,fsp,fst))

  parallel_reduction_variables_context: LEMMA
    (FORALL (x: Vars?(t)): parallel_reduction?(E)(ext(sigma)(x), ext(theta)(x)))
      IMPLIES
        parallel_reduction?(E)(ext(sigma)(t), ext(theta)(t))

  parallel_reduction_result: LEMMA
     Orthogonal?(E) AND E(e) AND SPP?(ext(sigma)(lhs(e)))(fsp) AND
     parallel_reduction_fix?(E)(ext(sigma)(lhs(e)), t, fsp)
       IMPLIES
          fsp = #(empty_seq) OR
          EXISTS(theta): t = ext(theta)(lhs(e))

  replace_par_pos_subterm2: LEMMA
      SPP?(s)(fsp) AND seq2set(fsp)(p1) AND
      p <= p1 AND p /= p1 AND
      fsp`length = fst`length IMPLIES
        EXISTS fst1: (complement_pos(p, fsp)`length = fst1`length AND
          subtermOF(replace_par_pos(s, fsp, fst), p) =
                 replace_par_pos(subtermOF(s, p), complement_pos(p, fsp), fst1))

  parallel_reduction_variables: LEMMA
   NOT Ambiguous?(E) AND E(e) AND
    SPP?(ext(sigma)(lhs(e)))(fsp) AND
    parallel_reduction_fix?(E)(ext(sigma)(lhs(e)), ext(theta)(lhs(e)),fsp) AND
    NOT fsp = #(empty_seq)    
      IMPLIES
        FORALL (x:Vars?(lhs(e))):
         parallel_reduction?(E)(ext(sigma)(x), ext(theta)(x))

  replace_par_pos_dominance: LEMMA
    SPP?(t)(fsp) AND SPP?(t)(fsp1) AND parallel_reduction_fix?(E)(t,s,fsp1) AND
     dominates?(<=)(seq2set(fsp), seq2set(fsp1))
       IMPLIES s = replace_par_pos(t,fsp,subtermsOF(s,fsp))
       
  Parallel_Moves_Lemma: LEMMA
      Orthogonal?(E) AND member(e,E) AND
      parallel_reduction?(E)(ext(sigma)(lhs(e)), t)
        IMPLIES EXISTS s: parallel_reduction?(E)(ext(sigma)(rhs(e)),s) AND
                        parallel_reduction?(E)(t,s)

 END orthogonality_basis

