(dp_termination (IMP_dependency_pairs_TCC1 0 (IMP_dependency_pairs_TCC1-1 nil 3765573363 ("" (rewrite "var_countable") nil nil) nil nil (IMP_dependency_pairs assuming "dependency_pairs[dp_termination.variable, dp_termination.symbol, dp_termination.arity].dependency_pairs" "var_countable: ASSUMPTION countability[term_adt[dependency_pairs.variable, dependency_pairs.symbol, dependency_pairs.arity].term].is_countably_infinite(variables_term[dependency_pairs.variable, dependency_pairs.symbol, dependency_pairs.arity].V)"))) (dp_termination_alt?_TCC1 0 (dp_termination_alt?_TCC1-1 nil 3763209458 ("" (skeep* :preds? t) (("" (typepred "dps(i)") (("" (expand "dep_pair_alt?") (("" (flatten) nil nil)) nil)) nil)) nil) ((dep_pair_alt type-eq-decl nil dependency_pairs nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (position type-eq-decl nil positions nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil)) nil (dp_termination_alt? subtype "dp_termination.dps(dp_termination.i)`2" "positions[dp_termination.variable, dp_termination.symbol, dp_termination.arity].positions?(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dps(dp_termination.i)`1))"))) (dp_termination_alt?_TCC2 0 (dp_termination_alt?_TCC2-1 nil 3763209458 ("" (skeep* :preds? t) (("" (replaces -2) (("" (assert) (("" (typepred "dps(x1)") (("" (expand "dep_pair_alt?") (("" (expand "dep_pair?") (("" (flatten) (("" (assert) (("" (inst?) (("" (assert) (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((dep_pair_alt type-eq-decl nil dependency_pairs nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (position type-eq-decl nil positions nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (dep_pair? const-decl "bool" dependency_pairs nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (rhs const-decl "term" rewrite_rules nil) (positions? type-eq-decl nil positions nil)) nil (dp_termination_alt? subtype "dp_termination.seq" "sequence[dep_pair[variable, symbol, arity](E)]"))) (dp_termination_and_alt_eq 0 (dp_termination_and_alt_eq-1 nil 3763209469 ("" (skeep*) (("" (prop) (("1" (expand "dp_termination_alt?") (("1" (expand "dp_termination?") (("1" (skeep*) (("1" (inst -1 "(LAMBDA(i:nat): rule_and_pos_from_dp(E)(seq(i)))" "sigmas") (("1" (expand "infinite_dep_chain?") (("1" (skolem 1 ("i" "j")) (("1" (inst?) (("1" (flatten) (("1" (assert) (("1" (expand "chained_dp?") (("1" (assert) (("1" (expand "rule_and_pos_from_dp") (("1" (typepred "choose({(e: rewrite_rule), (p: position)
                                                                                                |
                                                                                                member(e, E)
                                                                                                AND
                                                                                                lhs(e) = seq(i)`1
                                                                                                AND
                                                                                                positionsOF(rhs(e))(p)
                                                                                                AND
                                                                                                subtermOF(rhs(e), p) = seq(i)`2})") (("1" (name-replace "choose1" "choose({(e: rewrite_rule), (p: position)
                                                                                                                    |
                                                                                                                    member(e, E)
                                                                                                                    AND
                                                                                                                    lhs(e) = seq(i)`1
                                                                                                                    AND
                                                                                                                    positionsOF(rhs(e))(p)
                                                                                                                    AND
                                                                                                                    subtermOF(rhs(e), p) = seq(i)`2})") (("1" (typepred "choose({(e: rewrite_rule), (p: position) |
                                                                                                            member(e, E) AND
                                                                                                             lhs(e) = seq(1 + i)`1 AND
                                                                                                              positionsOF(rhs(e))(p) AND
                                                                                                               subtermOF(rhs(e), p) = seq(1 + i)`2})") (("1" (name-replace "choose2" "choose({(e: rewrite_rule), (p: position) |
                                                                                                                                member(e, E) AND
                                                                                                                                 lhs(e) = seq(1 + i)`1 AND
                                                                                                                                  positionsOF(rhs(e))(p) AND
                                                                                                                                   subtermOF(rhs(e), p) = seq(1 + i)`2})") (("1" (replaces -8) (("1" (replaces -2) nil nil)) nil)) nil) ("2" (hide -6 3) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (typepred "seq(i + 1)") (("2" (expand "dep_pair?") (("2" (flatten) (("2" (skeep*) (("2" (inst -6 "(e,p)") (("2" (assert) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 3) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (typepred "seq(i)") (("2" (expand "dep_pair?") (("2" (flatten) (("2" (skeep*) (("2" (inst -6 "(e,p)") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep*) (("2" (typepred "seq(i)") (("2" (hide -2) (("2" (expand "dep_pair?") (("2" (expand "dep_pair_alt?") (("2" (flatten) (("2" (assert) (("2" (skeep*) (("2" (expand "rule_and_pos_from_dp") (("2" (typepred "choose({(e: rewrite_rule), (p: position) |
                                                                                                 member(e, E) AND
                                                                                                  lhs(e) = seq(i)`1 AND
                                                                                                   positionsOF(rhs(e))(p) AND
                                                                                                    subtermOF(rhs(e), p) = seq(i)`2})") (("1" (assert) (("1" (name-replace "ee" "choose({(e: rewrite_rule), (p: position) |
                                         member(e, E) AND
                                          lhs(e) = seq(i)`1 AND
                                           positionsOF(rhs(e))(p) AND
                                            subtermOF(rhs(e), p) = seq(i)`2})") (("1" (hide-all-but (-1 1)) (("1" (expand "member") (("1" (expand "lhs") (("1" (typepred "ee`1") (("1" (expand "rewrite_rule?") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -1 "(e,p)") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "dp_termination_alt?") (("2" (skeep) (("2" (expand "dp_termination?") (("2" (inst -1 "(LAMBDA(i:nat): (lhs(dps(i)`1), subtermOF(rhs(dps(i)`1),dps(i)`2)))" "sigmas") (("1" (skeep) (("1" (hide -) (("1" (typepred "dps(i)") (("1" (expand "dep_pair_alt?") (("1" (expand "dep_pair?") (("1" (flatten) (("1" (assert) (("1" (expand "defined?") (("1" (assert) (("1" (inst 1 "dps(i)`1") (("1" (assert) (("1" (inst 1 "dps(i)`2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "dps(i)") (("2" (expand "dep_pair_alt?") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rule_and_pos_from_dp const-decl "[rewrite_rule, position]" dependency_pairs nil) (dep_pair type-eq-decl nil dependency_pairs nil) (dep_pair? const-decl "bool" dependency_pairs nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (position type-eq-decl nil positions nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (empty? const-decl "bool" sets nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (rhs const-decl "term" rewrite_rules nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (lhs const-decl "term" rewrite_rules nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (defined? const-decl "bool" rewrite_rules nil)) nil)) (noetherian_implies_dp_termination 0 (noetherian_implies_dp_termination-1 nil 3763209509 ("" (skeep) (("" (lemma "dp_termination_and_alt_eq") (("" (inst?) (("" (assert) (("" (hide 2) (("" (rewrite "R_is_Noet_iff_TC_is") (("" (assert) (("" (expand "noetherian?") (("" (expand "dp_termination_alt?") (("" (rewrite "no_infinite_descending_sequence") (("" (expand "empty?") (("" (skeep :preds? t) (("" (expand "member") (("" (expand "descending?") (("" (expand "converse") (("" (assert) (("" (inst -2 "(LAMBDA(i:nat): term_pos_dps_alt(E)(dps,sigmas,i)`1)") (("" (induct "n") (("1" (assert) (("1" (expand "term_pos_dps_alt") (("1" (expand "term_pos_dps_alt") (("1" (typepred "dps(0)" "dps(1)") (("1" (expand "dep_pair_alt?") (("1" (flatten) (("1" (expand "infinite_dep_chain?") (("1" (inst -11 0 1) (("1" (assert) (("1" (expand "chained_dp?") (("1" (lemma "non_root_subset_reduction") (("1" (inst?) (("1" (lemma "Closure_monotony") (("1" (inst?) (("1" (assert) (("1" (flatten) (("1" (hide -1 -2 -3 -5 -6) (("1" (expand "subset?") (("1" (expand "member") (("1" (inst?) (("1" (assert) (("1" (lemma "reduction_is_subs_op") (("1" (inst -1 "E") (("1" (flatten) (("1" (lemma "lhs_reduces_to_rhs") (("1" (inst -1 "E" "dps(1)`1") (("1" (expand "close_subs?") (("1" (inst -2 "lhs(dps(1)`1)" "rhs(dps(1)`1)" "sigmas(1)") (("1" (assert) (("1" (rewrite "comp_op_iff_comp_cont") (("1" (lemma "closure_comp_cont") (("1" (inst?) (("1" (assert) (("1" (flatten) (("1" (hide -1) (("1" (expand "comp_cont?" -1) (("1" (inst -1 "dps(0)`2" "ext(sigmas(0))(rhs(dps(0)`1))") (("1" (rewrite "ext_preserv_pos") (("1" (inst -1 "ext(sigmas(0))(subtermOF(rhs(dps(0)`1), dps(0)`2))" "ext(sigmas(1))(lhs(dps(1)`1))") (("1" (assert) (("1" (expand "TC" 1) (("1" (expand "RTC" -1) (("1" (expand "IUnion") (("1" (skeep*) (("1" (inst 1 "i+1") (("1" (lemma "iterate_add_applied") (("1" (inst -1 "reduction?(E)" "i" "1" "replaceTerm(ext(sigmas(0))(rhs(dps(0)`1)),ext(sigmas(0))(subtermOF(rhs(dps(0)`1), dps(0)`2)),dps(0)`2)" "replaceTerm(ext(sigmas(0))(rhs(dps(0)`1)),
                                                                                                      ext(sigmas(1))(lhs(dps(1)`1)),
                                                                                                      dps(0)`2)" "replaceTerm(ext(sigmas(0))(rhs(dps(0)`1)),
                                                                                                      ext(sigmas(1))(rhs(dps(1)`1)),
                                                                                                      dps(0)`2)") (("1" (assert) (("1" (rewrite "iterate_1") (("1" (prop) (("1" (lemma "replace_subterm_of_term") (("1" (inst -1 "dps(0)`2" "ext(sigmas(0))(rhs(dps(0)`1))") (("1" (rewrite "ext_preserv_pos") (("1" (lemma "subterm_of_ext") (("1" (inst -1 "dps(0)`2" "empty_seq" "sigmas(0)" "rhs(dps(0)`1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -6 2) (("2" (expand "comp_cont?") (("2" (inst -3 "dps(0)`2" "ext(sigmas(0))(rhs(dps(0)`1))") (("2" (rewrite "ext_preserv_pos") (("2" (inst -3 "ext(sigmas(1))(lhs(dps(1)`1))" "ext(sigmas(1))(rhs(dps(1)`1))") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (expand "term_pos_dps_alt" 1) (("2" (expand "term_pos_dps_alt" 1 (3 4)) (("2" (expand "term_pos_dps_alt" -1 2) (("2" (expand "infinite_dep_chain?") (("2" (inst -2 "1+j" "2+j") (("2" (assert) (("2" (expand "chained_dp?") (("2" (lemma "non_root_subset_reduction") (("2" (inst?) (("2" (lemma "Closure_monotony") (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (hide -1 -2 -3 -5 -6) (("2" (expand "subset?") (("2" (expand "member") (("2" (inst?) (("2" (assert) (("2" (typepred "dps(1+j)" "dps(2+j)") (("2" (expand "dep_pair_alt?") (("2" (flatten) (("2" (lemma "lhs_reduces_to_rhs") (("2" (inst-cp -1 "E" "dps(1 + j)`1") (("2" (inst -1 "E" "dps(2 + j)`1") (("2" (lemma "ext_preserv_pos") (("2" (inst-cp -1 "dps(1 + j)`2" "rhs(dps(1 + j)`1)" "sigmas(1 + j)") (("2" (assert) (("2" (inst -1 "dps(2 + j)`2" "rhs(dps(2 + j)`1)" "sigmas(2 + j)") (("2" (assert) (("2" (lemma "reduction_is_subs_op") (("2" (inst -1 "E") (("2" (flatten) (("2" (expand "close_subs?") (("2" (inst-cp -1 "lhs(dps(1 + j)`1)" "rhs(dps(1 + j)`1)" "sigmas(1 + j)") (("2" (assert) (("2" (inst -1 "lhs(dps(2 + j)`1)" "rhs(dps(2 + j)`1)" "sigmas(2 + j)") (("2" (assert) (("2" (rewrite "replace_associativity") (("2" (hide -6 -7 -8 -9 -10 -11 -12 -13 -14 -15 -16 -17 -20) (("2" (rewrite "comp_op_iff_comp_cont") (("2" (lemma "closure_comp_cont") (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (hide -3) (("2" (expand "comp_cont?" -5) (("2" (inst-cp -5 "dps(1 + j)`2" "ext(sigmas(1 + j))(rhs(dps(1 + j)`1))") (("2" (assert) (("2" (inst -6 "ext(sigmas(2 + j))(lhs(dps(2 + j)`1))" "ext(sigmas(2 + j))(rhs(dps(2 + j)`1))") (("2" (assert) (("2" (hide -3) (("2" (expand "comp_cont?" -2) (("2" (inst-cp -2 "dps(1 + j)`2" "ext(sigmas(1 + j))(rhs(dps(1 + j)`1))") (("2" (assert) (("2" (inst -3 "ext(sigmas(1 + j))
                                                     (subtermOF(rhs(dps(1 + j)`1), dps(1 + j)`2))" "ext(sigmas(2 + j))(lhs(dps(2 + j)`1))") (("2" (assert) (("2" (lemma "replace_subterm_of_term") (("2" (inst -1 "dps(1 + j)`2" "ext(sigmas(1 + j))(rhs(dps(1 + j)`1))") (("2" (assert) (("2" (lemma "subterm_of_ext") (("2" (inst -1 "dps(1 + j)`2" "empty_seq" "sigmas(1 + j)" "rhs(dps(1 + j)`1)") (("2" (assert) (("2" (replace -1 -5 rl) (("2" (replace -2 -5) (("2" (hide -1 -2) (("2" (typepred "term_pos_dps_alt(E)(dps, sigmas, j)") (("2" (inst -3 "term_pos_dps_alt(E)(dps, sigmas, j)`2" "term_pos_dps_alt(E)(dps, sigmas, j)`1") (("2" (assert) (("2" (inst -3 "ext(sigmas(1 + j))(rhs(dps(1 + j)`1))" "replaceTerm(ext(sigmas(1 + j))(rhs(dps(1 + j)`1)),ext(sigmas(2 + j))
                                                                   (lhs(dps(2 + j)`1)),
                                                                dps(1 + j)`2)") (("2" (assert) (("2" (hide -4) (("2" (expand "RTC") (("2" (expand "TC" 1) (("2" (expand "IUnion") (("2" (skeep) (("2" (inst 1 "i + 1") (("2" (lemma "iterate_add_applied") (("2" (inst -1 "reduction?(E)" "i" "1" "replaceTerm(term_pos_dps_alt(E)(dps, sigmas, j)`1,
                                                                    ext(sigmas(1 + j))
                                                                       (rhs(dps(1 + j)`1)),
                                                                    term_pos_dps_alt(E)(dps, sigmas, j)`2)" "replaceTerm(term_pos_dps_alt(E)(dps, sigmas, j)`1,
                                                                    replaceTerm(ext
                                                                                (sigmas(1 + j))
                                                                                (rhs(dps(1 + j)`1)),
                                                                                ext
                                                                                (sigmas(2 + j))
                                                                                (lhs(dps(2 + j)`1)),
                                                                                dps(1 + j)`2),
                                                                    term_pos_dps_alt(E)(dps, sigmas, j)`2)" "replaceTerm(term_pos_dps_alt(E)(dps, sigmas, j)`1,
                                                                    replaceTerm(ext
                                                                                (sigmas(1 + j))
                                                                                (rhs(dps(1 + j)`1)),
                                                                                ext
                                                                                (sigmas(2 + j))
                                                                                (rhs(dps(2 + j)`1)),
                                                                                dps(1 + j)`2),
                                                                    term_pos_dps_alt(E)(dps, sigmas, j)`2)") (("2" (assert) (("2" (hide-all-but (-1 -5 -6 1)) (("2" (inst - "term_pos_dps_alt(E)(dps, sigmas, j)`2" "term_pos_dps_alt(E)(dps, sigmas, j)`1") (("2" (assert) (("2" (inst -2 "replaceTerm(ext(sigmas(1 + j))(rhs(dps(1 + j)`1)),ext(sigmas(2 + j))
                                                                          (lhs(dps(2 + j)`1)),
                                                                       dps(1 + j)`2)" "replaceTerm(ext(sigmas(1 + j))(rhs(dps(1 + j)`1)),ext(sigmas(2 + j))
                                                                          (rhs(dps(2 + j)`1)),
                                                                       dps(1 + j)`2)") (("2" (assert) (("2" (rewrite "iterate_1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((R_is_Noet_iff_TC_is formula-decl nil noetherian nil) (reduction? const-decl "bool" reduction nil) (noetherian? const-decl "bool" noetherian nil) (no_infinite_descending_sequence formula-decl nil well_foundedness orders) (transitive? const-decl "bool" relations nil) (transitive type-eq-decl nil relations_closure nil) (TC const-decl "transitive" relations_closure nil) (descending? const-decl "bool" monotone_sequences orders) (non_root_reduction? const-decl "bool" reduction nil) (subset? const-decl "bool" sets nil) (lhs const-decl "term" rewrite_rules nil) (rhs const-decl "term" rewrite_rules nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (ext def-decl "term" substitution nil) (reduction_is_subs_op formula-decl nil reduction nil) (comp_op_iff_comp_cont formula-decl nil compatibility nil) (comp_cont? const-decl "bool" compatibility nil) (ext_preserv_pos formula-decl nil substitution nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (iterate_add_applied formula-decl nil relation_iterate orders) (subterm_of_ext formula-decl nil substitution nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (replace_subterm_of_term formula-decl nil replacement nil) (iterate_1 formula-decl nil relation_iterate orders) (replaceTerm def-decl "term" replacement nil) (closure_comp_cont formula-decl nil compatibility nil) (close_subs? const-decl "bool" reduction nil) (lhs_reduces_to_rhs formula-decl nil reduction nil) (Closure_monotony formula-decl nil relations_closure nil) (non_root_subset_reduction formula-decl nil reduction nil) (replace_associativity formula-decl nil replacement nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (term_pos_dps_alt def-decl "{(t, p) | positionsOF(t)(p)}" dependency_pairs nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil)) nil)) (mnt_is_app 0 (mnt_is_app-2 nil 3762593796 ("" (skeep) (("" (expand "minimal_non_terminating?") (("" (flatten) (("" (hide -1) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((Vars const-decl "set[(V)]" subterm nil) (subset? const-decl "bool" sets nil) (is_finite const-decl "bool" finite_sets nil) (empty_seq const-decl "finseq" finite_sequences nil) (only_empty_seq const-decl "positions" positions nil) (subtermOF def-decl "term" subterm nil) (replaceTerm def-decl "term" replacement nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (insert? const-decl "finseq" seq_extras structures) (add_first const-decl "finseq" seq_extras structures) (catenate const-decl "positions" positions nil) (union const-decl "set" sets nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (finseq type-eq-decl nil finite_sequences nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (ext def-decl "term" substitution nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (lhs const-decl "term" rewrite_rules nil) (rhs const-decl "term" rewrite_rules nil) (reduction? const-decl "bool" reduction nil) (term type-decl nil term_adt nil) (terminating? const-decl "bool" noetherian nil) (Dom const-decl "set[(V)]" substitution nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (V const-decl "set[term]" variables_term nil)) nil) (mnt_is_app-1 nil 3760195666 ("" (skeep) (("" (expand "minimal_innermost_non_terminating?") (("" (flatten) (("" (hide -1) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (ext def-decl "term" substitution nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (finseq type-eq-decl nil finite_sequences nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (union const-decl "set" sets nil) (catenate const-decl "positions" positions nil) (add_first const-decl "finseq" seq_extras structures) (insert? const-decl "finseq" seq_extras structures) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (replaceTerm def-decl "term" replacement nil) (subtermOF def-decl "term" subterm nil) (only_empty_seq const-decl "positions" positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (is_finite const-decl "bool" finite_sets nil) (subset? const-decl "bool" sets nil) (Vars const-decl "set[(V)]" subterm nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (lhs const-decl "term" rewrite_rules nil) (rhs const-decl "term" rewrite_rules nil) (reduction_fix? const-decl "bool" reduction nil) (non_root_reduction? const-decl "bool" reduction nil) (reducible? const-decl "bool" ars_terminology nil) (is_normal_form? const-decl "bool" ars_terminology nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (innermost_reduction? const-decl "bool" innermost_reduction nil) (terminating? const-decl "bool" noetherian nil) (Dom const-decl "set[(V)]" substitution nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (V const-decl "set[term]" variables_term nil)) shostak)) (args_minimal 0 (args_minimal-1 nil 3762527423 ("" (skeep :preds? t) (("" (expand "minimal_non_terminating?") (("" (prop) (("1" (expand "finseq_appl") (("1" (skeep) (("1" (inst -1 "#(i+1)") (("1" (expand "subtermOF") (("1" (expand "first") (("1" (expand "finseq_appl") (("1" (expand "#") (("1" (expand "rest") (("1" (expand "^") (("1" (rewrite "subterm_empty_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (prop) (("1" (hide 2 3) (("1" (grind) (("1" (inst 1 "1+i") (("1" (inst 1 "empty_seq") (("1" (prop) (("1" (expand "positionsOF") (("1" (expand "only_empty_seq") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "empty_seq") (("2" (propax) nil nil)) nil) ("3" (decompose-equality 1) (("3" (skeep :preds? t) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (skolem 1 "ps") (("2" (typepred "ps") (("2" (case "length(ps)=1") (("1" (inst -3 "first(ps) - 1") (("1" (expand "subtermOF") (("1" (expand "empty_seq") (("1" (decompose-equality 1) (("1" (expand "finseq_appl") (("1" (expand "rest") (("1" (expand "^") (("1" (rewrite "subterm_empty_seq") nil nil)) nil)) nil)) nil) ("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "first(ps)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil) ("2" (inst -2 "#(first(ps))`seq(0) - 1") (("1" (expand "#") (("1" (lemma "terminating_all_subterms") (("1" (inst -1 "E" "subtermOF(t, #(ps`seq(0)))") (("1" (assert) (("1" (lemma "pos_subterm") (("1" (inst -1 "#(ps`seq(0))" "rest(ps)" "t") (("1" (prop) (("1" (inst -2 "rest(ps)") (("1" (assert) (("1" (replace -3 -2 rl) (("1" (hide -3) (("1" (case "#(ps`seq(0)) o rest(ps) = ps") (("1" (assert) nil nil) ("2" (hide-all-but (1 2 3)) (("2" (grind) (("1" (decompose-equality 3) (("1" (decompose-equality) nil nil)) nil) ("2" (decompose-equality 2) (("1" (decompose-equality) (("1" (typepred "x!1") (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (typepred "n") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 1) (("2" (hide 4) (("2" (expand "subtermOF") (("2" (expand "finseq_appl") (("2" (expand "first") (("2" (expand "finseq_appl") (("2" (expand "#") (("2" (expand "rest") (("2" (expand "^") (("2" (rewrite "subterm_empty_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1 2 3)) (("3" (case "#(ps`seq(0)) o rest(ps) = ps") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (grind) (("1" (decompose-equality 3) (("1" (decompose-equality) nil nil)) nil) ("2" (decompose-equality 2) (("1" (decompose-equality) (("1" (typepred "x!1") (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (typepred "n") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -1 1 3 6 7) (("4" (expand "subtermOF") (("4" (expand "finseq_appl") (("4" (expand "first") (("4" (expand "rest") (("4" (expand "#") (("4" (expand "^") (("4" (expand "finseq_appl") (("4" (rewrite "subterm_empty_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "#") (("2" (expand "positionsOF") (("2" (expand "only_empty_seq") (("2" (expand "union") (("2" (expand "member") (("2" (assert) (("2" (prop) (("2" (expand "IUnion") (("2" (skeep) (("2" (expand "catenate") (("2" (expand "finseq_appl") (("2" (skeep) (("2" (inst 2 "i_1") (("2" (inst 2 "empty_seq") (("2" (prop) (("1" (expand "member") (("1" (hide -1) (("1" (expand "positionsOF") (("1" (expand "only_empty_seq") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (expand "union") (("3" (expand "member") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 3)) (("3" (expand "empty_seq") (("3" (decompose-equality 2) (("3" (decompose-equality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "first(ps)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("3" (expand "empty_seq") (("3" (decompose-equality 3) (("3" (decompose-equality) nil nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((terminating_all_subterms formula-decl nil reduction nil) (O const-decl "finseq" finite_sequences nil) (pos_subterm formula-decl nil subterm nil) (not_empty_seq type-eq-decl nil seq_extras structures) (rhs const-decl "term" rewrite_rules nil) (lhs const-decl "term" rewrite_rules nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (reduction? const-decl "bool" reduction nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (terminating? const-decl "bool" noetherian nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (positions? type-eq-decl nil positions nil) (first const-decl "T" seq_extras structures) (^ const-decl "finseq" finite_sequences nil) (subterm_empty_seq formula-decl nil subterm nil) (rest const-decl "finseq" seq_extras structures) (subtermOF def-decl "term" subterm nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (only_empty_seq const-decl "positions" positions nil) (member const-decl "bool" sets nil) (insert? const-decl "finseq" seq_extras structures) (add_first const-decl "finseq" seq_extras structures) (catenate const-decl "positions" positions nil) (union const-decl "set" sets nil)) nil)) (non_terminating_has_mnt 0 (non_terminating_has_mnt-1 nil 3760195556 ("" (skeep) (("" (induct "t") (("1" (typepred "t!1") (("1" (propax) nil nil)) nil) ("2" (skeep :preds? t) (("2" (hide 2) (("2" (expand "terminating?") (("2" (skeep) (("2" (inst -2 0) (("2" (assert) (("2" (use "reducible_is_app") (("2" (assert) (("2" (expand "reducible?") (("2" (inst 1 "seq(1)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (case "arity(app1_var) =0") (("1" (hide -3) (("1" (inst 2 "empty_seq") (("1" (rewrite "subterm_empty_seq") (("1" (expand "minimal_non_terminating?") (("1" (assert) (("1" (skeep :preds? t) (("1" (expand "positionsOF") (("1" (assert) (("1" (expand "only_empty_seq") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "empty_seq_is_position") nil nil)) nil)) nil) ("2" (expand "terminating?" 2) (("2" (skeep*) (("2" (case "minimal_non_terminating?(E)(app(app1_var, app2_var))") (("1" (inst 2 "empty_seq") (("1" (rewrite "subterm_empty_seq") nil nil) ("2" (use "empty_seq_is_position") nil nil)) nil) ("2" (case "FORALL(t:term | app?(t) AND length(args(t)) > 0 AND 
    	   NOT terminating?(reduction?(E))(t)):
      minimal_non_terminating?(E)(t) IFF
         FORALL(i: below[length(args(t))]): 
	  terminating?(reduction?(E))(args(t)(i))") (("1" (inst -1 "app(app1_var, app2_var)") (("1" (assert) (("1" (skeep) (("1" (inst -2 "i") (("1" (expand "finseq_appl") (("1" (prop) (("1" (skeep) (("1" (inst 4 "add_first(i+1,p)") (("1" (expand "subtermOF" 4) (("1" (prop) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil) ("2" (expand "first") (("2" (expand "finseq_appl") (("2" (expand "add_first") (("2" (assert) (("2" (case "insert?[posnat](1 + i, p, 0)`seq(0) - 1 = i AND rest(insert?(1 + i, p, 0)) = p") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (prop) (("1" (expand "insert?") (("1" (propax) nil nil)) nil) ("2" (expand "insert?") (("2" (expand "rest") (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (expand "^") (("2" (grind) (("1" (decompose-equality 2) (("1" (decompose-equality) nil nil)) nil) ("2" (decompose-equality 2) (("2" (decompose-equality) nil nil)) nil) ("3" (decompose-equality 4) (("1" (decompose-equality) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "p") (("2" (hide -2 -5 2 3) (("2" (expand "positionsOF" 1) (("2" (expand "union") (("2" (expand "member") (("2" (expand "only_empty_seq") (("2" (prop) (("2" (expand "IUnion") (("2" (inst 2 "i+1") (("2" (expand "catenate") (("2" (inst 2 "p") (("2" (expand "member") (("2" (expand "finseq_appl") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -3 3) (("2" (expand "minimal_non_terminating?") (("2" (prop) (("1" (expand "terminating?") (("1" (inst 1 "seq") (("1" (prop) nil nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (hide-all-but (-1 -2 2)) (("2" (lemma "terminating_all_subterms") (("2" (inst -1 "E" "app[variable, symbol, arity](app1_var, app2_var)") (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (use "args_minimal") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((term type-decl nil term_adt nil) (terminating? const-decl "bool" noetherian nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (reduction? const-decl "bool" reduction nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (term_induction formula-decl nil term_adt nil) (reducible? const-decl "bool" ars_terminology nil) (reducible_is_app formula-decl nil reduction nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (only_empty_seq const-decl "positions" positions nil) (subterm_empty_seq formula-decl nil subterm nil) (empty_seq_is_position formula-decl nil positions nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (terminating_all_subterms formula-decl nil reduction nil) (add_first const-decl "finseq" seq_extras structures) (insert? const-decl "finseq" seq_extras structures) (^ const-decl "finseq" finite_sequences nil) (rest const-decl "finseq" seq_extras structures) (first const-decl "T" seq_extras structures) (union const-decl "set" sets nil) (catenate const-decl "positions" positions nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (member const-decl "bool" sets nil)) nil)) (positions_of_infnr_reduction 0 (positions_of_infnr_reduction-1 nil 3760196789 ("" (skeep* :preds? t) (("" (inst 1 "LAMBDA(i:nat): choose({p: positions?(seqt(i)) | NOT p = empty_seq AND reduction_fix?(E)(seqt(i), seqt(i + 1), p)})") (("1" (skeep) (("1" (typepred "choose({p: positions?(seqt(j)) | NOT p = empty_seq AND
                                   reduction_fix?(E)
                                                            (seqt(j),
                                                             seqt(j + 1),
                                                             p)})") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (inst -2 "j") (("2" (expand "non_root_reduction?") (("2" (skeep) (("2" (inst?) (("2" (expand "reduction_fix?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (expand "non_root_reduction?") (("2" (inst -2 "i") (("2" (skeep) (("2" (inst?) (("2" (expand "reduction_fix?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((reduction_fix? const-decl "bool" reduction nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (choose const-decl "(p)" sets nil) (member const-decl "bool" sets nil) (non_root_reduction? const-decl "bool" reduction nil) (empty? const-decl "bool" sets nil)) shostak)) (positions_of_inf_reduction 0 (positions_of_inf_reduction-1 nil 3763232164 ("" (skeep* :preds? t) (("" (inst 1 "LAMBDA(i:nat): choose({p: positions?(seqt(i)) | reduction_fix?(E)(seqt(i), seqt(i + 1), p)})") (("1" (skeep) (("1" (typepred "choose({p: positions?(seqt(j)) | 
                                       reduction_fix?(E)
                                                                (seqt(j),
                                                                 seqt(j + 1),
                                                                 p)})") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (inst -2 "j") (("2" (expand "reduction?") (("2" (skeep) (("2" (inst?) (("2" (expand "reduction_fix?") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (expand "reduction?") (("2" (inst -2 "i") (("2" (skeep) (("2" (inst?) (("2" (expand "reduction_fix?") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((reduction_fix? const-decl "bool" reduction nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (choose const-decl "(p)" sets nil) (member const-decl "bool" sets nil) (reduction? const-decl "bool" reduction nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (empty? const-decl "bool" sets nil)) nil)) (exists_inf_red_arg_in_inf_nr_red_TCC1 0 (exists_inf_red_arg_in_inf_nr_red_TCC1-2 "" 3790334291 ("" (skeep :preds? t) nil nil) nil shostak (exists_inf_red_arg_in_inf_nr_red subtype "dp_termination.seqt(0)" "(term_adt[dp_termination.variable, dp_termination.symbol, dp_termination.arity].app?)")) (exists_inf_red_arg_in_inf_nr_red_TCC1-1 nil 3765557633 ("" (skeep :preds? t) (("" (inst?) (("" (flatten) (("" (use "reducible_is_app") (("" (assert) (("" (expand "reducible?") (("" (expand "reduction_fix?") (("" (skeep) (("" (inst 1 "seqt(1)") (("" (assert) (("" (expand "reduction?") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (exists_inf_red_arg_in_inf_nr_red subtype "dp_termination.seqt(0)" "(term_adt[dp_termination.variable, dp_termination.symbol, dp_termination.arity].app?)"))) (exists_inf_red_arg_in_inf_nr_red_TCC2 0 (exists_inf_red_arg_in_inf_nr_red_TCC2-1 nil 3765557633 ("" (skeep* :preds? t) (("" (inst -3 "i") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil) nil nil (exists_inf_red_arg_in_inf_nr_red subtype "dp_termination.seqp" "{seqp: sequences[position[variable, symbol, arity]].sequence | FORALL (i: naturalnumbers.nat): (booleans.NOT)(seqp(i) = finite_sequences[posnat].empty_seq)}"))) (exists_inf_red_arg_in_inf_nr_red 0 (exists_inf_red_arg_in_inf_nr_red-2 "" 3790334292 ("" (skeep* :preds? t) (("" (lemma "infinite_pigeonhole[nat, {l: posnat | l<= length(args(seqt(0)))}]") (("1" (inst -1 "args_of_pos_seq(seqp)") (("1" (skolem -1 "l") (("1" (typepred "l") (("1" (inst 2 "l") (("1" (expand "inf_red_arg_in_inf_nr_im_red") (("1" (expand "singleton") (("1" (expand "inverse_image") (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (case "RTC(non_root_reduction?(E))(seqt(0), seqt(x1))") (("1" (expand "args_of_pos_seq") (("1" (use "non_root_rtc_preserves_root_symbol") (("1" (assert) (("1" (flatten) (("1" (inst -4 "x1") (("1" (flatten) (("1" (hide -3 -5) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "seq_of_relation_RTC") (("2" (assert) (("2" (skeep) (("2" (inst?) (("2" (flatten) (("2" (expand "non_root_reduction?") (("2" (inst 1 "seqp(k)") (("2" (typepred "seqp") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (assert) (("3" (inst -2 "i") (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "is_finite_type") (("2" (inst 1 "length(args(seqt(0))) + 1" "LAMBDA(l: posnat | l <= length(args(seqt(0)))): l") (("2" (expand "injective?") (("2" (skeep) nil nil)) nil)) nil)) nil) ("3" (hide-all-but -1) (("3" (expand "is_finite_type") (("3" (lemma "infinite_def[nat]") (("3" (inst -1 "{x:nat | x >=0}") (("3" (prop) (("1" (expand "is_finite") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (term type-decl nil term_adt nil) (infinite_pigeonhole formula-decl nil infinite_pigeonhole orders) (is_finite_type const-decl "bool" finite_sets nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (non_root_reduction? const-decl "bool" reduction nil) (non_root_rtc_preserves_root_symbol formula-decl nil reduction nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (first const-decl "T" seq_extras structures) (only_empty_seq const-decl "positions" positions nil) (insert? const-decl "finseq" seq_extras structures) (add_first const-decl "finseq" seq_extras structures) (catenate const-decl "positions" positions nil) (union const-decl "set" sets nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (seq_of_relation_RTC formula-decl nil relations_closure nil) (singleton const-decl "(singleton?)" sets nil) (member const-decl "bool" sets nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (positions? type-eq-decl nil positions nil) (reduction_fix? const-decl "bool" reduction nil) (is_finite const-decl "bool" finite_sets nil) (infinite_def formula-decl nil infinite_nat_def sets_aux)) shostak) (exists_inf_red_arg_in_inf_nr_red-1 nil 3765557673 ("" (skeep* :preds? t) (("" (lemma "infinite_pigeonhole[nat, {l: posnat | l<= length(args(seqt(0)))}]") (("1" (inst -1 "args_of_pos_seq(seqp)") (("1" (skolem -1 "l") (("1" (typepred "l") (("1" (inst 2 "l") (("1" (expand "inf_red_arg_in_inf_nr_im_red") (("1" (expand "singleton") (("1" (expand "inverse_image") (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (case "RTC(non_root_reduction?(E))(seqt(0), seqt(x1))") (("1" (expand "args_of_pos_seq") (("1" (use "non_root_rtc_preserves_root_symbol") (("1" (assert) (("1" (flatten) (("1" (inst -4 "x1") (("1" (flatten) (("1" (hide -3 -5) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "seq_of_relation_RTC") (("2" (assert) (("2" (skeep) (("2" (inst?) (("2" (flatten) (("2" (expand "non_root_reduction?") (("2" (inst 1 "seqp(k)") (("2" (typepred "seqp") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (assert) (("3" (inst -2 "i") (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "is_finite_type") (("2" (inst 1 "length(args(seqt(0))) + 1" "LAMBDA(l: posnat | l <= length(args(seqt(0)))): l") (("2" (expand "injective?") (("2" (skeep) nil nil)) nil)) nil)) nil) ("3" (hide-all-but -1) (("3" (expand "is_finite_type") (("3" (lemma "infinite_def[nat]") (("3" (inst -1 "{x:nat | x >=0}") (("3" (prop) (("1" (expand "is_finite") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (inst?) (("2" (assert) (("2" (expand "injective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (term type-decl nil term_adt nil) (infinite_pigeonhole formula-decl nil infinite_pigeonhole orders) (is_finite_type const-decl "bool" finite_sets nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (non_root_reduction? const-decl "bool" reduction nil) (non_root_rtc_preserves_root_symbol formula-decl nil reduction nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (first const-decl "T" seq_extras structures) (only_empty_seq const-decl "positions" positions nil) (insert? const-decl "finseq" seq_extras structures) (add_first const-decl "finseq" seq_extras structures) (catenate const-decl "positions" positions nil) (union const-decl "set" sets nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (seq_of_relation_RTC formula-decl nil relations_closure nil) (singleton const-decl "(singleton?)" sets nil) (member const-decl "bool" sets nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (positions? type-eq-decl nil positions nil) (reduction_fix? const-decl "bool" reduction nil) (is_finite const-decl "bool" finite_sets nil) (infinite_def formula-decl nil infinite_nat_def sets_aux)) nil)) (exists_nth_in_inf_nr_red_TCC1 0 (exists_nth_in_inf_nr_red_TCC1-1 nil 3765559456 ("" (skeep* :preds? t) (("" (inst -3 "i") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil) nil nil (exists_nth_in_inf_nr_red subtype "dp_termination.seqp" "{seqp: sequences[position[variable, symbol, arity]].sequence | FORALL (i: naturalnumbers.nat): (booleans.NOT)(seqp(i) = finite_sequences[posnat].empty_seq)}"))) (exists_nth_in_inf_nr_red_TCC2 0 (exists_nth_in_inf_nr_red_TCC2-2 nil 3765569845 ("" (skolem 1 ("E" "seqt" "seqp" "l1" "m")) (("" (prop) (("" (expand "is_finite") (("" (inst 1 "m" "LAMBDA(k: nat |
                             args_of_pos_seq(seqp)(k) = l1 AND
                              k < m): k") (("" (expand "injective?") (("" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil) ((position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (positions? type-eq-decl nil positions nil) (reduction_fix? const-decl "bool" reduction nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (is_finite const-decl "bool" finite_sets nil)) nil (exists_nth_in_inf_nr_red subtype "{k: naturalnumbers.nat | booleans.AND(dependency_pairs[dp_termination.variable, dp_termination.symbol, dp_termination.arity].args_of_pos_seq(dp_termination.seqp)(k) = dp_termination.l, reals.<(k, dp_termination.m))}" "finite_set[nat]")) (exists_nth_in_inf_nr_red_TCC2-1 nil 3765559456 ("" (subtype-tcc) nil nil) nil nil (exists_nth_in_inf_nr_red subtype "{k: naturalnumbers.nat | booleans.AND(dependency_pairs[dp_termination.variable, dp_termination.symbol, dp_termination.arity].args_of_pos_seq(dp_termination.seqp)(k) = dp_termination.l, reals.<(k, dp_termination.m))}" "finite_set[nat]"))) (exists_nth_in_inf_nr_red 0 (exists_nth_in_inf_nr_red-1 nil 3765559491 ("" (skeep) (("" (skeep) (("" (skeep :preds? t) (("" (skeep :preds? t) (("" (with-tccs (induct "n")) (("1" (expand "inf_red_arg_in_inf_nr_im_red") (("1" (expand "inverse_image") (("1" (expand "member") (("1" (expand "singleton") (("1" (use "infinite_nonempty[nat]") (("1" (inst 1 "min({x: nat | args_of_pos_seq(seqp)(x) = l})") (("1" (with-tccs (typepred "min({x: nat |
                                                                                                                              args_of_pos_seq(seqp)(x) = l})")) (("1" (prop) (("1" (hide -1) (("1" (with-tccs (case "nonempty?({k: nat |
                                                                                 args_of_pos_seq(seqp)(k) = l AND
                                                                                  k < min({x: nat | args_of_pos_seq(seqp)(x) = l})})")) (("1" (with-tccs (name "nnat" "choose({k: nat |
                                                                                                                                                                                                                                                        args_of_pos_seq(seqp)(k) = l AND
                                                                                                                                                                                                                                                         k <
                                                                                                                                                                                                                                                          min({x: nat | args_of_pos_seq(seqp)(x) = l})})")) (("1" (inst -3 "nnat") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "nonempty_card[nat]") (("2" (hide-all-but (-1 1 2)) (("2" (with-tccs (name-replace "sset" "{k: nat |
                                                                  args_of_pos_seq(seqp)(k) = l AND
                                                                   k < min({x: nat | args_of_pos_seq(seqp)(x) = l})}")) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -5 "i") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -4 "i") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep* :preds? t) (("2" (case "nonempty?({x: nat | args_of_pos_seq(seqp)(x) = l AND x > m})") (("1" (case "is_finite[nat]({k: nat | args_of_pos_seq(seqp)(k) = l AND k < m})") (("1" (inst 1 " min({x: nat |
                                                                                                                                                  args_of_pos_seq(seqp)(x) = l AND x > m})") (("1" (prop) (("1" (typepred "min({x: nat | args_of_pos_seq(seqp)(x) = l AND x > m})") (("1" (propax) nil nil) ("2" (propax) nil nil)) nil) ("2" (with-tccs (case "{k: nat |
                                                                                      args_of_pos_seq(seqp)(k) = l AND
                                                                                       k < min({x: nat | args_of_pos_seq(seqp)(x) = l AND x > m})} = add(m,{x: nat | args_of_pos_seq(seqp)(x) = l AND x < m})")) (("1" (replaces -1) (("1" (use " card_add[nat]") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "add") (("2" (hide -6 2) (("2" (expand "member") (("2" (decompose-equality) (("2" (iff) (("2" (typepred "min({x: nat | args_of_pos_seq(seqp)(x) = l AND x > m})") (("2" (prop) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (inst?) (("2" (assert) nil nil)) nil) ("3" (inst?) (("3" (assert) nil nil)) nil) ("4" (inst?) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -4 1)) (("2" (expand "is_finite") (("2" (inst 1 "m" "LAMBDA(k: nat |
                                                                                                                                                   args_of_pos_seq(seqp)(k) = l AND k < m): k") (("2" (expand "injective?") (("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "l") (("2" (expand "inf_red_arg_in_inf_nr_im_red") (("2" (expand "inverse_image") (("2" (expand "singleton") (("2" (expand "member") (("2" (case "{x: nat | args_of_pos_seq(seqp)(x) = l} = union({x: nat | args_of_pos_seq(seqp)(x) = l AND x <= m}, {x: nat | args_of_pos_seq(seqp)(x) = l AND x > m})") (("1" (replace -1 1) (("1" (lemma "infinite_union[nat]") (("1" (inst? -1) (("1" (assert) (("1" (prop) (("1" (hide-all-but (-2 1)) (("1" (expand "is_finite") (("1" (inst 1 "m+1" "LAMBDA (x: nat |
                                                                                                                                                                       args_of_pos_seq(seqp)(x) = l AND x <= m) : x") (("1" (expand "injective?") (("1" (skeep) nil nil)) nil) ("2" (typepred "seqp") (("2" (skeep) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "infinite_nonempty[nat]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (expand "union") (("2" (expand "member") (("2" (decompose-equality) (("2" (iff) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((add const-decl "(nonempty?)" sets nil) (card_add formula-decl nil finite_sets nil) (infinite_union formula-decl nil infinite_sets_def nil) (union const-decl "set" sets nil) (member const-decl "bool" sets nil) (infinite_nonempty judgement-tcc nil infinite_sets_def nil) (infinite_set type-eq-decl nil infinite_sets_def nil) (nonempty_card formula-decl nil finite_sets nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (position type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (positions? type-eq-decl nil positions nil) (reduction_fix? const-decl "bool" reduction nil)) nil)) (nth_index_std_TCC1 0 (nth_index_std_TCC1-1 nil 3765568262 ("" (subtype-tcc) nil nil) nil nil (nth_index_std subtype "dp_termination.seqt(0)" "(term_adt[dp_termination.variable, dp_termination.symbol, dp_termination.arity].app?)"))) (nth_index_std_TCC2 0 (nth_index_std_TCC2-2 "" 3804408294 ("" (skeep :preds? t) (("" (skeep) (("" (inst - "i") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil) nil shostak (nth_index_std subtype "dp_termination.seqp" "{seqp: sequences[position[variable, symbol, arity]].sequence | FORALL (i: naturalnumbers.nat): (booleans.NOT)(seqp(i) = finite_sequences[posnat].empty_seq)}")) (nth_index_std_TCC2-1 nil 3804335377 ("" (subtype-tcc) nil nil) nil nil (nth_index_std subtype "dp_termination.seqp" "{seqp: sequences[position[variable, symbol, arity]].sequence | FORALL (i: naturalnumbers.nat): (booleans.NOT)(seqp(i) = finite_sequences[posnat].empty_seq)}"))) (nth_index_std_TCC3 0 (nth_index_std_TCC2-1 nil 3765568262 ("" (skolem 1 ("E" "seqt" "seqp" "l1" "n")) (("" (typepred ("E" "seqt" "seqp" "l1" "n")) (("" (lemma "exists_nth_in_inf_nr_red") (("" (inst -1 "E" "seqt" "seqp" "l1" "n") (("" (expand "nonempty?") (("" (expand "empty?") (("" (expand "member") (("" (skeep) (("" (assert) (("" (inst? -9) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (reduction_fix? const-decl "bool" reduction nil) (positions? type-eq-decl nil positions nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (term type-decl nil term_adt nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil)) nil (nth_index_std subtype "{m: naturalnumbers.nat | booleans.AND(dependency_pairs[dp_termination.variable, dp_termination.symbol, dp_termination.arity].args_of_pos_seq(dp_termination.seqp)(m) = dp_termination.l, finite_sets[nat].card({k: naturalnumbers.nat | booleans.AND(dependency_pairs[dp_termination.variable, dp_termination.symbol, dp_termination.arity].args_of_pos_seq(dp_termination.seqp)(k) = dp_termination.l, reals.<(k, m))}) = dp_termination.n)}" "(sets[nat].nonempty?)"))) (nth_index_std_increasing_TCC1 0 (nth_index_std_increasing_TCC1-1 nil 3765568262 ("" (skeep* :preds? t) nil nil) nil nil (nth_index_std_increasing subtype "dp_termination.seqp" "{seqp: sequences[position[variable, symbol, arity]].sequence | FORALL (n: naturalnumbers.nat): booleans.AND(positions[dp_termination.variable, dp_termination.symbol, dp_termination.arity].positionsOF(dp_termination.seqt(n))(seqp(n)), booleans.AND((booleans.NOT)(finite_sequences[posnat].empty_seq = seqp(n)), reduction[dp_termination.variable, dp_termination.symbol, dp_termination.arity].reduction_fix?(dp_termination.E)(dp_termination.seqt(n), dp_termination.seqt((number_fields.+)(1, n)), seqp(n))))}"))) (nth_index_std_increasing 0 (nth_index_std_increasing-1 nil 3765568280 ("" (skeep* :preds? t) (("" (expand "nth_index_std") (("" (with-tccs (typepred "choose({m: nat |
                                        args_of_pos_seq(seqp)(m) = l AND
                                         card({k: nat |
                                                 args_of_pos_seq(seqp)(k) = l AND k < m})
                                          = i})")) (("" (with-tccs (name-replace "ith_index" "choose({m: nat |
                                                    args_of_pos_seq(seqp)(m) = l AND
                                                     card({k: nat |
                                                             args_of_pos_seq(seqp)(k) = l AND k < m})
                                                      = i})")) (("" (with-tccs (name-replace "jth_index" "choose({m: nat |
                                                                 args_of_pos_seq(seqp)(m) = l AND
                                                                  card({k: nat |
                                                                          args_of_pos_seq(seqp)(k) = l AND k < m})
                                                                   = j})")) (("" (case "subset?({k_1: nat | args_of_pos_seq(seqp)(k_1) = l AND k_1 < jth_index},
                                                                                                              {k_1: nat | args_of_pos_seq(seqp)(k_1) = l AND k_1 < ith_index})") (("1" (with-tccs (use "card_subset[nat]") :tcc-step (skip)) (("1" (assert) nil nil) ("2" (expand "is_finite") (("2" (inst 1 "jth_index" "LAMBDA(i:nat | args_of_pos_seq[variable, symbol, arity](seqp)(i) =
                            l AND i < jth_index): i") (("2" (expand "injective?") (("2" (skeep) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?") (("2" (expand "member") (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (card_subset formula-decl nil finite_sets nil) (member const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (positions? type-eq-decl nil positions nil) (reduction_fix? const-decl "bool" reduction nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)) nil)) (nth_index_std_continuous_TCC1 0 (nth_index_std_continuous_TCC1-1 nil 3765568342 ("" (skeep* :preds? t) nil nil) nil nil (nth_index_std_continuous subtype "dp_termination.seqp" "{seqp: sequences[position[variable, symbol, arity]].sequence | FORALL (n: naturalnumbers.nat): booleans.AND(positions[dp_termination.variable, dp_termination.symbol, dp_termination.arity].positionsOF(dp_termination.seqt(n))(seqp(n)), booleans.AND((booleans.NOT)(finite_sequences[posnat].empty_seq = seqp(n)), reduction[dp_termination.variable, dp_termination.symbol, dp_termination.arity].reduction_fix?(dp_termination.E)(dp_termination.seqt(n), dp_termination.seqt((number_fields.+)(1, n)), seqp(n))))}"))) (nth_index_std_continuous_TCC2 0 (nth_index_std_continuous_TCC2-1 nil 3765568342 ("" (skeep* :preds? t) (("" (expand "is_finite") (("" (inst 1 "nth_index_std(E)(seqt)(seqp)(l)(i + 1)" "LAMBDA(k_1: nat |
                               args_of_pos_seq(seqp)(k_1) = l AND
                                k_1 < nth_index_std(E)(seqt)(seqp)(l)(i + 1)): k_1") (("" (expand "injective?") (("" (skeep) nil nil)) nil)) nil)) nil)) nil) ((is_finite const-decl "bool" finite_sets nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (reduction_fix? const-decl "bool" reduction nil) (positions? type-eq-decl nil positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil)) nil (nth_index_std_continuous subtype "{k_1: naturalnumbers.nat | booleans.AND(dependency_pairs[dp_termination.variable, dp_termination.symbol, dp_termination.arity].args_of_pos_seq(dp_termination.seqp)(k_1) = dp_termination.l, reals.<(k_1, dp_termination.nth_index_std(dp_termination.E)(dp_termination.seqt)(dp_termination.seqp)(dp_termination.l)((number_fields.+)(dp_termination.i, 1))))}" "finite_set[nat]"))) (nth_index_std_continuous_TCC3 0 (nth_index_std_continuous_TCC3-1 nil 3765568342 ("" (skeep* :preds? t) (("" (expand "is_finite") (("" (inst 1 "nth_index_std(E)(seqt)(seqp)(l)(i)" "LAMBDA(k_1: nat |
                               args_of_pos_seq(seqp)(k_1) = l AND
                                k_1 < nth_index_std(E)(seqt)(seqp)(l)(i)): k_1") (("" (expand "injective?") (("" (skeep) nil nil)) nil)) nil)) nil)) nil) ((is_finite const-decl "bool" finite_sets nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (reduction_fix? const-decl "bool" reduction nil) (positions? type-eq-decl nil positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil)) nil (nth_index_std_continuous subtype "{k_1: naturalnumbers.nat | booleans.AND(dependency_pairs[dp_termination.variable, dp_termination.symbol, dp_termination.arity].args_of_pos_seq(dp_termination.seqp)(k_1) = dp_termination.l, reals.<(k_1, dp_termination.nth_index_std(dp_termination.E)(dp_termination.seqt)(dp_termination.seqp)(dp_termination.l)(dp_termination.i)))}" "finite_set[nat]"))) (nth_index_std_continuous 0 (nth_index_std_continuous-5 "" 3804707798 ("" (skeep* :preds? t) (("" (expand "nth_index_std") (("" (with-tccs (typepred "choose({m: nat |
                                                      args_of_pos_seq(seqp)(m) = l AND
                                                       card({k: nat |
                                                               args_of_pos_seq(seqp)(k) = l AND
                                                                k < m})
                                                        = 1 + i})") :tcc-step (skip)) (("1" (with-tccs (name-replace "i1nth_index_std" "choose({m: nat |
                                                                          args_of_pos_seq(seqp)(m) = l AND
                                                                           card({k: nat |
                                                                                   args_of_pos_seq(seqp)(k) = l AND
                                                                                    k < m})
                                                                            = 1 + i})")) (("1" (with-tccs (typepred "choose({m: nat | args_of_pos_seq(seqp)(m) = l AND card({k: nat | args_of_pos_seq(seqp)(k) = l AND k < m}) = i})") :tcc-step (then (flatten) (subtype-tcc :exclude ("V" "Dom" "args_of_pos_seq" "inverse_image" "is_finite" "injective?")))) (("1" (with-tccs (name-replace "ith_index" "choose({m: nat |
                                                                                              args_of_pos_seq(seqp)(m) = l AND
                                                                                               card({k: nat |
                                                                                                       args_of_pos_seq(seqp)(k) = l
                                                                                                       AND
                                                                                                       k < m})
                                                                                                = i})")) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "is_finite") (("2" (inst 1 "m" "LAMBDA(k: nat |
                                                           args_of_pos_seq(seqp)(k) = l AND k < m): k") (("2" (expand "injective?") (("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (lemma "exists_nth_in_inf_nr_red") (("2" (inst -1 "E" "seqt" "seqp" "l" "1 + i") (("2" (skeep) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (expand "is_finite") (("3" (inst 1 "m" "LAMBDA(k: nat |
                                                             args_of_pos_seq(seqp)(k) = l AND k < m): k") (("3" (expand "injective?") (("3" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (nth_index_std_continuous-4 "" 3804362530 ("" (skeep* :preds? t) (("" (expand "nth_index_std") (("" (with-tccs (typepred "choose({m: nat |
                                                   args_of_pos_seq(seqp)(m) = l AND
                                                    card({k: nat |
                                                            args_of_pos_seq(seqp)(k) = l AND
                                                             k < m})
                                                     = 1 + i})") :tcc-step (skip)) (("1" (with-tccs (name-replace "i1nth_index_std" "choose({m: nat |
                                                                     args_of_pos_seq(seqp)(m) = l AND
                                                                      card({k: nat |
                                                                              args_of_pos_seq(seqp)(k) = l AND
                                                                               k < m})
                                                                       = 1 + i})")) (("1" (with-tccs (typepred "choose({m: nat | args_of_pos_seq(seqp)(m) = l AND card({k: nat | args_of_pos_seq(seqp)(k) = l AND k < m}) = i})") :tcc-step (then (flatten) (subtype-tcc :exclude ("V" "Dom" "args_of_pos_seq" "inverse_image" "is_finite" "injective?")))) (("1" (with-tccs (name-replace "ith_index" "choose({m: nat |
                                                                                       args_of_pos_seq(seqp)(m) = l AND
                                                                                        card({k: nat |
                                                                                                args_of_pos_seq(seqp)(k) = l
                                                                                                AND
                                                                                                k < m})
                                                                                         = i})")) (("1" (assert) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (lemma "exists_nth_in_inf_nr_red") (("2" (inst -1 "E" "seqt" "seqp" "l" "1 + i") (("2" (skeep) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (expand "is_finite") (("3" (inst 1 "m" "LAMBDA(k: nat |
                                                         args_of_pos_seq(seqp)(k) = l AND k < m): k") (("3" (expand "injective?") (("3" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nth_index_std const-decl "nat" dp_termination nil) (exists_nth_in_inf_nr_red formula-decl nil dp_termination nil) (int_minus_int_is_int application-judgement "int" integers nil) (injective? const-decl "bool" functions nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[nat]" countability sets_aux) (nonempty_singleton_finite application-judgement "non_empty_finite_set[posnat]" positions nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (lhs const-decl "term" rewrite_rules nil) (rhs const-decl "term" rewrite_rules nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (position type-eq-decl nil positions nil) (sequence type-eq-decl nil sequences nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (positions? type-eq-decl nil positions nil) (reduction_fix? const-decl "bool" reduction nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (< const-decl "bool" reals nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (finite_set type-eq-decl nil finite_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak) (nth_index_std_continuous-3 nil 3765569043 ("" (skeep* :preds? t) (("" (expand "nth_index_std") (("" (with-tccs (typepred "choose({m: nat |
                                                args_of_pos_seq(seqp)(m) = l AND
                                                 card({k: nat |
                                                         args_of_pos_seq(seqp)(k) = l AND
                                                          k < m})
                                                  = 1 + i})") :tcc-step (skip)) (("1" (with-tccs (name-replace "i1nth_index_std" "choose({m: nat |
                                                                args_of_pos_seq(seqp)(m) = l AND
                                                                 card({k: nat |
                                                                         args_of_pos_seq(seqp)(k) = l AND
                                                                          k < m})
                                                                  = 1 + i})")) (("1" (with-tccs (typepred "choose({m: nat |
                                                                  args_of_pos_seq(seqp)(m) = l AND
                                                                   card({k: nat |
                                                                           args_of_pos_seq(seqp)(k) = l
                                                                           AND
                                                                           k < m})
                                                                    = i})")) (("1" (with-tccs (name-replace "ith_index" "choose({m: nat |
                                                                                  args_of_pos_seq(seqp)(m) = l AND
                                                                                   card({k: nat |
                                                                                           args_of_pos_seq(seqp)(k) = l
                                                                                           AND
                                                                                           k < m})
                                                                                    = i})")) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (lemma "exists_nth_in_inf_nr_red") (("2" (inst -1 "E" "seqt" "seqp" "l" "1 + i") (("2" (skeep) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (expand "is_finite") (("3" (inst 1 "m" "LAMBDA(k: nat |
                                                     args_of_pos_seq(seqp)(k) = l AND k < m): k") (("3" (expand "injective?") (("3" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (first const-decl "T" seq_extras structures) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (lhs const-decl "term" rewrite_rules nil) (rhs const-decl "term" rewrite_rules nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (positions? type-eq-decl nil positions nil) (reduction_fix? const-decl "bool" reduction nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (finite_set type-eq-decl nil finite_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)) nil) (nth_index_std_continuous-2 nil 3765568906 ("" (skeep* :preds? t) (("" (expand "nth_index_std") (("" (with-tccs (typepred "choose({m: nat |
                                          args_of_pos_seq(seqp)(m) = l AND
                                           card({k: nat |
                                                   args_of_pos_seq(seqp)(k) = l AND
                                                    k < m})
                                            = 1 + i})")) (("1" (with-tccs (name-replace "i1nth_index_std" "choose({m: nat |
                                                      args_of_pos_seq(seqp)(m) = l AND
                                                       card({k: nat |
                                                               args_of_pos_seq(seqp)(k) = l AND
                                                                k < m})
                                                        = 1 + i})")) (("1" (with-tccs (typepred "choose({m: nat |
                                                        args_of_pos_seq(seqp)(m) = l AND
                                                         card({k: nat |
                                                                 args_of_pos_seq(seqp)(k) = l
                                                                 AND
                                                                 k < m})
                                                          = i})")) (("1" (with-tccs (name-replace "ith_index" "choose({m: nat |
                                                                    args_of_pos_seq(seqp)(m) = l AND
                                                                     card({k: nat |
                                                                             args_of_pos_seq(seqp)(k) = l
                                                                             AND
                                                                             k < m})
                                                                      = i})")) (("1" (assert) nil))) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (lemma "exists_nth_in_inf_nr_red") (("2" (inst -1 "E" "seqt(0)" "seqt" "seqp" "l" "i") (("2" (skeep) (("2" (inst -3 "m") (("2" (assert) nil))))))))))))))))) ("3" (hide 2) (("3" (skeep) (("3" (expand "is_finite") (("3" (inst 1 "m" "LAMBDA(k: nat |
                                                     args_of_pos_seq(seqp)(k) = l AND k < m): k") (("3" (expand "injective?") (("3" (skeep) nil))))))))))))))) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (lemma "exists_nth_in_inf_nr_red") (("2" (inst -1 "E" "seqt(0)" "seqt" "seqp" "l" "1 + i") (("2" (skeep) (("2" (inst?) (("2" (assert) nil))))))))))))))))) ("3" (hide 2) (("3" (skeep) (("3" (expand "is_finite") (("3" (inst 1 "m" "LAMBDA(k: nat |
                                             args_of_pos_seq(seqp)(k) = l AND k < m): k") (("3" (expand "injective?") (("3" (skeep) nil)))))))))))))))) nil) nil nil) (nth_index_std_continuous-1 nil 3765568387 ("" (skeep* :preds? t) (("" (expand "nth_index_std") (("" (with-tccs (typepred "choose({m: nat |
                                       args_of_pos_seq(seqp)(m) = l AND
                                        card({k: nat |
                                                args_of_pos_seq(seqp)(k) = l AND
                                                 k < m})
                                         = 1 + i})")) (("1" (with-tccs (name-replace "i1nth_index_std" "choose({m: nat |
                                                 args_of_pos_seq(seqp)(m) = l AND
                                                  card({k: nat |
                                                          args_of_pos_seq(seqp)(k) = l AND
                                                           k < m})
                                                   = 1 + i})")) (("1" (with-tccs (typepred "choose({m: nat |
                                                   args_of_pos_seq(seqp)(m) = l AND
                                                    card({k: nat |
                                                            args_of_pos_seq(seqp)(k) = l
                                                            AND
                                                            k < m})
                                                     = i})")) (("1" (with-tccs (name-replace "ith_index" "choose({m: nat |
                                                             args_of_pos_seq(seqp)(m) = l AND
                                                              card({k: nat |
                                                                      args_of_pos_seq(seqp)(k) = l
                                                                      AND
                                                                      k < m})
                                                               = i})")) (("1" (assert) nil))) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (lemma "exists_nth_in_inf_nr_red") (("2" (inst -1 "E" "seqt(0)" "seqt" "seqp" "l" "i") (("2" (skeep) (("2" (inst -3 "m") (("2" (assert) nil))))))))))))))))) ("3" (hide 2) (("3" (skeep) (("3" (expand "is_finite") (("3" (inst 1 "m" "LAMBDA(k: nat |
                                               args_of_pos_seq(seqp)(k) = l AND k < m): k") (("3" (expand "injective?") (("3" (skeep) nil))))))))))))))) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (lemma "exists_nth_in_inf_nr_red") (("2" (inst -1 "E" "seqt(0)" "seqt" "seqp" "l" "1 + i") (("2" (skeep) (("2" (inst?) (("2" (assert) nil))))))))))))))))) ("3" (hide 2) (("3" (skeep) (("3" (expand "is_finite") (("3" (inst 1 "m" "LAMBDA(k: nat |
                                         args_of_pos_seq(seqp)(k) = l AND k < m): k") (("3" (expand "injective?") (("3" (skeep) nil)))))))))))))))) nil) nil nil)) (argument_protected_in_non_nth_index_std_TCC1 0 (argument_protected_in_non_nth_index_std_TCC1-1 nil 3765569246 ("" (skeep* :preds? t) nil nil) nil nil (argument_protected_in_non_nth_index_std subtype "dp_termination.seqp" "{seqp: sequences[position[variable, symbol, arity]].sequence | FORALL (n: naturalnumbers.nat): booleans.AND(positions[dp_termination.variable, dp_termination.symbol, dp_termination.arity].positionsOF(dp_termination.seqt(n))(seqp(n)), booleans.AND((booleans.NOT)(finite_sequences[posnat].empty_seq = seqp(n)), reduction[dp_termination.variable, dp_termination.symbol, dp_termination.arity].reduction_fix?(dp_termination.E)(dp_termination.seqt(n), dp_termination.seqt((number_fields.+)(1, n)), seqp(n))))}"))) (argument_protected_in_non_nth_index_std_TCC2 0 (argument_protected_in_non_nth_index_std_TCC2-1 nil 3765569246 ("" (skeep* :preds? t) (("" (inst -2 "j") (("" (flatten) (("" (assert) (("" (rewrite "empty_0") nil nil)) nil)) nil)) nil)) nil) ((reduction_fix? const-decl "bool" reduction nil) (positions? type-eq-decl nil positions nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (empty_seq const-decl "finseq" finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (empty_0 formula-decl nil seq_extras structures)) nil (argument_protected_in_non_nth_index_std subtype "dp_termination.seqp(dp_termination.j)" "not_empty_seq[posnat]"))) (argument_protected_in_non_nth_index_std 0 (argument_protected_in_non_nth_index_std-1 nil 3765569307 ("" (skeep* :preds? t) (("" (prop) (("1" (expand "nth_index_std") (("1" (with-tccs (typepred "choose({m: nat |
                                                args_of_pos_seq(seqp)(m) = l AND
                                                 card({k: nat |
                                                         args_of_pos_seq(seqp)(k) = l AND
                                                          k < m})
                                                  = 0})")) (("1" (with-tccs (name-replace "zeroth_index" "choose({m: nat |
                                                             args_of_pos_seq(seqp)(m) = l AND
                                                              card({k: nat |
                                                                      args_of_pos_seq(seqp)(k) =
                                                                       l
                                                                       AND k < m})
                                                               = 0})")) (("1" (lemma "card_empty?[nat]") (("1" (inst?) (("1" (assert) (("1" (iff) (("1" (prop) (("1" (hide -1 -4) (("1" (expand "empty?") (("1" (expand "member") (("1" (inst -1 "j") (("1" (assert) (("1" (expand "args_of_pos_seq") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "is_finite") (("2" (inst 1 "zeroth_index" "LAMBDA(k_1: nat |
                                                                 args_of_pos_seq(seqp)(k_1) = l AND
                                                                  k_1 < zeroth_index): k_1") (("2" (expand "injective?") (("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (lemma "nth_index_std_continuous") (("2" (inst?) (("2" (assert) (("2" (expand "nth_index_std") (("2" (with-tccs (typepred "choose({m: nat |
                                                    args_of_pos_seq(seqp)(m) = l AND
                                                     card({k: nat |
                                                             args_of_pos_seq(seqp)(k) = l AND k < m})
                                                      = 1 + n})")) (("2" (with-tccs (name-replace "n1_index" "choose({m: nat |
                                                            args_of_pos_seq(seqp)(m) = l AND
                                                             card({k: nat |
                                                                     args_of_pos_seq(seqp)(k) = l AND k < m})
                                                              = 1 + n})")) (("2" (with-tccs (typepred "choose({m: nat |
                                                                args_of_pos_seq(seqp)(m) = l AND
                                                                 card({k: nat |
                                                                         args_of_pos_seq(seqp)(k) = l AND k < m})
                                                                  = n})") :tcc-step (skip)) (("1" (with-tccs (name-replace "n_index" "choose({m: nat |
                                                                                  args_of_pos_seq(seqp)(m) = l AND
                                                                                   card({k: nat |
                                                                                           args_of_pos_seq(seqp)(k) = l AND k < m})
                                                                                    = n})")) (("1" (typepred "min({m : nat | m > n_index AND m <= j AND
                                                                               args_of_pos_seq(seqp)(m) = l})") (("1" (name-replace "min_j_index" "min({m: nat |
                                                                                           m > n_index AND
                                                                                            m <= j AND args_of_pos_seq(seqp)(m) = l})") (("1" (case "strict_subset?({k: nat | args_of_pos_seq(seqp)(k) = l AND k < n_index}, {k_1: nat |
                                                                                                                                                        args_of_pos_seq(seqp)(k_1) = l AND k_1 < min_j_index})") (("1" (use "card_strict_subset[nat]") (("1" (assert) (("1" (replace -8) (("1" (case "strict_subset?({k_1: nat |
                                                                                                                                                                                            args_of_pos_seq(seqp)(k_1) = l AND k_1 < min_j_index}, {k: nat | args_of_pos_seq(seqp)(k) = l AND k < n1_index})") (("1" (hide -3) (("1" (use "card_strict_subset[nat]") (("1" (assert) nil nil) ("2" (expand "is_finite") (("2" (inst 1 "n1_index" "LAMBDA(k_1: nat |
                                                                                                                                                                                         args_of_pos_seq(seqp)(k_1) = l AND
                                                                                                                                                                                          k_1 < n1_index): k_1") (("2" (expand "injective?") (("2" (skeep) nil nil)) nil)) nil)) nil) ("3" (expand "is_finite") (("3" (inst 1 "min_j_index" "LAMBDA(k_1: nat |
                                                                                                                                                                           args_of_pos_seq(seqp)(k_1) = l AND
                                                                                                                                                                            k_1 < min_j_index): k_1") (("3" (expand "injective?") (("3" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "strict_subset?") (("2" (prop) (("1" (expand "subset?") (("1" (expand "member") (("1" (skeep) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (decompose-equality -1) (("2" (inst -1 "min_j_index") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "is_finite") (("2" (inst 1 "min_j_index" "LAMBDA(k_1: nat |
                                                                                                                                       args_of_pos_seq(seqp)(k_1) = l AND
                                                                                                                                        k_1 < min_j_index): k_1") (("2" (expand "injective?") (("2" (skeep) nil nil)) nil)) nil)) nil) ("3" (expand "is_finite") (("3" (inst 1 "n_index" "LAMBDA(k_1: nat |
                                                                                                                                       args_of_pos_seq(seqp)(k_1) = l AND
                                                                                                                                        k_1 < n_index): k_1") (("3" (expand "injective?") (("3" (skeep) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "strict_subset?") (("2" (prop) (("1" (expand "subset?") (("1" (expand "member") (("1" (skeep) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (decompose-equality -1) (("2" (inst -1 "n_index") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (inst -1 "j") (("2" (assert) (("2" (hide-all-but (-14 1)) (("2" (expand "args_of_pos_seq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "is_finite") (("2" (inst 1 "m" "LAMBDA(k: nat |
                                                                           args_of_pos_seq(seqp)(k) = l AND
                                                                            k < m): k") (("2" (expand "injective?") (("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (nonempty? const-decl "bool" sets nil) (reduction_fix? const-decl "bool" reduction nil) (positions? type-eq-decl nil positions nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (choose const-decl "(p)" sets nil) (card_empty? formula-decl nil finite_sets nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (strict_subset? const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (card_strict_subset formula-decl nil finite_sets nil)) nil)) (inf_deriv_of_mnt_has_min_root_reduction_index 0 (inf_deriv_of_mnt_has_min_root_reduction_index-2 nil 3785694325 ("" (skeep :preds? t) (("" (case "FORALL (n: nat):
                                    RTC(non_root_reduction?[variable, symbol, arity](E))
                                        (seqt(0), seqt(n)) AND NOT seqp(n) = empty_seq") (("1" (lemma "exists_inf_red_arg_in_inf_nr_red") (("1" (inst -1 "E" "seqt" "seqp") (("1" (hide 1) (("1" (skeep :preds? t) (("1" (copy -6) (("1" (expand "minimal_non_terminating?" -1) (("1" (flatten) (("1" (hide 1) (("1" (inst -1 "#(l)") (("1" (expand "terminating?") (("1" (with-tccs (inst 1 "LAMBDA(i:nat): IF i=0 THEN subtermOF(seqt(0), #(l)) ELSE subtermOF(seqt(nth_index_std(E)(seqt)(seqp)(l)(i - 1) + 1), #(l)) ENDIF") :tcc-step (skip)) (("1" (skeep) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (replaces -1) (("2" (case-replace "subtermOF(seqt(0),  #(l)) =
                                         subtermOF(seqt(nth_index_std(E)(seqt)(seqp)(l)(0)), #(l))" :hide? t) (("1" (with-tccs (name-replace "n1th_index_std" "nth_index_std(E)(seqt)(seqp)(l)(0)")) (("1" (inst -5 "n1th_index_std") (("1" (flatten) (("1" (case "first(seqp(n1th_index_std)) = l") (("1" (case " #(l) o rest(seqp(n1th_index_std)) = seqp(n1th_index_std)") (("1" (expand "reduction?") (("1" (expand "reduction_fix?") (("1" (skeep* :preds? t) (("1" (inst 2 "e" "sigma" "rest(seqp(n1th_index_std))") (("1" (lemma "pos_subterm") (("1" (inst -1 " #(l)" "rest(seqp(n1th_index_std))" "seqt(n1th_index_std)") (("1" (assert) (("1" (use "replace_distributivity") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "pos_subterm_ax") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "seq_first_rest_1[posnat]") (("2" (assert) (("2" (hide-all-but (-5 1)) (("2" (inst -1 "n1th_index_std") (("2" (flatten) (("2" (use "empty_0[posnat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "n1th_index_std") (("2" (expand "nth_index_std") (("2" (expand "args_of_pos_seq") (("2" (with-tccs (typepred "choose({m: nat |
                                                             first(seqp(m)) = l AND
                                                              card({k: nat | first(seqp(k)) = l AND k < m}) =
                                                               0})")) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (inst -1 "n1th_index_std") (("3" (flatten) (("3" (use "empty_0[posnat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "fseq_t" "(#length := nth_index_std(E)(seqt)(seqp)(l)(0) + 1,
                                                             seq := LAMBDA(i:below[nth_index_std(E)(seqt)(seqp)(l)(0)+1]): seqt(i) #)") (("2" (name "fseq_p" "(#length := nth_index_std(E)(seqt)(seqp)(l)(0) + 1,
                                                             seq := LAMBDA(i:below[nth_index_std(E)(seqt)(seqp)(l)(0)+1]): seqp(i) #)") (("2" (lemma "arg_preservation_in_finite_rtc") (("2" (inst -1 "E" "fseq_t" "fseq_p" "l") (("1" (expand "finseq_appl") (("1" (prop) (("1" (hide -2 -3) (("1" (expand "fseq_t") (("1" (inst -1 "nth_index_std(E)(seqt)(seqp)(l)(0)") (("1" (expand "fseq_p") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2) (("2" (skeep :preds? t) (("2" (expand "fseq_t") (("2" (expand "fseq_p") (("2" (inst -6 "n!1") (("2" (flatten) (("2" (assert) (("2" (inst -5 "n!1") (("2" (flatten) (("2" (assert) (("2" (use "argument_protected_in_non_nth_index_std") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (expand "fseq_t") (("2" (propax) nil nil)) nil)) nil) ("3" (expand "fseq_p") (("3" (expand "fseq_t") (("3" (propax) nil nil)) nil)) nil) ("4" (expand "finseq_appl") (("4" (hide -1 -2) (("4" (expand "fseq_t") (("4" (prop) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil) ("2" (use "reducible_is_app") (("2" (assert) (("2" (hide-all-but (-5 1)) (("2" (inst?) (("2" (flatten) (("2" (expand "reducible?") (("2" (inst 1 "seqt(1)") (("2" (expand "reduction?") (("2" (expand "reduction_fix?") (("2" (skeep) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst -4 "nth_index_std(E)(seqt)(seqp)(l)(0)") (("3" (flatten) (("3" (use "non_root_rtc_preserves_pos_args") (("1" (assert) nil nil) ("2" (rewrite "positions_of_arg") nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) (("4" (case-replace "subtermOF(seqt(1 + nth_index_std(E)(seqt)(seqp)(l)(n - 1)), #(l)) = subtermOF(seqt(nth_index_std(E)(seqt)(seqp)(l)(n)), #(l)) " :hide? t) (("1" (with-tccs (name-replace "n1th_index_std" "nth_index_std(E)(seqt)(seqp)(l)(n)")) (("1" (inst -5 "n1th_index_std") (("1" (flatten) (("1" (case "first(seqp(n1th_index_std)) = l") (("1" (case " #(l) o rest(seqp(n1th_index_std)) = seqp(n1th_index_std)") (("1" (expand "reduction?") (("1" (expand "reduction_fix?") (("1" (skeep* :preds? t) (("1" (inst 2 "e" "sigma" "rest(seqp(n1th_index_std))") (("1" (lemma "pos_subterm") (("1" (inst -1 " #(l)" "rest(seqp(n1th_index_std))" "seqt(n1th_index_std)") (("1" (assert) (("1" (use "replace_distributivity") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "pos_subterm_ax") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "seq_first_rest_1[posnat]") (("2" (assert) (("2" (inst -5 "n1th_index_std") (("2" (flatten) (("2" (hide-all-but (-1 5)) (("2" (use "empty_0[posnat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "n1th_index_std") (("2" (expand "nth_index_std") (("2" (expand "args_of_pos_seq") (("2" (with-tccs (typepred "choose({m: nat |
                                                                                                                                                                                                                                                                                                                          first(seqp(m)) = l AND
                                                                                                                                                                                                                                                                                                                           card({k: nat | first(seqp(k)) = l AND k < m})
                                                                                                                                                                                                                                                                                                                            =  n})")) nil nil)) nil)) nil)) nil)) nil) ("3" (inst -4 "n1th_index_std") (("3" (flatten) (("3" (hide-all-but (-1 4)) (("3" (use "empty_0[posnat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "l_seq" "nth_index_std(E)(seqt)(seqp)(l)(n) - nth_index_std(E)(seqt)(seqp)(l)(n - 1)") (("2" (name "fseq_p" "(#length := l_seq, seq := LAMBDA(i:below[l_seq]): seqp(i + 1 + nth_index_std(E)(seqt)(seqp)(l)(n - 1)) #)") (("1" (name "fseq_t" "(#length := l_seq, seq := LAMBDA(i:below[l_seq]): seqt(i + 1 + nth_index_std(E)(seqt)(seqp)(l)(n - 1)) #)") (("1" (lemma "arg_preservation_in_finite_rtc") (("1" (inst -1 "E" "fseq_t" "fseq_p" "l") (("1" (expand "finseq_appl") (("1" (prop) (("1" (expand "fseq_t") (("1" (inst -1 "l_seq - 1") (("1" (expand "l_seq") (("1" (propax) nil nil)) nil) ("2" (expand "l_seq") (("2" (assert) (("2" (lemma "nth_index_std_increasing") (("2" (inst -1 "E" "seqt" "seqp" "l" "n - 1" "n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 4) (("2" (skeep :preds? t) (("2" (expand "fseq_t") (("2" (expand "fseq_p") (("2" (inst -6 "1 +nth_index_std(E)
                                                                                    (seqt)
                                                                                    (seqp)
                                                                                    (l)
                                                                                    (n - 1)
                                                                       + n!1") (("2" (flatten) (("2" (assert) (("2" (hide -7) (("2" (inst -5 "1 +nth_index_std(E)
                                                                                    (seqt)
                                                                                    (seqp)
                                                                                    (l)
                                                                                    (n - 1)
                                                                       + n!1") (("2" (flatten) (("2" (assert) (("2" (expand "l_seq") (("2" (name-replace "index" "1 + nth_index_std(E)(seqt)(seqp)(l)(n - 1) +
                                                          n!1") (("2" (lemma "argument_protected_in_non_nth_index_std") (("2" (inst -1 "E" "seqt" "seqp" "l" "index") (("2" (assert) (("2" (hide -6 -7 -8 2) (("2" (prop) (("2" (expand "index") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 4) (("2" (expand "finseq_appl") (("2" (expand "fseq_t") (("2" (inst -5 "1 +nth_index_std(E)
                                                                                (seqt)
                                                                                (seqp)
                                                                                (l)
                                                                                (n - 1)
                                                                   ") (("2" (flatten) (("2" (use "non_root_rtc_preserves_root_symbol") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 4) (("3" (expand "fseq_p") (("3" (expand "l_seq") (("3" (expand "fseq_t") (("3" (expand "l_seq") (("3" (lemma "nth_index_std_increasing") (("3" (inst -1 "E" "seqt" "seqp" "l" "n - 1" "n") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -1 -2 4) (("4" (expand "fseq_t") (("4" (expand "l_seq") (("4" (expand "finseq_appl") (("4" (lemma "nth_index_std_increasing") (("4" (inst -1 "E" "seqt" "seqp" "l" "n - 1" "n") (("4" (assert) (("4" (prop) (("1" (hide-all-but (-1 -2)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (-7 1)) (("2" (name-replace "index" "1 + nth_index_std(E)(seqt)(seqp)(l)(n - 1)") (("2" (inst?) (("2" (flatten) (("2" (use "reducible_is_app") (("2" (assert) (("2" (expand "reducible?") (("2" (expand "reduction_fix?") (("2" (skeep) (("2" (expand "reduction?") (("2" (inst 1 "seqt(1 + index)") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "l_seq") (("2" (lemma "nth_index_std_increasing") (("2" (inst -1 "E" "seqt" "seqp" "l" "n - 1" "n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (inst -4 "nth_index_std(E)(seqt)(seqp)(l)(n)") (("3" (flatten) (("3" (use "non_root_rtc_preserves_pos_args") (("1" (assert) nil nil) ("2" (rewrite "positions_of_arg") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -4 "1 + nth_index_std(E)(seqt)(seqp)(l)(i - 1)") (("1" (flatten) (("1" (use "non_root_rtc_preserves_pos_args") (("1" (assert) nil nil) ("2" (rewrite "positions_of_arg") nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (skeep) (("3" (hide-all-but (-5 2)) (("3" (inst?) (("3" (flatten) (("3" (use "reducible_is_app") (("3" (prop) (("3" (expand "reducible?") (("3" (inst 1 "seqt(1)") (("3" (expand "reduction_fix?") (("3" (expand "reduction?") (("3" (skeep) (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep* :preds? t) (("4" (inst -7 "n") (("4" (flatten) (("4" (assert) (("4" (inst -7 "n") (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) nil nil) ("6" (skeep) (("6" (assert) nil nil)) nil) ("7" (skeep) (("7" (rewrite "positions_of_arg") nil nil)) nil)) nil)) nil) ("2" (rewrite "positions_of_arg") (("2" (hide-all-but -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (inst? -2) (("2" (flatten) (("2" (assert) (("2" (inst? -2) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (inst?) (("3" (flatten) (("3" (use "reducible_is_app") (("3" (assert) (("3" (expand "reducible?") (("3" (inst 1 "seqt(1)") (("3" (expand "reduction?") (("3" (expand "reduction_fix?") (("3" (skeep) (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (case "EXISTS (m: nat):
                          seqp(m) = empty_seq") (("1" (hide-all-but (-1 2)) (("1" (inst 1 "min({i:nat | seqp(i) = empty_seq})") (("1" (typepred "min({i: nat | seqp(i) = empty_seq})") (("1" (assert) (("1" (skeep) (("1" (inst -2 "k") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (skeep) (("2" (inst -1 "m") (("2" (assert) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (skeep) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (hide 1) (("2" (generalize "n" "n" :fnums (1)) (("2" (reveal 2) (("2" (induct "n" 2) (("1" (expand "RTC") (("1" (expand "IUnion") (("1" (inst 1 0) (("1" (expand "iterate") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (inst 1 0) nil nil) ("3" (skeep) (("3" (inst -2 "j") (("3" (flatten) (("3" (expand "RTC") (("3" (expand "IUnion") (("3" (skeep) (("3" (prop) (("1" (inst 1 "i + 1") (("1" (lemma "iterate_add") (("1" (inst -1 "non_root_reduction?(E)" "i" "1") (("1" (replaces -1) (("1" (expand "o") (("1" (inst 1 "seqt(j)") (("1" (assert) (("1" (expand "iterate" 1) (("1" (expand "o ") (("1" (inst 1 "seqt(j)") (("1" (expand "iterate" 1) (("1" (hide -1) (("1" (expand "non_root_reduction?") (("1" (inst 1 "seqp(j)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 2 "1 + j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (reduction_fix? const-decl "bool" reduction nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (non_root_reduction? const-decl "bool" reduction nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (term type-decl nil term_adt nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (terminating? const-decl "bool" noetherian nil) (not_empty_seq type-eq-decl nil seq_extras structures) (first const-decl "T" seq_extras structures) (seq_first_rest_1 formula-decl nil seq_extras structures) (empty_0 formula-decl nil seq_extras structures) (reduction? const-decl "bool" reduction nil) (pos_subterm_ax formula-decl nil subterm nil) (pos_subterm formula-decl nil subterm nil) (rhs const-decl "term" rewrite_rules nil) (ext def-decl "term" substitution nil) (replace_distributivity formula-decl nil replacement nil) (member const-decl "bool" sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (rest const-decl "finseq" seq_extras structures) (O const-decl "finseq" finite_sequences nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (nonempty? const-decl "bool" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (choose const-decl "(p)" sets nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (reducible? const-decl "bool" ars_terminology nil) (reducible_is_app formula-decl nil reduction nil) (arg_preservation_in_finite_rtc formula-decl nil reduction nil) (positions_of_arg formula-decl nil positions nil) (non_root_rtc_preserves_pos_args formula-decl nil reduction nil) (non_root_rtc_preserves_root_symbol formula-decl nil reduction nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (subtermOF def-decl "term" subterm nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (finite_sequence type-eq-decl nil finite_sequences nil) (empty? const-decl "bool" sets nil) (iterate_add formula-decl nil relation_iterate orders) (iterate def-decl "pred[[T, T]]" relation_iterate orders)) nil) (inf_deriv_of_mnt_has_min_root_reduction_index-1 nil 3763920092 ("" (skeep :preds? t) (("" (case "FORALL (n: nat):
                             RTC(non_root_reduction?[variable, symbol, arity](E))
                                 (seqt(0), seqt(n)) AND NOT seqp(n) = empty_seq") (("1" (lemma "exists_inf_red_arg_in_inf_nr_red") (("1" (inst -1 "E" "seqt" "seqp") (("1" (hide 1) (("1" (skeep :preds? t) (("1" (copy -6) (("1" (expand "minimal_non_terminating?" -1) (("1" (flatten) (("1" (hide 1) (("1" (inst -1 "#(l)") (("1" (expand "terminating?") (("1" (with-tccs (inst 1 "LAMBDA(i:nat): IF i=0 THEN subtermOF(seqt(0), #(l)) ELSE subtermOF(seqt(nth_index_std(E)(seqt)(seqp)(l)(i - 1) + 1), #(l)) ENDIF")) (("1" (skeep) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (replaces -1) (("2" (case-replace "subtermOF(seqt(0),  #(l)) =
                             subtermOF(seqt(nth_index_std(E)(seqt)(seqp)(l)(0)), #(l))" :hide? t) (("1" (with-tccs (name-replace "n1th_index_std" "nth_index_std(E)(seqt)(seqp)(l)(0)")) (("1" (inst -5 "n1th_index_std") (("1" (flatten) (("1" (case "first(seqp(n1th_index_std)) = l") (("1" (case " #(l) o rest(seqp(n1th_index_std)) = seqp(n1th_index_std)") (("1" (expand "reduction?") (("1" (expand "reduction_fix?") (("1" (skeep* :preds? t) (("1" (inst 2 "e" "sigma" "rest(seqp(n1th_index_std))") (("1" (lemma "pos_subterm") (("1" (inst -1 " #(l)" "rest(seqp(n1th_index_std))" "seqt(n1th_index_std)") (("1" (assert) (("1" (use "replace_distributivity") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "pos_subterm_ax") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "seq_first_rest_1[posnat]") (("2" (assert) (("2" (hide-all-but (-5 1)) (("2" (inst -1 "n1th_index_std") (("2" (flatten) (("2" (use "empty_0[posnat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "n1th_index_std") (("2" (expand "nth_index_std") (("2" (expand "args_of_pos_seq") (("2" (with-tccs (typepred "choose({m: nat |
                                            first(seqp(m)) = l AND
                                             card({k: nat | first(seqp(k)) = l AND k < m}) =
                                              0})")) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (inst -1 "n1th_index_std") (("3" (flatten) (("3" (use "empty_0[posnat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "fseq_t" "(#length := nth_index_std(E)(seqt)(seqp)(l)(0) + 1,
                                          seq := LAMBDA(i:below[nth_index_std(E)(seqt)(seqp)(l)(0)+1]): seqt(i) #)") (("2" (name "fseq_p" "(#length := nth_index_std(E)(seqt)(seqp)(l)(0) + 1,
                                          seq := LAMBDA(i:below[nth_index_std(E)(seqt)(seqp)(l)(0)+1]): seqp(i) #)") (("2" (lemma "arg_preservation_in_finite_rtc") (("2" (inst -1 "E" "fseq_t" "fseq_p" "l") (("1" (expand "finseq_appl") (("1" (prop) (("1" (hide -2 -3) (("1" (expand "fseq_t") (("1" (inst -1 "nth_index_std(E)(seqt)(seqp)(l)(0)") (("1" (expand "fseq_p") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2) (("2" (skeep :preds? t) (("2" (expand "fseq_t") (("2" (expand "fseq_p") (("2" (inst -6 "n!1") (("2" (flatten) (("2" (assert) (("2" (inst -5 "n!1") (("2" (flatten) (("2" (assert) (("2" (use "argument_protected_in_non_nth_index_std") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (expand "fseq_t") (("2" (propax) nil nil)) nil)) nil) ("3" (expand "fseq_p") (("3" (expand "fseq_t") (("3" (propax) nil nil)) nil)) nil) ("4" (expand "finseq_appl") (("4" (hide -1 -2) (("4" (expand "fseq_t") (("4" (prop) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil) ("2" (use "reducible_is_app") (("2" (assert) (("2" (hide-all-but (-5 1)) (("2" (inst?) (("2" (flatten) (("2" (expand "reducible?") (("2" (inst 1 "seqt(1)") (("2" (expand "reduction?") (("2" (expand "reduction_fix?") (("2" (skeep) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst -4 "nth_index_std(E)(seqt)(seqp)(l)(0)") (("3" (flatten) (("3" (use "non_root_rtc_preserves_pos_args") (("1" (assert) nil nil) ("2" (rewrite "positions_of_arg") nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) (("4" (case-replace "subtermOF(seqt(1 + nth_index_std(E)(seqt)(seqp)(l)(n - 1)), #(l)) = subtermOF(seqt(nth_index_std(E)(seqt)(seqp)(l)(n)), #(l)) " :hide? t) (("1" (with-tccs (name-replace "n1th_index_std" "nth_index_std(E)(seqt)(seqp)(l)(n)")) (("1" (inst -5 "n1th_index_std") (("1" (flatten) (("1" (case "first(seqp(n1th_index_std)) = l") (("1" (case " #(l) o rest(seqp(n1th_index_std)) = seqp(n1th_index_std)") (("1" (expand "reduction?") (("1" (expand "reduction_fix?") (("1" (skeep* :preds? t) (("1" (inst 2 "e" "sigma" "rest(seqp(n1th_index_std))") (("1" (lemma "pos_subterm") (("1" (inst -1 " #(l)" "rest(seqp(n1th_index_std))" "seqt(n1th_index_std)") (("1" (assert) (("1" (use "replace_distributivity") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "pos_subterm_ax") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "seq_first_rest_1[posnat]") (("2" (assert) (("2" (inst -5 "n1th_index_std") (("2" (flatten) (("2" (hide-all-but (-1 5)) (("2" (use "empty_0[posnat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "n1th_index_std") (("2" (expand "nth_index_std") (("2" (expand "args_of_pos_seq") (("2" (with-tccs (typepred "choose({m: nat |
                                                                                                                                                                                                                                                                                                         first(seqp(m)) = l AND
                                                                                                                                                                                                                                                                                                          card({k: nat | first(seqp(k)) = l AND k < m})
                                                                                                                                                                                                                                                                                                           =  n})")) nil nil)) nil)) nil)) nil)) nil) ("3" (inst -4 "n1th_index_std") (("3" (flatten) (("3" (hide-all-but (-1 4)) (("3" (use "empty_0[posnat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "l_seq" "nth_index_std(E)(seqt)(seqp)(l)(n) - nth_index_std(E)(seqt)(seqp)(l)(n - 1)") (("2" (name "fseq_p" "(#length := l_seq, seq := LAMBDA(i:below[l_seq]): seqp(i + 1 + nth_index_std(E)(seqt)(seqp)(l)(n - 1)) #)") (("1" (name "fseq_t" "(#length := l_seq, seq := LAMBDA(i:below[l_seq]): seqt(i + 1 + nth_index_std(E)(seqt)(seqp)(l)(n - 1)) #)") (("1" (lemma "arg_preservation_in_finite_rtc") (("1" (inst -1 "E" "fseq_t" "fseq_p" "l") (("1" (expand "finseq_appl") (("1" (prop) (("1" (expand "fseq_t") (("1" (inst -1 "l_seq - 1") (("1" (expand "l_seq") (("1" (propax) nil nil)) nil) ("2" (expand "l_seq") (("2" (assert) (("2" (lemma "nth_index_std_increasing") (("2" (inst -1 "E" "seqt" "seqp" "l" "n - 1" "n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 4) (("2" (skeep :preds? t) (("2" (expand "fseq_t") (("2" (expand "fseq_p") (("2" (inst -6 "1 +nth_index_std(E)
                                                                (seqt)
                                                                (seqp)
                                                                (l)
                                                                (n - 1)
                                                   + n!1") (("2" (flatten) (("2" (assert) (("2" (hide -7) (("2" (inst -5 "1 +nth_index_std(E)
                                                                (seqt)
                                                                (seqp)
                                                                (l)
                                                                (n - 1)
                                                   + n!1") (("2" (flatten) (("2" (assert) (("2" (expand "l_seq") (("2" (name-replace "index" "1 + nth_index_std(E)(seqt)(seqp)(l)(n - 1) +
                                      n!1") (("2" (lemma "argument_protected_in_non_nth_index_std") (("2" (inst -1 "E" "seqt" "seqp" "l" "index") (("2" (assert) (("2" (hide -6 -7 -8 2) (("2" (prop) (("2" (expand "index") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 4) (("2" (expand "finseq_appl") (("2" (expand "fseq_t") (("2" (inst -5 "1 +nth_index_std(E)
                                                              (seqt)
                                                              (seqp)
                                                              (l)
                                                              (n - 1)
                                                 ") (("2" (flatten) (("2" (use "non_root_rtc_preserves_root_symbol") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 4) (("3" (expand "fseq_p") (("3" (expand "l_seq") (("3" (expand "fseq_t") (("3" (expand "l_seq") (("3" (lemma "nth_index_std_increasing") (("3" (inst -1 "E" "seqt" "seqp" "l" "n - 1" "n") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -1 -2 4) (("4" (expand "fseq_t") (("4" (expand "l_seq") (("4" (expand "finseq_appl") (("4" (lemma "nth_index_std_increasing") (("4" (inst -1 "E" "seqt" "seqp" "l" "n - 1" "n") (("4" (assert) (("4" (prop) (("1" (hide-all-but (-1 -2)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (-7 1)) (("2" (name-replace "index" "1 + nth_index_std(E)(seqt)(seqp)(l)(n - 1)") (("2" (inst?) (("2" (flatten) (("2" (use "reducible_is_app") (("2" (assert) (("2" (expand "reducible?") (("2" (expand "reduction_fix?") (("2" (skeep) (("2" (expand "reduction?") (("2" (inst 1 "seqt(1 + index)") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "l_seq") (("2" (lemma "nth_index_std_increasing") (("2" (inst -1 "E" "seqt" "seqp" "l" "n - 1" "n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (inst -4 "nth_index_std(E)(seqt)(seqp)(l)(n)") (("3" (flatten) (("3" (use "non_root_rtc_preserves_pos_args") (("1" (assert) nil nil) ("2" (rewrite "positions_of_arg") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -4 "1 + nth_index_std(E)(seqt)(seqp)(l)(i - 1)") (("1" (flatten) (("1" (use "non_root_rtc_preserves_pos_args") (("1" (assert) nil nil) ("2" (rewrite "positions_of_arg") nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (skeep) (("3" (hide-all-but (-5 2)) (("3" (inst?) (("3" (flatten) (("3" (use "reducible_is_app") (("3" (prop) (("3" (expand "reducible?") (("3" (inst 1 "seqt(1)") (("3" (expand "reduction_fix?") (("3" (expand "reduction?") (("3" (skeep) (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep* :preds? t) (("4" (inst -7 "n") (("4" (flatten) (("4" (assert) (("4" (inst -7 "n") (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) nil nil) ("6" (skeep) (("6" (assert) nil nil)) nil) ("7" (skeep) (("7" (rewrite "positions_of_arg") nil nil)) nil)) nil)) nil) ("2" (rewrite "positions_of_arg") (("2" (hide-all-but -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (inst? -2) (("2" (flatten) (("2" (assert) (("2" (inst? -2) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (inst?) (("3" (flatten) (("3" (use "reducible_is_app") (("3" (assert) (("3" (expand "reducible?") (("3" (inst 1 "seqt(1)") (("3" (expand "reduction?") (("3" (expand "reduction_fix?") (("3" (skeep) (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (case "EXISTS (m: nat):
                 seqp(m) = empty_seq") (("1" (hide-all-but (-1 2)) (("1" (inst 1 "min({i:nat | seqp(i) = empty_seq})") (("1" (typepred "min({i: nat | seqp(i) = empty_seq})") (("1" (assert) (("1" (skeep) (("1" (inst -2 "k") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (skeep) (("2" (inst -1 "m") (("2" (assert) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (skeep) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (hide 1) (("2" (generalize "n" "n" :fnums (1)) (("2" (reveal 2) (("2" (induct "n" 2) (("1" (expand "RTC") (("1" (expand "IUnion") (("1" (inst 1 0) (("1" (expand "iterate") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (inst 1 0) nil nil) ("3" (skeep) (("3" (inst -2 "j") (("3" (flatten) (("3" (expand "RTC") (("3" (expand "IUnion") (("3" (skeep) (("3" (prop) (("1" (inst 1 "i + 1") (("1" (lemma "iterate_add") (("1" (inst -1 "non_root_reduction?(E)" "i" "1") (("1" (replaces -1) (("1" (expand "o") (("1" (inst 1 "seqt(j)") (("1" (assert) (("1" (expand "iterate" 1) (("1" (expand "o ") (("1" (inst 1 "seqt(j)") (("1" (expand "iterate" 1) (("1" (hide -1) (("1" (expand "non_root_reduction?") (("1" (inst 1 "seqp(j)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 2 "1 + j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (reduction_fix? const-decl "bool" reduction nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (non_root_reduction? const-decl "bool" reduction nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (term type-decl nil term_adt nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (terminating? const-decl "bool" noetherian nil) (not_empty_seq type-eq-decl nil seq_extras structures) (first const-decl "T" seq_extras structures) (seq_first_rest_1 formula-decl nil seq_extras structures) (empty_0 formula-decl nil seq_extras structures) (reduction? const-decl "bool" reduction nil) (pos_subterm_ax formula-decl nil subterm nil) (pos_subterm formula-decl nil subterm nil) (rhs const-decl "term" rewrite_rules nil) (ext def-decl "term" substitution nil) (replace_distributivity formula-decl nil replacement nil) (member const-decl "bool" sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (rest const-decl "finseq" seq_extras structures) (O const-decl "finseq" finite_sequences nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (nonempty? const-decl "bool" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (choose const-decl "(p)" sets nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (reducible? const-decl "bool" ars_terminology nil) (reducible_is_app formula-decl nil reduction nil) (arg_preservation_in_finite_rtc formula-decl nil reduction nil) (positions_of_arg formula-decl nil positions nil) (non_root_rtc_preserves_pos_args formula-decl nil reduction nil) (non_root_rtc_preserves_root_symbol formula-decl nil reduction nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (subtermOF def-decl "term" subterm nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (finite_sequence type-eq-decl nil finite_sequences nil) (empty? const-decl "bool" sets nil) (iterate_add formula-decl nil relation_iterate orders) (iterate def-decl "pred[[T, T]]" relation_iterate orders)) shostak)) (position_of_replaced_term 0 (position_of_replaced_term-1 nil 3765117984 ("" (measure-induct "length(p1)" "p1") (("" (skeep*) (("" (case-replace "x = empty_seq" :hide? t) (("1" (hide -1) (("1" (expand "replaceTerm") (("1" (expand "empty_seq" -2 1) (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil) ("2" (inst -1 "rest(x)") (("2" (prop) (("1" (inst -1 "subtermOF(t1, #(first(x)))" "t2" "p2") (("1" (prop) (("1" (hide -2) (("1" (expand "positionsOF" -1) (("1" (expand "IUnion") (("1" (expand "union") (("1" (expand "catenate") (("1" (expand "member") (("1" (expand "finseq_appl") (("1" (expand "only_empty_seq") (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (skeep*) (("1" (expand "subtermOF") (("1" (expand "finseq_appl") (("1" (prop) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil) ("2" (expand "rest" 2 1) (("2" (lift-if) (("2" (prop) (("2" (replaces -2) (("2" (expand "^") (("2" (lift-if) (("2" (prop) (("1" (rewrite "subterm_empty_seq") (("1" (rewrite "first_add") (("1" (rewrite "rest_add_first") (("1" (expand "first") (("1" (expand "finseq_appl") (("1" (expand "#") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "subterm_empty_seq") (("2" (rewrite "rest_add_first") (("2" (rewrite "first_add") (("2" (expand "first") (("2" (expand "finseq_appl") (("2" (expand "#") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "first_add") (("3" (rewrite "rest_add_first") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "replace_distributivity") (("2" (inst -1 "#(first(x))" "rest(x)" "t1" "t2") (("2" (use "seq_first_rest_1[posnat]") (("2" (expand "/=") (("2" (rewrite "empty_0[posnat]") (("2" (assert) (("2" (replace -2 1 :dir rl :hide? t) (("2" (replace -1 1 rl) (("2" (expand "positionsOF" -3) (("2" (expand "IUnion") (("2" (expand "union") (("2" (expand "catenate") (("2" (expand "member") (("2" (expand "finseq_appl") (("2" (lift-if) (("2" (assert) (("2" (expand "only_empty_seq") (("2" (prop) (("1" (hide-all-but (-2 2)) (("1" (use "seq_empty[posnat]") (("1" (prop) (("1" (rewrite "empty_0[posnat]") nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 3)) (("2" (use "seq_empty[posnat]") (("2" (prop) (("2" (rewrite "empty_0[posnat]") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 4)) (("3" (use "seq_empty[posnat]") (("3" (prop) (("3" (rewrite "empty_0[posnat]") nil nil)) nil)) nil)) nil) ("4" (skeep*) (("4" (lemma "args_subterm") (("4" (expand "finseq_appl") (("4" (inst -1 "replaceTerm(t1, t2, x)" "i_1 - 1") (("1" (replaces -1) (("1" (assert) (("1" (case "first(x) = i_1 AND rest(x) o p2 = x_2") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-2 1 5)) (("2" (prop) (("1" (expand "first") (("1" (expand "finseq_appl") (("1" (expand "o ") (("1" (decompose-equality -1) (("1" (decompose-equality -2) (("1" (inst -1 0) (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (expand "add_first") (("1" (expand "insert?") (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (lemma "empty_0[posnat]") (("2" (inst -1 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -) (("2" (lemma "empty_0[posnat]") (("2" (inst -1 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "seq_first_rest_1[posnat]") (("2" (inst?) (("2" (prop) (("1" (replace -1 -2) (("1" (rewrite "add_first_is_o") (("1" (lemma "equal_prefix[posnat]") (("1" (inst -1 "#(first(x))" "rest(x) o p2" "x_2") (("1" (assert) (("1" (case-replace "first(x) = i_1") (("1" (use "o_assoc[posnat]") (("1" (assert) nil nil)) nil) ("2" (hide -1 2 3) (("2" (expand "o ") (("2" (flatten) (("2" (decompose-equality -2) (("2" (inst -1 0) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "empty_0[posnat]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (expand "positionsOF" -1) (("2" (expand "union") (("2" (expand "IUnion") (("2" (expand "catenate") (("2" (expand "member") (("2" (expand "finseq_appl") (("2" (expand "only_empty_seq") (("2" (lift-if) (("2" (assert) (("2" (prop) (("2" (skeep*) (("2" (lemma "args_subterm") (("2" (inst -1 "t1" "i_1 - 1") (("1" (assert) (("1" (expand "finseq_appl") (("1" (replaces -1) (("1" (replaces -2) (("1" (rewrite "first_add") (("1" (expand "positionsOF" 3) (("1" (expand "union") (("1" (expand "IUnion") (("1" (expand "catenate") (("1" (expand "member") (("1" (expand "only_empty_seq") (("1" (assert) (("1" (prop) (("1" (expand "finseq_appl") (("1" (inst 4 "i_1") (("1" (inst 4 "empty_seq") (("1" (rewrite "empty_seq_is_position") (("1" (hide-all-but (4)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 2)) (("3" (expand "/=") (("3" (rewrite "empty_0[posnat]") nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (use "length_rest[posnat]") (("2" (assert) (("2" (expand "/=") (("2" (rewrite "empty_0[posnat]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rest const-decl "finseq" seq_extras structures) (length_rest formula-decl nil seq_extras structures) (finite_sequence type-eq-decl nil finite_sequences nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (not_empty_seq type-eq-decl nil seq_extras structures) (first const-decl "T" seq_extras structures) (subtermOF def-decl "term" subterm nil) (replace_distributivity formula-decl nil replacement nil) (seq_first_rest_1 formula-decl nil seq_extras structures) (empty_0 formula-decl nil seq_extras structures) (insert? const-decl "finseq" seq_extras structures) (equal_prefix formula-decl nil seq_extras structures) (o_assoc formula-decl nil finite_sequences nil) (add_first_is_o formula-decl nil seq_extras structures) (args_subterm formula-decl nil subterm nil) (seq_empty formula-decl nil seq_extras structures) (catenate const-decl "positions" positions nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (add_first const-decl "finseq" seq_extras structures) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (subterm_empty_seq formula-decl nil subterm nil) (rest_add_first formula-decl nil seq_extras structures) (first_add formula-decl nil seq_extras structures) (^ const-decl "finseq" finite_sequences nil) (only_empty_seq const-decl "positions" positions nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (empty_seq_is_position formula-decl nil positions nil) (empty_o_seq formula-decl nil seq_extras structures) (empty_seq const-decl "finseq" finite_sequences nil) (O const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (replaceTerm def-decl "term" replacement nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (well_founded? const-decl "bool" orders nil)) shostak)) (mnt_reduces_at_root_to_nt_TCC1 0 (mnt_reduces_at_root_to_nt_TCC1-1 nil 3763224751 ("" (skeep :preds? t) (("" (rewrite "empty_seq_is_position") nil nil)) nil) ((empty_seq_is_position formula-decl nil positions nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil)) nil (mnt_reduces_at_root_to_nt subtype "finite_sequences[posnat].empty_seq" "positions[dp_termination.variable, dp_termination.symbol, dp_termination.arity].positions?(dp_termination.t)"))) (mnt_reduces_at_root_to_nt 0 (mnt_reduces_at_root_to_nt-1 nil 3763570940 ("" (skeep :preds? t) (("" (expand "minimal_non_terminating?") (("" (flatten) (("" (expand "terminating?" 1) (("" (skeep) (("" (use "positions_of_inf_reduction") (("" (prop) (("1" (skeep) (("1" (use "inf_deriv_of_mnt_has_min_root_reduction_index") (("1" (assert) (("1" (skeep) (("1" (case "RTC(non_root_reduction?(E))(s, seq(j))") (("1" (inst 1 "seq(j)" "seq(j + 1)") (("1" (assert) (("1" (inst -4 "j") (("1" (assert) nil nil)) nil)) nil) ("2" (hide -8) (("2" (expand "terminating?") (("2" (inst 1 "LAMBDA(i:nat): seq(i + 1 +j)") (("2" (assert) (("2" (skeep) (("2" (inst -6 "1 + n + j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "s") (("3" (case "FORALL ( jj : upto[j]) : minimal_non_terminating?(E)(seq(jj))") (("1" (inst? -1) nil nil) ("2" (induct "jj") (("1" (assert) nil nil) ("2" (hide 2) (("2" (skolem 1 "i") (("2" (prop) (("2" (hide -3 -4 -8 -10) (("2" (expand "minimal_non_terminating?") (("2" (prop) (("1" (hide-all-but (-1 -7)) (("1" (expand "terminating?") (("1" (inst 1 "LAMBDA(k:nat): seq(k + 1 + i)") (("1" (assert) (("1" (skeep) (("1" (inst -1 "1 + n + i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -5 "i") (("2" (inst -4 "i") (("2" (prop) (("1" (assert) nil nil) ("2" (hide -3 -6 3) (("2" (skeep :preds? t) (("2" (name-replace "si" "seq(i)") (("2" (name-replace "sii" "seq(i+1)") (("2" (name-replace "pp" "seqp(i)") (("2" (case "parallel(pp,p)") (("1" (expand "reduction_fix?") (("1" (skeep) (("1" (lemma "preserv_unchanged_pos") (("1" (inst -1 "pp" "p" "si" "ext(sigma)(rhs(e))") (("1" (assert) (("1" (lemma "replace_persistence") (("1" (inst -1 "pp" "p" "si" "ext(sigma)(rhs(e))") (("1" (assert) (("1" (inst -6 "p") (("1" (assert) nil nil) ("2" (expand "si") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "parallel") (("2" (prop) (("1" (expand "<=") (("1" (skeep) (("1" (replaces -1) (("1" (inst -3 "pp") (("1" (expand "reduction_fix?") (("1" (skeep) (("1" (expand "terminating?") (("1" (skolem -2 "sqii") (("1" (flatten) (("1" (inst 3 "LAMBDA (i : nat) : IF i = 0 THEN subtermOF(si, pp) ELSE replaceTerm(subtermOF(sii, pp), sqii(i-1), p1) ENDIF") (("1" (skeep) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (replaces -1) (("1" (replaces -2) (("1" (replaces -6) (("1" (use "subterm_of_replace") (("1" (assert) (("1" (replace -1 1) (("1" (use "replace_embedding") (("1" (prop) (("1" (replace -1 1) (("1" (use "replace_subterm_of_term") (("1" (assert) (("1" (prop) (("1" (replace -1 1) (("1" (replace -8 1) (("1" (hide-all-but 1) (("1" (expand "reduction?") (("1" (inst?) (("1" (inst 1 "empty_seq") (("1" (rewrite "subterm_empty_seq") (("1" (expand "replaceTerm") (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (rewrite "empty_seq_is_position") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -6 1)) (("2" (use "position_of_replaced_term") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -5 1)) (("2" (use "position_of_replaced_term") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -3 "n -1") (("1" (assert) (("1" (expand "reduction?") (("1" (skeep) (("1" (inst 2 "e!1" "sigma!1" "p1 o p!1") (("1" (use "replace_embedding") (("1" (assert) (("1" (split -1) (("1" (replaces -1) (("1" (assert) (("1" (replace -4 2) (("1" (use "replace_associativity") (("1" (prop) (("1" (assert) nil nil) ("2" (lemma "position_of_replaced_term") (("2" (inst -1 "sii" "subtermOF(sii, pp)" "pp" "p1") (("2" (prop) (("1" (lemma "closed_positions") (("1" (inst -1 "pp" "pp o p1" "sii") (("1" (prop) (("1" (hide-all-but 1) (("1" (expand "<=") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "replace_subterm_of_term") (("2" (assert) (("2" (lemma "closed_positions") (("2" (inst -1 "pp" "pp o p1" "sii") (("2" (assert) (("2" (hide-all-but 1) (("2" (expand "<=") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "p!1") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (replaces -8) (("2" (use "subterm_of_replace") (("2" (assert) (("2" (replaces -1) (("2" (hide-all-but (-1 -6 1)) (("2" (use "position_of_replaced_term") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (lemma "closed_positions") (("2" (inst -1 "pp" "pp o p1" "sii") (("2" (assert) (("2" (hide-all-but 1) (("2" (expand "<=") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "p!1") (("2" (lemma "replace_compose_pos") (("2" (inst -1 "p1" "p!1" "subtermOF[variable, symbol, arity](sii, pp)" "sqii(n - 1)") (("2" (prop) (("2" (hide-all-but (-2 1 4 5)) (("2" (lemma " pos_subterm_ax") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (replaces -7) (("2" (use "subterm_of_replace") (("2" (assert) (("2" (replaces -1) (("2" (hide-all-but (-1 -5 2 3 4)) (("2" (lemma "position_of_replaced_term") (("2" (inst -1 "si" "ext(sigma)(rhs(e))" "pp" "p1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil) ("4" (skeep) (("4" (replaces -7) (("4" (use "replace_preserv_pos") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "sii") (("2" (expand "reduction_fix?") (("2" (skeep) (("2" (replaces -5) (("2" (use "subterm_of_replace") (("2" (assert) (("2" (expand "si") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "<=") (("2" (skeep :preds? t) (("2" (inst -4 "p") (("1" (expand "terminating?") (("1" (skeep) (("1" (inst 3 "LAMBDA (k : nat) : IF k = 0 THEN subtermOF(si, p) ELSE seq!1(k-1) ENDIF") (("1" (skeep) (("1" (lift-if) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (replaces -1) (("2" (assert) (("2" (expand "reduction_fix?") (("2" (skeep) (("2" (hide -4) (("2" (expand "reduction?") (("2" (inst 2 "e" "sigma" "p1") (("1" (prop) (("1" (use "pos_subterm") (("1" (assert) nil nil)) nil) ("2" (replaces -3) (("2" (replace -6 1) (("2" (replace -1 1) (("2" (lemma "replace_distributivity") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (hide-all-but (-4 1 3 4)) (("2" (use " pos_subterm_ax") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lift-if) (("3" (assert) (("3" (inst? -4) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (hide-all-but (-2 -7 1 2 3)) (("3" (replaces -1) (("3" (use "pos_ax") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "si") (("2" (hide-all-but (-1 -4 1 2 3)) (("2" (replaces -1) (("2" (use "pos_ax") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "RTC") (("2" (expand "IUnion") (("2" (inst 1 "j") (("2" (hide -6) (("2" (case "FORALL ( jj : upto[j]) : iterate(non_root_reduction?(E), jj)(s, seq(jj)) ") (("1" (inst? -1) nil nil) ("2" (hide 2) (("2" (induct "jj") (("1" (expand "iterate") (("1" (assert) nil nil)) nil) ("2" (skolem 1 "i") (("2" (prop) (("2" (expand "iterate" 1) (("2" (expand "o ") (("2" (inst 1 "seq(i)") (("2" (assert) (("2" (inst -5 "i") (("2" (expand "non_root_reduction?") (("2" (inst 1 "seqp(i)") (("1" (flatten) nil nil) ("2" (inst -5 "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (inst -1 "n") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst? -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((terminating? const-decl "bool" noetherian nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (non_root_reduction? const-decl "bool" reduction nil) (pos_ax formula-decl nil positions nil) (replace_distributivity formula-decl nil replacement nil) (pos_subterm formula-decl nil subterm nil) (<= const-decl "bool" positions nil) (replace_preserv_pos formula-decl nil replacement nil) (O const-decl "finseq" finite_sequences nil) (closed_positions formula-decl nil positions nil) (replace_associativity formula-decl nil replacement nil) (replace_compose_pos formula-decl nil replacement nil) (pos_subterm_ax formula-decl nil subterm nil) (replace_embedding formula-decl nil replacement nil) (empty_seq_is_position formula-decl nil positions nil) (subterm_empty_seq formula-decl nil subterm nil) (lhs const-decl "term" rewrite_rules nil) (replace_subterm_of_term formula-decl nil replacement nil) (subterm_of_replace formula-decl nil replacement nil) (replaceTerm def-decl "term" replacement nil) (subtermOF def-decl "term" subterm nil) (preserv_unchanged_pos formula-decl nil replacement nil) (replace_persistence formula-decl nil replacement nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (ext def-decl "term" substitution nil) (rhs const-decl "term" rewrite_rules nil) (member const-decl "bool" sets nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (parallel const-decl "bool" positions nil) (reduction? const-decl "bool" reduction nil) (iterate def-decl "pred[[T, T]]" relation_iterate orders) (reduction_fix? const-decl "bool" reduction nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil)) shostak)) (reducible_position_of_terminating_inst_is_app_pos_of_term 0 (reducible_position_of_terminating_inst_is_app_pos_of_term-1 nil 3763571963 ("" (skeep* :preds? t) (("" (lemma "positions_of_ext") (("" (inst -1 "sigma" "t") (("" (expand "union") (("" (expand "member") (("" (assert) (("" (decompose-equality -1) (("" (inst -1 "p") (("" (assert) (("" (split -1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (skeep) (("2" (replaces -1) (("2" (lemma "subterm_of_ext") (("2" (inst -1 "p1" "p2" "sigma" "t") (("2" (assert) (("2" (replaces -1) (("2" (expand "terminating_sub?") (("2" (inst -5 "subtermOF(t, p1)") (("1" (expand "terminating?") (("1" (skeep) (("1" (inst 1 "LAMBDA (i : nat) : replaceTerm(sigma(subtermOF(t, p1)), seq(i) ,p2)") (("1" (split 1) (("1" (replace -6 1) (("1" (expand "ext" 1) (("1" (use "replace_subterm_of_term") (("1" (assert) (("1" (expand "ext") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -7 "n") (("2" (lemma "reduction_is_subs_op") (("2" (inst?) (("2" (flatten) (("2" (use "comp_op_iff_comp_cont") (("2" (assert) (("2" (expand "comp_cont?") (("2" (expand "ext" -6) (("2" (inst -1 "p2" "sigma(subtermOF(t, p1))") (("2" (assert) (("2" (inst -1 "seq(n)" "seq(n+1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ext" -3) (("2" (propax) nil nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (hide-all-but (-2 1)) (("1" (grind) nil nil)) nil) ("2" (case "positionsOF(t)(p1 o p2)") (("1" (assert) (("1" (expand "terminating?") (("1" (skeep) (("1" (inst -8 0) (("1" (replaces -7) (("1" (assert) (("1" (expand "Dom") (("1" (expand "/=") (("1" (expand "ext" -8) (("1" (replaces -2 -8) (("1" (use "pos_subterm") (("1" (assert) (("1" (replace -1 -8 :dir rl) (("1" (name-replace "tt" "subtermOF(t, p1 o p2)") (("1" (use "reducible_is_app") (("1" (assert) (("1" (expand "reducible?") (("1" (inst? 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3 4) (("2" (expand "Dom") (("2" (expand "/=") (("2" (expand "ext" -4) (("2" (replace -1 -4) (("2" (use "pos_o_term") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((positions_of_ext formula-decl nil substitution nil) (union const-decl "set" sets nil) (Dom const-decl "set[(V)]" substitution nil) (replace_subterm_of_term formula-decl nil replacement nil) (comp_op_iff_comp_cont formula-decl nil compatibility nil) (reduction? const-decl "bool" reduction nil) (comp_cont? const-decl "bool" compatibility nil) (reduction_is_subs_op formula-decl nil reduction nil) (replaceTerm def-decl "term" replacement nil) (terminating? const-decl "bool" noetherian nil) (reducible? const-decl "bool" ars_terminology nil) (reducible_is_app formula-decl nil reduction nil) (pos_subterm formula-decl nil subterm nil) (pos_o_term formula-decl nil subterm nil) (subterm_of_ext formula-decl nil substitution nil) (O const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (ext def-decl "term" substitution nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (member const-decl "bool" sets nil) (terminating_sub? const-decl "bool" reduction nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil)) nil)) (terminating_inst_of_rule_with_mint_on_rhs_gives_dp_alt 0 (terminating_inst_of_rule_with_mint_on_rhs_gives_dp_alt-1 nil 3763807517 ("" (skeep* :preds? t) (("" (expand "rewrite_rule?") (("" (flatten) (("" (lemma "mnt_reduces_at_root_to_nt") (("" (inst -1 "E" "subtermOF(ext(sigma)(rhs(e)), p)") (("" (skeep :preds? t) (("" (use "non_root_rtc_preserves_root_symbol") (("1" (assert) (("1" (flatten) (("1" (expand "dep_pair_alt?") (("1" (expand "lhs") (("1" (assert) (("1" (use "reducible_position_of_terminating_inst_is_app_pos_of_term") (("1" (expand "minimal_non_terminating?") (("1" (prop) (("1" (hide -5 -13) (("1" (expand "reduction_fix?") (("1" (skeep :preds? t) (("1" (expand "defined?") (("1" (inst 1 "e!1") (("1" (rewrite* "subterm_empty_seq") (("1" (replaces -9) (("1" (hide-all-but (-5 -6 -7 1)) (("1" (use "ext_preserve_symbol") (("1" (assert) (("1" (replaces -1) (("1" (lemma "ext_preserve_symbol") (("1" (inst -1 "lhs(e!1)" "sigma!1" "empty_seq") (("1" (rewrite* "subterm_empty_seq") (("1" (assert) (("1" (typepred "e!1") (("1" (expand "rewrite_rule?") (("1" (flatten) (("1" (expand "lhs") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "empty_seq_is_position") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-9 1)) (("2" (use "reducible_is_app") (("2" (assert) (("2" (hide 2) (("2" (expand "minimal_non_terminating?") (("2" (flatten) (("2" (hide -) (("2" (expand "terminating?") (("2" (expand "reducible?") (("2" (skeep) (("2" (inst -2 0) (("2" (replaces -1) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rewrite_rule? const-decl "bool" rewrite_rules nil) (reducible? const-decl "bool" ars_terminology nil) (terminating? const-decl "bool" noetherian nil) (reducible_is_app formula-decl nil reduction nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (ext_preserve_symbol formula-decl nil substitution nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (empty_seq_is_position formula-decl nil positions nil) (subterm_empty_seq formula-decl nil subterm nil) (defined? const-decl "bool" rewrite_rules nil) (reduction_fix? const-decl "bool" reduction nil) (lhs const-decl "term" rewrite_rules nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (non_root_rtc_preserves_root_symbol formula-decl nil reduction nil) (term type-decl nil term_adt nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (ext def-decl "term" substitution nil) (terminating_sub? const-decl "bool" reduction nil) (rhs const-decl "term" rewrite_rules nil) (member const-decl "bool" sets nil)) nil)) (mnt_to_nt_by_root_reduction_TCC1 0 (mnt_to_nt_by_root_reduction_TCC1-1 nil 3763825735 ("" (skeep :preds? t) (("" (rewrite "empty_seq_is_position") nil nil)) nil) ((empty_seq_is_position formula-decl nil positions nil) (term type-decl nil term_adt nil)) nil (mnt_to_nt_by_root_reduction subtype "finite_sequences[posnat].empty_seq" "positions[dp_termination.variable, dp_termination.symbol, dp_termination.arity].positions?(dp_termination.t)"))) (mnt_to_nt_by_root_reduction_TCC2 0 (mnt_to_nt_by_root_reduction_TCC2-1 nil 3763825735 ("" (skeep :preds? t) (("" (use "mnt_reduces_at_root_to_nt") (("" (skeep :preds? t) (("" (expand "nonempty?") (("" (expand "empty?") (("" (expand "member") (("" (inst -5 "(t,u)") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (nonempty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (reduction? const-decl "bool" reduction nil) (terminating? const-decl "bool" noetherian nil) (empty? const-decl "bool" sets nil)) nil (mnt_to_nt_by_root_reduction subtype "{(t: term_adt[dp_termination.variable, dp_termination.symbol, dp_termination.arity].term, u: term_adt[dp_termination.variable, dp_termination.symbol, dp_termination.arity].term) | booleans.AND(dp_termination.minimal_non_terminating?(dp_termination.E)(t), booleans.AND(relations_closure[term_adt[dp_termination.variable, dp_termination.symbol, dp_termination.arity].term].RTC(reduction[dp_termination.variable, dp_termination.symbol, dp_termination.arity].non_root_reduction?(dp_termination.E))(dp_termination.s, t), booleans.AND(reduction[dp_termination.variable, dp_termination.symbol, dp_termination.arity].reduction_fix?(dp_termination.E)(t, u, finite_sequences[posnat].empty_seq), (booleans.NOT)(noetherian[term_adt[dp_termination.variable, dp_termination.symbol, dp_termination.arity].term].terminating?(reduction[dp_termination.variable, dp_termination.symbol, dp_termination.arity].reduction?(dp_termination.E))(u)))))}" "(sets[[term_adt[dp_termination.variable, dp_termination.symbol, dp_termination.arity].term, term_adt[dp_termination.variable, dp_termination.symbol, dp_termination.arity].term]].nonempty?)"))) (reduced_nt_by_root_has_mnt_TCC1 0 (reduced_nt_by_root_has_mnt_TCC1-1 nil 3763827790 ("" (skeep* :preds? t) (("" (use "ext_preserv_pos") (("" (assert) nil nil)) nil)) nil) ((ext_preserv_pos formula-decl nil substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (positions? type-eq-decl nil positions nil) (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (rhs const-decl "term" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil)) nil (reduced_nt_by_root_has_mnt subtype "dp_termination.p" "positions[dp_termination.variable, dp_termination.symbol, dp_termination.arity].positions?(substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].ext(dp_termination.sigma)(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.e)))"))) (reduced_nt_by_root_has_mnt 0 (reduced_nt_by_root_has_mnt-1 nil 3763827792 ("" (skeep* :preds? t) (("" (expand "mnt_to_nt_by_root_reduction") (("" (typepred "choose({(t: term), (u: term) |
                   minimal_non_terminating?(E)(t) AND
                    RTC(non_root_reduction?(E))(s, t) AND
                     reduction_fix?(E)(t, u, empty_seq) AND
                      NOT terminating?(reduction?(E))(u)})") (("1" (name-replace "lhs_and_rhs" "choose({(t: term), (u: term) |
                   minimal_non_terminating?(E)(t) AND
                    RTC(non_root_reduction?(E))(s, t) AND
                     reduction_fix?(E)(t, u, empty_seq) AND
                      NOT terminating?(reduction?(E))(u)})") (("1" (expand "reduction_fix?") (("1" (skeep :preds? t) (("1" (rewrite* "subterm_empty_seq") (("1" (case-replace "ext(restriction(sigma)(Vars(lhs(e))))(lhs(e)) = ext(sigma)(lhs(e)) AND ext(restriction(sigma)(Vars(lhs(e))))(rhs(e)) = ext(sigma)(rhs(e))") (("1" (flatten) (("1" (lemma "non_terminating_has_mnt") (("1" (inst -1 "E" "lhs_and_rhs`2") (("1" (skeep :preds? t) (("1" (expand "replaceTerm") (("1" (rewrite "empty_0") (("1" (inst 2 "restriction(sigma)(Vars(lhs(e)))" "e" "p") (("1" (assert) nil nil) ("2" (replaces -10) (("2" (replaces -10) (("2" (lemma "reducible_position_of_terminating_inst_is_app_pos_of_term") (("2" (inst -1 "E" "rhs(e)" "restriction(sigma)(Vars(lhs(e)))" "p") (("1" (replaces -5) (("1" (expand "minimal_non_terminating?" -3) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (hide-all-but (-3 -4 -8 1)) (("3" (expand "minimal_non_terminating?") (("3" (flatten) (("3" (expand "terminating_sub?") (("3" (skeep :preds? t) (("3" (lemma "pos_vars_subset_pos") (("3" (inst -1 "lhs(e)" "x") (("3" (assert) (("3" (case "EXISTS (p: positions?(lhs(e))): NOT p = empty_seq AND x = subtermOF(lhs(e), p)") (("1" (skeep :preds? t) (("1" (inst -8 "p!1") (("1" (lemma "subterm_of_ext") (("1" (inst -1 "p!1" "empty_seq" "sigma" "lhs(e)") (("1" (assert) (("1" (prop) (("1" (rewrite "subterm_empty_seq") (("1" (rewrite "seq_o_empty") (("1" (expand "restriction" 2) (("1" (expand "member") (("1" (replace -4 -1 rl) (("1" (expand "ext" -1 2) (("1" (assert) (("1" (prop) (("1" (hide-all-but 2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "empty_seq_is_position") nil nil) ("3" (hide-all-but (-2 -3 -5 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (use "ext_preserv_pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -4 -5 -6 2 3) (("2" (expand "Dom") (("2" (expand "/=") (("2" (assert) (("2" (expand "restriction") (("2" (expand "member") (("2" (lift-if) (("2" (prop) (("2" (expand "Vars") (("2" (skeep :preds? t) (("2" (inst?) (("2" (assert) (("2" (hide 1) (("2" (typepred "e") (("2" (expand "rewrite_rule?") (("2" (flatten) (("2" (expand "lhs") (("2" (assert) (("2" (expand "subtermOF") (("2" (rewrite "empty_0") (("2" (hide-all-but (-4 -6 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "rewrite_rule?") (("2" (expand "lhs") (("2" (expand "rhs") (("2" (prop) (("1" (use "restriction_term") (("1" (assert) (("1" (expand "subset?") (("1" (skeep) nil nil)) nil)) nil)) nil) ("2" (use "restriction_term") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (prop) (("3" (rewrite "restriction_Subs") nil nil)) nil) ("4" (rewrite "restriction_Subs") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (use "mnt_reduces_at_root_to_nt") (("2" (skeep) (("2" (inst -3 "(t,u)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep* :preds? t) (("3" (rewrite "empty_seq_is_position") nil nil)) nil)) nil)) nil)) nil)) nil) ((empty? const-decl "bool" sets nil) (rhs const-decl "term" rewrite_rules nil) (member const-decl "bool" sets nil) (lhs const-decl "term" rewrite_rules nil) (Vars const-decl "set[(V)]" subterm nil) (restriction const-decl "term" substitution nil) (ext def-decl "term" substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (empty_0 formula-decl nil seq_extras structures) (Dom const-decl "set[(V)]" substitution nil) (subtermOF def-decl "term" subterm nil) (seq_o_empty formula-decl nil seq_extras structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (subset? const-decl "bool" sets nil) (is_finite const-decl "bool" finite_sets nil) (only_empty_seq const-decl "positions" positions nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (insert? const-decl "finseq" seq_extras structures) (add_first const-decl "finseq" seq_extras structures) (catenate const-decl "positions" positions nil) (union const-decl "set" sets nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (empty_seq_is_position formula-decl nil positions nil) (subterm_of_ext formula-decl nil substitution nil) (ext_preserv_pos formula-decl nil substitution nil) (pos_vars_subset_pos formula-decl nil subterm nil) (terminating_sub? const-decl "bool" reduction nil) (replaceTerm def-decl "term" replacement nil) (restriction_term formula-decl nil substitution nil) (restriction_Subs formula-decl nil substitution nil) (subterm_empty_seq formula-decl nil subterm nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (non_root_reduction? const-decl "bool" reduction nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (reduction_fix? const-decl "bool" reduction nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (terminating? const-decl "bool" noetherian nil) (reduction? const-decl "bool" reduction nil)) shostak)) (dp_and_sub_from_first_root_reduction_TCC1 0 (dp_and_sub_from_first_root_reduction_TCC1-1 nil 3763825735 ("" (skeep* :preds? t) (("" (use "ext_preserv_pos") (("" (assert) nil nil)) nil)) nil) ((ext_preserv_pos formula-decl nil substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (positions? type-eq-decl nil positions nil) (rhs const-decl "term" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil)) nil (dp_and_sub_from_first_root_reduction subtype "dp_termination.p" "positions[dp_termination.variable, dp_termination.symbol, dp_termination.arity].positions?(substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].ext(dp_termination.sigma)(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.e)))"))) (dp_and_sub_from_first_root_reduction_TCC2 0 (dp_and_sub_from_first_root_reduction_TCC2-1 nil 3763825735 ("" (skeep* :preds? t) (("" (use "reduced_nt_by_root_has_mnt") (("" (skolem -1 ("sigma1" "e1" "p1")) (("" (flatten) (("" (expand "nonempty?") (("" (expand "empty?") (("" (expand "member") (("" (inst -5 "(sigma1, e1, p1)") (("" (assert) (("" (typepred "e1") (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (empty? const-decl "bool" sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (rhs const-decl "term" rewrite_rules nil) (positions? type-eq-decl nil positions nil) (member const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil)) nil (dp_and_sub_from_first_root_reduction subtype "{(sigma: substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].Sub, e: rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rewrite_rule, p: positions[dp_termination.variable, dp_termination.symbol, dp_termination.arity].positions?(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.e))) | booleans.AND(sets[rewrite_rule[variable, symbol, arity]].member(e, dp_termination.E), booleans.AND(substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].ext(sigma)(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].lhs(e)) = dp_termination.lhs_term, dp_termination.minimal_non_terminating?(dp_termination.E)(subterm[dp_termination.variable, dp_termination.symbol, dp_termination.arity].subtermOF(substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].ext(sigma)(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(e)), p))))}" "(sets[[Sub[variable, symbol, arity], e: rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rewrite_rule, positions[dp_termination.variable, dp_termination.symbol, dp_termination.arity].positions?(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(e))]].nonempty?)"))) (dp_and_sub_from_first_root_reduction_TCC3 0 (dp_and_sub_from_first_root_reduction_TCC3-2 "" 3804409044 ("" (skeep* :preds? t) (("" (expand "mnt_to_nt_by_root_reduction") (("" (typepred "choose({(t: term), (u: term) |
                 minimal_non_terminating?(E)(t) AND
                  RTC(non_root_reduction?(E))(s, t) AND
                   reduction_fix?(E)(t, u, empty_seq) AND
                    NOT terminating?(reduction?(E))(u)})") (("1" (replaces -8 :dir rl) (("1" (lemma "terminating_inst_of_rule_with_mint_on_rhs_gives_dp_alt") (("1" (inst -1 "E" "sub_e_p`2" "restriction(sub_e_p`1)(Vars(lhs(sub_e_p`2)))" "sub_e_p`3") (("1" (assert) (("1" (use "restriction_term") (("1" (assert) (("1" (hide-all-but 1) (("1" (typepred "sub_e_p`2") (("1" (expand "rewrite_rule?") (("1" (flatten) (("1" (expand "rhs") (("1" (expand "lhs") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "ext_preserv_pos") (("2" (assert) nil nil)) nil) ("3" (use "restriction_Subs") (("3" (assert) (("3" (replaces -7 :dir rl) (("3" (hide-all-but (-1 -2 1)) (("3" (expand "minimal_non_terminating?") (("3" (flatten) (("3" (expand "terminating_sub?") (("3" (skeep :preds? t) (("3" (expand "Dom") (("3" (expand "/=") (("3" (assert) (("3" (expand "restriction" 1) (("3" (expand "member") (("3" (lift-if) (("3" (prop) (("3" (expand "Vars" -1) (("3" (skeep :preds? t) (("3" (inst -5 "p") (("1" (use "subterm_ext_commute") (("1" (assert) (("1" (replace -1 -6) (("1" (replace -3 -6) (("1" (case-replace "ext(sub_e_p`1)(x) = restriction[variable, symbol, arity]
                               (sub_e_p`1)
                               (Vars[variable, symbol, arity]
                                    (lhs[variable, symbol, arity](sub_e_p`2)))
                               (x)") (("1" (hide-all-but (-3 -4 1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "ext_preserv_pos") (("2" (assert) (("2" (hide-all-but (-2 -4 -5)) (("2" (typepred "sub_e_p`2") (("2" (expand "rewrite_rule?") (("2" (flatten) (("2" (expand "subtermOF") (("2" (rewrite "empty_0") (("2" (expand "lhs") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (use "mnt_reduces_at_root_to_nt") (("2" (skeep :preds? t) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (inst -4 "(t,u)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (rewrite "empty_seq_is_position") nil nil)) nil)) nil)) nil)) nil) nil shostak (dp_and_sub_from_first_root_reduction subtype "(dp_termination.sub_e_p`2, dp_termination.sub_e_p`3)" "dependency_pairs[dp_termination.variable, dp_termination.symbol, dp_termination.arity].dep_pair_alt(dp_termination.E)")) (dp_and_sub_from_first_root_reduction_TCC3-1 nil 3763825735 ("" (skeep* :preds? t) (("" (expand "mnt_to_nt_by_root_reduction") (("" (typepred "choose({(t: term), (u: term) |
                 minimal_non_terminating?(E)(t) AND
                  RTC(non_root_reduction?(E))(s, t) AND
                   reduction_fix?(E)(t, u, empty_seq) AND
                    NOT terminating?(reduction?(E))(u)})") (("1" (replaces -8 :dir rl) (("1" (lemma "terminating_inst_of_rule_with_mint_on_rhs_gives_dp_alt") (("1" (inst -1 "E" "sub_e_p`2" "restriction(sub_e_p`1)(Vars(lhs(sub_e_p`2)))" "sub_e_p`3") (("1" (assert) (("1" (use "restriction_term") (("1" (assert) (("1" (hide-all-but 1) (("1" (typepred "sub_e_p`2") (("1" (expand "rewrite_rule?") (("1" (flatten) (("1" (expand "rhs") (("1" (expand "lhs") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "ext_preserv_pos") (("2" (assert) nil nil)) nil) ("3" (use "restriction_Subs") (("3" (assert) (("3" (replaces -6 :dir rl) (("3" (hide-all-but (-1 -2 1)) (("3" (expand "minimal_non_terminating?") (("3" (flatten) (("3" (expand "terminating_sub?") (("3" (skeep :preds? t) (("3" (expand "Dom") (("3" (expand "/=") (("3" (assert) (("3" (expand "restriction" 1) (("3" (expand "member") (("3" (lift-if) (("3" (prop) (("3" (expand "Vars" -1) (("3" (skeep :preds? t) (("3" (inst -5 "p") (("1" (use "subterm_ext_commute") (("1" (assert) (("1" (replace -1 -6) (("1" (replace -3 -6) (("1" (case-replace "ext(sub_e_p`1)(x) = restriction[variable, symbol, arity]
                       (sub_e_p`1)
                       (Vars[variable, symbol, arity]
                            (lhs[variable, symbol, arity](sub_e_p`2)))
                       (x)") (("1" (hide-all-but (-3 -4 1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "ext_preserv_pos") (("2" (assert) (("2" (hide-all-but (-2 -4 -5)) (("2" (typepred "sub_e_p`2") (("2" (expand "rewrite_rule?") (("2" (flatten) (("2" (expand "subtermOF") (("2" (rewrite "empty_0") (("2" (expand "lhs") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (use "mnt_reduces_at_root_to_nt") (("2" (skeep :preds? t) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (inst -4 "(t,u)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (rewrite "empty_seq_is_position") nil nil)) nil)) nil)) nil)) nil) ((empty_seq_is_position formula-decl nil positions nil) (empty? const-decl "bool" sets nil) (subterm_ext_commute formula-decl nil substitution nil) (empty_0 formula-decl nil seq_extras structures) (subset? const-decl "bool" sets nil) (Dom const-decl "set[(V)]" substitution nil) (restriction_Subs formula-decl nil substitution nil) (ext_preserv_pos formula-decl nil substitution nil) (restriction_term formula-decl nil substitution nil) (terminating_sub? const-decl "bool" reduction nil) (Vars const-decl "set[(V)]" subterm nil) (subtermOF def-decl "term" subterm nil) (lhs const-decl "term" rewrite_rules nil) (ext def-decl "term" substitution nil) (member const-decl "bool" sets nil) (rhs const-decl "term" rewrite_rules nil) (restriction const-decl "term" substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (non_root_reduction? const-decl "bool" reduction nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (reduction_fix? const-decl "bool" reduction nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (terminating? const-decl "bool" noetherian nil) (reduction? const-decl "bool" reduction nil)) nil (dp_and_sub_from_first_root_reduction subtype "(dp_termination.sub_e_p`2, dp_termination.sub_e_p`3)" "dependency_pairs[dp_termination.variable, dp_termination.symbol, dp_termination.arity].dep_pair_alt(dp_termination.E)"))) (next_inst_dp_is_chained_and_mnt_TCC1 0 (next_inst_dp_is_chained_and_mnt_TCC1-1 nil 3763825735 ("" (skeep* :preds? t) (("" (expand "dep_pair_alt?") (("" (flatten) (("" (use "ext_preserv_pos") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((dep_pair_alt? const-decl "bool" dependency_pairs nil) (ext_preserv_pos formula-decl nil substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (rhs const-decl "term" rewrite_rules nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil)) nil (next_inst_dp_is_chained_and_mnt subtype "dp_termination.dp`2" "positions[dp_termination.variable, dp_termination.symbol, dp_termination.arity].positions?(substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].ext(dp_termination.sigma)(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dp`1)))"))) (next_inst_dp_is_chained_and_mnt_TCC2 0 (next_inst_dp_is_chained_and_mnt_TCC2-1 nil 3763825735 ("" (subtype-tcc) nil nil) ((term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (ext def-decl "term" substitution nil) (terminating? const-decl "bool" noetherian nil) (reduction? const-decl "bool" reduction nil) (is_finite const-decl "bool" finite_sets nil) (defined? const-decl "bool" rewrite_rules nil) (lhs const-decl "term" rewrite_rules nil) (member const-decl "bool" sets nil) (rhs const-decl "term" rewrite_rules nil)) nil (next_inst_dp_is_chained_and_mnt subtype "dp_termination.dp`2" "positions[dp_termination.variable, dp_termination.symbol, dp_termination.arity].positions?(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dp`1))"))) (next_inst_dp_is_chained_and_mnt_TCC3 0 (next_inst_dp_is_chained_and_mnt_TCC3-1 nil 3763825735 ("" (subtype-tcc) nil nil) ((rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (ext def-decl "term" substitution nil) (is_finite const-decl "bool" finite_sets nil) (defined? const-decl "bool" rewrite_rules nil) (member const-decl "bool" sets nil) (lhs const-decl "term" rewrite_rules nil) (rhs const-decl "term" rewrite_rules nil) (reduction? const-decl "bool" reduction nil) (term type-decl nil term_adt nil) (terminating? const-decl "bool" noetherian nil)) nil (next_inst_dp_is_chained_and_mnt subtype "subterm[dp_termination.variable, dp_termination.symbol, dp_termination.arity].subtermOF(substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].ext(dp_termination.sigma)(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dp`1)), dp_termination.dp`2)" "{s: term_adt[dp_termination.variable, dp_termination.symbol, dp_termination.arity].term | dp_termination.minimal_non_terminating?(dp_termination.E)(s)}"))) (next_inst_dp_is_chained_and_mnt_TCC4 0 (next_inst_dp_is_chained_and_mnt_TCC4-1 nil 3763825735 ("" (skeep* :preds? t) (("" (typepred "next_dp_sub`1") (("" (expand "dep_pair_alt?") (("" (flatten) nil nil)) nil)) nil)) nil) ((Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (position type-eq-decl nil positions nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil)) nil (next_inst_dp_is_chained_and_mnt subtype "dp_termination.next_dp_sub`1`2" "positions[dp_termination.variable, dp_termination.symbol, dp_termination.arity].positions?(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.next_dp_sub`1`1))"))) (next_inst_dp_is_chained_and_mnt_TCC5 0 (next_inst_dp_is_chained_and_mnt_TCC5-2 "" 3804432011 ("" (skeep* :preds? t) (("" (hide-all-but (-1 -5 1)) (("" (expand "dep_pair_alt?") (("" (expand "dep_pair?") (("" (flatten) (("" (assert) (("" (inst?) (("" (assert) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (next_inst_dp_is_chained_and_mnt subtype "dp_termination.std_dp" "dependency_pairs[dp_termination.variable, dp_termination.symbol, dp_termination.arity].dep_pair(dp_termination.E)")) (next_inst_dp_is_chained_and_mnt_TCC5-1 nil 3763825735 ("" (skeep* :preds? t) (("" (hide-all-but (-2 -5 1)) (("" (expand "dep_pair_alt?") (("" (expand "dep_pair?") (("" (flatten) (("" (assert) (("" (inst?) (("" (assert) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((dep_pair? const-decl "bool" dependency_pairs nil) (positions? type-eq-decl nil positions nil) (rhs const-decl "term" rewrite_rules nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (set type-eq-decl nil sets nil) (position type-eq-decl nil positions nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil)) nil (next_inst_dp_is_chained_and_mnt subtype "dp_termination.std_dp" "dependency_pairs[dp_termination.variable, dp_termination.symbol, dp_termination.arity].dep_pair(dp_termination.E)"))) (next_inst_dp_is_chained_and_mnt_TCC6 0 (next_inst_dp_is_chained_and_mnt_TCC6-1 nil 3763825735 ("" (skeep* :preds? t) (("" (replaces -7) (("" (typepred "next_dp_sub`1") (("" (hide-all-but (-1 1)) (("" (expand "dep_pair_alt?") (("" (expand "dep_pair?") (("" (flatten) (("" (assert) (("" (inst?) (("" (assert) (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((dep_pair? const-decl "bool" dependency_pairs nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (rhs const-decl "term" rewrite_rules nil) (positions? type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil)) nil (next_inst_dp_is_chained_and_mnt subtype "dp_termination.next_std_dp" "dependency_pairs[dp_termination.variable, dp_termination.symbol, dp_termination.arity].dep_pair(dp_termination.E)"))) (next_inst_dp_is_chained_and_mnt 0 (next_inst_dp_is_chained_and_mnt-1 nil 3763834823 ("" (skeep* :preds? t) (("" (assert) (("" (expand "dp_and_sub_from_first_root_reduction") (("" (typepred "choose
                                     ({(sigma_1: Sub),
                                       (e: rewrite_rule),
                                       (p: positions?(rhs(e)))
                                       |
                                       member(e, E)
                                       AND
                                       ext(sigma_1)(lhs(e))
                                       =
                                       mnt_to_nt_by_root_reduction
                                       (E)
                                       (subtermOF
                                        (ext(sigma)(rhs(dp`1)), dp`2))`1
                                       AND
                                       minimal_non_terminating?
                                       (E)
                                       (subtermOF
                                        (ext(sigma_1)(rhs(e)), p))})") (("1" (name-replace "s_e_p" "choose
                                     ({(sigma_1: Sub),
                                       (e: rewrite_rule),
                                       (p: positions?(rhs(e)))
                                       |
                                       member(e, E)
                                       AND
                                       ext(sigma_1)(lhs(e))
                                       =
                                       mnt_to_nt_by_root_reduction
                                       (E)
                                       (subtermOF
                                        (ext(sigma)(rhs(dp`1)), dp`2))`1
                                       AND
                                       minimal_non_terminating?
                                       (E)
                                       (subtermOF
                                        (ext(sigma_1)(rhs(e)), p))})") (("1" (expand "mnt_to_nt_by_root_reduction") (("1" (typepred "choose({(t: term), (u: term) |
                 minimal_non_terminating?(E)(t) AND
                  RTC(non_root_reduction?(E))
                     (subtermOF(ext(sigma)(rhs(dp`1)), dp`2), t)
                   AND
                   reduction_fix?(E)(t, u, empty_seq) AND
                    NOT terminating?(reduction?(E))(u)})") (("1" (name-replace "cTerm" "choose({(t: term), (u: term) |
                 minimal_non_terminating?(E)(t) AND
                  RTC(non_root_reduction?(E))
                     (subtermOF(ext(sigma)(rhs(dp`1)), dp`2), t)
                   AND
                   reduction_fix?(E)(t, u, empty_seq) AND
                    NOT terminating?(reduction?(E))(u)})") (("1" (prop) (("1" (expand "chained_dp?") (("1" (assert) (("1" (lemma "subterm_ext_commute") (("1" (inst -1 "dp`2" "rhs(dp`1)" "sigma") (("1" (assert) (("1" (expand "dep_pair_alt?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (typepred "s_e_p`3") (("2" (use "subterm_ext_commute") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (use "mnt_reduces_at_root_to_nt") (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (skeep) (("2" (inst -3 "(t,u)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (rewrite "empty_seq_is_position") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "reduced_nt_by_root_has_mnt") (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (skolem -1 ("sigma1" "e1" "p1")) (("2" (inst -2 "(sigma1, e1, p1)") (("2" (flatten) (("2" (assert) (("2" (typepred "e1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep :preds? t) (("3" (use "ext_preserv_pos") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((dep_pair_alt type-eq-decl nil dependency_pairs nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (subtermOF def-decl "term" subterm nil) (lhs const-decl "term" rewrite_rules nil) (ext def-decl "term" substitution nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (positions? type-eq-decl nil positions nil) (rhs const-decl "term" rewrite_rules nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (empty_seq_is_position formula-decl nil positions nil) (empty? const-decl "bool" sets nil) (subterm_ext_commute formula-decl nil substitution nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (non_root_reduction? const-decl "bool" reduction nil) (reduction_fix? const-decl "bool" reduction nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (terminating? const-decl "bool" noetherian nil) (reduction? const-decl "bool" reduction nil) (ext_preserv_pos formula-decl nil substitution nil)) shostak)) (next_dp_and_subs_TCC1 0 (next_dp_and_subs_TCC1-1 nil 3763836407 ("" (skeep* :preds? t) (("" (typepred "dp_s`1") (("" (expand "dep_pair_alt?") (("" (flatten) (("" (use "ext_preserv_pos") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (position type-eq-decl nil positions nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (rhs const-decl "term" rewrite_rules nil) (ext_preserv_pos formula-decl nil substitution nil)) nil (next_dp_and_subs subtype "dp_termination.dp_s`1`2" "positions[dp_termination.variable, dp_termination.symbol, dp_termination.arity].positions?(substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].ext(dp_termination.dp_s`2)(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dp_s`1`1)))"))) (next_dp_and_subs_TCC2 0 (next_dp_and_subs_TCC2-1 nil 3763836407 ("" (skeep* :preds? t) (("" (hide -) (("" (typepred "dp_s`1") (("" (expand "dep_pair_alt?") (("" (flatten) nil nil)) nil)) nil)) nil)) nil) ((term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (ext def-decl "term" substitution nil) (rhs const-decl "term" rewrite_rules nil)) nil (next_dp_and_subs subtype "dp_termination.dp_s`1`2" "positions[dp_termination.variable, dp_termination.symbol, dp_termination.arity].positions?(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dp_s`1`1))"))) (next_dp_and_subs_TCC3 0 (next_dp_and_subs_TCC3-1 nil 3763836407 ("" (skeep* :preds? t) (("" (hide -) (("" (typepred "dp_s`1") (("" (expand "dep_pair_alt?") (("" (expand "dep_pair?") (("" (flatten) (("" (assert) (("" (inst?) (("" (assert) (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((dep_pair? const-decl "bool" dependency_pairs nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (ext def-decl "term" substitution nil) (rhs const-decl "term" rewrite_rules nil)) nil (next_dp_and_subs subtype "(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].lhs(dp_termination.dp_s`1`1), subterm[dp_termination.variable, dp_termination.symbol, dp_termination.arity].subtermOF(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dp_s`1`1), dp_termination.dp_s`1`2))" "dependency_pairs[dp_termination.variable, dp_termination.symbol, dp_termination.arity].dep_pair(dp_termination.E)"))) (next_dp_and_subs_TCC4 0 (next_dp_and_subs_TCC4-1 nil 3763836407 ("" (subtype-tcc) nil nil) ((term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (is_finite const-decl "bool" finite_sets nil) (defined? const-decl "bool" rewrite_rules nil) (lhs const-decl "term" rewrite_rules nil) (member const-decl "bool" sets nil) (rhs const-decl "term" rewrite_rules nil)) nil (next_dp_and_subs subtype "dp_termination.dp_`2" "positions[dp_termination.variable, dp_termination.symbol, dp_termination.arity].positions?(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dp_`1))"))) (next_dp_and_subs_TCC5 0 (next_dp_and_subs_TCC5-1 nil 3763836407 ("" (subtype-tcc) nil nil) ((term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (Vars const-decl "set[(V)]" subterm nil) (subset? const-decl "bool" sets nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (is_finite const-decl "bool" finite_sets nil) (lhs const-decl "term" rewrite_rules nil) (defined? const-decl "bool" rewrite_rules nil) (member const-decl "bool" sets nil) (dep_pair? const-decl "bool" dependency_pairs nil) (rhs const-decl "term" rewrite_rules nil) (Dom const-decl "set[(V)]" substitution nil) (V const-decl "set[term]" variables_term nil)) nil (next_dp_and_subs subtype "(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].lhs(dp_termination.dp_`1), subterm[dp_termination.variable, dp_termination.symbol, dp_termination.arity].subtermOF(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dp_`1), dp_termination.dp_`2))" "dependency_pairs[dp_termination.variable, dp_termination.symbol, dp_termination.arity].dep_pair(dp_termination.E)"))) (next_dp_and_subs_TCC6 0 (next_dp_and_subs_TCC6-1 nil 3763836407 ("" (subtype-tcc) nil nil) ((rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (ext def-decl "term" substitution nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (rhs const-decl "term" rewrite_rules nil) (lhs const-decl "term" rewrite_rules nil) (reduction? const-decl "bool" reduction nil) (term type-decl nil term_adt nil) (terminating? const-decl "bool" noetherian nil)) nil (next_dp_and_subs subtype "subterm[dp_termination.variable, dp_termination.symbol, dp_termination.arity].subtermOF(substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].ext(dp_termination.dp_s`2)(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dp_s`1`1)), dp_termination.dp_s`1`2)" "{s: term_adt[dp_termination.variable, dp_termination.symbol, dp_termination.arity].term | dp_termination.minimal_non_terminating?(dp_termination.E)(s)}"))) (next_dp_and_subs_TCC7 0 (next_dp_and_subs_TCC7-1 nil 3763836407 ("" (skeep* :preds? t) (("" (use "next_inst_dp_is_chained_and_mnt") (("" (assert) (("" (flatten) (("" (assert) (("" (hide -1 -3) (("" (lemma "subterm_ext_commute") (("" (inst -1 "dp_and_sub_from_first_root_reduction
                                    (E)
                                    (subtermOF[variable, symbol, arity]
                                     (ext[variable, symbol, arity]
                                      (dp_s`2)
                                      (rhs[variable, symbol, arity]
                                       (dp_s`1`1)),
                                      dp_s`1`2))`1`2" "_" "_") (("" (inst -1 "rhs[variable, symbol, arity]
                                     (dp_and_sub_from_first_root_reduction
                                      (E)
                                      (subtermOF[variable, symbol, arity]
                                       (ext[variable, symbol, arity]
                                        (dp_s`2)
                                        (rhs[variable, symbol, arity]
                                         (dp_s`1`1)),
                                        dp_s`1`2))`1`1)" "_") (("" (inst -1 "dp_and_sub_from_first_root_reduction
                                     (E)
                                     (subtermOF[variable, symbol, arity]
                                      (ext[variable, symbol, arity]
                                       (dp_s`2)
                                       (rhs[variable, symbol, arity]
                                        (dp_s`1`1)),
                                       dp_s`1`2))`2") (("" (assert) (("" (hide 2) (("" (typepred "dp_and_sub_from_first_root_reduction(E)
                                                      (subtermOF
                                                       [variable,
                                                        symbol,
                                                        arity]
                                                       (ext
                                                        [variable,
                                                         symbol,
                                                         arity]
                                                        (dp_s`2)
                                                        (rhs
                                                         [variable,
                                                          symbol,
                                                          arity]
                                                         (dp_s`1`1)),
                                                        dp_s`1`2))`1") (("" (expand "dep_pair_alt?") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rhs const-decl "term" rewrite_rules nil) (ext def-decl "term" substitution nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (position type-eq-decl nil positions nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (subterm_ext_commute formula-decl nil substitution nil)) nil (next_dp_and_subs subtype "dp_termination.dp_and_sub_from_first_root_reduction(dp_termination.E)(subterm[dp_termination.variable, dp_termination.symbol, dp_termination.arity].subtermOF(substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].ext(dp_termination.dp_s`2)(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dp_s`1`1)), dp_termination.dp_s`1`2))" "{(dp_: dependency_pairs[dp_termination.variable, dp_termination.symbol, dp_termination.arity].dep_pair_alt(dp_termination.E), sigma_: substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].Sub) | booleans.AND(dp_termination.chained_dp?(dp_termination.E)((rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].lhs(dp_termination.dp_s`1`1), subterm[dp_termination.variable, dp_termination.symbol, dp_termination.arity].subtermOF(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dp_s`1`1), dp_termination.dp_s`1`2)), (rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].lhs(dp_`1), subterm[dp_termination.variable, dp_termination.symbol, dp_termination.arity].subtermOF(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_`1), dp_`2)))(dp_termination.dp_s`2, sigma_), dp_termination.minimal_non_terminating?(dp_termination.E)(subterm[dp_termination.variable, dp_termination.symbol, dp_termination.arity].subtermOF(substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].ext(sigma_)(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_`1)), dp_`2)))}"))) (dp_termination_implies_noetherian 0 (dp_termination_implies_noetherian-1 nil 3763836700 ("" (skeep) (("" (rewrite "dp_termination_and_alt_eq" :dir rl) (("" (expand "noetherian?") (("" (rewrite "no_infinite_descending_sequence") (("" (expand "empty?") (("" (expand "member") (("" (expand "descending?") (("" (expand "converse") (("" (skolem 1 "seqTerms") (("" (inst-cp -2 0) (("" (assert) (("" (case "NOT terminating?(reduction?(E))(seqTerms(0))") (("1" (use "non_terminating_has_mnt") (("1" (skeep) (("1" (hide -3 -4 1) (("1" (lemma "recursion_theorem[[dep_pair_alt(E), Sub]]") (("1" (name-replace "mnt1" "subtermOF(seqTerms(0),p)") (("1" (inst -1 "{(dp: dep_pair_alt(E), sigma: Sub) | minimal_non_terminating?(E)(subtermOF(ext(sigma)(rhs(dp`1)), dp`2))}" "dp_and_sub_from_first_root_reduction(E)(mnt1)" "next_dp_and_subs(E)") (("1" (skolem -1 "u1") (("1" (flatten) (("1" (expand "dp_termination_alt?") (("1" (inst -4 "LAMBDA(i:nat): u1(i)`1" "LAMBDA(j:nat): u1(j)`2") (("1" (expand "infinite_dep_chain?") (("1" (skeep) (("1" (inst -2 "i") (("1" (typepred "u1(i)") (("1" (typepred "u1(i+1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "member") (("2" (expand "dp_and_sub_from_first_root_reduction") (("2" (typepred "choose
                                            ({(sigma: Sub),
                                              (e: rewrite_rule),
                                              (p: positions?(rhs(e)))
                                              |
                                              member(e, E)
                                              AND
                                              ext(sigma)(lhs(e))
                                              =
                                              mnt_to_nt_by_root_reduction
                                              (E)(mnt1)`1
                                              AND
                                              minimal_non_terminating?
                                              (E)
                                              (subtermOF
                                               (ext(sigma)(rhs(e)), p))})") (("1" (propax) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (expand "dep_pair_alt?") (("3" (flatten) (("3" (assert) (("3" (use "ext_preserv_pos") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "dp_and_sub_from_first_root_reduction(E)(subtermOF(seqTerms(0), p))") nil nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -4) (("2" (expand "terminating?") (("2" (inst 1 "seqTerms") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (no_infinite_descending_sequence formula-decl nil well_foundedness orders) (reduction? const-decl "bool" reduction nil) (member const-decl "bool" sets nil) (terminating? const-decl "bool" noetherian nil) (recursion_theorem formula-decl nil seq_recursion_theorem nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (ext def-decl "term" substitution nil) (rhs const-decl "term" rewrite_rules nil) (lhs const-decl "term" rewrite_rules nil) (dep_pair type-eq-decl nil dependency_pairs nil) (dep_pair? const-decl "bool" dependency_pairs nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (ext_preserv_pos formula-decl nil substitution nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (descending? const-decl "bool" monotone_sequences orders) (empty? const-decl "bool" sets nil) (noetherian? const-decl "bool" noetherian nil)) nil)))
