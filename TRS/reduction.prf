(reduction
 (IMP_rewrite_rules_TCC1 0
  (IMP_rewrite_rules_TCC1-1 nil 3763213849
   ("" (rewrite "var_countable") nil nil)
   ((var_countable formula-decl nil reduction nil)) nil))
 (closure_close_subs 0
  (closure_close_subs-1 nil 3433013930
   ("" (skeep)
    (("" (expand "close_subs?")
      (("" (split)
        (("1" (skeep)
          (("1" (expand "TC")
            (("1" (expand "IUnion")
              (("1" (skolem * "j")
                (("1" (generalize "s" "s" :fnums (-1 1))
                  (("1" (generalize "t" "t" :fnums 1)
                    (("1" (generalize "j" "n" :fnums 1)
                      (("1" (induct "n")
                        (("1" (assert) nil nil) ("2" (assert) nil nil)
                         ("3" (skosimp*)
                          (("3" (prop)
                            (("1" (rewrite "iterate_add_one")
                              (("1"
                                (expand "o")
                                (("1"
                                  (skosimp*)
                                  (("1"
                                    (inst -1 "t!1" "y!1")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (skosimp*)
                                        (("1"
                                          (inst -5 "s!1" "y!1" "sigma")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (inst 1 "i!1 + 1")
                                              (("1"
                                                (rewrite
                                                 "iterate_add_one"
                                                 1)
                                                (("1"
                                                  (expand "o")
                                                  (("1"
                                                    (inst
                                                     1
                                                     "ext(sigma)(y!1)")
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (typepred "j!1")
                              (("2"
                                (case "j!1 = 0")
                                (("1"
                                  (hide-all-but (-1 -4 -5 2))
                                  (("1"
                                    (replaces -1)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (rewrite "iterate_1")
                                        (("1"
                                          (inst -2 "s!1" "t!1" "sigma")
                                          (("1"
                                            (inst 1 "1")
                                            (("1"
                                              (rewrite "iterate_1")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (expand "RTC")
            (("2" (expand "IUnion")
              (("2" (skolem * "j")
                (("2" (generalize "s" "s" :fnums (-1 1))
                  (("2" (generalize "t" "t" :fnums 1)
                    (("2" (generalize "j" "n" :fnums 1)
                      (("2" (induct "n")
                        (("1" (skolem * ("s1" "t1"))
                          (("1" (flatten)
                            (("1" (inst 1 "0")
                              (("1"
                                (hide -2)
                                (("1"
                                  (expand "iterate")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skosimp*)
                          (("2" (rewrite "iterate_add_one")
                            (("2" (expand "o")
                              (("2"
                                (skosimp*)
                                (("2"
                                  (inst -1 "t!1" "y!1")
                                  (("2"
                                    (assert)
                                    (("2"
                                      (skosimp*)
                                      (("2"
                                        (inst -4 "s!1" "y!1" "sigma")
                                        (("2"
                                          (assert)
                                          (("2"
                                            (inst 1 "i!1 + 1")
                                            (("2"
                                              (rewrite
                                               "iterate_add_one"
                                               1)
                                              (("2"
                                                (expand "o")
                                                (("2"
                                                  (inst
                                                   1
                                                   "ext(sigma)(y!1)")
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (skeep)
          (("3" (expand "EC")
            (("3" (expand "RTC")
              (("3" (expand "IUnion")
                (("3" (skolem * "j")
                  (("3" (generalize "s" "s" :fnums (-1 1))
                    (("3" (generalize "t" "t" :fnums 1)
                      (("3" (generalize "j" "n" :fnums 1)
                        (("3" (induct "n")
                          (("1" (skolem * ("s1" "t1"))
                            (("1" (flatten)
                              (("1"
                                (hide -2)
                                (("1"
                                  (inst 1 "0")
                                  (("1"
                                    (expand "iterate")
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (skosimp*)
                            (("2" (rewrite "iterate_add_one")
                              (("2"
                                (expand "o")
                                (("2"
                                  (skosimp*)
                                  (("2"
                                    (inst -1 "t!1" "y!1")
                                    (("2"
                                      (assert)
                                      (("2"
                                        (skosimp*)
                                        (("2"
                                          (expand "SC" -2)
                                          (("2"
                                            (expand* "union" "member")
                                            (("2"
                                              (prop)
                                              (("1"
                                                (inst
                                                 -4
                                                 "s!1"
                                                 "y!1"
                                                 "sigma")
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (lemma
                                                     "R_subset_SC")
                                                    (("1"
                                                      (inst?)
                                                      (("1"
                                                        (expand
                                                         "subset?")
                                                        (("1"
                                                          (inst
                                                           -1
                                                           "(ext(sigma)(s!1), ext(sigma)(y!1))")
                                                          (("1"
                                                            (expand
                                                             "member")
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (inst
                                                                 1
                                                                 "i!1 + 1")
                                                                (("1"
                                                                  (rewrite
                                                                   "iterate_add_one")
                                                                  (("1"
                                                                    (expand
                                                                     "o")
                                                                    (("1"
                                                                      (inst
                                                                       1
                                                                       "ext(sigma)(y!1)")
                                                                      (("1"
                                                                        (assert)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (expand "converse")
                                                (("2"
                                                  (inst 1 "i!1 + 1")
                                                  (("2"
                                                    (rewrite
                                                     "iterate_add_one")
                                                    (("2"
                                                      (expand "o")
                                                      (("2"
                                                        (inst
                                                         1
                                                         "ext(sigma)(y!1)")
                                                        (("2"
                                                          (assert)
                                                          (("2"
                                                            (expand
                                                             "SC"
                                                             1)
                                                            (("2"
                                                              (expand*
                                                               "union"
                                                               "member"
                                                               "converse")
                                                              (("2"
                                                                (prop)
                                                                (("2"
                                                                  (inst
                                                                   -4
                                                                   "y!1"
                                                                   "s!1"
                                                                   "sigma")
                                                                  (("2"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((close_subs? const-decl "bool" reduction nil)
    (subset? const-decl "bool" sets nil)
    (R_subset_SC formula-decl nil relations_closure nil)
    (converse const-decl "pred[[T2, T1]]" relation_defs nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (symmetric? const-decl "bool" relations nil)
    (symmetric type-eq-decl nil relations_closure nil)
    (SC const-decl "symmetric" relations_closure nil)
    (EC const-decl "equivalence" relations_closure nil)
    (RTC const-decl "reflexive_transitive" relations_closure nil)
    (IUnion const-decl "set[T]" indexed_sets nil)
    (ext def-decl "term" substitution nil)
    (Sub type-eq-decl nil substitution nil)
    (Sub? const-decl "bool" substitution nil)
    (V const-decl "set[term]" variables_term nil)
    (set type-eq-decl nil sets nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (iterate def-decl "pred[[T, T]]" relation_iterate "orders/")
    (pred type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (iterate_1 formula-decl nil relation_iterate "orders/")
    (TRUE const-decl "bool" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (iterate_add_one formula-decl nil relation_iterate "orders/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (O const-decl "bool" relation_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (TC const-decl "transitive" relations_closure nil))
   shostak))
 (reduction_is_subs_op 0
  (reduction_is_subs_op-1 nil 3433014142
   ("" (skeep)
    (("" (split)
      (("1" (expand "close_subs?")
        (("1" (skosimp*)
          (("1" (expand "reduction?")
            (("1" (skosimp*)
              (("1" (inst 1 "e!1" "comp(sigma!1, sigma!2)" "p!1")
                (("1" (split)
                  (("1" (rewrite "ext_o")
                    (("1" (expand "o")
                      (("1" (rewrite "subterm_ext_commute")
                        (("1" (assert) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (rewrite "ext_o")
                    (("2" (expand "o")
                      (("2" (replace -2)
                        (("2" (lemma "ext_replace_ext")
                          (("2"
                            (inst -1 "p!1" "s!1" "sigma!1"
                             "ext(sigma!2)(rhs(e!1))")
                            (("2" (typepred "p!1")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (rewrite "ext_preserv_pos") nil nil)
                 ("3" (rewrite "subs_o") nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "comp_op?")
        (("2" (skosimp*)
          (("2" (expand "reduction?")
            (("2" (skosimp*)
              (("2" (inst 1 "e!1" "sigma!1" "add_first(i!1 + 1, p!1)")
                (("1" (split)
                  (("1" (expand "subtermOF" 1)
                    (("1" (lift-if)
                      (("1" (prop)
                        (("1" (grind) nil nil)
                         ("2" (expand "finseq_appl")
                          (("2"
                            (case-replace
                             "first(add_first(1 + i!1, p!1)) - 1 = i!1"
                             :hide? t)
                            (("1"
                              (case-replace
                               "rest(add_first(1 + i!1, p!1)) = p!1"
                               :hide? t)
                              (("1"
                                (hide-all-but 1)
                                (("1"
                                  (rewrite "rest_add_first")
                                  nil
                                  nil))
                                nil))
                              nil)
                             ("2" (hide-all-but 1)
                              (("2"
                                (rewrite "first_add")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand "finseq_appl")
                    (("2" (decompose-equality)
                      (("1" (grind) nil nil)
                       ("2" (expand "replace")
                        (("2" (expand "finseq_appl")
                          (("2" (decompose-equality)
                            (("1" (grind) nil nil)
                             ("2" (decompose-equality)
                              (("2"
                                (lift-if)
                                (("2"
                                  (prop)
                                  (("1" (grind) nil nil)
                                   ("2" (grind) nil nil)
                                   ("3" (grind) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("3" (grind) nil nil))
                            nil))
                          nil))
                        nil)
                       ("3" (grind) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide (-1 -2))
                  (("2" (typepred "p!1")
                    (("2" (expand "finseq_appl")
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subs_o formula-decl nil substitution nil)
    (ext_preserv_pos formula-decl nil substitution nil)
    (O const-decl "T3" function_props nil)
    (subterm_ext_commute formula-decl nil substitution nil)
    (ext_o formula-decl nil substitution nil)
    (ext_replace_ext formula-decl nil substitution nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rhs const-decl "term" rewrite_rules nil)
    (member const-decl "bool" sets nil)
    (rewrite_rule type-eq-decl nil rewrite_rules nil)
    (rewrite_rule? const-decl "bool" rewrite_rules nil)
    (below type-eq-decl nil nat_types nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (position type-eq-decl nil positions nil)
    (positions type-eq-decl nil positions nil)
    (positionsOF def-decl "positions" positions nil)
    (ext def-decl "term" substitution nil)
    (s!1 skolem-const-decl "term[variable, symbol, arity]" reduction
     nil)
    (positions? type-eq-decl nil positions nil)
    (p!1 skolem-const-decl "positions?[variable, symbol, arity](s!1)"
     reduction nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil)
    (V const-decl "set[term]" variables_term nil)
    (Sub? const-decl "bool" substitution nil)
    (Sub type-eq-decl nil substitution nil)
    (comp const-decl "term" substitution nil)
    (sigma!1 skolem-const-decl "Sub[variable, symbol, arity]" reduction
     nil)
    (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" reduction
     nil)
    (reduction? const-decl "bool" reduction nil)
    (close_subs? const-decl "bool" reduction nil)
    (<= const-decl "bool" reals nil)
    (upto? nonempty-type-eq-decl nil IUnion_extra nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (union const-decl "set" sets nil)
    (IUnion const-decl "set[T]" indexed_sets nil)
    (catenate const-decl "positions" positions nil)
    (only_empty_seq const-decl "positions" positions nil)
    (first_add formula-decl nil seq_extras "structures/")
    (rest const-decl "finseq" seq_extras "structures/")
    (rest_add_first formula-decl nil seq_extras "structures/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (not_empty_seq type-eq-decl nil seq_extras "structures/")
    (first const-decl "T" seq_extras "structures/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (insert? const-decl "finseq" seq_extras "structures/")
    (subtermOF def-decl "term" subterm nil)
    (e!1 skolem-const-decl "{e | member(e, E)}" reduction nil)
    (E skolem-const-decl "set[rewrite_rule]" reduction nil)
    (sigma!1 skolem-const-decl "Sub[variable, symbol, arity]" reduction
     nil)
    (replaceTerm def-decl "term" replacement nil)
    (replace const-decl "finseq" seq_extras "structures/")
    (term_app_extensionality formula-decl nil term_adt nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^ const-decl "finseq" finite_sequences nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (lhs const-decl "term" rewrite_rules nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (args adt-accessor-decl
          "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]"
          term_adt nil)
    (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (app? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (app adt-constructor-decl
     "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil)
    (n!1 skolem-const-decl "nat" reduction nil)
    (arity_eq type-eq-decl nil compatibility nil)
    (f!1 skolem-const-decl "arity_eq[variable, symbol, arity](n!1)"
     reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (fs_len type-eq-decl nil seq_extras "structures/")
    (st1!1 skolem-const-decl
     "fs_len[term[variable, symbol, arity]](n!1)" reduction nil)
    (add_first const-decl "finseq" seq_extras "structures/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (i!1 skolem-const-decl "below[n!1]" reduction nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (p!1 skolem-const-decl "positions?
    [variable, symbol, arity](finseq_appl[term[variable, symbol, arity]]
                                  (st1!1)(i!1))" reduction nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (comp_op? const-decl "bool" compatibility nil))
   shostak))
 (lhs_reduces_to_rhs 0
  (lhs_reduces_to_rhs-1 nil 3433014645
   ("" (skeep)
    (("" (expand "reduction?")
      (("" (inst 1 "e" "identity" "empty_seq")
        (("1" (expand* "subtermOF" "replaceTerm")
          (("1" (lift-if)
            (("1" (rewrite "ext_iden")
              (("1" (rewrite "ext_iden")
                (("1" (rewrite "empty_0") nil nil)) nil))
              nil))
            nil))
          nil)
         ("2" (expand "positionsOF")
          (("2" (lift-if) (("2" (grind) nil nil)) nil)) nil)
         ("3" (rewrite "iden_subs") nil nil))
        nil))
      nil))
    nil)
   ((reduction? const-decl "bool" reduction nil)
    (iden_subs formula-decl nil substitution nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (only_empty_seq const-decl "positions" positions nil)
    (union const-decl "set" sets nil)
    (IUnion const-decl "set[T]" indexed_sets nil)
    (catenate const-decl "positions" positions nil)
    (add_first const-decl "finseq" seq_extras "structures/")
    (insert? const-decl "finseq" seq_extras "structures/")
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (replaceTerm def-decl "term" replacement nil)
    (subtermOF def-decl "term" subterm nil)
    (ext_iden formula-decl nil substitution nil)
    (empty_0 formula-decl nil seq_extras "structures/")
    (rhs const-decl "term" rewrite_rules nil)
    (positions? type-eq-decl nil positions nil)
    (Sub type-eq-decl nil substitution nil)
    (below type-eq-decl nil nat_types nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (position type-eq-decl nil positions nil)
    (positions type-eq-decl nil positions nil)
    (positionsOF def-decl "positions" positions nil)
    (rewrite_rule? const-decl "bool" rewrite_rules nil)
    (rewrite_rule type-eq-decl nil rewrite_rules nil)
    (lhs const-decl "term" rewrite_rules nil)
    (member const-decl "bool" sets nil)
    (E skolem-const-decl "set[rewrite_rule]" reduction nil)
    (e skolem-const-decl "{e | member(e, E)}" reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil)
    (V const-decl "set[term]" variables_term nil)
    (Sub? const-decl "bool" substitution nil)
    (bijective? const-decl "bool" functions nil)
    (identity const-decl "(bijective?[T, T])" identity nil))
   shostak))
 (reducible_is_app 0
  (reducible_is_app-1 nil 3757322088
   ("" (skeep)
    (("" (expand "reducible?")
      (("" (skeep)
        (("" (expand "reduction?")
          (("" (skeep)
            (("" (case-replace "p=empty_seq")
              (("1" (hide -3)
                (("1" (rewrite "subterm_empty_seq")
                  (("1" (typepred "e")
                    (("1" (expand "rewrite_rule?")
                      (("1" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (expand "replaceTerm")
                (("2" (rewrite "empty_0")
                  (("2" (assert)
                    (("2" (decompose-equality -2)
                      (("2" (hide -2)
                        (("2" (typepred "p") (("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((reducible? const-decl "bool" ars_terminology nil)
    (reduction? const-decl "bool" reduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (position type-eq-decl nil positions nil)
    (term type-decl nil term_adt nil)
    (positions type-eq-decl nil positions nil)
    (positionsOF def-decl "positions" positions nil)
    (positions? type-eq-decl nil positions nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (subterm_empty_seq formula-decl nil subterm nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (Vars const-decl "set[(V)]" subterm nil)
    (subset? const-decl "bool" sets nil)
    (lhs const-decl "term" rewrite_rules nil)
    (ext def-decl "term" substitution nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (V const-decl "set[term]" variables_term nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (rewrite_rule type-eq-decl nil rewrite_rules nil)
    (rewrite_rule? const-decl "bool" rewrite_rules nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (empty_0 formula-decl nil seq_extras "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (app? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (app adt-constructor-decl
     "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil)
    (replace const-decl "finseq" seq_extras "structures/")
    (args adt-accessor-decl
          "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]"
          term_adt nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (not_empty_seq type-eq-decl nil seq_extras "structures/")
    (first const-decl "T" seq_extras "structures/")
    (Sub? const-decl "bool" substitution nil)
    (Sub type-eq-decl nil substitution nil)
    (rhs const-decl "term" rewrite_rules nil)
    (rest const-decl "finseq" seq_extras "structures/")
    (only_empty_seq const-decl "positions" positions nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (replaceTerm def-decl "term" replacement nil))
   nil))
 (non_root_subset_reduction 0
  (non_root_subset_reduction-1 nil 3756717181
   ("" (skeep)
    (("" (expand "subset?")
      (("" (skeep)
        (("" (expand "member")
          (("" (expand "non_root_reduction?")
            (("" (expand "reduction?")
              (("" (expand "reduction_fix?")
                (("" (skeep*)
                  (("" (inst?) (("" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (reduction? const-decl "bool" reduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (positions? type-eq-decl nil positions nil)
    (positionsOF def-decl "positions" positions nil)
    (positions type-eq-decl nil positions nil)
    (position type-eq-decl nil positions nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil nat_types nil)
    (Sub type-eq-decl nil substitution nil)
    (Sub? const-decl "bool" substitution nil)
    (V const-decl "set[term]" variables_term nil)
    (set type-eq-decl nil sets nil)
    (rewrite_rule type-eq-decl nil rewrite_rules nil)
    (rewrite_rule? const-decl "bool" rewrite_rules nil)
    (term type-decl nil term_adt nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (reduction_fix? const-decl "bool" reduction nil)
    (non_root_reduction? const-decl "bool" reduction nil))
   nil))
 (non_root_rtc_preserves_root_symbol 0
  (non_root_rtc_preserves_root_symbol-1 nil 3760177562
   ("" (skeep)
    (("" (expand "RTC")
      (("" (expand "IUnion")
        (("" (skeep)
          (("" (generalize "i" "i" :fnums (-1 1))
            (("" (generalize "s" "s" :fnums 1)
              (("" (generalize "t" "t" :fnums 1)
                (("" (induct "i")
                  (("1" (grind) nil nil)
                   ("2" (skeep)
                    (("2" (skeep)
                      (("2" (expand "iterate" -2)
                        (("2" (expand "o")
                          (("2" (skeep)
                            (("2" (inst -1 "y" "s!1")
                              (("2"
                                (assert)
                                (("2"
                                  (flatten)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (hide -3)
                                      (("2"
                                        (expand "non_root_reduction?")
                                        (("2"
                                          (skeep :preds? t)
                                          (("2"
                                            (expand "reduction_fix?")
                                            (("2"
                                              (skeep)
                                              (("2"
                                                (expand "replaceTerm")
                                                (("2"
                                                  (use
                                                   "empty_0[posnat]")
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (expand
                                                       "finseq_appl")
                                                      (("2"
                                                        (decompose-equality
                                                         -5)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((RTC const-decl "reflexive_transitive" relations_closure nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (O const-decl "bool" relation_props nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (empty_0 formula-decl nil seq_extras "structures/")
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (position type-eq-decl nil positions nil)
    (positions type-eq-decl nil positions nil)
    (positionsOF def-decl "positions" positions nil)
    (positions? type-eq-decl nil positions nil)
    (< const-decl "bool" reals nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (rest const-decl "finseq" seq_extras "structures/")
    (member const-decl "bool" sets nil)
    (rhs const-decl "term" rewrite_rules nil)
    (ext def-decl "term" substitution nil)
    (Sub type-eq-decl nil substitution nil)
    (Sub? const-decl "bool" substitution nil)
    (V const-decl "set[term]" variables_term nil)
    (first const-decl "T" seq_extras "structures/")
    (not_empty_seq type-eq-decl nil seq_extras "structures/")
    (/= const-decl "boolean" notequal nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (args adt-accessor-decl
          "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]"
          term_adt nil)
    (replace const-decl "finseq" seq_extras "structures/")
    (app adt-constructor-decl
     "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (replaceTerm def-decl "term" replacement nil)
    (reduction_fix? const-decl "bool" reduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (term type-decl nil term_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (iterate def-decl "pred[[T, T]]" relation_iterate "orders/")
    (rewrite_rule? const-decl "bool" rewrite_rules nil)
    (rewrite_rule type-eq-decl nil rewrite_rules nil)
    (set type-eq-decl nil sets nil)
    (non_root_reduction? const-decl "bool" reduction nil)
    (app? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil)
    (IUnion const-decl "set[T]" indexed_sets nil))
   nil))
 (non_root_rtc_preserves_pos_args 0
  (non_root_rtc_preserves_pos_args-1 nil 3763211340
   ("" (skeep :preds? t)
    (("" (use "non_root_rtc_preserves_root_symbol")
      (("" (assert)
        (("" (lemma "equal_symbol_equal_length_arg")
          (("" (inst -1 "s" "t" "f(s)" "f(t)" "args(s)" "args(t)")
            (("" (flatten)
              (("" (prop)
                (("1" (lemma "positions_of_arg")
                  (("1" (inst -1 "t" "k - 1")
                    (("1" (assert) nil nil)
                     ("2" (replace -1 1 rl)
                      (("2" (hide -1 -2 -3 -7 2)
                        (("2" (expand "#")
                          (("2" (grind)
                            (("2" (decompose-equality -7)
                              (("2" (inst -1 "0") nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (decompose-equality) nil nil)
                 ("3" (decompose-equality) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((non_root_rtc_preserves_root_symbol formula-decl nil reduction nil)
    (app? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (set type-eq-decl nil sets nil)
    (rewrite_rule type-eq-decl nil rewrite_rules nil)
    (rewrite_rule? const-decl "bool" rewrite_rules nil)
    (term type-decl nil term_adt nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (equal_symbol_equal_length_arg formula-decl nil positions nil)
    (term_app_extensionality formula-decl nil term_adt nil)
    (app adt-constructor-decl
     "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil)
    (positions_of_arg formula-decl nil positions nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (upto? nonempty-type-eq-decl nil IUnion_extra nil)
    (<= const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (only_empty_seq const-decl "positions" positions nil)
    (member const-decl "bool" sets nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (insert? const-decl "finseq" seq_extras "structures/")
    (add_first const-decl "finseq" seq_extras "structures/")
    (catenate const-decl "positions" positions nil)
    (IUnion const-decl "set[T]" indexed_sets nil)
    (union const-decl "set" sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (position type-eq-decl nil positions nil)
    (positions type-eq-decl nil positions nil)
    (positionsOF def-decl "positions" positions nil)
    (s skolem-const-decl "{s: term | app?(s)}" reduction nil)
    (|#| const-decl "finite_sequence[T]" set2seq "structures/")
    (k skolem-const-decl "{k: posnat | positionsOF(s)( #(k))}"
     reduction nil)
    (t skolem-const-decl "term[variable, symbol, arity]" reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (args adt-accessor-decl
          "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]"
          term_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (arg_preservation_in_finite_rtc_TCC1 0
  (arg_preservation_in_finite_rtc_TCC1-1 nil 3763211466
   ("" (skeep :preds? t)
    (("" (use "empty_0[term]") (("" (assert) nil nil)) nil)) nil)
   ((empty_0 formula-decl nil seq_extras "structures/")
    (variable formal-nonempty-type-decl nil reduction nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (term type-decl nil term_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (arg_preservation_in_finite_rtc_TCC2 0
  (arg_preservation_in_finite_rtc_TCC2-1 nil 3763211466
   ("" (skeep :preds? t)
    (("" (use "empty_0[term]") (("" (assert) nil nil)) nil)) nil)
   ((empty_0 formula-decl nil seq_extras "structures/")
    (variable formal-nonempty-type-decl nil reduction nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (term type-decl nil term_adt nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (< const-decl "bool" reals nil)
    (app? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (arg_preservation_in_finite_rtc_TCC3 0
  (arg_preservation_in_finite_rtc_TCC3-1 nil 3763211466
   ("" (subtype-tcc) nil nil)
   ((nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (term type-decl nil term_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (app? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (position type-eq-decl nil positions nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (arg_preservation_in_finite_rtc_TCC4 0
  (arg_preservation_in_finite_rtc_TCC4-1 nil 3763211466
   ("" (skeep :preds? t)
    (("" (expand "finseq_appl")
      (("" (use "empty_0[term]") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (app? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (< const-decl "bool" reals nil) (term type-decl nil term_adt nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (empty_0 formula-decl nil seq_extras "structures/"))
   nil))
 (arg_preservation_in_finite_rtc_TCC5 0
  (arg_preservation_in_finite_rtc_TCC5-1 nil 3763211466
   ("" (subtype-tcc) nil nil) nil nil))
 (arg_preservation_in_finite_rtc_TCC6 0
  (arg_preservation_in_finite_rtc_TCC6-1 nil 3763211466
   ("" (subtype-tcc) nil nil) nil nil))
 (arg_preservation_in_finite_rtc_TCC7 0
  (arg_preservation_in_finite_rtc_TCC7-1 nil 3763211466
   ("" (skeep* :preds? t)
    (("" (expand "finseq_appl")
      (("" (hide-all-but (-7 2))
        (("" (use "empty_0[posnat]") (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (empty_0 formula-decl nil seq_extras "structures/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (app? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (term type-decl nil term_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (position type-eq-decl nil positions nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (arg_preservation_in_finite_rtc_TCC8 0
  (arg_preservation_in_finite_rtc_TCC8-1 nil 3763211466
   ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (first const-decl "T" seq_extras "structures/")
    (empty_seq const-decl "finseq" finite_sequences nil))
   nil))
 (arg_preservation_in_finite_rtc_TCC9 0
  (arg_preservation_in_finite_rtc_TCC9-1 nil 3763211466
   ("" (skeep* :preds? t)
    (("" (expand "finseq_appl")
      (("" (use "positions_of_arg")
        (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
      nil))
    nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (l skolem-const-decl "{l: posnat |
         l <=
          length(args(finseq_appl[term[variable, symbol, arity]](seqt)(0)))}"
     reduction nil)
    (seqt skolem-const-decl "{seqt: finseq[term] |
         NOT seqt = empty_seq AND
          app?(finseq_appl[term[variable, symbol, arity]](seqt)(0))}"
     reduction nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (args adt-accessor-decl
          "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]"
          term_adt nil)
    (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (app? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (term type-decl nil term_adt nil) (<= const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (positions_of_arg formula-decl nil positions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (arg_preservation_in_finite_rtc_TCC10 0
  (arg_preservation_in_finite_rtc_TCC10-1 nil 3763211466
   ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (first const-decl "T" seq_extras "structures/")
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (lhs const-decl "term" rewrite_rules nil)
    (rhs const-decl "term" rewrite_rules nil)
    (reduction_fix? const-decl "bool" reduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil))
 (arg_preservation_in_finite_rtc_TCC11 0
  (arg_preservation_in_finite_rtc_TCC11-1 nil 3763211466
   ("" (auto-rewrite "finseq_appl")
    (("" (assert)
      (("" (skeep* :preds? t)
        (("" (assert)
          (("" (case-replace "n1 = 0")
            (("1" (use "positions_of_arg") (("1" (assert) nil nil))
              nil)
             ("2" (case "positionsOF(seqt`seq(0))( #[posnat](l))")
              (("1" (lemma "non_root_rtc_preserves_pos_args")
                (("1" (inst-cp -1 "E" "seqt(0)" "l" "seqt(n1 - 1)")
                  (("1" (expand "finseq_appl")
                    (("1" (prop)
                      (("1" (inst -2 "E" "seqt(n1 - 1)" "l" "seqt(n1)")
                        (("1" (expand "finseq_appl")
                          (("1" (hide-all-but (-8 1 2))
                            (("1" (lemma "finseq_to_RTC")
                              (("1"
                                (expand "finseq_appl")
                                (("1"
                                  (inst?)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (hide 2)
                                      (("1"
                                        (skeep)
                                        (("1"
                                          (inst?)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (expand
                                               "non_root_reduction?")
                                              (("1"
                                                (inst?)
                                                (("1"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (inst? -8)
                          (("1" (flatten)
                            (("1" (hide-all-but (-9 1 2))
                              (("1"
                                (lemma "reducible_is_app")
                                (("1"
                                  (inst -1 "E" "seqt(n1 - 1)")
                                  (("1"
                                    (expand "finseq_appl")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand "reducible?")
                                        (("1"
                                          (inst 1 "seqt(n1)")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (expand "reduction_fix?")
                                              (("1"
                                                (expand "reduction?")
                                                (("1"
                                                  (skeep)
                                                  (("1"
                                                    (inst?)
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert) nil nil))
                          nil)
                         ("3" (assert) nil nil))
                        nil)
                       ("2" (lemma "finseq_to_RTC")
                        (("2" (expand "finseq_appl")
                          (("2" (inst? -1)
                            (("1" (assert)
                              (("1"
                                (hide-all-but (-8 1))
                                (("1"
                                  (skeep)
                                  (("1"
                                    (inst?)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (expand "non_root_reduction?")
                                        (("1"
                                          (inst?)
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil))
                nil)
               ("2" (use "positions_of_arg") (("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (|#| const-decl "finite_sequence[T]" set2seq "structures/")
    (positionsOF def-decl "positions" positions nil)
    (positions type-eq-decl nil positions nil)
    (seqt skolem-const-decl "{seqt: finseq[term] |
         NOT seqt = empty_seq AND
          app?(finseq_appl[term[variable, symbol, arity]](seqt)(0))}"
     reduction nil)
    (l skolem-const-decl "{l: posnat |
         l <=
          length(args(finseq_appl[term[variable, symbol, arity]](seqt)(0)))}"
     reduction nil)
    (seqp skolem-const-decl
     "{seqp: finseq[position] | length(seqt) = length(seqp)}" reduction
     nil)
    (n1 skolem-const-decl "below[length(seqp)]" reduction nil)
    (set type-eq-decl nil sets nil)
    (rewrite_rule type-eq-decl nil rewrite_rules nil)
    (rewrite_rule? const-decl "bool" rewrite_rules nil)
    (reduction_fix? const-decl "bool" reduction nil)
    (member const-decl "bool" sets nil)
    (V const-decl "set[term]" variables_term nil)
    (Sub? const-decl "bool" substitution nil)
    (Sub type-eq-decl nil substitution nil)
    (reduction? const-decl "bool" reduction nil)
    (reducible? const-decl "bool" ars_terminology nil)
    (reducible_is_app formula-decl nil reduction nil)
    (finseq_to_RTC formula-decl nil relations_closure nil)
    (non_root_reduction? const-decl "bool" reduction nil)
    (pred type-eq-decl nil defined_types nil)
    (k skolem-const-decl "{k: nat | k >= n1 - 1 AND k < n1}" reduction
     nil)
    (positions? type-eq-decl nil positions nil)
    (k skolem-const-decl "{k: nat | k < n1 - 1}" reduction nil)
    (non_root_rtc_preserves_pos_args formula-decl nil reduction nil)
    (positions_of_arg formula-decl nil positions nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil)
    (args adt-accessor-decl
          "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]"
          term_adt nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (app? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (term type-decl nil term_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (position type-eq-decl nil positions nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (arg_preservation_in_finite_rtc 0
  (arg_preservation_in_finite_rtc-1 nil 3763211558
   ("" (auto-rewrite "finseq_appl")
    (("" (assert)
      (("" (skeep)
        (("" (skeep)
          (("" (skeep :preds? t)
            (("" (skolem 1 "l1")
              (("" (typepred "l1")
                (("" (prop)
                  ((""
                    (case "positionsOF[variable, symbol, arity](seqt`seq(0))( #[posnat](l1))")
                    (("1"
                      (case " FORALL (n: below[length(seqp)]):
                                                            positionsOF[variable, symbol, arity](seqt`seq(n))( #[posnat](l1))")
                      (("1" (induct "n")
                        (("1" (skeep)
                          (("1" (assert)
                            (("1" (replaces -2)
                              (("1"
                                (inst -7 "jb")
                                (("1"
                                  (flatten)
                                  (("1"
                                    (expand "reduction_fix?")
                                    (("1"
                                      (skeep)
                                      (("1"
                                        (use "replace_persistence")
                                        (("1"
                                          (assert)
                                          (("1"
                                            (prop)
                                            (("1"
                                              (use
                                               "non_root_rtc_preserves_pos_args")
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (lemma
                                                   "finseq_to_RTC")
                                                  (("1"
                                                    (inst
                                                     -1
                                                     "seqt"
                                                     "non_root_reduction?(E)"
                                                     "0"
                                                     "jb")
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (skeep)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (reveal -8)
                                                            (("1"
                                                              (inst
                                                               -1
                                                               "k")
                                                              (("1"
                                                                (flatten)
                                                                (("1"
                                                                  (hide-all-but
                                                                   (-1
                                                                    -2
                                                                    1
                                                                    2
                                                                    3))
                                                                  (("1"
                                                                    (expand
                                                                     "non_root_reduction?")
                                                                    (("1"
                                                                      (expand
                                                                       "reduction_fix?")
                                                                      (("1"
                                                                        (inst?
                                                                         3)
                                                                        (("1"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (hide-all-but (-1 1 3 4))
                                              (("2"
                                                (use "empty_0[posnat]")
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (expand "parallel")
                                                    (("2"
                                                      (expand "<=")
                                                      (("2"
                                                        (prop)
                                                        (("1"
                                                          (skeep)
                                                          (("1"
                                                            (expand
                                                             "#")
                                                            (("1"
                                                              (decompose-equality
                                                               -1)
                                                              (("1"
                                                                (decompose-equality
                                                                 -2)
                                                                (("1"
                                                                  (inst
                                                                   -1
                                                                   "0")
                                                                  (("1"
                                                                    (expand
                                                                     "o ")
                                                                    (("1"
                                                                      (expand
                                                                       "first")
                                                                      (("1"
                                                                        (expand
                                                                         "finseq_appl")
                                                                        (("1"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (skeep)
                                                          (("2"
                                                            (replaces
                                                             -1)
                                                            (("2"
                                                              (expand
                                                               "first")
                                                              (("2"
                                                                (expand
                                                                 "finseq_appl")
                                                                (("2"
                                                                  (expand
                                                                   "#")
                                                                  (("2"
                                                                    (expand
                                                                     "o ")
                                                                    (("2"
                                                                      (propax)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skeep) nil nil))
                        nil)
                       ("2" (skeep :preds? t)
                        (("2" (use "non_root_rtc_preserves_pos_args")
                          (("2" (assert)
                            (("2" (lemma "finseq_to_RTC")
                              (("2"
                                (assert)
                                (("2"
                                  (inst
                                   -1
                                   "seqt"
                                   "non_root_reduction?(E)"
                                   "0"
                                   "n")
                                  (("2"
                                    (assert)
                                    (("2"
                                      (skeep)
                                      (("2"
                                        (inst -6 "k")
                                        (("2"
                                          (flatten)
                                          (("2"
                                            (hide 2 3 6)
                                            (("2"
                                              (expand
                                               "non_root_reduction?")
                                              (("2"
                                                (expand
                                                 "reduction_fix?")
                                                (("2"
                                                  (inst?)
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (assert)
                      (("2" (rewrite "positions_of_arg") nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (positions_of_arg formula-decl nil positions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (TRUE const-decl "bool" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (<= const-decl "bool" positions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (O const-decl "finseq" finite_sequences nil)
    (first const-decl "T" seq_extras "structures/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (parallel const-decl "bool" positions nil)
    (empty_0 formula-decl nil seq_extras "structures/")
    (non_root_rtc_preserves_pos_args formula-decl nil reduction nil)
    (finseq_to_RTC formula-decl nil relations_closure nil)
    (k skolem-const-decl "{k: nat | k < jb}" reduction nil)
    (jb skolem-const-decl "below(length(seqp))" reduction nil)
    (non_root_reduction? const-decl "bool" reduction nil)
    (member const-decl "bool" sets nil)
    (rhs const-decl "term" rewrite_rules nil)
    (rewrite_rule type-eq-decl nil rewrite_rules nil)
    (rewrite_rule? const-decl "bool" rewrite_rules nil)
    (ext def-decl "term" substitution nil)
    (Sub type-eq-decl nil substitution nil)
    (Sub? const-decl "bool" substitution nil)
    (V const-decl "set[term]" variables_term nil)
    (set type-eq-decl nil sets nil)
    (replace_persistence formula-decl nil replacement nil)
    (reduction_fix? const-decl "bool" reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below_induction formula-decl nil bounded_nat_inductions nil)
    (subtermOF def-decl "term" subterm nil)
    (positions? type-eq-decl nil positions nil)
    (pred type-eq-decl nil defined_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (seqt skolem-const-decl "{seqt: finseq[term] |
         NOT seqt = empty_seq AND
          app?(finseq_appl[term[variable, symbol, arity]](seqt)(0))}"
     reduction nil)
    (seqp skolem-const-decl
     "{seqp: finseq[position] | length(seqt) = length(seqp)}" reduction
     nil)
    (l1 skolem-const-decl "{l: posnat |
         l <=
          length(args(finseq_appl[term[variable, symbol, arity]](seqt)(0)))}"
     reduction nil)
    (n skolem-const-decl "below[length(seqp)]" reduction nil)
    (k skolem-const-decl "{k: nat | k < n}" reduction nil)
    (position type-eq-decl nil positions nil)
    (positions type-eq-decl nil positions nil)
    (positionsOF def-decl "positions" positions nil)
    (|#| const-decl "finite_sequence[T]" set2seq "structures/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (term type-decl nil term_adt nil)
    (app? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil)
    (args adt-accessor-decl
          "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]"
          term_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (empty_seq const-decl "finseq" finite_sequences nil))
   nil))
 (non_root_rtc_rtc_of_argument_TCC1 0
  (non_root_rtc_rtc_of_argument_TCC1-1 nil 3763211650
   ("" (skeep* :preds? t)
    (("" (use "positions_of_arg") (("" (assert) nil nil)) nil)) nil)
   ((positions_of_arg formula-decl nil positions nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (<= const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (args adt-accessor-decl
          "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]"
          term_adt nil)
    (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (app? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (term type-decl nil term_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (non_root_rtc_rtc_of_argument_TCC2 0
  (non_root_rtc_rtc_of_argument_TCC2-1 nil 3763211650
   ("" (skeep* :preds? t)
    (("" (lemma "non_root_rtc_preserves_pos_args")
      (("" (inst -1 "E" "s" "k" "t")
        (("1" (assert) nil nil)
         ("2" (use "positions_of_arg") (("2" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((non_root_rtc_preserves_pos_args formula-decl nil reduction nil)
    (positions_of_arg formula-decl nil positions nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (set type-eq-decl nil sets nil)
    (rewrite_rule type-eq-decl nil rewrite_rules nil)
    (rewrite_rule? const-decl "bool" rewrite_rules nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (term type-decl nil term_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (position type-eq-decl nil positions nil)
    (positions type-eq-decl nil positions nil)
    (positionsOF def-decl "positions" positions nil)
    (app? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (s skolem-const-decl "{s: term | app?(s)}" reduction nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (|#| const-decl "finite_sequence[T]" set2seq "structures/")
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil)
    (args adt-accessor-decl
          "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]"
          term_adt nil)
    (k skolem-const-decl "{k: posnat | k <= length(args(s))}" reduction
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (non_root_rtc_rtc_of_argument 0
  (non_root_rtc_rtc_of_argument-1 nil 3763211731
   ("" (skeep :preds? t)
    (("" (expand "RTC")
      (("" (expand "IUnion")
        (("" (skeep -2)
          (("" (skeep :preds? t)
            (("" (generalize "s" "s" :fnums (-1 -2 -3 -4 1))
              (("1" (generalize "t" "t" :fnums (1))
                (("1" (generalize "i" "i" :fnums (1))
                  (("1" (induct "i")
                    (("1" (assert) nil nil)
                     ("2" (skeep* :preds? t)
                      (("2" (inst 1 "0")
                        (("2" (expand "iterate")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil)
                     ("3" (skeep* :preds? t)
                      (("3" (expand "iterate" -6)
                        (("3" (expand "o")
                          (("3" (skeep)
                            (("3" (inst -3 "y" "s!1")
                              (("3"
                                (assert)
                                (("3"
                                  (skeep)
                                  (("3"
                                    (expand "non_root_reduction?" -7)
                                    (("3"
                                      (skeep* :preds? t)
                                      (("3"
                                        (case "first(p) = k")
                                        (("1"
                                          (inst 2 "i!1+1")
                                          (("1"
                                            (expand "iterate" 2)
                                            (("1"
                                              (expand "o ")
                                              (("1"
                                                (inst
                                                 2
                                                 "subtermOF(y,  #(k))")
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (hide
                                                     -3
                                                     -4
                                                     -5
                                                     -6
                                                     -7
                                                     -8)
                                                    (("1"
                                                      (expand
                                                       "reduction?")
                                                      (("1"
                                                        (expand
                                                         "reduction_fix?")
                                                        (("1"
                                                          (case-replace
                                                           "#(k) o rest(p) = p")
                                                          (("1"
                                                            (use
                                                             "pos_subterm")
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (skeep)
                                                                (("1"
                                                                  (inst
                                                                   2
                                                                   "e"
                                                                   "sigma"
                                                                   "rest(p)")
                                                                  (("1"
                                                                    (assert)
                                                                    (("1"
                                                                      (use
                                                                       "replace_distributivity")
                                                                      (("1"
                                                                        (assert)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (hide-all-but
                                                             (-1 1 2))
                                                            (("2"
                                                              (lemma
                                                               "empty_0[posnat]")
                                                              (("2"
                                                                (inst
                                                                 -1
                                                                 "p")
                                                                (("2"
                                                                  (assert)
                                                                  (("2"
                                                                    (use
                                                                     "seq_first_rest_1[posnat]")
                                                                    (("2"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (inst 3 "i!1")
                                          (("2"
                                            (case-replace
                                             "subtermOF(y,  #(k)) = subtermOF(t!1,  #(k))")
                                            (("2"
                                              (hide 4)
                                              (("2"
                                                (expand
                                                 "reduction_fix?")
                                                (("2"
                                                  (skeep)
                                                  (("2"
                                                    (replaces -9)
                                                    (("2"
                                                      (use
                                                       "replace_persistence")
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (split)
                                                          (("1"
                                                            (lemma
                                                             "non_root_rtc_preserves_pos_args")
                                                            (("1"
                                                              (inst
                                                               -1
                                                               "E"
                                                               "s!1"
                                                               "k"
                                                               "y")
                                                              (("1"
                                                                (prop)
                                                                (("1"
                                                                  (expand
                                                                   "RTC")
                                                                  (("1"
                                                                    (expand
                                                                     "IUnion")
                                                                    (("1"
                                                                      (inst?)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (use
                                                                 "positions_of_arg")
                                                                (("2"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (use
                                                             "seq_first_rest_1[posnat]")
                                                            (("2"
                                                              (use
                                                               "empty_0[posnat]")
                                                              (("2"
                                                                (assert)
                                                                (("2"
                                                                  (hide-all-but
                                                                   (-1
                                                                    1
                                                                    2
                                                                    4
                                                                    5))
                                                                  (("2"
                                                                    (expand
                                                                     "parallel")
                                                                    (("2"
                                                                      (expand
                                                                       "<=")
                                                                      (("2"
                                                                        (prop)
                                                                        (("1"
                                                                          (skeep)
                                                                          (("1"
                                                                            (hide-all-but
                                                                             (-1
                                                                              1
                                                                              2))
                                                                            (("1"
                                                                              (expand
                                                                               "#")
                                                                              (("1"
                                                                                (decompose-equality
                                                                                 -1)
                                                                                (("1"
                                                                                  (decompose-equality
                                                                                   -2)
                                                                                  (("1"
                                                                                    (inst
                                                                                     -1
                                                                                     "0")
                                                                                    (("1"
                                                                                      (expand
                                                                                       "o"
                                                                                       -1)
                                                                                      (("1"
                                                                                        (expand
                                                                                         "first")
                                                                                        (("1"
                                                                                          (expand
                                                                                           "finseq_appl")
                                                                                          (("1"
                                                                                            (assert)
                                                                                            nil
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (skeep)
                                                                          (("2"
                                                                            (replace
                                                                             -1
                                                                             2)
                                                                            (("2"
                                                                              (expand
                                                                               "first")
                                                                              (("2"
                                                                                (expand
                                                                                 "finseq_appl")
                                                                                (("2"
                                                                                  (expand
                                                                                   "#")
                                                                                  (("2"
                                                                                    (expand
                                                                                     "o ")
                                                                                    (("2"
                                                                                      (propax)
                                                                                      nil
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("3"
                                          (use "empty_0[posnat]")
                                          (("3" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("4" (hide 2)
                      (("4" (skeep)
                        (("4" (lemma "non_root_rtc_preserves_pos_args")
                          (("4" (inst -1 "E" "s!1" "k" "t!1")
                            (("1" (prop)
                              (("1"
                                (expand "RTC")
                                (("1"
                                  (expand "IUnion")
                                  (("1" (inst?) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (use "positions_of_arg")
                              (("1" (assert) nil nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("5" (hide 2)
                      (("5" (skeep :preds? t)
                        (("5" (use "positions_of_arg")
                          (("1" (assert) nil nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 2)
                    (("2" (skeep :preds? t)
                      (("2" (lemma "non_root_rtc_preserves_pos_args")
                        (("2" (inst -1 "E" "s!1" "k" "t!1")
                          (("1" (prop)
                            (("1" (expand "RTC")
                              (("1"
                                (expand "IUnion")
                                (("1" (inst?) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (use "positions_of_arg")
                            (("1" (assert) nil nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (hide 2)
                    (("3" (skeep :preds? t)
                      (("3" (use "positions_of_arg")
                        (("1" (assert) nil nil) ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide 2)
                  (("2" (skeep :preds? t)
                    (("2" (lemma "non_root_rtc_preserves_pos_args")
                      (("2" (inst -1 "E" "s!1" "k" "t!1")
                        (("1" (prop)
                          (("1" (expand "RTC")
                            (("1" (expand "IUnion")
                              (("1" (inst?) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (use "positions_of_arg")
                          (("1" (assert) nil nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (hide 2)
                  (("3" (skeep)
                    (("3" (use "positions_of_arg")
                      (("1" (assert) nil nil) ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 2)
                (("2" (skeep :preds? t)
                  (("2" (lemma "non_root_rtc_preserves_pos_args")
                    (("2" (inst -1 "E" "s!1" "k" "t")
                      (("1" (prop)
                        (("1" (expand "RTC")
                          (("1" (expand "IUnion")
                            (("1" (inst?) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (use "positions_of_arg")
                        (("1" (assert) nil nil) ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (hide 2)
                (("3" (skeep :preds? t)
                  (("3" (use "positions_of_arg")
                    (("1" (assert) nil nil) ("2" (assert) nil nil))
                    nil))
                  nil))
                nil)
               ("4" (assert)
                (("4" (lemma "non_root_rtc_preserves_pos_args")
                  (("4" (inst -1 "E" "s" "k" "t")
                    (("1" (assert)
                      (("1" (expand "RTC")
                        (("1" (expand "IUnion")
                          (("1" (hide 3) (("1" (inst?) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (use "positions_of_arg")
                      (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("5" (assert)
                (("5" (use "positions_of_arg") (("5" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((RTC const-decl "reflexive_transitive" relations_closure nil)
    (|#| const-decl "finite_sequence[T]" set2seq "structures/")
    (subtermOF def-decl "term" subterm nil)
    (positions? type-eq-decl nil positions nil)
    (positionsOF def-decl "positions" positions nil)
    (positions type-eq-decl nil positions nil)
    (position type-eq-decl nil positions nil)
    (reduction? const-decl "bool" reduction nil)
    (non_root_reduction? const-decl "bool" reduction nil)
    (set type-eq-decl nil sets nil)
    (rewrite_rule type-eq-decl nil rewrite_rules nil)
    (rewrite_rule? const-decl "bool" rewrite_rules nil)
    (iterate def-decl "pred[[T, T]]" relation_iterate "orders/")
    (pred type-eq-decl nil defined_types nil)
    (args adt-accessor-decl
          "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]"
          term_adt nil)
    (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (app? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (term type-decl nil term_adt nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (<= const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (s!1 skolem-const-decl "{s: term | app?(s)}" reduction nil)
    (s!1 skolem-const-decl "{s: term | app?(s)}" reduction nil)
    (s!1 skolem-const-decl "{s: term | app?(s)}" reduction nil)
    (s!1 skolem-const-decl "{s: term | app?(s)}" reduction nil)
    (O const-decl "bool" relation_props nil)
    (replace_persistence formula-decl nil replacement nil)
    (s!1 skolem-const-decl "{s: term | app?(s)}" reduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (positions_of_arg formula-decl nil positions nil)
    (non_root_rtc_preserves_pos_args formula-decl nil reduction nil)
    (<= const-decl "bool" positions nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (parallel const-decl "bool" positions nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (rest const-decl "finseq" seq_extras "structures/")
    (O const-decl "finseq" finite_sequences nil)
    (Sub type-eq-decl nil substitution nil)
    (Sub? const-decl "bool" substitution nil)
    (V const-decl "set[term]" variables_term nil)
    (member const-decl "bool" sets nil)
    (replace_distributivity formula-decl nil replacement nil)
    (ext def-decl "term" substitution nil)
    (rhs const-decl "term" rewrite_rules nil)
    (pos_subterm formula-decl nil subterm nil)
    (empty_0 formula-decl nil seq_extras "structures/")
    (seq_first_rest_1 formula-decl nil seq_extras "structures/")
    (reduction_fix? const-decl "bool" reduction nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (< const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (first const-decl "T" seq_extras "structures/")
    (not_empty_seq type-eq-decl nil seq_extras "structures/")
    (/= const-decl "boolean" notequal nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (TRUE const-decl "bool" booleans nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (E skolem-const-decl "set[rewrite_rule]" reduction nil)
    (k skolem-const-decl "{k: posnat | k <= length(args(s))}" reduction
     nil)
    (s skolem-const-decl "{s: term | app?(s)}" reduction nil)
    (s!1 skolem-const-decl "{s: term | app?(s)}" reduction nil)
    (s!1 skolem-const-decl "{s: term | app?(s)}" reduction nil)
    (s!1 skolem-const-decl "{s: term | app?(s)}" reduction nil)
    (s!1 skolem-const-decl "{s: term | app?(s)}" reduction nil)
    (IUnion const-decl "set[T]" indexed_sets nil))
   nil))
 (arg_rest_std?_TCC1 0
  (arg_rest_std?_TCC1-1 nil 3763213849
   ("" (skeep* :preds? t)
    (("" (use "empty_0[posnat]") (("" (assert) nil nil)) nil)) nil)
   ((empty_0 formula-decl nil seq_extras "structures/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (positions? type-eq-decl nil positions nil)
    (positionsOF def-decl "positions" positions nil)
    (positions type-eq-decl nil positions nil)
    (term type-decl nil term_adt nil)
    (position type-eq-decl nil positions nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (nf_subterms 0
  (nf_subterms-2 nil 3758892193
   ("" (skeep)
    (("" (expand "is_normal_form?")
      (("" (prop)
        (("1" (skeep)
          (("1" (expand "reducible?" 1)
            (("1" (expand "reducible?")
              (("1" (skeep)
                (("1" (inst 1 "replaceTerm(t, y, p)")
                  (("1" (expand "reduction?")
                    (("1" (skeep)
                      (("1" (inst 1 "e" "sigma" "p o p_1")
                        (("1" (use "pos_subterm")
                          (("1" (assert)
                            (("1" (use "pos_o_term")
                              (("1"
                                (assert)
                                (("1"
                                  (name-replace
                                   "ss"
                                   "ext(sigma)(rhs(e))")
                                  (("1"
                                    (replace -4 1)
                                    (("1"
                                      (lemma "replace_associativity")
                                      (("1"
                                        (inst?)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (replace -1 1 rl)
                                            (("1"
                                              (use
                                               "replace_subterm_of_term")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (typepred "p" "p_1")
                          (("2" (rewrite "pos_o_term") nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "reducible?" -2)
          (("2" (skeep)
            (("2" (expand "reduction?" -2)
              (("2" (skeep)
                (("2" (inst -1 "p")
                  (("2" (expand "reducible?")
                    (("2" (inst 1 "ext(sigma)(rhs(e))")
                      (("2" (assert)
                        (("2" (expand "reduction?")
                          (("2" (inst 1 "e" "sigma" "empty_seq")
                            (("1" (rewrite "subterm_empty_seq")
                              (("1"
                                (assert)
                                (("1"
                                  (expand "replaceTerm " 1)
                                  (("1"
                                    (expand "empty_seq" 1 1)
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (expand "positionsOF")
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((is_normal_form? const-decl "bool" ars_terminology nil)
    (only_empty_seq const-decl "positions" positions nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (insert? const-decl "finseq" seq_extras "structures/")
    (add_first const-decl "finseq" seq_extras "structures/")
    (catenate const-decl "positions" positions nil)
    (IUnion const-decl "set[T]" indexed_sets nil)
    (union const-decl "set" sets nil)
    (lhs const-decl "term" rewrite_rules nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (subterm_empty_seq formula-decl nil subterm nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (p skolem-const-decl "positions?[variable, symbol, arity](t)"
     reduction nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (term type-decl nil term_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (position type-eq-decl nil positions nil)
    (positions type-eq-decl nil positions nil)
    (positionsOF def-decl "positions" positions nil)
    (positions? type-eq-decl nil positions nil)
    (replaceTerm def-decl "term" replacement nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pos_subterm formula-decl nil subterm nil)
    (pos_o_term formula-decl nil subterm nil)
    (rhs const-decl "term" rewrite_rules nil)
    (ext def-decl "term" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (replace_associativity formula-decl nil replacement nil)
    (replace_subterm_of_term formula-decl nil replacement nil)
    (Sub type-eq-decl nil substitution nil)
    (Sub? const-decl "bool" substitution nil)
    (V const-decl "set[term]" variables_term nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (rewrite_rule type-eq-decl nil rewrite_rules nil)
    (rewrite_rule? const-decl "bool" rewrite_rules nil)
    (t skolem-const-decl "term[variable, symbol, arity]" reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (O const-decl "finseq" finite_sequences nil)
    (p skolem-const-decl "positions?[variable, symbol, arity](t)"
     reduction nil)
    (subtermOF def-decl "term" subterm nil)
    (p_1 skolem-const-decl
     "positions?[variable, symbol, arity](subtermOF(t, p))" reduction
     nil)
    (reduction? const-decl "bool" reduction nil)
    (reducible? const-decl "bool" ars_terminology nil))
   nil)
  (nf_subterms-1 nil 3749401052
   ("" (skeep)
    (("" (prop)
      (("1" (skeep)
        (("1" (expand "reducible?" 1)
          (("1" (expand "reducible?")
            (("1" (skeep)
              (("1" (inst 1 "replaceTerm(t, y, p)")
                (("1" (expand "reduction?")
                  (("1" (skeep)
                    (("1" (inst 1 "e" "sigma" "p o p_1")
                      (("1" (use "pos_subterm")
                        (("1" (assert)
                          (("1" (use "pos_o_term")
                            (("1" (assert)
                              (("1"
                                (name-replace
                                 "ss"
                                 "ext(sigma)(rhs(e))")
                                (("1"
                                  (replace -4 1)
                                  (("1"
                                    (lemma "replace_associativity")
                                    (("1"
                                      (inst?)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (replace -1 1 rl)
                                          (("1"
                                            (use
                                             "replace_subterm_of_term")
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (typepred "p" "p_1")
                        (("2" (rewrite "pos_o_term") nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "reducible?" -2)
        (("2" (skeep)
          (("2" (expand "reduction?" -2)
            (("2" (skeep)
              (("2" (inst -1 "p")
                (("2" (expand "reducible?")
                  (("2" (inst 1 "ext(sigma)(rhs(e))")
                    (("2" (assert)
                      (("2" (expand "reduction?")
                        (("2" (inst 1 "e" "sigma" "empty_seq")
                          (("1" (rewrite "subterm_empty_seq")
                            (("1" (assert)
                              (("1"
                                (expand "replaceTerm " 1)
                                (("1"
                                  (expand "empty_seq" 1 1)
                                  (("1" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand "positionsOF")
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((reducible? const-decl "bool" ars_terminology nil)
    (subtermOF def-decl "term" subterm nil)
    (O const-decl "finseq" finite_sequences nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (rewrite_rule? const-decl "bool" rewrite_rules nil)
    (rewrite_rule type-eq-decl nil rewrite_rules nil)
    (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil)
    (V const-decl "set[term]" variables_term nil)
    (Sub? const-decl "bool" substitution nil)
    (Sub type-eq-decl nil substitution nil)
    (replace_subterm_of_term formula-decl nil replacement nil)
    (replace_associativity formula-decl nil replacement nil)
    (ext def-decl "term" substitution nil)
    (rhs const-decl "term" rewrite_rules nil)
    (pos_o_term formula-decl nil subterm nil)
    (pos_subterm formula-decl nil subterm nil)
    (replaceTerm def-decl "term" replacement nil)
    (positions? type-eq-decl nil positions nil)
    (positionsOF def-decl "positions" positions nil)
    (positions type-eq-decl nil positions nil)
    (position type-eq-decl nil positions nil)
    (term type-decl nil term_adt nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (subterm_empty_seq formula-decl nil subterm nil)
    (lhs const-decl "term" rewrite_rules nil)
    (union const-decl "set" sets nil)
    (catenate const-decl "positions" positions nil)
    (add_first const-decl "finseq" seq_extras "structures/")
    (insert? const-decl "finseq" seq_extras "structures/")
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (only_empty_seq const-decl "positions" positions nil))
   nil))
 (terminating_all_subterms 0
  (terminating_all_subterms-1 nil 3755566054
   ("" (skeep*)
    (("" (prop)
      (("1" (expand "terminating?")
        (("1" (skeep*)
          (("1"
            (inst 1
             "(LAMBDA(i:nat): IF i=0 THEN t ELSE replaceTerm(t,seq(i),p) ENDIF)")
            (("1" (induct "n")
              (("1" (assert)
                (("1" (inst -2 0)
                  (("1" (lemma "reduction_is_subs_op")
                    (("1" (inst?)
                      (("1" (flatten)
                        (("1" (rewrite "comp_op_iff_comp_cont")
                          (("1" (expand "comp_cont?")
                            (("1" (inst -2 "p" "t")
                              (("1"
                                (typepred "p")
                                (("1"
                                  (assert)
                                  (("1"
                                    (inst -3 "seq(0)" "seq(1)")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (replace -4 -3)
                                        (("1"
                                          (lemma
                                           "replace_subterm_of_term")
                                          (("1"
                                            (inst?)
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skeep*)
                (("2" (assert)
                  (("2" (lift-if)
                    (("2" (prop)
                      (("1" (replaces -1)
                        (("1" (assert)
                          (("1" (inst -3 1)
                            (("1" (lemma "reduction_is_subs_op")
                              (("1"
                                (inst?)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (rewrite "comp_op_iff_comp_cont")
                                    (("1"
                                      (expand "comp_cont?")
                                      (("1"
                                        (hide -1)
                                        (("1"
                                          (inst -1 "p" "t")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (inst
                                               -1
                                               "seq(1)"
                                               "seq(2)")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (inst -3 "1 + j")
                        (("2" (lemma "reduction_is_subs_op")
                          (("2" (inst?)
                            (("2" (flatten)
                              (("2"
                                (hide -1)
                                (("2"
                                  (rewrite "comp_op_iff_comp_cont")
                                  (("2"
                                    (expand "comp_cont?")
                                    (("2"
                                      (inst -1 "p" "t")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (inst
                                           -1
                                           "seq(1 + j)"
                                           "seq(2 + j)")
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "terminating?")
        (("2" (skeep)
          (("2" (inst -1 "empty_seq")
            (("1" (inst 1 "seq")
              (("1" (rewrite "subterm_empty_seq")
                (("1" (assert) nil nil)) nil))
              nil)
             ("2" (hide -2)
              (("2" (expand "positionsOF")
                (("2" (lift-if)
                  (("2" (prop)
                    (("1" (expand "only_empty_seq")
                      (("1" (propax) nil nil)) nil)
                     ("2" (expand "only_empty_seq")
                      (("2" (propax) nil nil)) nil)
                     ("3" (expand "only_empty_seq")
                      (("3" (expand "union")
                        (("3" (expand "member")
                          (("3" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pred type-eq-decl nil defined_types nil)
    (rewrite_rule? const-decl "bool" rewrite_rules nil)
    (rewrite_rule type-eq-decl nil rewrite_rules nil)
    (set type-eq-decl nil sets nil)
    (reduction? const-decl "bool" reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (comp_op_iff_comp_cont formula-decl nil compatibility nil)
    (replace_subterm_of_term formula-decl nil replacement nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (comp_cont? const-decl "bool" compatibility nil)
    (reduction_is_subs_op formula-decl nil reduction nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (even_plus_even_is_even application-judgement "even_int" integers
     nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers
     nil)
    (replaceTerm def-decl "term" replacement nil)
    (positions? type-eq-decl nil positions nil)
    (positionsOF def-decl "positions" positions nil)
    (positions type-eq-decl nil positions nil)
    (position type-eq-decl nil positions nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (sequence type-eq-decl nil sequences nil)
    (term type-decl nil term_adt nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (terminating? const-decl "bool" noetherian nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (only_empty_seq const-decl "positions" positions nil)
    (subterm_empty_seq formula-decl nil subterm nil)
    (t skolem-const-decl "term[variable, symbol, arity]" reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil)))

