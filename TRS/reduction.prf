(reduction
 (IMP_rewrite_rules_TCC1 0
  (IMP_rewrite_rules_TCC1-1 nil 3762678769
   ("" (rewrite "var_countable") nil nil)
   ((var_countable formula-decl nil reduction nil)) nil))
 (closure_close_subs 0
  (closure_close_subs-1 nil 3433013930
   ("" (skeep)
    (("" (expand "close_subs?")
      (("" (split)
        (("1" (skeep)
          (("1" (expand "TC")
            (("1" (expand "IUnion")
              (("1" (skolem * "j")
                (("1" (generalize "s" "s" :fnums (-1 1))
                  (("1" (generalize "t" "t" :fnums 1)
                    (("1" (generalize "j" "n" :fnums 1)
                      (("1" (induct "n")
                        (("1" (assert) nil nil) ("2" (assert) nil nil)
                         ("3" (skosimp*)
                          (("3" (prop)
                            (("1" (rewrite "iterate_add_one")
                              (("1"
                                (expand "o")
                                (("1"
                                  (skosimp*)
                                  (("1"
                                    (inst -1 "t!1" "y!1")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (skosimp*)
                                        (("1"
                                          (inst -5 "s!1" "y!1" "sigma")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (inst 1 "i!1 + 1")
                                              (("1"
                                                (rewrite
                                                 "iterate_add_one"
                                                 1)
                                                (("1"
                                                  (expand "o")
                                                  (("1"
                                                    (inst
                                                     1
                                                     "ext(sigma)(y!1)")
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (typepred "j!1")
                              (("2"
                                (case "j!1 = 0")
                                (("1"
                                  (hide-all-but (-1 -4 -5 2))
                                  (("1"
                                    (replaces -1)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (rewrite "iterate_1")
                                        (("1"
                                          (inst -2 "s!1" "t!1" "sigma")
                                          (("1"
                                            (inst 1 "1")
                                            (("1"
                                              (rewrite "iterate_1")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (expand "RTC")
            (("2" (expand "IUnion")
              (("2" (skolem * "j")
                (("2" (generalize "s" "s" :fnums (-1 1))
                  (("2" (generalize "t" "t" :fnums 1)
                    (("2" (generalize "j" "n" :fnums 1)
                      (("2" (induct "n")
                        (("1" (skolem * ("s1" "t1"))
                          (("1" (flatten)
                            (("1" (inst 1 "0")
                              (("1"
                                (hide -2)
                                (("1"
                                  (expand "iterate")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skosimp*)
                          (("2" (rewrite "iterate_add_one")
                            (("2" (expand "o")
                              (("2"
                                (skosimp*)
                                (("2"
                                  (inst -1 "t!1" "y!1")
                                  (("2"
                                    (assert)
                                    (("2"
                                      (skosimp*)
                                      (("2"
                                        (inst -4 "s!1" "y!1" "sigma")
                                        (("2"
                                          (assert)
                                          (("2"
                                            (inst 1 "i!1 + 1")
                                            (("2"
                                              (rewrite
                                               "iterate_add_one"
                                               1)
                                              (("2"
                                                (expand "o")
                                                (("2"
                                                  (inst
                                                   1
                                                   "ext(sigma)(y!1)")
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (skeep)
          (("3" (expand "EC")
            (("3" (expand "RTC")
              (("3" (expand "IUnion")
                (("3" (skolem * "j")
                  (("3" (generalize "s" "s" :fnums (-1 1))
                    (("3" (generalize "t" "t" :fnums 1)
                      (("3" (generalize "j" "n" :fnums 1)
                        (("3" (induct "n")
                          (("1" (skolem * ("s1" "t1"))
                            (("1" (flatten)
                              (("1"
                                (hide -2)
                                (("1"
                                  (inst 1 "0")
                                  (("1"
                                    (expand "iterate")
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (skosimp*)
                            (("2" (rewrite "iterate_add_one")
                              (("2"
                                (expand "o")
                                (("2"
                                  (skosimp*)
                                  (("2"
                                    (inst -1 "t!1" "y!1")
                                    (("2"
                                      (assert)
                                      (("2"
                                        (skosimp*)
                                        (("2"
                                          (expand "SC" -2)
                                          (("2"
                                            (expand* "union" "member")
                                            (("2"
                                              (prop)
                                              (("1"
                                                (inst
                                                 -4
                                                 "s!1"
                                                 "y!1"
                                                 "sigma")
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (lemma
                                                     "R_subset_SC")
                                                    (("1"
                                                      (inst?)
                                                      (("1"
                                                        (expand
                                                         "subset?")
                                                        (("1"
                                                          (inst
                                                           -1
                                                           "(ext(sigma)(s!1), ext(sigma)(y!1))")
                                                          (("1"
                                                            (expand
                                                             "member")
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (inst
                                                                 1
                                                                 "i!1 + 1")
                                                                (("1"
                                                                  (rewrite
                                                                   "iterate_add_one")
                                                                  (("1"
                                                                    (expand
                                                                     "o")
                                                                    (("1"
                                                                      (inst
                                                                       1
                                                                       "ext(sigma)(y!1)")
                                                                      (("1"
                                                                        (assert)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (expand "converse")
                                                (("2"
                                                  (inst 1 "i!1 + 1")
                                                  (("2"
                                                    (rewrite
                                                     "iterate_add_one")
                                                    (("2"
                                                      (expand "o")
                                                      (("2"
                                                        (inst
                                                         1
                                                         "ext(sigma)(y!1)")
                                                        (("2"
                                                          (assert)
                                                          (("2"
                                                            (expand
                                                             "SC"
                                                             1)
                                                            (("2"
                                                              (expand*
                                                               "union"
                                                               "member"
                                                               "converse")
                                                              (("2"
                                                                (prop)
                                                                (("2"
                                                                  (inst
                                                                   -4
                                                                   "y!1"
                                                                   "s!1"
                                                                   "sigma")
                                                                  (("2"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((close_subs? const-decl "bool" reduction nil)
    (subset? const-decl "bool" sets nil)
    (R_subset_SC formula-decl nil relations_closure nil)
    (converse const-decl "pred[[T2, T1]]" relation_defs nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (symmetric? const-decl "bool" relations nil)
    (symmetric type-eq-decl nil relations_closure nil)
    (SC const-decl "symmetric" relations_closure nil)
    (EC const-decl "equivalence" relations_closure nil)
    (RTC const-decl "reflexive_transitive" relations_closure nil)
    (IUnion const-decl "set[T]" indexed_sets nil)
    (ext def-decl "term" substitution nil)
    (Sub type-eq-decl nil substitution nil)
    (Sub? const-decl "bool" substitution nil)
    (V const-decl "set[term]" variables_term nil)
    (set type-eq-decl nil sets nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (iterate def-decl "pred[[T, T]]" relation_iterate "orders/")
    (pred type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (iterate_1 formula-decl nil relation_iterate "orders/")
    (TRUE const-decl "bool" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (iterate_add_one formula-decl nil relation_iterate "orders/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (O const-decl "bool" relation_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (TC const-decl "transitive" relations_closure nil))
   shostak))
 (reduction_is_subs_op 0
  (reduction_is_subs_op-1 nil 3433014142
   ("" (skeep)
    (("" (split)
      (("1" (expand "close_subs?")
        (("1" (skosimp*)
          (("1" (expand "reduction?")
            (("1" (skosimp*)
              (("1" (inst 1 "e!1" "comp(sigma!1, sigma!2)" "p!1")
                (("1" (split)
                  (("1" (rewrite "ext_o")
                    (("1" (expand "o")
                      (("1" (rewrite "subterm_ext_commute")
                        (("1" (assert) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (rewrite "ext_o")
                    (("2" (expand "o")
                      (("2" (replace -2)
                        (("2" (lemma "ext_replace_ext")
                          (("2"
                            (inst -1 "p!1" "s!1" "sigma!1"
                             "ext(sigma!2)(rhs(e!1))")
                            (("2" (typepred "p!1")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (rewrite "ext_preserv_pos") nil nil)
                 ("3" (rewrite "subs_o") nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "comp_op?")
        (("2" (skosimp*)
          (("2" (expand "reduction?")
            (("2" (skosimp*)
              (("2" (inst 1 "e!1" "sigma!1" "add_first(i!1 + 1, p!1)")
                (("1" (split)
                  (("1" (expand "subtermOF" 1)
                    (("1" (lift-if)
                      (("1" (prop)
                        (("1" (grind) nil nil)
                         ("2" (expand "finseq_appl")
                          (("2"
                            (case-replace
                             "first(add_first(1 + i!1, p!1)) - 1 = i!1"
                             :hide? t)
                            (("1"
                              (case-replace
                               "rest(add_first(1 + i!1, p!1)) = p!1"
                               :hide? t)
                              (("1"
                                (hide-all-but 1)
                                (("1"
                                  (rewrite "rest_add_first")
                                  nil
                                  nil))
                                nil))
                              nil)
                             ("2" (hide-all-but 1)
                              (("2"
                                (rewrite "first_add")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand "finseq_appl")
                    (("2" (decompose-equality)
                      (("1" (grind) nil nil)
                       ("2" (expand "replace")
                        (("2" (expand "finseq_appl")
                          (("2" (decompose-equality)
                            (("1" (grind) nil nil)
                             ("2" (decompose-equality)
                              (("2"
                                (lift-if)
                                (("2"
                                  (prop)
                                  (("1" (grind) nil nil)
                                   ("2" (grind) nil nil)
                                   ("3" (grind) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("3" (grind) nil nil))
                            nil))
                          nil))
                        nil)
                       ("3" (grind) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide (-1 -2))
                  (("2" (typepred "p!1")
                    (("2" (expand "finseq_appl")
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subs_o formula-decl nil substitution nil)
    (ext_preserv_pos formula-decl nil substitution nil)
    (O const-decl "T3" function_props nil)
    (subterm_ext_commute formula-decl nil substitution nil)
    (ext_o formula-decl nil substitution nil)
    (ext_replace_ext formula-decl nil substitution nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rhs const-decl "term" rewrite_rules nil)
    (member const-decl "bool" sets nil)
    (rewrite_rule type-eq-decl nil rewrite_rules nil)
    (rewrite_rule? const-decl "bool" rewrite_rules nil)
    (below type-eq-decl nil nat_types nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (position type-eq-decl nil positions nil)
    (positions type-eq-decl nil positions nil)
    (positionsOF def-decl "positions" positions nil)
    (ext def-decl "term" substitution nil)
    (s!1 skolem-const-decl "term[variable, symbol, arity]" reduction
     nil)
    (positions? type-eq-decl nil positions nil)
    (p!1 skolem-const-decl "positions?[variable, symbol, arity](s!1)"
     reduction nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil)
    (V const-decl "set[term]" variables_term nil)
    (Sub? const-decl "bool" substitution nil)
    (Sub type-eq-decl nil substitution nil)
    (comp const-decl "term" substitution nil)
    (sigma!1 skolem-const-decl "Sub[variable, symbol, arity]" reduction
     nil)
    (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" reduction
     nil)
    (reduction? const-decl "bool" reduction nil)
    (close_subs? const-decl "bool" reduction nil)
    (<= const-decl "bool" reals nil)
    (upto? nonempty-type-eq-decl nil IUnion_extra nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (union const-decl "set" sets nil)
    (IUnion const-decl "set[T]" indexed_sets nil)
    (catenate const-decl "positions" positions nil)
    (only_empty_seq const-decl "positions" positions nil)
    (first_add formula-decl nil seq_extras "structures/")
    (rest const-decl "finseq" seq_extras "structures/")
    (rest_add_first formula-decl nil seq_extras "structures/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (not_empty_seq type-eq-decl nil seq_extras "structures/")
    (first const-decl "T" seq_extras "structures/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (insert? const-decl "finseq" seq_extras "structures/")
    (subtermOF def-decl "term" subterm nil)
    (e!1 skolem-const-decl "{e | member(e, E)}" reduction nil)
    (E skolem-const-decl "set[rewrite_rule]" reduction nil)
    (sigma!1 skolem-const-decl "Sub[variable, symbol, arity]" reduction
     nil)
    (replaceTerm def-decl "term" replacement nil)
    (replace const-decl "finseq" seq_extras "structures/")
    (term_app_extensionality formula-decl nil term_adt nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^ const-decl "finseq" finite_sequences nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (lhs const-decl "term" rewrite_rules nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (args adt-accessor-decl
          "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]"
          term_adt nil)
    (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (app? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (app adt-constructor-decl
     "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil)
    (n!1 skolem-const-decl "nat" reduction nil)
    (arity_eq type-eq-decl nil compatibility nil)
    (f!1 skolem-const-decl "arity_eq[variable, symbol, arity](n!1)"
     reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (fs_len type-eq-decl nil seq_extras "structures/")
    (st1!1 skolem-const-decl
     "fs_len[term[variable, symbol, arity]](n!1)" reduction nil)
    (add_first const-decl "finseq" seq_extras "structures/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (i!1 skolem-const-decl "below[n!1]" reduction nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (p!1 skolem-const-decl "positions?
    [variable, symbol, arity](finseq_appl[term[variable, symbol, arity]]
                                  (st1!1)(i!1))" reduction nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (comp_op? const-decl "bool" compatibility nil))
   shostak))
 (lhs_reduces_to_rhs 0
  (lhs_reduces_to_rhs-1 nil 3433014645
   ("" (skeep)
    (("" (expand "reduction?")
      (("" (inst 1 "e" "identity" "empty_seq")
        (("1" (expand* "subtermOF" "replaceTerm")
          (("1" (lift-if)
            (("1" (rewrite "ext_iden")
              (("1" (rewrite "ext_iden")
                (("1" (rewrite "empty_0") nil nil)) nil))
              nil))
            nil))
          nil)
         ("2" (expand "positionsOF")
          (("2" (lift-if) (("2" (grind) nil nil)) nil)) nil)
         ("3" (rewrite "iden_subs") nil nil))
        nil))
      nil))
    nil)
   ((reduction? const-decl "bool" reduction nil)
    (iden_subs formula-decl nil substitution nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (only_empty_seq const-decl "positions" positions nil)
    (union const-decl "set" sets nil)
    (IUnion const-decl "set[T]" indexed_sets nil)
    (catenate const-decl "positions" positions nil)
    (add_first const-decl "finseq" seq_extras "structures/")
    (insert? const-decl "finseq" seq_extras "structures/")
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (replaceTerm def-decl "term" replacement nil)
    (subtermOF def-decl "term" subterm nil)
    (ext_iden formula-decl nil substitution nil)
    (empty_0 formula-decl nil seq_extras "structures/")
    (rhs const-decl "term" rewrite_rules nil)
    (positions? type-eq-decl nil positions nil)
    (Sub type-eq-decl nil substitution nil)
    (below type-eq-decl nil nat_types nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (position type-eq-decl nil positions nil)
    (positions type-eq-decl nil positions nil)
    (positionsOF def-decl "positions" positions nil)
    (rewrite_rule? const-decl "bool" rewrite_rules nil)
    (rewrite_rule type-eq-decl nil rewrite_rules nil)
    (lhs const-decl "term" rewrite_rules nil)
    (member const-decl "bool" sets nil)
    (E skolem-const-decl "set[rewrite_rule]" reduction nil)
    (e skolem-const-decl "{e | member(e, E)}" reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil)
    (V const-decl "set[term]" variables_term nil)
    (Sub? const-decl "bool" substitution nil)
    (bijective? const-decl "bool" functions nil)
    (identity const-decl "(bijective?[T, T])" identity nil))
   shostak))
 (reducible_is_app 0
  (reducible_is_app-1 nil 3757322088
   ("" (skeep)
    (("" (expand "reducible?")
      (("" (skeep)
        (("" (expand "reduction?")
          (("" (skeep)
            (("" (case-replace "p=empty_seq")
              (("1" (hide -3)
                (("1" (rewrite "subterm_empty_seq")
                  (("1" (typepred "e")
                    (("1" (expand "rewrite_rule?")
                      (("1" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (expand "replaceTerm")
                (("2" (rewrite "empty_0")
                  (("2" (assert)
                    (("2" (decompose-equality -2)
                      (("2" (hide -2)
                        (("2" (typepred "p") (("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((reducible? const-decl "bool" ars_terminology nil)
    (reduction? const-decl "bool" reduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (position type-eq-decl nil positions nil)
    (term type-decl nil term_adt nil)
    (positions type-eq-decl nil positions nil)
    (positionsOF def-decl "positions" positions nil)
    (positions? type-eq-decl nil positions nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (subterm_empty_seq formula-decl nil subterm nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (Vars const-decl "set[(V)]" subterm nil)
    (subset? const-decl "bool" sets nil)
    (lhs const-decl "term" rewrite_rules nil)
    (ext def-decl "term" substitution nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (V const-decl "set[term]" variables_term nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (rewrite_rule type-eq-decl nil rewrite_rules nil)
    (rewrite_rule? const-decl "bool" rewrite_rules nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (empty_0 formula-decl nil seq_extras "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (app? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (app adt-constructor-decl
     "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil)
    (replace const-decl "finseq" seq_extras "structures/")
    (args adt-accessor-decl
          "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]"
          term_adt nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (not_empty_seq type-eq-decl nil seq_extras "structures/")
    (first const-decl "T" seq_extras "structures/")
    (Sub? const-decl "bool" substitution nil)
    (Sub type-eq-decl nil substitution nil)
    (rhs const-decl "term" rewrite_rules nil)
    (rest const-decl "finseq" seq_extras "structures/")
    (only_empty_seq const-decl "positions" positions nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (replaceTerm def-decl "term" replacement nil))
   nil))
 (non_root_subset_reduction 0
  (non_root_subset_reduction-1 nil 3756717181
   ("" (skeep)
    (("" (expand "subset?")
      (("" (skeep)
        (("" (expand "member")
          (("" (expand "non_root_reduction?")
            (("" (expand "reduction?")
              (("" (expand "reduction_fix?")
                (("" (skeep*)
                  (("" (inst?) (("" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (reduction? const-decl "bool" reduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (positions? type-eq-decl nil positions nil)
    (positionsOF def-decl "positions" positions nil)
    (positions type-eq-decl nil positions nil)
    (position type-eq-decl nil positions nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil nat_types nil)
    (Sub type-eq-decl nil substitution nil)
    (Sub? const-decl "bool" substitution nil)
    (V const-decl "set[term]" variables_term nil)
    (set type-eq-decl nil sets nil)
    (rewrite_rule type-eq-decl nil rewrite_rules nil)
    (rewrite_rule? const-decl "bool" rewrite_rules nil)
    (term type-decl nil term_adt nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (reduction_fix? const-decl "bool" reduction nil)
    (non_root_reduction? const-decl "bool" reduction nil))
   nil))
 (non_root_rtc_preserves_root_symbol 0
  (non_root_rtc_preserves_root_symbol-1 nil 3760177562
   ("" (skeep)
    (("" (expand "RTC")
      (("" (expand "IUnion")
        (("" (skeep)
          (("" (generalize "i" "i" :fnums (-1 1))
            (("" (generalize "s" "s" :fnums 1)
              (("" (generalize "t" "t" :fnums 1)
                (("" (induct "i")
                  (("1" (grind) nil nil)
                   ("2" (skeep)
                    (("2" (skeep)
                      (("2" (expand "iterate" -2)
                        (("2" (expand "o")
                          (("2" (skeep)
                            (("2" (inst -1 "y" "s!1")
                              (("2"
                                (assert)
                                (("2"
                                  (flatten)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (hide -3)
                                      (("2"
                                        (expand "non_root_reduction?")
                                        (("2"
                                          (skeep :preds? t)
                                          (("2"
                                            (expand "reduction_fix?")
                                            (("2"
                                              (skeep)
                                              (("2"
                                                (expand "replaceTerm")
                                                (("2"
                                                  (use
                                                   "empty_0[posnat]")
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (expand
                                                       "finseq_appl")
                                                      (("2"
                                                        (decompose-equality
                                                         -5)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((RTC const-decl "reflexive_transitive" relations_closure nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (O const-decl "bool" relation_props nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (empty_0 formula-decl nil seq_extras "structures/")
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (position type-eq-decl nil positions nil)
    (positions type-eq-decl nil positions nil)
    (positionsOF def-decl "positions" positions nil)
    (positions? type-eq-decl nil positions nil)
    (< const-decl "bool" reals nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (rest const-decl "finseq" seq_extras "structures/")
    (member const-decl "bool" sets nil)
    (rhs const-decl "term" rewrite_rules nil)
    (ext def-decl "term" substitution nil)
    (Sub type-eq-decl nil substitution nil)
    (Sub? const-decl "bool" substitution nil)
    (V const-decl "set[term]" variables_term nil)
    (first const-decl "T" seq_extras "structures/")
    (not_empty_seq type-eq-decl nil seq_extras "structures/")
    (/= const-decl "boolean" notequal nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (args adt-accessor-decl
          "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]"
          term_adt nil)
    (replace const-decl "finseq" seq_extras "structures/")
    (app adt-constructor-decl
     "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (replaceTerm def-decl "term" replacement nil)
    (reduction_fix? const-decl "bool" reduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (term type-decl nil term_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (iterate def-decl "pred[[T, T]]" relation_iterate "orders/")
    (rewrite_rule? const-decl "bool" rewrite_rules nil)
    (rewrite_rule type-eq-decl nil rewrite_rules nil)
    (set type-eq-decl nil sets nil)
    (non_root_reduction? const-decl "bool" reduction nil)
    (app? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil)
    (IUnion const-decl "set[T]" indexed_sets nil))
   nil))
 (nf_subterms 0
  (nf_subterms-2 nil 3758892193
   ("" (skeep)
    (("" (expand "is_normal_form?")
      (("" (prop)
        (("1" (skeep)
          (("1" (expand "reducible?" 1)
            (("1" (expand "reducible?")
              (("1" (skeep)
                (("1" (inst 1 "replaceTerm(t, y, p)")
                  (("1" (expand "reduction?")
                    (("1" (skeep)
                      (("1" (inst 1 "e" "sigma" "p o p_1")
                        (("1" (use "pos_subterm")
                          (("1" (assert)
                            (("1" (use "pos_o_term")
                              (("1"
                                (assert)
                                (("1"
                                  (name-replace
                                   "ss"
                                   "ext(sigma)(rhs(e))")
                                  (("1"
                                    (replace -4 1)
                                    (("1"
                                      (lemma "replace_associativity")
                                      (("1"
                                        (inst?)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (replace -1 1 rl)
                                            (("1"
                                              (use
                                               "replace_subterm_of_term")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (typepred "p" "p_1")
                          (("2" (rewrite "pos_o_term") nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "reducible?" -2)
          (("2" (skeep)
            (("2" (expand "reduction?" -2)
              (("2" (skeep)
                (("2" (inst -1 "p")
                  (("2" (expand "reducible?")
                    (("2" (inst 1 "ext(sigma)(rhs(e))")
                      (("2" (assert)
                        (("2" (expand "reduction?")
                          (("2" (inst 1 "e" "sigma" "empty_seq")
                            (("1" (rewrite "subterm_empty_seq")
                              (("1"
                                (assert)
                                (("1"
                                  (expand "replaceTerm " 1)
                                  (("1"
                                    (expand "empty_seq" 1 1)
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (expand "positionsOF")
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((is_normal_form? const-decl "bool" ars_terminology nil)
    (only_empty_seq const-decl "positions" positions nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (insert? const-decl "finseq" seq_extras "structures/")
    (add_first const-decl "finseq" seq_extras "structures/")
    (catenate const-decl "positions" positions nil)
    (IUnion const-decl "set[T]" indexed_sets nil)
    (union const-decl "set" sets nil)
    (lhs const-decl "term" rewrite_rules nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (subterm_empty_seq formula-decl nil subterm nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (p skolem-const-decl "positions?[variable, symbol, arity](t)"
     reduction nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (term type-decl nil term_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (position type-eq-decl nil positions nil)
    (positions type-eq-decl nil positions nil)
    (positionsOF def-decl "positions" positions nil)
    (positions? type-eq-decl nil positions nil)
    (replaceTerm def-decl "term" replacement nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pos_subterm formula-decl nil subterm nil)
    (pos_o_term formula-decl nil subterm nil)
    (rhs const-decl "term" rewrite_rules nil)
    (ext def-decl "term" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (replace_associativity formula-decl nil replacement nil)
    (replace_subterm_of_term formula-decl nil replacement nil)
    (Sub type-eq-decl nil substitution nil)
    (Sub? const-decl "bool" substitution nil)
    (V const-decl "set[term]" variables_term nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (rewrite_rule type-eq-decl nil rewrite_rules nil)
    (rewrite_rule? const-decl "bool" rewrite_rules nil)
    (t skolem-const-decl "term[variable, symbol, arity]" reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (O const-decl "finseq" finite_sequences nil)
    (p skolem-const-decl "positions?[variable, symbol, arity](t)"
     reduction nil)
    (subtermOF def-decl "term" subterm nil)
    (p_1 skolem-const-decl
     "positions?[variable, symbol, arity](subtermOF(t, p))" reduction
     nil)
    (reduction? const-decl "bool" reduction nil)
    (reducible? const-decl "bool" ars_terminology nil))
   nil)
  (nf_subterms-1 nil 3749401052
   ("" (skeep)
    (("" (prop)
      (("1" (skeep)
        (("1" (expand "reducible?" 1)
          (("1" (expand "reducible?")
            (("1" (skeep)
              (("1" (inst 1 "replaceTerm(t, y, p)")
                (("1" (expand "reduction?")
                  (("1" (skeep)
                    (("1" (inst 1 "e" "sigma" "p o p_1")
                      (("1" (use "pos_subterm")
                        (("1" (assert)
                          (("1" (use "pos_o_term")
                            (("1" (assert)
                              (("1"
                                (name-replace
                                 "ss"
                                 "ext(sigma)(rhs(e))")
                                (("1"
                                  (replace -4 1)
                                  (("1"
                                    (lemma "replace_associativity")
                                    (("1"
                                      (inst?)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (replace -1 1 rl)
                                          (("1"
                                            (use
                                             "replace_subterm_of_term")
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (typepred "p" "p_1")
                        (("2" (rewrite "pos_o_term") nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "reducible?" -2)
        (("2" (skeep)
          (("2" (expand "reduction?" -2)
            (("2" (skeep)
              (("2" (inst -1 "p")
                (("2" (expand "reducible?")
                  (("2" (inst 1 "ext(sigma)(rhs(e))")
                    (("2" (assert)
                      (("2" (expand "reduction?")
                        (("2" (inst 1 "e" "sigma" "empty_seq")
                          (("1" (rewrite "subterm_empty_seq")
                            (("1" (assert)
                              (("1"
                                (expand "replaceTerm " 1)
                                (("1"
                                  (expand "empty_seq" 1 1)
                                  (("1" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand "positionsOF")
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((reducible? const-decl "bool" ars_terminology nil)
    (subtermOF def-decl "term" subterm nil)
    (O const-decl "finseq" finite_sequences nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (rewrite_rule? const-decl "bool" rewrite_rules nil)
    (rewrite_rule type-eq-decl nil rewrite_rules nil)
    (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil)
    (V const-decl "set[term]" variables_term nil)
    (Sub? const-decl "bool" substitution nil)
    (Sub type-eq-decl nil substitution nil)
    (replace_subterm_of_term formula-decl nil replacement nil)
    (replace_associativity formula-decl nil replacement nil)
    (ext def-decl "term" substitution nil)
    (rhs const-decl "term" rewrite_rules nil)
    (pos_o_term formula-decl nil subterm nil)
    (pos_subterm formula-decl nil subterm nil)
    (replaceTerm def-decl "term" replacement nil)
    (positions? type-eq-decl nil positions nil)
    (positionsOF def-decl "positions" positions nil)
    (positions type-eq-decl nil positions nil)
    (position type-eq-decl nil positions nil)
    (term type-decl nil term_adt nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (subterm_empty_seq formula-decl nil subterm nil)
    (lhs const-decl "term" rewrite_rules nil)
    (union const-decl "set" sets nil)
    (catenate const-decl "positions" positions nil)
    (add_first const-decl "finseq" seq_extras "structures/")
    (insert? const-decl "finseq" seq_extras "structures/")
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (only_empty_seq const-decl "positions" positions nil))
   nil))
 (terminating_all_subterms 0
  (terminating_all_subterms-1 nil 3755566054
   ("" (skeep*)
    (("" (prop)
      (("1" (expand "terminating?")
        (("1" (skeep*)
          (("1"
            (inst 1
             "(LAMBDA(i:nat): IF i=0 THEN t ELSE replaceTerm(t,seq(i),p) ENDIF)")
            (("1" (induct "n")
              (("1" (assert)
                (("1" (inst -2 0)
                  (("1" (lemma "reduction_is_subs_op")
                    (("1" (inst?)
                      (("1" (flatten)
                        (("1" (rewrite "comp_op_iff_comp_cont")
                          (("1" (expand "comp_cont?")
                            (("1" (inst -2 "p" "t")
                              (("1"
                                (typepred "p")
                                (("1"
                                  (assert)
                                  (("1"
                                    (inst -3 "seq(0)" "seq(1)")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (replace -4 -3)
                                        (("1"
                                          (lemma
                                           "replace_subterm_of_term")
                                          (("1"
                                            (inst?)
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skeep*)
                (("2" (assert)
                  (("2" (lift-if)
                    (("2" (prop)
                      (("1" (replaces -1)
                        (("1" (assert)
                          (("1" (inst -3 1)
                            (("1" (lemma "reduction_is_subs_op")
                              (("1"
                                (inst?)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (rewrite "comp_op_iff_comp_cont")
                                    (("1"
                                      (expand "comp_cont?")
                                      (("1"
                                        (hide -1)
                                        (("1"
                                          (inst -1 "p" "t")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (inst
                                               -1
                                               "seq(1)"
                                               "seq(2)")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (inst -3 "1 + j")
                        (("2" (lemma "reduction_is_subs_op")
                          (("2" (inst?)
                            (("2" (flatten)
                              (("2"
                                (hide -1)
                                (("2"
                                  (rewrite "comp_op_iff_comp_cont")
                                  (("2"
                                    (expand "comp_cont?")
                                    (("2"
                                      (inst -1 "p" "t")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (inst
                                           -1
                                           "seq(1 + j)"
                                           "seq(2 + j)")
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "terminating?")
        (("2" (skeep)
          (("2" (inst -1 "empty_seq")
            (("1" (inst 1 "seq")
              (("1" (rewrite "subterm_empty_seq")
                (("1" (assert) nil nil)) nil))
              nil)
             ("2" (hide -2)
              (("2" (expand "positionsOF")
                (("2" (lift-if)
                  (("2" (prop)
                    (("1" (expand "only_empty_seq")
                      (("1" (propax) nil nil)) nil)
                     ("2" (expand "only_empty_seq")
                      (("2" (propax) nil nil)) nil)
                     ("3" (expand "only_empty_seq")
                      (("3" (expand "union")
                        (("3" (expand "member")
                          (("3" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pred type-eq-decl nil defined_types nil)
    (rewrite_rule? const-decl "bool" rewrite_rules nil)
    (rewrite_rule type-eq-decl nil rewrite_rules nil)
    (set type-eq-decl nil sets nil)
    (reduction? const-decl "bool" reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (comp_op_iff_comp_cont formula-decl nil compatibility nil)
    (replace_subterm_of_term formula-decl nil replacement nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (comp_cont? const-decl "bool" compatibility nil)
    (reduction_is_subs_op formula-decl nil reduction nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (even_plus_even_is_even application-judgement "even_int" integers
     nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers
     nil)
    (replaceTerm def-decl "term" replacement nil)
    (positions? type-eq-decl nil positions nil)
    (positionsOF def-decl "positions" positions nil)
    (positions type-eq-decl nil positions nil)
    (position type-eq-decl nil positions nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (sequence type-eq-decl nil sequences nil)
    (term type-decl nil term_adt nil)
    (arity formal-const-decl "[symbol -> nat]" reduction nil)
    (symbol formal-nonempty-type-decl nil reduction nil)
    (variable formal-nonempty-type-decl nil reduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (terminating? const-decl "bool" noetherian nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (only_empty_seq const-decl "positions" positions nil)
    (subterm_empty_seq formula-decl nil subterm nil)
    (t skolem-const-decl "term[variable, symbol, arity]" reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil)))

