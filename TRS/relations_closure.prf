(relations_closure
 (RC_TCC1 0
  (RC_TCC1-1 nil 3370210023 ("" (subtype-tcc) nil nil)
   ((member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (reflexive? const-decl "bool" relations nil))
   nil))
 (change_to_RC 0
  (change_to_RC-1 nil 3375182313
   ("" (expand* "reflexive_closure" "RC") nil nil)
   ((RC const-decl "reflexive" relations_closure nil)
    (reflexive_closure const-decl "(reflexive?)" closure_ops
     "orders/"))
   shostak))
 (R_subset_RC 0
  (R_subset_RC-1 nil 3371210190
   ("" (skeep)
    (("" (expand* "subset?" "member")
      (("" (skeep)
        (("" (expand* "RC" "union" "member") (("" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (RC const-decl "reflexive" relations_closure nil))
   shostak))
 (RC_idempotent 0
  (RC_idempotent-1 nil 3370210197
   ("" (skeep)
    (("" (lemma "reflexive_closure_identity")
      (("" (inst -1 "RC(R)")
        (("" (rewrite-lemma "change_to_RC" ("R" "RC(R)")) nil nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil relations_closure nil)
    (reflexive_closure_identity formula-decl nil closure_ops "orders/")
    (change_to_RC formula-decl nil relations_closure nil)
    (RC const-decl "reflexive" relations_closure nil)
    (reflexive type-eq-decl nil relations_closure nil)
    (pred type-eq-decl nil defined_types nil)
    (reflexive? const-decl "bool" relations nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (RC_characterization 0
  (RC_characterization-1 nil 3370210321
   ("" (skeep)
    (("" (prop)
      (("1" (lemma "reflexive_closure_identity")
        (("1" (inst?)
          (("1" (rewrite-lemma "change_to_RC" ("R" "S"))
            (("1" (assert) nil nil)) nil))
          nil))
        nil)
       ("2" (assert) nil nil))
      nil))
    nil)
   ((S skolem-const-decl "pred[[T, T]]" relations_closure nil)
    (pred type-eq-decl nil defined_types nil)
    (reflexive? const-decl "bool" relations nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (change_to_RC formula-decl nil relations_closure nil)
    (reflexive_closure_identity formula-decl nil closure_ops "orders/")
    (T formal-type-decl nil relations_closure nil))
   shostak))
 (SC_TCC1 0
  (SC_TCC1-1 nil 3370210023 ("" (subtype-tcc) nil nil)
   ((member const-decl "bool" sets nil)
    (converse const-decl "pred[[T2, T1]]" relation_defs nil)
    (union const-decl "set" sets nil)
    (symmetric? const-decl "bool" relations nil))
   nil))
 (change_to_SC 0
  (change_to_SC-1 nil 3375182425
   ("" (expand* "symmetric_closure" "SC") nil nil)
   ((SC const-decl "symmetric" relations_closure nil)
    (symmetric_closure const-decl "(symmetric?)" closure_ops
     "orders/"))
   shostak))
 (R_subset_SC 0
  (R_subset_SC-1 nil 3371210082
   ("" (skeep)
    (("" (expand* "subset?" "member")
      (("" (skeep)
        (("" (expand* "SC" "union" "member") (("" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (SC const-decl "symmetric" relations_closure nil))
   shostak))
 (SC_idempotent 0
  (SC_idempotent-1 nil 3370210671
   ("" (skeep)
    (("" (lemma "symmetric_closure_identity")
      (("" (inst -1 "SC(R)")
        (("" (rewrite-lemma "change_to_SC" ("R" "SC(R)")) nil nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil relations_closure nil)
    (symmetric_closure_identity formula-decl nil closure_ops "orders/")
    (change_to_SC formula-decl nil relations_closure nil)
    (SC const-decl "symmetric" relations_closure nil)
    (symmetric type-eq-decl nil relations_closure nil)
    (pred type-eq-decl nil defined_types nil)
    (symmetric? const-decl "bool" relations nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (SC_characterization 0
  (SC_characterization-1 nil 3370210710
   ("" (skeep)
    (("" (prop)
      (("1" (lemma "symmetric_closure_identity")
        (("1" (inst?)
          (("1" (rewrite-lemma "change_to_SC" ("R" "S"))
            (("1" (assert) nil nil)) nil))
          nil))
        nil)
       ("2" (assert) nil nil))
      nil))
    nil)
   ((S skolem-const-decl "pred[[T, T]]" relations_closure nil)
    (pred type-eq-decl nil defined_types nil)
    (symmetric? const-decl "bool" relations nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (change_to_SC formula-decl nil relations_closure nil)
    (symmetric_closure_identity formula-decl nil closure_ops "orders/")
    (T formal-type-decl nil relations_closure nil))
   shostak))
 (TC_TCC1 0
  (TC_TCC1-1 nil 3370210023
   ("" (expand* "transitive?" "IUnion")
    (("" (skosimp*)
      (("" (forward-chain "iterate_add_applied") (("" (inst?) nil nil))
        nil))
      nil))
    nil)
   ((numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (T formal-type-decl nil relations_closure nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (iterate_add_applied formula-decl nil relation_iterate "orders/")
    (transitive? const-decl "bool" relations nil)
    (IUnion const-decl "set[T]" indexed_sets nil))
   nil))
 (change_to_TC 0
  (change_to_TC-1 nil 3375182475
   ("" (expand* "transitive_closure" "TC") nil nil)
   ((TC const-decl "transitive" relations_closure nil)
    (transitive_closure const-decl "(transitive?)" closure_ops
     "orders/"))
   shostak))
 (R_subset_TC 0
  (R_subset_TC-1 nil 3371210276
   ("" (skeep)
    (("" (expand* "subset?" "member")
      (("" (skeep)
        (("" (expand* "TC" "IUnion")
          (("" (inst 1 "1") (("" (rewrite "iterate_1") nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (IUnion const-decl "set[T]" indexed_sets nil)
    (TC const-decl "transitive" relations_closure nil)
    (T formal-type-decl nil relations_closure nil)
    (pred type-eq-decl nil defined_types nil)
    (iterate_1 formula-decl nil relation_iterate "orders/")
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (TC_converse 0
  (TC_converse-1 nil 3372708950
   ("" (skeep)
    (("" (decompose-equality)
      (("" (expand* "TC" "IUnion")
        (("" (iff)
          (("" (prop)
            (("1" (skolem * "i")
              (("1" (rewrite "iterate_converse")
                (("1" (expand "converse") (("1" (inst?) nil nil)) nil))
                nil))
              nil)
             ("2" (expand "converse" -1)
              (("2" (skolem * "i")
                (("2" (inst?)
                  (("2" (rewrite "iterate_converse")
                    (("2" (expand "converse") (("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((transitive_converse application-judgement "(transitive?[T])"
     relation_converse_props nil)
    (pred type-eq-decl nil defined_types nil)
    (transitive? const-decl "bool" relations nil)
    (transitive type-eq-decl nil relations_closure nil)
    (TC const-decl "transitive" relations_closure nil)
    (converse const-decl "pred[[T2, T1]]" relation_defs nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil relations_closure nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (iterate_converse formula-decl nil relation_iterate "orders/")
    (IUnion const-decl "set[T]" indexed_sets nil))
   shostak))
 (TC_idempotent 0
  (TC_idempotent-1 nil 3370214273
   ("" (skeep)
    (("" (lemma "transitive_closure_identity")
      (("" (inst -1 "TC(R)")
        (("" (rewrite-lemma "change_to_TC" ("R" "TC(R)")) nil nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil relations_closure nil)
    (transitive_closure_identity formula-decl nil closure_ops
     "orders/")
    (change_to_TC formula-decl nil relations_closure nil)
    (TC const-decl "transitive" relations_closure nil)
    (transitive type-eq-decl nil relations_closure nil)
    (pred type-eq-decl nil defined_types nil)
    (transitive? const-decl "bool" relations nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (TC_characterization 0
  (TC_characterization-1 nil 3370211587
   ("" (skeep)
    (("" (prop)
      (("1" (lemma "transitive_closure_identity")
        (("1" (inst?)
          (("1" (rewrite-lemma "change_to_TC" ("R" "S"))
            (("1" (assert) nil nil)) nil))
          nil))
        nil)
       ("2" (assert) nil nil))
      nil))
    nil)
   ((S skolem-const-decl "pred[[T, T]]" relations_closure nil)
    (pred type-eq-decl nil defined_types nil)
    (transitive? const-decl "bool" relations nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (change_to_TC formula-decl nil relations_closure nil)
    (transitive_closure_identity formula-decl nil closure_ops
     "orders/")
    (T formal-type-decl nil relations_closure nil))
   shostak))
 (RTC_TCC1 0
  (RTC_TCC1-1 nil 3370210023
   ("" (expand "reflexive_transitive?")
    (("" (skolem!)
      (("" (split)
        (("1" (expand* "reflexive?" "IUnion")
          (("1" (skolem!)
            (("1" (inst + "0")
              (("1" (expand "iterate") (("1" (propax) nil nil)) nil))
              nil))
            nil))
          nil)
         ("2" (expand* "transitive?" "IUnion")
          (("2" (skosimp*)
            (("2" (forward-chain "iterate_add_applied")
              (("2" (inst?) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((transitive? const-decl "bool" relations nil)
    (iterate_add_applied formula-decl nil relation_iterate "orders/")
    (pred type-eq-decl nil defined_types nil)
    (T formal-type-decl nil relations_closure nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (IUnion const-decl "set[T]" indexed_sets nil)
    (reflexive? const-decl "bool" relations nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (iterate def-decl "pred[[T, T]]" relation_iterate "orders/")
    (reflexive_transitive? const-decl "bool" relations_closure nil))
   nil))
 (change_to_RTC 0
  (change_to_RTC-1 nil 3375182493
   ("" (expand* "preorder_closure" "RTC") nil nil)
   ((RTC const-decl "reflexive_transitive" relations_closure nil)
    (preorder_closure const-decl "(preorder?)" closure_ops "orders/"))
   shostak))
 (R_subset_RTC 0
  (R_subset_RTC-1 nil 3371209765
   ("" (skeep)
    (("" (expand* "subset?" "member")
      (("" (skeep)
        (("" (expand* "RTC" "IUnion")
          (("" (inst 1 "1") (("" (rewrite "iterate_1") nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (IUnion const-decl "set[T]" indexed_sets nil)
    (RTC const-decl "reflexive_transitive" relations_closure nil)
    (T formal-type-decl nil relations_closure nil)
    (pred type-eq-decl nil defined_types nil)
    (iterate_1 formula-decl nil relation_iterate "orders/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (iterate_RTC 0
  (iterate_RTC-1 nil 3372720815
   ("" (skeep)
    (("" (expand* "subset?" "member" "RTC" "IUnion")
      (("" (skeep) (("" (inst 1 "n") nil nil)) nil)) nil))
    nil)
   ((member const-decl "bool" sets nil)
    (IUnion const-decl "set[T]" indexed_sets nil)
    (RTC const-decl "reflexive_transitive" relations_closure nil)
    (subset? const-decl "bool" sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   shostak))
 (RTC_idempotent 0
  (RTC_idempotent-1 nil 3370216879
   ("" (skeep)
    (("" (lemma " preorder_closure_identity")
      (("" (inst -1 "RTC(R)")
        (("1" (rewrite-lemma "change_to_RTC" ("R" "RTC(R)")) nil nil)
         ("2" (assert)
          (("2" (expand "preorder?")
            (("2" (hide 2)
              (("2" (typepred "RTC(R)")
                (("2" (expand "reflexive_transitive?")
                  (("2" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil relations_closure nil)
    (preorder_closure_identity formula-decl nil closure_ops "orders/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (change_to_RTC formula-decl nil relations_closure nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive_transitive? const-decl "bool" relations_closure nil)
    (reflexive_transitive type-eq-decl nil relations_closure nil)
    (RTC const-decl "reflexive_transitive" relations_closure nil)
    (R skolem-const-decl "pred[[T, T]]" relations_closure nil))
   shostak))
 (RTC_characterization 0
  (RTC_characterization-1 nil 3370216958
   ("" (skeep)
    (("" (prop)
      (("1" (lemma " preorder_closure_identity")
        (("1" (inst?)
          (("1" (rewrite-lemma "change_to_RTC" ("R" "S"))
            (("1" (assert) nil nil)) nil)
           ("2" (expand* "reflexive_transitive?" "preorder?") nil nil))
          nil))
        nil)
       ("2" (assert) nil nil))
      nil))
    nil)
   ((S skolem-const-decl "pred[[T, T]]" relations_closure nil)
    (preorder? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (change_to_RTC formula-decl nil relations_closure nil)
    (reflexive_transitive? const-decl "bool" relations_closure nil)
    (preorder_closure_identity formula-decl nil closure_ops "orders/")
    (T formal-type-decl nil relations_closure nil))
   shostak))
 (EC_TCC1 0
  (EC_TCC1-1 nil 3375182313
   ("" (skeep)
    (("" (lemma "preorder_closure_preserves_symmetry")
      (("" (inst -1 "SC(R)")
        (("" (rewrite-lemma "change_to_RTC" ("R" "SC(R)")) nil nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil relations_closure nil)
    (preorder_closure_preserves_symmetry judgement-tcc nil closure_ops
     "orders/")
    (change_to_RTC formula-decl nil relations_closure nil)
    (SC const-decl "symmetric" relations_closure nil)
    (symmetric type-eq-decl nil relations_closure nil)
    (pred type-eq-decl nil defined_types nil)
    (symmetric? const-decl "bool" relations nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (change_to_EC 0
  (change_to_EC-1 nil 3375182512
   ("" (skeep)
    (("" (expand* "equivalence_closure" "EC")
      (("" (rewrite-lemma "change_to_SC" ("R" "R"))
        (("" (rewrite-lemma "change_to_RTC" ("R" "SC(R)")) nil nil))
        nil))
      nil))
    nil)
   ((EC const-decl "equivalence" relations_closure nil)
    (equivalence_closure const-decl "(equivalence?)" closure_ops
     "orders/")
    (change_to_RTC formula-decl nil relations_closure nil)
    (PRED type-eq-decl nil defined_types nil)
    (symmetric? const-decl "bool" relations nil)
    (symmetric type-eq-decl nil relations_closure nil)
    (SC const-decl "symmetric" relations_closure nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil relations_closure nil)
    (change_to_SC formula-decl nil relations_closure nil))
   shostak))
 (R_subset_EC 0
  (R_subset_EC-1 nil 3371210430
   ("" (skeep)
    (("" (lemma "R_subset_SC")
      (("" (inst?)
        (("" (expand* "subset?" "member")
          (("" (skeep)
            (("" (inst?)
              (("" (expand "EC")
                (("" (expand* "RTC" "IUnion")
                  (("" (inst 1 "1")
                    (("" (rewrite "iterate_1") (("" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((R_subset_SC formula-decl nil relations_closure nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (IUnion const-decl "set[T]" indexed_sets nil)
    (RTC const-decl "reflexive_transitive" relations_closure nil)
    (SC const-decl "symmetric" relations_closure nil)
    (symmetric type-eq-decl nil relations_closure nil)
    (symmetric? const-decl "bool" relations nil)
    (PRED type-eq-decl nil defined_types nil)
    (iterate_1 formula-decl nil relation_iterate "orders/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (EC const-decl "equivalence" relations_closure nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil relations_closure nil))
   shostak))
 (RTC_subset_EC 0
  (RTC_subset_EC-1 nil 3372883240
   ("" (skeep)
    (("" (expand "EC")
      (("" (lemma "R_subset_SC")
        (("" (inst?)
          (("" (lemma "preorder_closure_is_monotone")
            (("" (inst -1 "R" "SC(R)")
              (("" (rewrite-lemma "change_to_RTC" ("R" "R"))
                (("" (rewrite-lemma "change_to_RTC" ("R" "SC(R)"))
                  (("" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((EC const-decl "equivalence" relations_closure nil)
    (T formal-type-decl nil relations_closure nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (PRED type-eq-decl nil defined_types nil)
    (symmetric? const-decl "bool" relations nil)
    (symmetric type-eq-decl nil relations_closure nil)
    (SC const-decl "symmetric" relations_closure nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (change_to_RTC formula-decl nil relations_closure nil)
    (preorder_closure_is_monotone formula-decl nil closure_ops
     "orders/")
    (R_subset_SC formula-decl nil relations_closure nil))
   shostak))
 (EC_idempotent 0
  (EC_idempotent-1 nil 3370261011
   ("" (skeep)
    (("" (lemma "equivalence_closure_identity")
      (("" (inst -1 "EC(R)")
        (("" (rewrite-lemma "change_to_EC" ("R" "EC(R)")) nil nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil relations_closure nil)
    (equivalence_closure_identity formula-decl nil closure_ops
     "orders/")
    (change_to_EC formula-decl nil relations_closure nil)
    (EC const-decl "equivalence" relations_closure nil)
    (equivalence type-eq-decl nil relations_closure nil)
    (pred type-eq-decl nil defined_types nil)
    (equivalence? const-decl "bool" relations nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (EC_characterization 0
  (EC_characterization-1 nil 3370261180
   ("" (skeep)
    (("" (prop)
      (("1" (lemma "equivalence_closure_identity")
        (("1" (inst?)
          (("1" (rewrite-lemma "change_to_EC" ("R" "S"))
            (("1" (assert) nil nil)) nil))
          nil))
        nil)
       ("2" (assert) nil nil))
      nil))
    nil)
   ((S skolem-const-decl "pred[[T, T]]" relations_closure nil)
    (pred type-eq-decl nil defined_types nil)
    (equivalence? const-decl "bool" relations nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (change_to_EC formula-decl nil relations_closure nil)
    (equivalence_closure_identity formula-decl nil closure_ops
     "orders/")
    (T formal-type-decl nil relations_closure nil))
   shostak))
 (RTC_vs_TC 0
  (RTC_vs_TC-1 nil 3744642801
   ("" (skeep)
    (("" (expand "union")
      (("" (decompose-equality)
        (("" (expand "RTC")
          (("" (expand "TC")
            (("" (expand "IUnion")
              (("" (iff)
                (("" (prop)
                  (("1" (skeep)
                    (("1" (case-replace "i=0")
                      (("1" (expand "iterate")
                        (("1" (expand "member")
                          (("1" (propax) nil nil)) nil))
                        nil)
                       ("2" (hide 2)
                        (("2" (expand "member")
                          (("2" (inst?) (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inst 1 "0") (("2" (grind) nil nil)) nil)
                   ("3" (expand "member")
                    (("3" (skeep) (("3" (inst?) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((union const-decl "set" sets nil)
    (IUnion const-decl "set[T]" indexed_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (iterate def-decl "pred[[T, T]]" relation_iterate "orders/")
    (i skolem-const-decl "nat" relations_closure nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (T formal-type-decl nil relations_closure nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (TC const-decl "transitive" relations_closure nil)
    (transitive type-eq-decl nil relations_closure nil)
    (transitive? const-decl "bool" relations nil)
    (PRED type-eq-decl nil defined_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (RTC const-decl "reflexive_transitive" relations_closure nil)
    (reflexive_transitive type-eq-decl nil relations_closure nil)
    (reflexive_transitive? const-decl "bool" relations_closure nil))
   shostak))
 (Closure_monotony 0
  (Closure_monotony-1 nil 3744642575
   ("" (skeep)
    (("" (split)
      (("1" (expand "SC")
        (("1" (expand "union")
          (("1" (expand "member")
            (("1" (expand "subset?")
              (("1" (copy -1)
                (("1" (skeep)
                  (("1" (inst? -1)
                    (("1" (prop)
                      (("1" (expand "member") (("1" (assert) nil nil))
                        nil)
                       ("2" (expand "member")
                        (("2" (assert)
                          (("2" (expand "converse")
                            (("2" (inst -2 "(x_1`2, x_1`1)")
                              (("2"
                                (assert)
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide -1)
        (("2" (grind)
          (("2" (reveal -1)
            (("2" (expand "subset?")
              (("2" (inst?)
                (("2" (expand "member") (("2" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (lemma "transitive_closure_is_monotone")
        (("3" (inst -1 "R" "S")
          (("3" (assert)
            (("3" (rewrite "change_to_TC")
              (("3" (rewrite "change_to_TC") nil nil)) nil))
            nil))
          nil))
        nil)
       ("4" (rewrite "RTC_vs_TC")
        (("4" (rewrite "RTC_vs_TC")
          (("4" (expand "union")
            (("4" (expand "subset?")
              (("4" (skeep)
                (("4" (expand "member")
                  (("4" (assert)
                    (("4" (prop)
                      (("4" (lemma "transitive_closure_is_monotone")
                        (("4" (inst -1 "R" "S")
                          (("4" (expand "subset?")
                            (("4" (expand "member")
                              (("4"
                                (assert)
                                (("4"
                                  (prop)
                                  (("4"
                                    (rewrite "change_to_TC")
                                    (("4"
                                      (rewrite "change_to_TC")
                                      (("4"
                                        (inst?)
                                        (("4" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("5" (expand "subset?")
        (("5" (expand "EC")
          (("5" (expand "RTC")
            (("5" (expand "IUnion")
              (("5" (skeep)
                (("5" (expand "member")
                  (("5" (skeep)
                    (("5" (inst?)
                      (("5" (generalize "x" "x" :fnums (-1 1))
                        (("5" (generalize "i" "i" :fnums (1))
                          (("5" (induct "i")
                            (("1" (skeep) (("1" (grind) nil nil)) nil)
                             ("2" (skeep)
                              (("2"
                                (skeep)
                                (("2"
                                  (rewrite "iterate_add_one")
                                  (("2"
                                    (rewrite "iterate_add_one")
                                    (("2"
                                      (expand "o ")
                                      (("2"
                                        (skeep)
                                        (("2"
                                          (inst -1 "(y, x!1`2)")
                                          (("2"
                                            (assert)
                                            (("2"
                                              (inst 1 "y")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (hide -1 -3)
                                                  (("2"
                                                    (expand "SC")
                                                    (("2"
                                                      (expand "union")
                                                      (("2"
                                                        (expand
                                                         "member")
                                                        (("2"
                                                          (expand
                                                           "converse")
                                                          (("2"
                                                            (prop)
                                                            (("1"
                                                              (inst
                                                               -2
                                                               "(x!1`1, y)")
                                                              (("1"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (inst
                                                               -2
                                                               "(y, x!1`1)")
                                                              (("2"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((union const-decl "set" sets nil)
    (subset? const-decl "bool" sets nil)
    (converse const-decl "pred[[T2, T1]]" relation_defs nil)
    (T formal-type-decl nil relations_closure nil)
    (member const-decl "bool" sets nil)
    (SC const-decl "symmetric" relations_closure nil)
    (RC const-decl "reflexive" relations_closure nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (change_to_TC formula-decl nil relations_closure nil)
    (transitive_closure_is_monotone formula-decl nil closure_ops
     "orders/")
    (RTC_vs_TC formula-decl nil relations_closure nil)
    (EC const-decl "equivalence" relations_closure nil)
    (IUnion const-decl "set[T]" indexed_sets nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (iterate_add_one formula-decl nil relation_iterate "orders/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (O const-decl "bool" relation_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (iterate def-decl "pred[[T, T]]" relation_iterate "orders/")
    (PRED type-eq-decl nil defined_types nil)
    (symmetric? const-decl "bool" relations nil)
    (symmetric type-eq-decl nil relations_closure nil)
    (RTC const-decl "reflexive_transitive" relations_closure nil))
   nil))
 (seq_of_relation_RTC 0
  (seq_of_relation_RTC-1 nil 3755567562
   ("" (skeep)
    (("" (measure-induct+ "j-i" ("i" "j"))
      (("" (case "x!1 = x!2")
        (("1" (hide -2 -3)
          (("1" (expand "RTC")
            (("1" (expand "IUnion")
              (("1" (inst 1 0)
                (("1" (expand "iterate") (("1" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (inst -1 "x!1" "x!2 - 1")
          (("1" (assert)
            (("1" (expand "RTC")
              (("1" (expand "IUnion")
                (("1" (assert)
                  (("1" (prop)
                    (("1" (skeep)
                      (("1" (inst 2 "i+1")
                        (("1" (lemma "iterate_add")
                          (("1" (inst -1 "R" "i" "1")
                            (("1" (replaces -1)
                              (("1"
                                (expand "o ")
                                (("1"
                                  (inst 2 "seq(x!2 - 1)")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (hide -1)
                                      (("1"
                                        (expand "iterate")
                                        (("1"
                                          (expand "iterate")
                                          (("1"
                                            (expand "o ")
                                            (("1"
                                              (inst -1 "x!2 - 1")
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (inst
                                                   2
                                                   "seq(x!2 - 1)")
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide 3)
                      (("2" (skeep* :preds? t)
                        (("2" (inst -3 "k") nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-type-decl nil relations_closure nil)
    (sequence type-eq-decl nil sequences nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (reflexive_transitive? const-decl "bool" relations_closure nil)
    (reflexive_transitive type-eq-decl nil relations_closure nil)
    (RTC const-decl "reflexive_transitive" relations_closure nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (x!1 skolem-const-decl "nat" relations_closure nil)
    (x!2 skolem-const-decl "{j: nat | j >= x!1}" relations_closure nil)
    (iterate_add formula-decl nil relation_iterate "orders/")
    (TRUE const-decl "bool" booleans nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (O const-decl "bool" relation_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (IUnion const-decl "set[T]" indexed_sets nil)
    (iterate def-decl "pred[[T, T]]" relation_iterate "orders/"))
   nil))
 (finseq_to_RTC_TCC1 0
  (finseq_to_RTC_TCC1-1 nil 3757155964 ("" (subtype-tcc) nil nil) nil
   nil))
 (finseq_to_RTC_TCC2 0
  (finseq_to_RTC_TCC2-1 nil 3757155964 ("" (subtype-tcc) nil nil) nil
   nil))
 (finseq_to_RTC 0
  (finseq_to_RTC-1 nil 3757155966
   ("" (auto-rewrite "finseq_appl")
    (("" (assert)
      (("" (skeep)
        (("" (measure-induct "j-i" ("i" "j"))
          (("1" (skeep* :preds? t)
            (("1" (case "x_1 = x_2")
              (("1" (hide-all-but (-1 1))
                (("1" (expand "RTC")
                  (("1" (expand "IUnion")
                    (("1" (inst 1 0)
                      (("1" (expand "iterate") (("1" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (inst -4 "x_1" "x_2 - 1")
                (("1" (assert)
                  (("1" (prop)
                    (("1" (expand "RTC")
                      (("1" (expand "IUnion")
                        (("1" (assert)
                          (("1" (skeep)
                            (("1" (inst 2 "i+1")
                              (("1"
                                (lemma "iterate_add")
                                (("1"
                                  (inst -1 "R" "i" "1")
                                  (("1"
                                    (replaces -1)
                                    (("1"
                                      (expand "o ")
                                      (("1"
                                        (inst 2 "seq(x_2 - 1)")
                                        (("1"
                                          (assert)
                                          (("1"
                                            (inst -5 "x_2 - 1")
                                            (("1"
                                              (expand "iterate")
                                              (("1"
                                                (expand "iterate")
                                                (("1"
                                                  (expand "o ")
                                                  (("1"
                                                    (inst? 2)
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide-all-but (-4 1))
                      (("2" (skeep) (("2" (inst?) nil nil)) nil)) nil))
                    nil))
                  nil)
                 ("2" (assert) nil nil))
                nil))
              nil))
            nil)
           ("2" (hide 2)
            (("2" (skeep* :preds? t) (("2" (grind) nil nil)) nil)) nil)
           ("3" (hide 2) (("3" (grind) nil nil)) nil)
           ("4" (hide 2) (("4" (grind) nil nil)) nil)
           ("5" (hide 2) (("5" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (T formal-type-decl nil relations_closure nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (reflexive_transitive? const-decl "bool" relations_closure nil)
    (reflexive_transitive type-eq-decl nil relations_closure nil)
    (RTC const-decl "reflexive_transitive" relations_closure nil)
    (iterate def-decl "pred[[T, T]]" relation_iterate "orders/")
    (IUnion const-decl "set[T]" indexed_sets nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (O const-decl "bool" relation_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (iterate_add formula-decl nil relation_iterate "orders/")
    (x_2 skolem-const-decl "{j: nat | j < length(seq) AND j >= x_1}"
     relations_closure nil)
    (x_1 skolem-const-decl "{i: nat | i < length(seq)}"
     relations_closure nil)
    (seq skolem-const-decl "{seq: finseq[T] | NOT seq = empty_seq}"
     relations_closure nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (iterate_to_finseq_TCC1 0
  (iterate_to_finseq_TCC1-1 nil 3757153530 ("" (subtype-tcc) nil nil)
   nil nil))
 (iterate_to_finseq_TCC2 0
  (iterate_to_finseq_TCC2-1 nil 3757153530 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (iterate_to_finseq_TCC3 0
  (iterate_to_finseq_TCC3-1 nil 3757153530 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (iterate_to_finseq_TCC4 0
  (iterate_to_finseq_TCC4-1 nil 3757153530 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (iterate_to_finseq_TCC5 0
  (iterate_to_finseq_TCC5-1 nil 3757153530 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (iterate_to_finseq 0
  (iterate_to_finseq-1 nil 3755567588
   ("" (induct "i")
    (("1" (skeep)
      (("1" (expand "finseq_appl")
        (("1" (inst 1 "#(x)")
          (("1" (grind) nil nil)
           ("2" (hide -) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("2" (skeep* :preds? t)
      (("2" (expand "iterate" -3)
        (("2" (expand "finseq_appl")
          (("2" (expand "o ")
            (("2" (skeep)
              (("2" (inst -2 "x" "y_1" "R")
                (("2" (assert)
                  (("2" (skeep)
                    (("2" (inst 1 "seq o #(y)")
                      (("1" (expand "o ")
                        (("1" (assert)
                          (("1" (lift-if)
                            (("1" (assert)
                              (("1"
                                (prop)
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand "#")
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (expand "#")
                                  (("2" (assert) nil nil))
                                  nil)
                                 ("3"
                                  (hide-all-but 1)
                                  (("3" (grind) nil nil))
                                  nil)
                                 ("4"
                                  (skeep)
                                  (("4"
                                    (lift-if)
                                    (("4"
                                      (lift-if)
                                      (("4"
                                        (prop)
                                        (("1"
                                          (inst -6 "k")
                                          (("1" (assert) nil nil))
                                          nil)
                                         ("2"
                                          (case-replace
                                           "k = seq`length - 1")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (expand "#")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil)
                                           ("2" (assert) nil nil))
                                          nil)
                                         ("3"
                                          (lift-if)
                                          (("3"
                                            (assert)
                                            (("3"
                                              (typepred "k")
                                              (("3"
                                                (expand "o ")
                                                (("3"
                                                  (expand "#")
                                                  (("3"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (typepred "seq")
                        (("2" (expand "o")
                          (("2" (expand "#") (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (O const-decl "finseq" finite_sequences nil)
    (j skolem-const-decl "nat" relations_closure nil)
    (seq skolem-const-decl "{seq: finseq[T] | length(seq) = 1 + j}"
     relations_closure nil)
    (y skolem-const-decl "T" relations_closure nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (k skolem-const-decl "below[length(seq o  #(y)) - 1]"
     relations_closure nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (O const-decl "bool" relation_props nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (|#| const-decl "finite_sequence[T]" set2seq "structures/")
    (x skolem-const-decl "T" relations_closure nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (iterate def-decl "pred[[T, T]]" relation_iterate "orders/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-type-decl nil relations_closure nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil)))

