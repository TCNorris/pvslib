(csequence_filter
 (filter_TCC1 0
  (filter_TCC1-1 nil 3513634660
   ("" (skolem!)
    (("" (lemma "subsequence?_coinduction")
      ((""
        (inst -
         "LAMBDA cseq1, cseq2: cseq1 = coreduce[T, [csequence, pred[T]]](filter_struct)(cseq2, p!1)")
        (("" (split)
          (("1"
            (inst -
             "coreduce[T, [csequence, pred[T]]](filter_struct)(cseq!1, p!1)"
             "cseq!1")
            nil nil)
           ("2" (delete 2)
            (("2" (skosimp)
              (("2" (expand "coreduce" -)
                (("2" (lift-if)
                  (("2" (ground)
                    (("2" (decompose-equality)
                      (("2" (expand "filter_struct" (-1 1))
                        (("2" (expand "filter_struct" -2 2)
                          (("2" (reduce) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil csequence_filter nil)
    (subsequence?_coinduction formula-decl nil csequence_subsequence nil)
    (first adt-accessor-decl "[(nonempty?) -> T]" csequence_codt nil)
    (add adt-constructor-decl "[[T, csequence] -> (nonempty?)]" csequence_codt
     nil)
    (inj_first adt-accessor-decl "[(inj_nonempty?) -> T]"
     csequence_codt_coreduce nil)
    (inj_rest adt-accessor-decl "[(inj_nonempty?) -> domain]"
     csequence_codt_coreduce nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (PRED type-eq-decl nil defined_types nil)
    (some inductive-decl "boolean" csequence_codt nil)
    (p!1 skolem-const-decl "pred[T]" csequence_filter nil)
    (cseq2!1 skolem-const-decl "csequence[T]" csequence_filter nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (index? def-decl "bool" csequence_nth nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (first_p const-decl "indexes(cseq)" csequence_first_p nil)
    (filter_struct const-decl "csequence_struct[T, [csequence, pred[T]]]"
     csequence_filter nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (inj_nonempty? adt-recognizer-decl "[csequence_struct -> boolean]"
     csequence_codt_coreduce nil)
    (empty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt nil)
    (inj_empty? adt-recognizer-decl "[csequence_struct -> boolean]"
     csequence_codt_coreduce nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (csequence_struct type-decl nil csequence_codt_coreduce nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (csequence type-decl nil csequence_codt nil))
   nil
   (filter subtype
    "csequence_codt_coreduce[csequence_filter.T, [csequence_codt[csequence_filter.T].csequence, pred[T]]].coreduce(csequence_filter.filter_struct)(csequence_filter.cseq, csequence_filter.p)"
    "(LAMBDA (cseq1: csequence_codt[csequence_filter.T].csequence): csequence_subsequence[csequence_filter.T].subsequence?(cseq1, csequence_filter.cseq))")))
 (filter_empty 0
  (filter_empty-1 nil 3513634759
   ("" (expand* "filter" "filter_struct" "coreduce" "some") nil nil)
   ((some inductive-decl "boolean" csequence_codt nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (filter_struct const-decl "csequence_struct[T, [csequence, pred[T]]]"
     csequence_filter nil)
    (filter const-decl
     "(LAMBDA (cseq1: csequence[T]): subsequence?(cseq1, cseq))"
     csequence_filter nil))
   shostak))
 (filter_nonempty 0
  (filter_nonempty-1 nil 3513634777
   ("" (expand* "filter" "filter_struct" "coreduce") (("" (reduce) nil nil))
    nil)
   ((filter const-decl
     "(LAMBDA (cseq1: csequence[T]): subsequence?(cseq1, cseq))"
     csequence_filter nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (filter_struct const-decl "csequence_struct[T, [csequence, pred[T]]]"
     csequence_filter nil))
   shostak))
 (filter_def 0
  (filter_def-1 nil 3513635390
   ("" (skolem!)
    (("" (lemma "every_weak_coinduction")
      ((""
        (inst - "p!1"
         "LAMBDA cseq: EXISTS (cseq2: csequence): cseq = filter(cseq2, p!1)")
        (("" (split)
          (("1" (inst - "filter(cseq!1, p!1)")
            (("1" (assert) (("1" (inst + "cseq!1") nil nil)) nil)) nil)
           ("2" (delete 2)
            (("2" (skosimp*)
              (("2" (replace -1)
                (("2" (hide -1)
                  (("2" (lift-if)
                    (("2" (ground)
                      (("1"
                        (expand* "filter" "filter_struct" "coreduce" "first_p"
                         "p_indexes")
                        (("1" (reduce) nil nil)) nil)
                       ("2" (expand* "filter" "filter_struct")
                        (("2" (expand "coreduce" 1 1)
                          (("2" (expand "coreduce" 2)
                            (("2" (smash)
                              (("2"
                                (inst +
                                 "suffix(cseq2!1, 1 + first_p(p!1, cseq2!1))")
                                nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil csequence_filter nil)
    (every_weak_coinduction formula-decl nil csequence_codt nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (p_indexes const-decl "set[indexes[T](cseq)]" csequence_first_p nil)
    (first_p const-decl "indexes(cseq)" csequence_first_p nil)
    (filter_struct const-decl "csequence_struct[T, [csequence, pred[T]]]"
     csequence_filter nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (index? def-decl "bool" csequence_nth nil)
    (some inductive-decl "boolean" csequence_codt nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (suffix def-decl "(LAMBDA (cseq1: csequence): suffix?(cseq1, cseq))"
     csequence_suffix nil)
    (suffix? inductive-decl "bool" csequence_suffix nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (filter const-decl
     "(LAMBDA (cseq1: csequence[T]): subsequence?(cseq1, cseq))"
     csequence_filter nil)
    (subsequence? coinductive-decl "bool" csequence_subsequence nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (csequence type-decl nil csequence_codt nil)
    (pred type-eq-decl nil defined_types nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (filter_finite 0
  (filter_finite-1 nil 3513634660
   ("" (skolem!)
    (("" (typepred "filter(fseq!1, p!1)")
      (("" (forward-chain "subsequence?_finite") nil nil)) nil))
    nil)
   ((finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (filter const-decl
     "(LAMBDA (cseq1: csequence[T]): subsequence?(cseq1, cseq))"
     csequence_filter nil)
    (pred type-eq-decl nil defined_types nil)
    (subsequence? coinductive-decl "bool" csequence_subsequence nil)
    (csequence type-decl nil csequence_codt nil)
    (T formal-type-decl nil csequence_filter nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (subsequence?_finite formula-decl nil csequence_subsequence nil))
   nil
   (filter_finite subtype
    "csequence_filter.filter(csequence_filter.fseq, csequence_filter.p)"
    "finite_csequence[T]")))
 (filter_length 0
  (filter_length-1 nil 3513635531
   ("" (skolem!)
    (("" (typepred "filter(fseq!1, p!1)")
      (("" (forward-chain "subsequence?_length") nil nil)) nil))
    nil)
   ((finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (filter const-decl
     "(LAMBDA (cseq1: csequence[T]): subsequence?(cseq1, cseq))"
     csequence_filter nil)
    (pred type-eq-decl nil defined_types nil)
    (subsequence? coinductive-decl "bool" csequence_subsequence nil)
    (csequence type-decl nil csequence_codt nil)
    (T formal-type-decl nil csequence_filter nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (filter_finite application-judgement "finite_csequence" csequence_filter
     nil)
    (subsequence?_length formula-decl nil csequence_subsequence nil))
   shostak))
 (filter_length_eq 0
  (filter_length_eq-1 nil 3513635549
   ("" (skosimp)
    (("" (typepred "filter(fseq!1, p!1)")
      (("" (forward-chain "subsequence?_length_eq") nil nil)) nil))
    nil)
   ((finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (filter const-decl
     "(LAMBDA (cseq1: csequence[T]): subsequence?(cseq1, cseq))"
     csequence_filter nil)
    (pred type-eq-decl nil defined_types nil)
    (subsequence? coinductive-decl "bool" csequence_subsequence nil)
    (csequence type-decl nil csequence_codt nil)
    (T formal-type-decl nil csequence_filter nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (filter_finite application-judgement "finite_csequence" csequence_filter
     nil)
    (subsequence?_length_eq formula-decl nil csequence_subsequence nil))
   shostak))
 (filter_reduce_TCC1 0
  (filter_reduce_TCC1-1 nil 3513634660 ("" (subtype-tcc) nil nil) nil nil
   (filter_reduce subtype "csequence_filter.cseq"
    "(csequence_codt[csequence_filter.T].nonempty?)")))
 (filter_reduce 0
  (filter_reduce-1 nil 3513635573
   ("" (skosimp)
    (("" (expand* "filter" "filter_struct" "coreduce")
      (("" (smash)
        (("1" (forward-chain "first_p_rest")
          (("1" (assert)
            (("1" (replace -1)
              (("1" (expand "nth" 3 1)
                (("1" (decompose-equality)
                  (("1" (rewrite "suffix_rest1") nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "some" -) (("2" (propax) nil nil)) nil)
         ("3" (expand "some" +) (("3" (propax) nil nil)) nil))
        nil))
      nil))
    nil)
   ((filter_struct const-decl "csequence_struct[T, [csequence, pred[T]]]"
     csequence_filter nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (filter const-decl
     "(LAMBDA (cseq1: csequence[T]): subsequence?(cseq1, cseq))"
     csequence_filter nil)
    (first_p_rest formula-decl nil csequence_first_p nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (T formal-type-decl nil csequence_filter nil)
    (add adt-constructor-decl "[[T, csequence] -> (nonempty?)]" csequence_codt
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (index? def-decl "bool" csequence_nth nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (PRED type-eq-decl nil defined_types nil)
    (some inductive-decl "boolean" csequence_codt nil)
    (first_p const-decl "indexes(cseq)" csequence_first_p nil)
    (csequence_struct type-decl nil csequence_codt_coreduce nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (inj_empty? adt-recognizer-decl "[csequence_struct -> boolean]"
     csequence_codt_coreduce nil)
    (empty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt nil)
    (inj_nonempty? adt-recognizer-decl "[csequence_struct -> boolean]"
     csequence_codt_coreduce nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (inj_add adt-constructor-decl "[[T, domain] -> (inj_nonempty?)]"
     csequence_codt_coreduce nil)
    (suffix? inductive-decl "bool" csequence_suffix nil)
    (suffix def-decl "(LAMBDA (cseq1: csequence): suffix?(cseq1, cseq))"
     csequence_suffix nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (inj_empty_cseq adt-constructor-decl "(inj_empty?)"
     csequence_codt_coreduce nil)
    (csequence_add_extensionality formula-decl nil csequence_codt nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (suffix_rest1 formula-decl nil csequence_suffix nil)
    (nonempty_csequence type-eq-decl nil csequence_props nil)
    (nth def-decl "T" csequence_nth nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil))
   shostak))
 (filter_add 0
  (filter_add-1 nil 3513635645
   ("" (skolem!)
    (("" (lift-if)
      (("" (prop)
        (("1" (case "first_p(p!1, add(t!1, cseq!1)) = 0")
          (("1" (expand* "filter" "filter_struct")
            (("1" (expand "coreduce" 1 1)
              (("1" (smash)
                (("1" (expand "nth" 1 1)
                  (("1" (decompose-equality)
                    (("1" (expand "suffix" 1 2)
                      (("1" (expand "suffix" 1 2) (("1" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "some") (("2" (propax) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (expand* "first_p" "p_indexes")
            (("2" (rewrite "min_def")
              (("1" (expand* "minimum?" "nth") nil nil)
               ("2" (expand* "nonempty?" "empty?" "member")
                (("2" (inst - 0)
                  (("1" (expand "nth") (("1" (propax) nil nil)) nil)
                   ("2" (expand "index?") (("2" (propax) nil nil)) nil))
                  nil))
                nil)
               ("3" (expand "index?") (("3" (propax) nil nil)) nil))
              nil))
            nil)
           ("3" (expand "some") (("3" (flatten) nil nil)) nil))
          nil)
         ("2" (use "filter_reduce") (("2" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((filter_reduce formula-decl nil csequence_filter nil)
    (add adt-constructor-decl "[[T, csequence] -> (nonempty?)]" csequence_codt
     nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (first_p const-decl "indexes(cseq)" csequence_first_p nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (index? def-decl "bool" csequence_nth nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (some inductive-decl "boolean" csequence_codt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (pred type-eq-decl nil defined_types nil)
    (T formal-type-decl nil csequence_filter nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (nth def-decl "T" csequence_nth nil)
    (csequence_add_extensionality formula-decl nil csequence_codt nil)
    (inj_empty_cseq adt-constructor-decl "(inj_empty?)"
     csequence_codt_coreduce nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (suffix def-decl "(LAMBDA (cseq1: csequence): suffix?(cseq1, cseq))"
     csequence_suffix nil)
    (suffix? inductive-decl "bool" csequence_suffix nil)
    (inj_add adt-constructor-decl "[[T, domain] -> (inj_nonempty?)]"
     csequence_codt_coreduce nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (inj_nonempty? adt-recognizer-decl "[csequence_struct -> boolean]"
     csequence_codt_coreduce nil)
    (empty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt nil)
    (inj_empty? adt-recognizer-decl "[csequence_struct -> boolean]"
     csequence_codt_coreduce nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (csequence_struct type-decl nil csequence_codt_coreduce nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (filter const-decl
     "(LAMBDA (cseq1: csequence[T]): subsequence?(cseq1, cseq))"
     csequence_filter nil)
    (filter_struct const-decl "csequence_struct[T, [csequence, pred[T]]]"
     csequence_filter nil)
    (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (min_def formula-decl nil min_nat nil)
    (minimum? const-decl "bool" min_nat nil)
    (t!1 skolem-const-decl "T" csequence_filter nil)
    (cseq!1 skolem-const-decl "csequence[T]" csequence_filter nil)
    (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (p_indexes const-decl "set[indexes[T](cseq)]" csequence_first_p nil))
   shostak))
 (filter_rest_TCC1 0
  (filter_rest_TCC1-1 nil 3513634660
   ("" (skosimp)
    (("" (rewrite "filter_nonempty" :dir rl)
      (("" (expand "some") (("" (flatten) nil nil)) nil)) nil))
    nil)
   ((filter_nonempty formula-decl nil csequence_filter nil)
    (T formal-type-decl nil csequence_filter nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (nonempty_csequence type-eq-decl nil csequence_props nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (some inductive-decl "boolean" csequence_codt nil))
   nil
   (filter_rest subtype
    "csequence_filter.filter(csequence_filter.nseq, csequence_filter.p)"
    "(csequence_codt[csequence_filter.T].nonempty?)")))
 (filter_rest 0
  (filter_rest-1 nil 3513635781
   ("" (skolem!)
    (("" (lemma "filter_add")
      (("" (inst - "rest(nseq!1)" "p!1" "first(nseq!1)")
        (("" (apply-eta "nseq!1") (("" (reduce) nil nil)) nil)) nil))
      nil))
    nil)
   ((filter_add formula-decl nil csequence_filter nil)
    (csequence_add_eta formula-decl nil csequence_codt nil)
    (first adt-accessor-decl "[(nonempty?) -> T]" csequence_codt nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (nonempty_csequence type-eq-decl nil csequence_props nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (boolean nonempty-type-decl nil booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (T formal-type-decl nil csequence_filter nil))
   shostak))
 (filter_suffix_TCC1 0
  (filter_suffix_TCC1-1 nil 3513634660 ("" (subtype-tcc) nil nil)
   ((filter const-decl
     "(LAMBDA (cseq1: csequence[T]): subsequence?(cseq1, cseq))"
     csequence_filter nil))
   nil
   (filter_suffix subtype
    "csequence_filter.filter(csequence_filter.cseq, csequence_filter.p)"
    "(csequence_codt[csequence_filter.T].nonempty?)")))
 (filter_suffix_TCC2 0
  (filter_suffix_TCC2-1 nil 3513634660
   ("" (skosimp)
    (("" (rewrite "filter_nonempty") (("" (assert) nil nil)) nil)) nil)
   ((filter_nonempty formula-decl nil csequence_filter nil)
    (T formal-type-decl nil csequence_filter nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil))
   nil
   (filter_suffix subtype "csequence_filter.cseq"
    "(csequence_codt[csequence_filter.T].some(csequence_filter.p))")))
 (filter_suffix 0
  (filter_suffix-1 nil 3513635836
   ("" (skosimp)
    (("" (use "filter_nonempty")
      (("" (assert)
        (("" (expand* "filter" "filter_struct")
          (("" (expand "coreduce" 2 1) (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((filter_nonempty formula-decl nil csequence_filter nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (T formal-type-decl nil csequence_filter nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (filter_struct const-decl "csequence_struct[T, [csequence, pred[T]]]"
     csequence_filter nil)
    (filter const-decl
     "(LAMBDA (cseq1: csequence[T]): subsequence?(cseq1, cseq))"
     csequence_filter nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil))
   shostak))
 (filter_first_TCC1 0
  (filter_first_TCC1-1 nil 3513634660
   ("" (skosimp) (("" (rewrite "filter_nonempty") nil nil)) nil)
   ((filter_nonempty formula-decl nil csequence_filter nil)
    (T formal-type-decl nil csequence_filter nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil))
   nil
   (filter_first subtype
    "csequence_filter.filter(csequence_filter.cseq, csequence_filter.p)"
    "(csequence_codt[csequence_filter.T].nonempty?)")))
 (filter_first 0
  (filter_first-1 nil 3513635883
   ("" (skosimp)
    (("" (expand* "filter" "filter_struct" "coreduce") (("" (bash) nil nil))
      nil))
    nil)
   ((filter_struct const-decl "csequence_struct[T, [csequence, pred[T]]]"
     csequence_filter nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (filter const-decl
     "(LAMBDA (cseq1: csequence[T]): subsequence?(cseq1, cseq))"
     csequence_filter nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil))
   shostak))
 (filter_first_first_TCC1 0
  (filter_first_first_TCC1-1 nil 3513634660
   ("" (skosimp)
    (("" (expand "some") (("" (lift-if) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((some inductive-decl "boolean" csequence_codt nil)) nil
   (filter_first_first subtype "csequence_filter.cseq"
    "(csequence_codt[csequence_filter.T].nonempty?)")))
 (filter_first_first 0
  (filter_first_first-1 nil 3513635939
   ("" (skosimp)
    (("" (rewrite "filter_first")
      (("" (use "first_p_rest")
        (("" (expand "nth") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((filter_first formula-decl nil csequence_filter nil)
    (T formal-type-decl nil csequence_filter nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (nth def-decl "T" csequence_nth nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (first_p_rest formula-decl nil csequence_first_p nil))
   shostak))
 (filter_full 0
  (filter_full-1 nil 3513635996
   ("" (skolem!)
    (("" (prop)
      (("1" (lemma "coinduction")
        (("1"
          (inst -
           "LAMBDA cseq1, cseq2: cseq1 = filter(cseq2, p!1) AND every(p!1)(cseq2)"
           "filter(cseq!1, p!1)" "cseq!1")
          (("1" (assert) nil nil)
           ("2" (delete -1 2)
            (("2" (expand "bisimulation?")
              (("2" (skosimp)
                (("2" (smash)
                  (("1"
                    (expand* "filter" "filter_struct" "coreduce" "every"
                     "some")
                    (("1" (reduce) nil nil)) nil)
                   ("2" (expand* "filter" "filter_struct" "coreduce" "some")
                    nil nil)
                   ("3" (expand "every" -)
                    (("3" (expand* "filter" "filter_struct" "coreduce" "some")
                      (("3" (reduce) nil nil)) nil))
                    nil)
                   ("4" (use "filter_rest")
                    (("4"
                      (expand* "filter" "filter_struct" "coreduce" "every"
                       "some")
                      (("4" (reduce) nil nil)) nil))
                    nil)
                   ("5" (replace -1)
                    (("5" (hide -1)
                      (("5" (case "some(p!1)(y!1)")
                        (("1" (forward-chain "first_p_rest")
                          (("1"
                            (expand* "filter" "filter_struct" "coreduce"
                             "every" "some")
                            (("1" (reduce)
                              (("1" (expand "nth" +) (("1" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (hide 2)
                          (("2"
                            (expand* "filter" "filter_struct" "coreduce"
                             "every" "some")
                            (("2" (reduce) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (use "filter_def") (("2" (assert) nil nil)) nil))
      nil))
    nil)
   ((every coinductive-decl "boolean" csequence_codt nil)
    (p!1 skolem-const-decl "pred[T]" csequence_filter nil)
    (filter const-decl
     "(LAMBDA (cseq1: csequence[T]): subsequence?(cseq1, cseq))"
     csequence_filter nil)
    (subsequence? coinductive-decl "bool" csequence_subsequence nil)
    (pred type-eq-decl nil defined_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bisimulation? adt-def-decl "boolean" csequence_codt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (some inductive-decl "boolean" csequence_codt nil)
    (filter_struct const-decl "csequence_struct[T, [csequence, pred[T]]]"
     csequence_filter nil)
    (nonempty_csequence type-eq-decl nil csequence_props nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (filter_rest formula-decl nil csequence_filter nil)
    (first_p_rest formula-decl nil csequence_first_p nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (nth def-decl "T" csequence_nth nil)
    (coinduction formula-decl nil csequence_codt nil)
    (T formal-type-decl nil csequence_filter nil)
    (filter_def formula-decl nil csequence_filter nil))
   shostak))
 (filter_idem 0
  (filter_idem-1 nil 3513636138
   ("" (skolem!)
    (("" (use "filter_def" ("cseq" "cseq!1"))
      (("" (rewrite "filter_full") nil nil)) nil))
    nil)
   ((filter_def formula-decl nil csequence_filter nil)
    (T formal-type-decl nil csequence_filter nil)
    (csequence type-decl nil csequence_codt nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (filter const-decl
     "(LAMBDA (cseq1: csequence[T]): subsequence?(cseq1, cseq))"
     csequence_filter nil)
    (subsequence? coinductive-decl "bool" csequence_subsequence nil)
    (filter_full formula-decl nil csequence_filter nil))
   shostak))
 (filter_some 0
  (filter_some-1 nil 3513636164
   ("" (skolem!)
    (("" (prop)
      (("1" (lemma "some_induction")
        (("1"
          (inst - "q!1"
           "LAMBDA cseq: FORALL cseq2: cseq = filter(cseq2, p!1) IMPLIES some(pred_AND(p!1, q!1))(cseq2)")
          (("1" (split)
            (("1" (inst - "filter(cseq!1, p!1)")
              (("1" (assert) (("1" (inst - "cseq!1") nil nil)) nil)) nil)
             ("2" (delete -1 2)
              (("2" (skosimp*)
                (("2" (lift-if)
                  (("2" (replace -2)
                    (("2" (hide -2)
                      (("2" (ground)
                        (("1" (rewrite "nth_some")
                          (("1" (expand* "filter" "filter_struct")
                            (("1" (expand "coreduce" -)
                              (("1" (smash)
                                (("1" (expand "pred_AND")
                                  (("1" (inst + "first_p(p!1, cseq2!1)")
                                    (("1" (assert)
                                      (("1"
                                        (hide-all-but 2)
                                        (("1"
                                          (expand* "first_p" "p_indexes")
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (expand "coreduce")
                                  (("2" (propax) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand* "filter" "filter_struct" "pred_AND")
                          (("2" (expand "coreduce" -1 1)
                            (("2" (smash)
                              (("1"
                                (inst -
                                 "suffix(cseq2!1, 1 + first_p(p!1, cseq2!1))")
                                (("1" (hide -1 -2 1)
                                  (("1" (rewrite "suffix_some")
                                    (("1" (rewrite "nth_some")
                                      (("1"
                                        (expand "coreduce" -1 1)
                                        (("1"
                                          (skosimp)
                                          (("1"
                                            (inst + "i!1")
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (expand "coreduce" +)
                                (("2" (propax) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (lemma "some_induction")
        (("2"
          (inst - "pred_AND(p!1, q!1)"
           "LAMBDA cseq: some(q!1)(filter(cseq, p!1))")
          (("2" (split)
            (("1" (inst - "cseq!1") (("1" (assert) nil nil)) nil)
             ("2" (delete -1 2)
              (("2" (skosimp)
                (("2" (expand "pred_AND")
                  (("2" (lift-if)
                    (("2" (ground)
                      (("1"
                        (expand* "filter" "filter_struct" "coreduce" "some")
                        (("1" (flatten)
                          (("1" (case "first_p(p!1, a!1) = 0")
                            (("1" (expand "nth" +) (("1" (assert) nil nil))
                              nil)
                             ("2" (hide 3 4)
                              (("2" (expand* "first_p" "p_indexes")
                                (("2" (rewrite "min_def")
                                  (("1" (expand* "minimum?" "nth") nil nil)
                                   ("2"
                                    (expand* "nonempty?" "empty?" "member")
                                    (("2" (inst - 0)
                                      (("1"
                                        (expand "nth")
                                        (("1" (propax) nil nil))
                                        nil)
                                       ("2"
                                        (expand "index?")
                                        (("2" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3" (expand "index?")
                                    (("3" (propax) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (use "filter_rest")
                        (("2" (expand "some" +)
                          (("2" (lift-if)
                            (("2" (ground)
                              (("2"
                                (expand* "filter" "filter_struct" "coreduce"
                                 "some")
                                nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (pred type-eq-decl nil defined_types nil)
    (csequence type-decl nil csequence_codt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (subsequence? coinductive-decl "bool" csequence_subsequence nil)
    (filter const-decl
     "(LAMBDA (cseq1: csequence[T]): subsequence?(cseq1, cseq))"
     csequence_filter nil)
    (some inductive-decl "boolean" csequence_codt nil)
    (pred_AND const-decl "bool" csequence_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (suffix_some formula-decl nil csequence_suffix nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (suffix def-decl "(LAMBDA (cseq1: csequence): suffix?(cseq1, cseq))"
     csequence_suffix nil)
    (suffix? inductive-decl "bool" csequence_suffix nil)
    (nth_some formula-decl nil csequence_nth nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (p_indexes const-decl "set[indexes[T](cseq)]" csequence_first_p nil)
    (first_p const-decl "indexes(cseq)" csequence_first_p nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (index? def-decl "bool" csequence_nth nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (filter_struct const-decl "csequence_struct[T, [csequence, pred[T]]]"
     csequence_filter nil)
    (some_induction formula-decl nil csequence_codt nil)
    (T formal-type-decl nil csequence_filter nil)
    (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (min_def formula-decl nil min_nat nil)
    (minimum? const-decl "bool" min_nat nil)
    (a!1 skolem-const-decl "csequence[T]" csequence_filter nil)
    (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (nth def-decl "T" csequence_nth nil)
    (nonempty_csequence type-eq-decl nil csequence_props nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (filter_rest formula-decl nil csequence_filter nil))
   shostak))
 (filter_every 0
  (filter_every-1 nil 3513636479
   ("" (skolem!)
    (("" (lemma "every_some_rew")
      (("" (inst-cp - "pred_IMPLIES(p!1, q!1)" "cseq!1")
        (("" (inst - "q!1" "filter(cseq!1, p!1)")
          (("" (use "filter_some")
            (("" (expand* "pred_AND" "pred_NOT" "pred_IMPLIES")
              ((""
                (case "(LAMBDA t: p!1(t) AND NOT q!1(t)) = (LAMBDA t: NOT (p!1(t) IMPLIES q!1(t)))")
                (("1" (ground) nil nil)
                 ("2" (hide-all-but 1)
                  (("2" (decompose-equality)
                    (("2" (iff) (("2" (prop) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil csequence_filter nil)
    (every_some_rew formula-decl nil csequence_props nil)
    (subsequence? coinductive-decl "bool" csequence_subsequence nil)
    (filter const-decl
     "(LAMBDA (cseq1: csequence[T]): subsequence?(cseq1, cseq))"
     csequence_filter nil)
    (pred_AND const-decl "bool" csequence_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred_NOT const-decl "bool" csequence_props nil)
    (filter_some formula-decl nil csequence_filter nil)
    (csequence type-decl nil csequence_codt nil)
    (pred_IMPLIES const-decl "bool" csequence_props nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (filter_filter_of 0
  (filter_filter_of-1 nil 3513636563
   ("" (skolem!)
    (("" (prop)
      (("1" (lemma "filter_of?_coinduction")
        (("1"
          (inst - "p!1" "LAMBDA filt_seq, cseq: filter(cseq, p!1) = filt_seq")
          (("1" (split)
            (("1" (inst - "filt_seq!1" "cseq!1") (("1" (assert) nil nil)) nil)
             ("2" (delete -1 2)
              (("2" (skosimp)
                (("2" (use "filter_nonempty")
                  (("2" (lemma "filter_rest")
                    (("2" (lemma "filter_first_first")
                      (("2" (reduce) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (lemma "coinduction")
        (("2"
          (inst -
           "LAMBDA cseq1, filt_seq: EXISTS cseq2: cseq1 = filter(cseq2, p!1) AND filter_of?(filt_seq, cseq2, p!1)"
           "filter(cseq!1, p!1)" "filt_seq!1")
          (("1" (assert) (("1" (inst + "cseq!1") nil nil)) nil)
           ("2" (delete -1 2)
            (("2" (expand "bisimulation?")
              (("2" (skosimp*)
                (("2" (replace -1)
                  (("2" (hide -1)
                    (("2" (use "filter_nonempty")
                      (("2" (use "filter_of?_empty")
                        (("2" (smash)
                          (("1" (expand "filter_of?" -)
                            (("1" (prop)
                              (("1" (inst + "rest(cseq2!1)")
                                (("1" (use "filter_rest")
                                  (("1" (assert) nil nil)) nil))
                                nil)
                               ("2" (lemma "filter_of?_suffix")
                                (("2" (inst - "y!1" "cseq2!1" "p!1")
                                  (("2"
                                    (inst +
                                     "suffix(cseq2!1, 1 + first_p(p!1, cseq2!1))")
                                    (("2" (use "filter_suffix")
                                      (("2" (assert) nil nil)) nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (forward-chain "filter_of?_first_p")
                            (("2"
                              (expand* "filter" "filter_struct" "coreduce")
                              nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (csequence type-decl nil csequence_codt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (subsequence? coinductive-decl "bool" csequence_subsequence nil)
    (filter const-decl
     "(LAMBDA (cseq1: csequence[T]): subsequence?(cseq1, cseq))"
     csequence_filter nil)
    (filter_nonempty formula-decl nil csequence_filter nil)
    (filter_first_first formula-decl nil csequence_filter nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (nonempty_csequence type-eq-decl nil csequence_props nil)
    (filter_rest formula-decl nil csequence_filter nil)
    (filter_of?_coinduction formula-decl nil csequence_filter_of nil)
    (T formal-type-decl nil csequence_filter nil)
    (filter_of? coinductive-decl "bool" csequence_filter_of nil)
    (p!1 skolem-const-decl "pred[T]" csequence_filter nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bisimulation? adt-def-decl "boolean" csequence_codt nil)
    (PRED type-eq-decl nil defined_types nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (filter_suffix formula-decl nil csequence_filter nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers nil)
    (first_p const-decl "indexes(cseq)" csequence_first_p nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (index? def-decl "bool" csequence_nth nil)
    (some inductive-decl "boolean" csequence_codt nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (suffix def-decl "(LAMBDA (cseq1: csequence): suffix?(cseq1, cseq))"
     csequence_suffix nil)
    (suffix? inductive-decl "bool" csequence_suffix nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (filter_of?_suffix formula-decl nil csequence_filter_of nil)
    (filter_struct const-decl "csequence_struct[T, [csequence, pred[T]]]"
     csequence_filter nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (filter_of?_first_p formula-decl nil csequence_filter_of nil)
    (filter_of?_empty formula-decl nil csequence_filter_of nil)
    (coinduction formula-decl nil csequence_codt nil))
   shostak))
 (filter_concatenate 0
  (filter_concatenate-1 nil 3513637853
   ("" (skolem!)
    (("" (lift-if)
      (("" (ground)
        (("1" (name "filt_conc" "filter(cseq1!1 o cseq2!1, p!1)")
          (("1" (name "filt2" "filter(cseq2!1, p!1)")
            (("1" (name "filt1" "filter(cseq1!1, p!1)")
              (("1" (replace*)
                (("1" (rewrite "filter_filter_of")
                  (("1" (rewrite "filter_filter_of")
                    (("1" (rewrite "filter_filter_of")
                      (("1" (lemma "filter_of?_concatenate")
                        (("1"
                          (inst - "filt1" "filt2" "cseq1!1" "cseq2!1" "p!1")
                          (("1" (assert)
                            (("1" (lemma "filter_of?_injective")
                              (("1"
                                (inst - "filt1 o filt2" "filt_conc"
                                 "cseq1!1 o cseq2!1" "p!1")
                                (("1" (assert) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (rewrite "o_infinite") nil nil))
        nil))
      nil))
    nil)
   ((o_infinite formula-decl nil csequence_concatenate nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (infinite_csequence type-eq-decl nil csequence_props nil)
    (O const-decl "csequence" csequence_concatenate nil)
    (filter const-decl
     "(LAMBDA (cseq1: csequence[T]): subsequence?(cseq1, cseq))"
     csequence_filter nil)
    (subsequence? coinductive-decl "bool" csequence_subsequence nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (T formal-type-decl nil csequence_filter nil)
    (filter_filter_of formula-decl nil csequence_filter nil)
    (filter_of?_injective formula-decl nil csequence_filter_of nil)
    (filter_of?_concatenate formula-decl nil csequence_filter_of nil))
   shostak))
 (filter_filter 0
  (filter_filter-1 nil 3513637946
   ("" (skolem!)
    (("" (name "filter_and" "filter(cseq!1, pred_AND(p!1, q!1))")
      (("" (name "filter_q" "filter(filter(cseq!1, p!1), q!1)")
        (("" (name "filter_p" "filter(cseq!1, p!1)")
          (("" (replace*)
            (("" (rewrite "filter_filter_of")
              (("" (rewrite "filter_filter_of")
                (("" (rewrite "filter_filter_of")
                  (("" (lemma "filter_of?_filter_of?")
                    (("" (inst - "filter_p" "filter_q" "cseq!1" "p!1" "q!1")
                      (("" (assert)
                        (("" (use "filter_of?_injective")
                          (("" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pred_AND const-decl "bool" csequence_props nil)
    (filter const-decl
     "(LAMBDA (cseq1: csequence[T]): subsequence?(cseq1, cseq))"
     csequence_filter nil)
    (subsequence? coinductive-decl "bool" csequence_subsequence nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (T formal-type-decl nil csequence_filter nil)
    (filter_filter_of formula-decl nil csequence_filter nil)
    (filter_of?_injective formula-decl nil csequence_filter_of nil)
    (filter_of?_filter_of? formula-decl nil csequence_filter_of nil))
   shostak)))

