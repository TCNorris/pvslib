(csequence_filter_of
 (filter_of?_TCC1 0
  (filter_of?_TCC1-1 nil 3513626629
   ("" (skosimp)
    (("" (expand "some") (("" (lift-if) (("" (ground) nil nil)) nil)) nil))
    nil)
   ((some inductive-decl "boolean" csequence_codt nil)) nil
   (filter_of? subtype "csequence_filter_of.cseq"
    "(csequence_codt[csequence_filter_of.T].nonempty?)")))
 (filter_of?_empty 0
  (filter_of?_empty-1 nil 3513626684
   ("" (skosimp) (("" (expand "filter_of?") (("" (ground) nil nil)) nil)) nil)
   ((filter_of? coinductive-decl "bool" csequence_filter_of nil)) shostak))
 (filter_of?_nonempty 0
  (filter_of?_nonempty-1 nil 3513626701
   ("" (skosimp) (("" (expand "filter_of?") (("" (ground) nil nil)) nil)) nil)
   ((filter_of? coinductive-decl "bool" csequence_filter_of nil)) shostak))
 (filter_of?_finite 0
  (filter_of?_finite-1 nil 3513626715
   ("" (induct "cseq" :name "is_finite_induction")
    (("1" (assert) nil nil)
     ("2" (skosimp*)
      (("2" (expand "filter_of?" -2)
        (("2" (expand "is_finite" +)
          (("2" (expand "some")
            (("2" (ground)
              (("1" (inst - "rest(filt_seq!1)" "p!1") (("1" (assert) nil nil))
                nil)
               ("2" (inst - "filt_seq!1" "p!1")
                (("2" (expand "is_finite" -5) (("2" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (some inductive-decl "boolean" csequence_codt nil)
    (is_finite_induction formula-decl nil csequence_props nil)
    (T formal-type-decl nil csequence_filter_of nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (filter_of? coinductive-decl "bool" csequence_filter_of nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (csequence type-decl nil csequence_codt nil))
   shostak))
 (filter_of?_def 0
  (filter_of?_def-1 nil 3513626787
   ("" (skosimp)
    (("" (lemma "every_coinduction")
      ((""
        (inst - "p!1"
         "LAMBDA filt_seq: EXISTS cseq: filter_of?(filt_seq, cseq, p!1)")
        (("" (split)
          (("1" (inst - "filt_seq!1")
            (("1" (assert) (("1" (inst + "cseq!1") nil nil)) nil)) nil)
           ("2" (delete -1 2)
            (("2" (skosimp*)
              (("2" (expand "filter_of?" -)
                (("2" (lift-if)
                  (("2" (ground)
                    (("1" (inst + "rest(cseq!2)") nil nil)
                     ("2" (lemma "some_induction")
                      (("2"
                        (inst - "p!1"
                         "LAMBDA cseq: nonempty?(cseq) AND (FORALL filt_seq: nonempty?(filt_seq) AND filter_of?(filt_seq, rest(cseq), p!1) IMPLIES p!1(first(filt_seq)) OR p!1(first(cseq)))")
                        (("2" (split)
                          (("1" (inst - "cseq!2")
                            (("1" (ground)
                              (("1" (inst - "a!1") (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (delete -1 -2 -3 2 3 4)
                            (("2" (skosimp)
                              (("2" (lift-if)
                                (("2" (ground)
                                  (("2" (skosimp)
                                    (("2" (expand "filter_of?" -2)
                                      (("2"
                                        (prop)
                                        (("1"
                                          (inst - "rest(filt_seq!2)")
                                          (("1" (assert) nil nil))
                                          nil)
                                         ("2"
                                          (inst - "filt_seq!2")
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("3" (lemma "some_induction")
                      (("3"
                        (inst - "p!1"
                         "LAMBDA cseq: nonempty?(cseq) AND (FORALL filt_seq: nonempty?(filt_seq) AND filter_of?(filt_seq, rest(cseq), p!1) IMPLIES every(p!1)(rest(filt_seq)) OR (EXISTS cseq2: filter_of?(rest(filt_seq), cseq2, p!1)) OR p!1(first(cseq)))")
                        (("3" (split)
                          (("1" (inst - "cseq!2")
                            (("1" (ground)
                              (("1" (inst - "a!1") (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (delete -1 -2 -3 2 3 4 5)
                            (("2" (skosimp)
                              (("2" (lift-if)
                                (("2" (ground)
                                  (("2" (skosimp)
                                    (("2" (expand "filter_of?" -2)
                                      (("2"
                                        (prop)
                                        (("1"
                                          (inst + "rest(rest(a!2))")
                                          nil
                                          nil)
                                         ("2"
                                          (inst - "filt_seq!2")
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil csequence_filter_of nil)
    (every_coinduction formula-decl nil csequence_codt nil)
    (every coinductive-decl "boolean" csequence_codt nil)
    (some_induction formula-decl nil csequence_codt nil)
    (first adt-accessor-decl "[(nonempty?) -> T]" csequence_codt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (filter_of? coinductive-decl "bool" csequence_filter_of nil)
    (csequence type-decl nil csequence_codt nil)
    (pred type-eq-decl nil defined_types nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (filter_of?_first_p_TCC1 0
  (filter_of?_first_p_TCC1-1 nil 3513626629
   ("" (skosimp)
    (("" (forward-chain "filter_of?_nonempty") (("" (assert) nil nil)) nil))
    nil)
   ((filter_of?_nonempty formula-decl nil csequence_filter_of nil)
    (T formal-type-decl nil csequence_filter_of nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil))
   nil
   (filter_of?_first_p subtype "csequence_filter_of.filt_seq"
    "(csequence_codt[csequence_filter_of.T].nonempty?)")))
 (filter_of?_first_p 0
  (filter_of?_first_p-1 nil 3513627069
   ("" (skosimp)
    (("" (lemma "some_induction")
      ((""
        (inst - "p!1"
         "LAMBDA cseq: some(p!1)(cseq) AND (FORALL filt_seq: filter_of?(filt_seq, cseq, p!1) IMPLIES nth(cseq, first_p(p!1, cseq)) = first(filt_seq))")
        (("1" (split)
          (("1" (inst - "cseq!1")
            (("1" (assert)
              (("1" (inst - "filt_seq!1") (("1" (assert) nil nil)) nil)) nil))
            nil)
           ("2" (delete -1 -2 2)
            (("2" (skosimp)
              (("2" (expand "some" +)
                (("2" (lift-if)
                  (("2" (ground)
                    (("1" (skosimp)
                      (("1" (use "first_p_rest")
                        (("1" (expand "some")
                          (("1" (assert)
                            (("1" (expand* "nth" "filter_of?")
                              (("1" (ground)
                                (("1" (expand "some") (("1" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (skosimp)
                      (("2" (use "first_p_rest")
                        (("2" (expand "some" -1)
                          (("2" (lift-if)
                            (("2" (ground)
                              (("1" (expand "nth" +)
                                (("1" (expand "filter_of?" -3)
                                  (("1" (ground)
                                    (("1" (expand "some" +)
                                      (("1" (propax) nil nil)) nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (replace -1)
                                (("2" (expand "nth" +)
                                  (("2" (inst - "filt_seq!2")
                                    (("2" (assert)
                                      (("2"
                                        (expand "filter_of?" -)
                                        (("2"
                                          (flatten)
                                          (("2"
                                            (expand "some" +)
                                            (("2" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skosimp*)
          (("2" (use "filter_of?_nonempty") (("2" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil csequence_filter_of nil)
    (some_induction formula-decl nil csequence_codt nil)
    (filter_of?_nonempty formula-decl nil csequence_filter_of nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (first_p_rest formula-decl nil csequence_first_p nil)
    (first adt-accessor-decl "[(nonempty?) -> T]" csequence_codt nil)
    (first_p const-decl "indexes(cseq)" csequence_first_p nil)
    (nth def-decl "T" csequence_nth nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (index? def-decl "bool" csequence_nth nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (some inductive-decl "boolean" csequence_codt nil)
    (pred type-eq-decl nil defined_types nil)
    (p!1 skolem-const-decl "pred[T]" csequence_filter_of nil)
    (filter_of? coinductive-decl "bool" csequence_filter_of nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil))
   shostak))
 (filter_of?_suffix 0
  (filter_of?_suffix-1 nil 3513627240
   ("" (skosimp)
    (("" (lemma "some_induction")
      ((""
        (inst - "p!1"
         "LAMBDA cseq: some(p!1)(cseq) AND (FORALL filt_seq: filter_of?(filt_seq, cseq, p!1) IMPLIES filter_of?(rest(filt_seq), suffix(cseq, 1 + first_p(p!1, cseq)), p!1))")
        (("1" (split)
          (("1" (inst - "cseq!1")
            (("1" (assert)
              (("1" (inst - "filt_seq!1") (("1" (assert) nil nil)) nil)) nil))
            nil)
           ("2" (delete -1 -2 2)
            (("2" (skosimp)
              (("2" (expand "some" +)
                (("2" (lift-if)
                  (("2" (ground)
                    (("1" (skosimp)
                      (("1" (use "first_p_rest")
                        (("1" (expand "filter_of?" -)
                          (("1" (ground)
                            (("1" (expand "some") (("1" (propax) nil nil))
                              nil)
                             ("2" (expand* "suffix" "suffix") nil nil)
                             ("3" (expand "some") (("3" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (skosimp)
                      (("2" (expand "filter_of?" -1)
                        (("2" (expand "some" -1 1)
                          (("2" (expand "some" -1 1)
                            (("2" (smash)
                              (("1" (use "first_p_rest")
                                (("1" (expand "some" -1 1)
                                  (("1" (expand* "suffix" "suffix")
                                    (("1" (assert) nil nil)) nil))
                                  nil))
                                nil)
                               ("2" (inst - "filt_seq!2")
                                (("2" (assert)
                                  (("2" (use "first_p_rest")
                                    (("2" (expand "some" -1 1)
                                      (("2"
                                        (expand "suffix" +)
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skosimp*)
          (("2" (use "filter_of?_nonempty") (("2" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil csequence_filter_of nil)
    (some_induction formula-decl nil csequence_codt nil)
    (filter_of?_nonempty formula-decl nil csequence_filter_of nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (first_p_rest formula-decl nil csequence_first_p nil)
    (first_p const-decl "indexes(cseq)" csequence_first_p nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (index? def-decl "bool" csequence_nth nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (suffix def-decl "(LAMBDA (cseq1: csequence): suffix?(cseq1, cseq))"
     csequence_suffix nil)
    (suffix? inductive-decl "bool" csequence_suffix nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (some inductive-decl "boolean" csequence_codt nil)
    (pred type-eq-decl nil defined_types nil)
    (p!1 skolem-const-decl "pred[T]" csequence_filter_of nil)
    (filter_of? coinductive-decl "bool" csequence_filter_of nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil))
   shostak))
 (filter_of?_injective 0
  (filter_of?_injective-1 nil 3513627419
   ("" (skosimp)
    (("" (lemma "coinduction")
      ((""
        (inst -
         "LAMBDA filt_seq1, filt_seq2: EXISTS cseq: filter_of?(filt_seq1, cseq, p!1) AND filter_of?(filt_seq2, cseq, p!1)"
         "filt_seq1!1" "filt_seq2!1")
        (("1" (assert) (("1" (inst + "cseq!1") (("1" (assert) nil nil)) nil))
          nil)
         ("2" (delete -1 -2 2)
          (("2" (expand "bisimulation?")
            (("2" (skosimp*)
              (("2" (expand "filter_of?" -)
                (("2" (smash)
                  (("1" (inst + "rest(cseq!2)") (("1" (assert) nil nil)) nil)
                   ("2" (inst + "suffix(cseq!2, 1 + first_p(p!1, cseq!2))")
                    (("2" (lemma "filter_of?_suffix")
                      (("2" (inst-cp - "y!1" "cseq!2" "p!1")
                        (("2" (inst - "x!1" "cseq!2" "p!1")
                          (("2" (expand "filter_of?" -2 1)
                            (("2" (expand "filter_of?" -1 1)
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (lemma "filter_of?_first_p")
                    (("3" (inst-cp - "y!1" "rest(cseq!2)" "p!1")
                      (("3" (inst - "x!1" "rest(cseq!2)" "p!1")
                        (("3" (expand "some" -4)
                          (("3" (lift-if) (("3" (ground) nil nil)) nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil csequence_filter_of nil)
    (coinduction formula-decl nil csequence_codt nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (filter_of?_suffix formula-decl nil csequence_filter_of nil)
    (first_p const-decl "indexes(cseq)" csequence_first_p nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (index? def-decl "bool" csequence_nth nil)
    (some inductive-decl "boolean" csequence_codt nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (suffix def-decl "(LAMBDA (cseq1: csequence): suffix?(cseq1, cseq))"
     csequence_suffix nil)
    (suffix? inductive-decl "bool" csequence_suffix nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (filter_of?_first_p formula-decl nil csequence_filter_of nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bisimulation? adt-def-decl "boolean" csequence_codt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (filter_of? coinductive-decl "bool" csequence_filter_of nil)
    (p!1 skolem-const-decl "pred[T]" csequence_filter_of nil))
   shostak))
 (filter_of?_concatenate 0
  (filter_of?_concatenate-1 nil 3513627581
   ("" (auto-rewrite "o_empty_left")
    (("" (auto-rewrite "o_first")
      (("" (auto-rewrite "o_rest")
        (("" (induct "cseq1" :name "is_finite_induction")
          (("1" (assert) nil nil)
           ("2" (skosimp*)
            (("2" (ground)
              (("1" (expand "filter_of?" -3)
                (("1" (expand "some") (("1" (assert) nil nil)) nil)) nil)
               ("2" (expand "filter_of?" -4)
                (("2" (smash)
                  (("1" (use "o_nonempty_left" ("nseq" "cseq!1"))
                    (("1" (expand "filter_of?" +)
                      (("1" (smash)
                        (("1" (rewrite "o_some")
                          (("1" (use "filter_of?_empty")
                            (("1" (assert) nil nil)) nil))
                          nil)
                         ("2" (use "filter_of?_empty")
                          (("2" (assert)
                            (("2" (use "o_nonempty_right")
                              (("1" (expand "some" +)
                                (("1" (lift-if)
                                  (("1" (ground)
                                    (("1" (expand "filter_of?" -9)
                                      (("1" (propax) nil nil)) nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (expand "some" -1)
                                (("2" (assert) nil nil)) nil))
                              nil))
                            nil))
                          nil)
                         ("3" (expand "some")
                          (("3" (lift-if)
                            (("3" (ground)
                              (("3" (expand "filter_of?" -7)
                                (("3" (propax) nil nil)) nil))
                              nil))
                            nil))
                          nil)
                         ("4" (rewrite "o_first")
                          (("4" (lift-if)
                            (("4" (ground)
                              (("1" (expand "filter_of?" -7)
                                (("1" (propax) nil nil)) nil)
                               ("2"
                                (inst - "filt_seq1!1" "filt_seq2!1" "cseq2!1"
                                 "p!1")
                                (("2" (assert)
                                  (("2" (expand "filter_of?" 3)
                                    (("2" (expand "some" +)
                                      (("2" (propax) nil nil)) nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("5" (rewrite "o_some")
                          (("5" (expand "filter_of?" -6)
                            (("5" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (use "o_nonempty_left" ("nseq" "cseq!1"))
                    (("2" (expand "filter_of?" +)
                      (("2" (smash)
                        (("1" (rewrite "o_empty") nil nil)
                         ("2" (rewrite "o_rest")
                          (("2" (lift-if)
                            (("2" (ground)
                              (("1" (expand "some") (("1" (propax) nil nil))
                                nil)
                               ("2"
                                (inst - "rest(filt_seq1!1)" "filt_seq2!1"
                                 "cseq2!1" "p!1")
                                (("2" (assert) nil nil)) nil))
                              nil))
                            nil))
                          nil)
                         ("3" (rewrite "o_first")
                          (("3" (expand "some")
                            (("3" (lift-if) (("3" (ground) nil nil)) nil))
                            nil))
                          nil)
                         ("4" (rewrite "o_first")
                          (("4" (expand "some")
                            (("4" (lift-if) (("4" (ground) nil nil)) nil))
                            nil))
                          nil)
                         ("5" (rewrite "o_some") nil nil))
                        nil))
                      nil))
                    nil)
                   ("3" (use "o_nonempty_left" ("nseq" "cseq!1"))
                    (("3" (expand "filter_of?" +)
                      (("3" (smash)
                        (("1" (rewrite "o_empty") nil nil)
                         ("2" (rewrite "o_first")
                          (("2" (expand "some")
                            (("2" (lift-if) (("2" (ground) nil nil)) nil))
                            nil))
                          nil)
                         ("3" (rewrite "o_first")
                          (("3" (expand "some")
                            (("3" (lift-if) (("3" (ground) nil nil)) nil))
                            nil))
                          nil)
                         ("4" (rewrite "o_rest")
                          (("4" (expand "some")
                            (("4" (lift-if)
                              (("4" (ground)
                                (("4"
                                  (inst - "filt_seq1!1" "filt_seq2!1"
                                   "cseq2!1" "p!1")
                                  (("4" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("5" (rewrite "o_some") nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (filter_of? coinductive-decl "bool" csequence_filter_of nil)
    (O const-decl "csequence" csequence_concatenate nil)
    (T formal-type-decl nil csequence_filter_of nil)
    (is_finite_induction formula-decl nil csequence_props nil)
    (o_empty_left formula-decl nil csequence_concatenate nil)
    (some inductive-decl "boolean" csequence_codt nil)
    (o_nonempty_right judgement-tcc nil csequence_concatenate nil)
    (cseq2!1 skolem-const-decl "csequence[T]" csequence_filter_of nil)
    (o_first formula-decl nil csequence_concatenate nil)
    (o_rest formula-decl nil csequence_concatenate nil)
    (o_some formula-decl nil csequence_concatenate nil)
    (filter_of?_empty formula-decl nil csequence_filter_of nil)
    (o_nonempty_left judgement-tcc nil csequence_concatenate nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (nonempty_csequence type-eq-decl nil csequence_props nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (o_empty formula-decl nil csequence_concatenate nil))
   shostak))
 (filter_of?_implication 0
  (filter_of?_implication-1 nil 3513628112
   ("" (skosimp)
    (("" (lemma "some_induction")
      ((""
        (inst - "p!1"
         "LAMBDA cseq: FORALL filt_seq: filter_of?(filt_seq, cseq, q!1) IMPLIES some(p!1)(filt_seq)")
        (("" (split)
          (("1" (inst - "cseq!1")
            (("1" (assert)
              (("1" (inst - "filt_seq!1") (("1" (assert) nil nil)) nil)) nil))
            nil)
           ("2" (delete -2 -3 2)
            (("2" (skosimp*)
              (("2" (lift-if)
                (("2" (ground)
                  (("1" (inst - "first(a!1)")
                    (("1" (expand* "pred_IMPLIES" "filter_of?" "some")
                      (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil))
                    nil)
                   ("2" (forward-chain "some_implies")
                    (("2" (expand "filter_of?" -4)
                      (("2" (ground)
                        (("1" (expand "some" 1) (("1" (propax) nil nil)) nil)
                         ("2" (inst - "rest(filt_seq!2)")
                          (("2" (expand "some" +) (("2" (assert) nil nil))
                            nil))
                          nil)
                         ("3" (inst - "filt_seq!2") (("3" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil csequence_filter_of nil)
    (some_induction formula-decl nil csequence_codt nil)
    (pred_IMPLIES const-decl "bool" csequence_props nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (first adt-accessor-decl "[(nonempty?) -> T]" csequence_codt nil)
    (some_implies formula-decl nil csequence_props nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (some inductive-decl "boolean" csequence_codt nil)
    (filter_of? coinductive-decl "bool" csequence_filter_of nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (pred type-eq-decl nil defined_types nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (filter_of?_implication_rev 0
  (filter_of?_implication_rev-1 nil 3513628236
   ("" (skosimp)
    (("" (lemma "some_induction")
      ((""
        (inst - "q!1"
         "LAMBDA filt_seq: FORALL cseq: filter_of?(filt_seq, cseq, p!1) IMPLIES some(q!1)(cseq)")
        (("" (split)
          (("1" (inst - "filt_seq!1")
            (("1" (assert)
              (("1" (inst - "cseq!1") (("1" (assert) nil nil)) nil)) nil))
            nil)
           ("2" (delete -1 -2 2)
            (("2" (skosimp*)
              (("2" (lift-if)
                (("2" (ground)
                  (("1" (use "filter_of?_empty")
                    (("1" (assert)
                      (("1" (use "filter_of?_first_p")
                        (("1" (assert)
                          (("1" (rewrite "nth_some" +)
                            (("1" (inst + "first_p(p!1, cseq!2)")
                              (("1" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (use "filter_of?_empty")
                    (("2" (assert)
                      (("2" (forward-chain "filter_of?_suffix")
                        (("2"
                          (inst - "suffix(cseq!2, 1 + first_p(p!1, cseq!2))")
                          (("2" (assert)
                            (("2" (rewrite "suffix_some")
                              (("2" (rewrite "nth_some" +)
                                (("2" (skosimp) (("2" (inst + "i!1") nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil csequence_filter_of nil)
    (some_induction formula-decl nil csequence_codt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (index? def-decl "bool" csequence_nth nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (first_p const-decl "indexes(cseq)" csequence_first_p nil)
    (nth_some formula-decl nil csequence_nth nil)
    (filter_of?_first_p formula-decl nil csequence_filter_of nil)
    (filter_of?_empty formula-decl nil csequence_filter_of nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (suffix? inductive-decl "bool" csequence_suffix nil)
    (suffix def-decl "(LAMBDA (cseq1: csequence): suffix?(cseq1, cseq))"
     csequence_suffix nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (suffix_some formula-decl nil csequence_suffix nil)
    (filter_of?_suffix formula-decl nil csequence_filter_of nil)
    (some inductive-decl "boolean" csequence_codt nil)
    (filter_of? coinductive-decl "bool" csequence_filter_of nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (pred type-eq-decl nil defined_types nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (filter_of?_some 0
  (filter_of?_some-1 nil 3513628372
   ("" (skosimp)
    (("" (prop)
      (("1" (forward-chain "filter_of?_def")
        (("1" (lemma "filter_of?_implication_rev")
          (("1" (inst - "filt_seq1!1" "cseq!1" "p!1" "pred_AND(p!1, q!1)")
            (("1" (assert)
              (("1" (rewrite "nth_every")
                (("1" (rewrite "nth_some")
                  (("1" (rewrite "nth_some" -3)
                    (("1" (skolem!)
                      (("1" (inst - "i!1")
                        (("1" (inst + "i!1")
                          (("1" (expand "pred_AND" 1) (("1" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (rewrite "nth_some")
        (("2" (rewrite "nth_some")
          (("2" (expand "pred_AND")
            (("2" (skosimp) (("2" (inst + "i!1") nil nil)) nil)) nil))
          nil))
        nil)
       ("3" (lemma "filter_of?_implication")
        (("3" (inst - "filt_seq1!1" "cseq!1" "pred_AND(p!1, q!1)" "p!1")
          (("3" (ground)
            (("1" (lemma "some_implies")
              (("1" (inst - "filt_seq1!1" "pred_AND(p!1, q!1)" "q!1")
                (("1" (expand* "pred_AND" "pred_IMPLIES")
                  (("1" (assert) (("1" (skosimp) nil nil)) nil)) nil))
                nil))
              nil)
             ("2" (expand* "pred_AND" "pred_IMPLIES")
              (("2" (skosimp) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((filter_of?_implication_rev formula-decl nil csequence_filter_of nil)
    (nth_some formula-decl nil csequence_nth nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (index? def-decl "bool" csequence_nth nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (nth_every formula-decl nil csequence_nth nil)
    (pred_AND const-decl "bool" csequence_props nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (T formal-type-decl nil csequence_filter_of nil)
    (filter_of?_def formula-decl nil csequence_filter_of nil)
    (some_implies formula-decl nil csequence_props nil)
    (pred_IMPLIES const-decl "bool" csequence_props nil)
    (filter_of?_implication formula-decl nil csequence_filter_of nil))
   shostak))
 (filter_of?_filter_of? 0
  (filter_of?_filter_of?-1 nil 3513634415
   ("" (skolem!)
    (("" (prop)
      (("" (lemma "filter_of?_coinduction")
        ((""
          (inst - "pred_AND(p!1, q!1)"
           "LAMBDA filt_seq2, cseq: EXISTS filt_seq1: filter_of?(filt_seq1, cseq, p!1) AND filter_of?(filt_seq2, filt_seq1, q!1)")
          (("" (split)
            (("1" (inst - "filt_seq2!1" "cseq!1")
              (("1" (assert)
                (("1" (inst + "filt_seq1!1") (("1" (assert) nil nil)) nil))
                nil))
              nil)
             ("2" (delete -1 -2 2)
              (("2" (skosimp*)
                (("2" (use "filter_of?_some")
                  (("2" (expand "pred_AND")
                    (("2" (smash)
                      (("1" (lemma "filter_of?_empty")
                        (("1" (inst - "filt_seq!1" "filt_seq1!2" "q!1")
                          (("1" (assert) nil nil)) nil))
                        nil)
                       ("2" (expand "filter_of?" -)
                        (("2" (ground)
                          (("2" (inst + "rest(filt_seq1!2)")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil)
                       ("3" (expand "filter_of?") (("3" (ground) nil nil))
                        nil)
                       ("4" (expand "filter_of?" -1)
                        (("4" (smash)
                          (("1" (expand "filter_of?" -5)
                            (("1" (flatten)
                              (("1" (inst + "rest(filt_seq1!2)")
                                (("1" (assert) nil nil)) nil))
                              nil))
                            nil)
                           ("2" (inst + "filt_seq1!2")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil)
                       ("5" (expand "filter_of?" -1)
                        (("5" (flatten)
                          (("5" (inst + "filt_seq1!2")
                            (("5" (assert) nil nil)) nil))
                          nil))
                        nil)
                       ("6" (lemma "filter_of?_nonempty")
                        (("6" (inst - "filt_seq!1" "filt_seq1!2" "q!1")
                          (("6" (assert) nil nil)) nil))
                        nil)
                       ("7" (lemma "filter_of?_nonempty")
                        (("7" (inst-cp - "filt_seq!1" "filt_seq1!2" "q!1")
                          (("7" (inst - "filt_seq1!2" "cseq!2" "p!1")
                            (("7" (assert)
                              (("7" (expand "some" -) (("7" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil csequence_filter_of nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (pred_AND const-decl "bool" csequence_props nil)
    (csequence type-decl nil csequence_codt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (filter_of? coinductive-decl "bool" csequence_filter_of nil)
    (filter_of?_some formula-decl nil csequence_filter_of nil)
    (filter_of?_empty formula-decl nil csequence_filter_of nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (filter_of?_nonempty formula-decl nil csequence_filter_of nil)
    (some inductive-decl "boolean" csequence_codt nil)
    (filter_of?_coinduction formula-decl nil csequence_filter_of nil))
   shostak)))

