(csequence_map_props
 (map_empty 0
  (map_empty-1 nil 3513550848 ("" (grind) nil nil)
   ((map adt-def-decl "csequence[T1]" csequence_codt_map nil)) shostak))
 (map_nonempty 0
  (map_nonempty-1 nil 3513550854 ("" (grind) nil nil)
   ((map adt-def-decl "csequence[T1]" csequence_codt_map nil)) shostak))
 (map_finite 0
  (map_finite-1 nil 3513550835
   ("" (skolem + ("f!1" "_"))
    (("" (induct "fseq" :name "is_finite_induction[T1]")
      (("1" (assert) nil nil) ("2" (assert) nil nil)
       ("3" (skosimp)
        (("3" (expand "map" +)
          (("3" (expand "is_finite" +) (("3" (reduce) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (T2 formal-type-decl nil csequence_map_props nil)
    (map adt-def-decl "csequence[T1]" csequence_codt_map nil)
    (T1 formal-type-decl nil csequence_map_props nil)
    (is_finite_induction formula-decl nil csequence_props nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil))
   nil
   (map_finite subtype
    "csequence_codt_map[csequence_map_props.T1, csequence_map_props.T2].map(csequence_map_props.f, csequence_map_props.fseq)"
    "finite_csequence[T2]")))
 (map_infinite 0
  (map_infinite-1 nil 3513550835
   ("" (skolem + ("f!1" "_"))
    ((""
      (measure-induct+
       "IF is_finite[T2](map(f!1, iseq)) THEN length(map(f!1, iseq)) ELSE 0 ENDIF"
       ("iseq") :skolem-typepreds? t)
      (("" (assert)
        (("" (expand "is_finite" (-2 +))
          (("" (expand "map" -2)
            (("" (lift-if)
              (("" (ground)
                (("" (inst - "rest(x!1)")
                  (("" (assert)
                    (("" (expand "map" 4 2)
                      (("" (expand "length" 4 2) (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (measure_induction formula-decl nil measure_induction nil)
    (T1 formal-type-decl nil csequence_map_props nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (infinite_csequence type-eq-decl nil csequence_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (T2 formal-type-decl nil csequence_map_props nil)
    (map adt-def-decl "csequence[T1]" csequence_codt_map nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (has_length def-decl "bool" csequence_props nil)
    (length def-decl "{n | has_length(fseq, n)}" csequence_length nil)
    (< const-decl "bool" reals nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (map_infinite subtype
    "csequence_codt_map[csequence_map_props.T1, csequence_map_props.T2].map(csequence_map_props.f, csequence_map_props.iseq)"
    "infinite_csequence[T2]")))
 (map_first_TCC1 0
  (map_first_TCC1-1 nil 3513550835
   ("" (skolem!) (("" (rewrite "map_nonempty") nil nil)) nil)
   ((map_nonempty formula-decl nil csequence_map_props nil)
    (T1 formal-type-decl nil csequence_map_props nil)
    (T2 formal-type-decl nil csequence_map_props nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (nonempty_csequence type-eq-decl nil csequence_props nil))
   nil
   (map_first subtype
    "csequence_codt_map[csequence_map_props.T1, csequence_map_props.T2].map(csequence_map_props.f, csequence_map_props.nseq)"
    "(csequence_codt[csequence_map_props.T2].nonempty?)")))
 (map_first 0
  (map_first-1 nil 3513551066 ("" (grind) nil nil)
   ((map adt-def-decl "csequence[T1]" csequence_codt_map nil)) shostak))
 (map_rest 0
  (map_rest-1 nil 3513551075
   ("" (expand "map" 1 1) (("" (propax) nil nil)) nil)
   ((map adt-def-decl "csequence[T1]" csequence_codt_map nil)) shostak))
 (map_length 0
  (map_length-1 nil 3513551085
   ("" (skolem + ("f!1" "_"))
    (("" (induct "fseq" :name "is_finite_induction[T1]")
      (("1" (assert) nil nil) ("2" (assert) nil nil)
       ("3" (skosimp)
        (("3" (ground)
          (("1" (use "map_empty")
            (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil)
           ("2" (expand "map" +)
            (("2" (expand "length" +) (("2" (reduce) nil nil)) nil)) nil))
          nil))
        nil)
       ("4" (skosimp) (("4" (rewrite "map_finite") nil nil)) nil))
      nil))
    nil)
   ((f!1 skolem-const-decl "[T1 -> T2]" csequence_map_props nil)
    (map adt-def-decl "csequence[T1]" csequence_codt_map nil)
    (T2 formal-type-decl nil csequence_map_props nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (has_length def-decl "bool" csequence_props nil)
    (length def-decl "{n | has_length(fseq, n)}" csequence_length nil)
    (T1 formal-type-decl nil csequence_map_props nil)
    (is_finite_induction formula-decl nil csequence_props nil)
    (map_empty formula-decl nil csequence_map_props nil)
    (map_finite judgement-tcc nil csequence_map_props nil))
   shostak))
 (map_index 0
  (map_index-1 nil 3513551180
   ("" (skolem!)
    (("" (decompose-equality)
      (("" (rewrite "index?_prop[T1]")
        (("" (rewrite "index?_prop[T2]")
          (("" (iff)
            (("" (rewrite "map_length")
              (("" (ground)
                (("1" (rewrite "map_finite") nil nil)
                 ("2" (rewrite "map_infinite") nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T2 formal-type-decl nil csequence_map_props nil)
    (csequence type-decl nil csequence_codt nil)
    (index? def-decl "bool" csequence_nth nil)
    (T1 formal-type-decl nil csequence_map_props nil)
    (map adt-def-decl "csequence[T1]" csequence_codt_map nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (map_length formula-decl nil csequence_map_props nil)
    (infinite_csequence type-eq-decl nil csequence_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (map_infinite judgement-tcc nil csequence_map_props nil)
    (map_finite judgement-tcc nil csequence_map_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (index?_prop formula-decl nil csequence_nth nil))
   shostak))
 (map_nth_TCC1 0
  (map_nth_TCC1-1 nil 3513550835
   ("" (skolem!) (("" (rewrite "map_index") (("" (assert) nil nil)) nil)) nil)
   ((map_index formula-decl nil csequence_map_props nil)
    (T1 formal-type-decl nil csequence_map_props nil)
    (T2 formal-type-decl nil csequence_map_props nil)
    (csequence type-decl nil csequence_codt nil))
   nil
   (map_nth subtype "csequence_map_props.n"
    "csequence_nth[csequence_map_props.T2].indexes(csequence_codt_map[csequence_map_props.T1, csequence_map_props.T2].map(csequence_map_props.f, csequence_map_props.cseq))")))
 (map_nth 0
  (map_nth-1 nil 3513551248
   ("" (skolem + ("f!1" "_" "_"))
    (("" (measure-induct+ "n" ("cseq" "n") :skolem-typepreds? t)
      (("1" (expand "map" +)
        (("1" (lift-if)
          (("1" (use "index?_nonempty[T1]")
            (("1" (assert)
              (("1" (expand "nth" +)
                (("1" (lift-if)
                  (("1" (ground)
                    (("1" (inst - "rest(x!1)" "x!2 - 1")
                      (("1" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (rewrite "map_index") nil nil)
       ("3" (rewrite "map_index") (("3" (assert) nil nil)) nil)
       ("4" (rewrite "map_index") (("4" (assert) nil nil)) nil)
       ("5" (rewrite "map_index") nil nil))
      nil))
    nil)
   ((pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (measure_induction formula-decl nil measure_induction nil)
    (T1 formal-type-decl nil csequence_map_props nil)
    (csequence type-decl nil csequence_codt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (index? def-decl "bool" csequence_nth nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (f!1 skolem-const-decl "[T1 -> T2]" csequence_map_props nil)
    (map adt-def-decl "csequence[T1]" csequence_codt_map nil)
    (T2 formal-type-decl nil csequence_map_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nth def-decl "T" csequence_nth nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (index?_nonempty formula-decl nil csequence_nth nil)
    (map_index formula-decl nil csequence_map_props nil))
   shostak))
 (map_add 0
  (map_add-1 nil 3513551339
   ("" (expand "map" 1 2) (("" (propax) nil nil)) nil)
   ((map adt-def-decl "csequence[T1]" csequence_codt_map nil)) shostak))
 (map_last_TCC1 0
  (map_last_TCC1-1 nil 3513550835
   ("" (skolem!) (("" (rewrite "map_nonempty") nil nil)) nil)
   ((map_nonempty formula-decl nil csequence_map_props nil)
    (T1 formal-type-decl nil csequence_map_props nil)
    (T2 formal-type-decl nil csequence_map_props nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (nonempty_finite_csequence type-eq-decl nil csequence_props nil))
   nil
   (map_last subtype
    "csequence_codt_map[csequence_map_props.T1, csequence_map_props.T2].map(csequence_map_props.f, csequence_map_props.nfseq)"
    "nonempty_finite_csequence[T2]")))
 (map_last 0
  (map_last-1 nil 3513551375
   ("" (auto-rewrite "map_length")
    (("" (skolem-typepred)
      (("" (expand "last")
        (("" (rewrite "map_nth")
          (("" (rewrite "length_nonempty?_rew[T1]")
            (("" (assert) (("" (rewrite "index?_finite") nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T1 formal-type-decl nil csequence_map_props nil)
    (csequence type-decl nil csequence_codt nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (nonempty_finite_csequence type-eq-decl nil csequence_props nil)
    (map_length formula-decl nil csequence_map_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (map_finite application-judgement "finite_csequence[T2]"
     csequence_map_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (map_nth formula-decl nil csequence_map_props nil)
    (T2 formal-type-decl nil csequence_map_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (index? def-decl "bool" csequence_nth nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (has_length def-decl "bool" csequence_props nil)
    (length def-decl "{n | has_length(fseq, n)}" csequence_length nil)
    (map adt-def-decl "csequence[T1]" csequence_codt_map nil)
    (index?_finite formula-decl nil csequence_nth nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length_nonempty?_rew formula-decl nil csequence_length nil)
    (last const-decl "T" csequence_nth nil))
   shostak))
 (map_map 0
  (map_map-1 nil 3513551441
   ("" (skolem!)
    (("" (lemma "coinduction[T2]")
      ((""
        (inst -
         "LAMBDA (cseq1, cseq2: csequence[T2]): EXISTS cseq: cseq1 = map(f!1)(cseq) AND cseq2 = map(f!1, cseq)"
         "map(f!1)(cseq!1)" "map(f!1, cseq!1)")
        (("1" (assert) (("1" (inst + "cseq!1") nil nil)) nil)
         ("2" (delete 2)
          (("2" (expand "bisimulation?")
            (("2" (skosimp*)
              (("2" (expand "map" -)
                (("2" (replace*)
                  (("2" (hide -1 -2)
                    (("2" (smash) (("2" (inst + "rest(cseq!2)") nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T2 formal-type-decl nil csequence_map_props nil)
    (coinduction formula-decl nil csequence_codt nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bisimulation? adt-def-decl "boolean" csequence_codt nil)
    (T1 formal-type-decl nil csequence_map_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (map adt-def-decl "csequence[T1]" csequence_codt_map nil)
    (f!1 skolem-const-decl "[T1 -> T2]" csequence_map_props nil)
    (map adt-def-decl "csequence[T1]" csequence_codt_map nil))
   shostak))
 (map_injective 0
  (map_injective-1 nil 3513551608
   ("" (expand "injective?")
    (("" (skosimp*)
      (("" (lemma "coinduction[T1]")
        ((""
          (inst - "LAMBDA cseq1, cseq2: map(f!1)(cseq1) = map(f!1)(cseq2)"
           "x1!1" "x2!1")
          (("1" (assert) nil nil)
           ("2" (delete -2 2)
            (("2" (expand "bisimulation?")
              (("2" (skosimp)
                (("2" (expand "map" -)
                  (("2" (reduce)
                    (("1" (decompose-equality) nil nil)
                     ("2" (decompose-equality) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((f!1 skolem-const-decl "[T1 -> T2]" csequence_map_props nil)
    (map adt-def-decl "csequence[T1]" csequence_codt_map nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T2 formal-type-decl nil csequence_map_props nil)
    (bisimulation? adt-def-decl "boolean" csequence_codt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (add adt-constructor-decl "[[T, csequence] -> (nonempty?)]" csequence_codt
     nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (first adt-accessor-decl "[(nonempty?) -> T]" csequence_codt nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (coinduction formula-decl nil csequence_codt nil)
    (T1 formal-type-decl nil csequence_map_props nil)
    (injective? const-decl "bool" functions nil))
   shostak))
 (map_extensionality 0
  (map_extensionality-1 nil 3513551776
   ("" (skosimp)
    (("" (forward-chain "map_injective")
      (("" (expand "injective?" -1)
        (("" (inst - "cseq1!1" "cseq2!1")
          (("" (assert)
            (("" (rewrite "map_map") (("" (rewrite "map_map") nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((map_injective formula-decl nil csequence_map_props nil)
    (T1 formal-type-decl nil csequence_map_props nil)
    (T2 formal-type-decl nil csequence_map_props nil)
    (csequence type-decl nil csequence_codt nil)
    (map_map formula-decl nil csequence_map_props nil)
    (injective? const-decl "bool" functions nil))
   shostak))
 (map_some 0
  (map_some-1 nil 3513551820
   ("" (skolem!)
    (("" (prop)
      (("1" (lemma "some_induction[T2]")
        (("1"
          (inst - "p!1"
           "LAMBDA (cseq2: csequence[T2]): FORALL cseq: cseq2 = map(f!1, cseq) IMPLIES some(p!1 o f!1)(cseq)")
          (("1" (split)
            (("1" (inst - "map(f!1, cseq!1)")
              (("1" (assert) (("1" (inst - "cseq!1") nil nil)) nil)) nil)
             ("2" (delete -1 2)
              (("2" (skosimp*)
                (("2" (replace -2)
                  (("2" (hide -2)
                    (("2" (lift-if)
                      (("2" (ground)
                        (("1" (expand* "map" "o" "some")
                          (("1" (reduce) nil nil)) nil)
                         ("2" (use "map_empty")
                          (("2" (assert)
                            (("2" (rewrite "map_rest")
                              (("2" (inst - "rest(cseq!2)")
                                (("2" (expand "some" +)
                                  (("2" (flatten) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (lemma "some_induction[T1]")
        (("2" (inst - "p!1 o f!1" "LAMBDA cseq: some(p!1)(map(f!1, cseq))")
          (("2" (split)
            (("1" (inst - "cseq!1") (("1" (assert) nil nil)) nil)
             ("2" (delete -1 2)
              (("2" (skosimp)
                (("2" (lift-if)
                  (("2" (ground)
                    (("1" (expand* "map" "o" "some") (("1" (flatten) nil nil))
                      nil)
                     ("2" (use "map_empty" ("cseq" "a!1"))
                      (("2" (assert)
                        (("2" (expand "some" +)
                          (("2" (flatten) (("2" (rewrite "map_rest") nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (pred type-eq-decl nil defined_types nil)
    (csequence type-decl nil csequence_codt nil)
    (T1 formal-type-decl nil csequence_map_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (map adt-def-decl "csequence[T1]" csequence_codt_map nil)
    (some inductive-decl "boolean" csequence_codt nil)
    (O const-decl "T3" function_props nil)
    (map_empty formula-decl nil csequence_map_props nil)
    (nonempty_csequence type-eq-decl nil csequence_props nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (map_rest formula-decl nil csequence_map_props nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (some_induction formula-decl nil csequence_codt nil)
    (T2 formal-type-decl nil csequence_map_props nil))
   shostak))
 (map_every 0
  (map_every-1 nil 3513551969
   ("" (skolem!)
    (("" (prop)
      (("1" (lemma "every_coinduction[T1]")
        (("1" (inst - "p!1 o f!1" "LAMBDA cseq: every(p!1)(map(f!1, cseq))")
          (("1" (split)
            (("1" (inst - "cseq!1") (("1" (assert) nil nil)) nil)
             ("2" (delete -1 2)
              (("2" (skosimp)
                (("2" (lift-if)
                  (("2" (ground)
                    (("1" (expand* "map" "o" "every")
                      (("1" (flatten) nil nil)) nil)
                     ("2" (use "map_empty" ("cseq" "a!1"))
                      (("2" (assert)
                        (("2" (expand "every" -)
                          (("2" (flatten) (("2" (rewrite "map_rest") nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (lemma "every_coinduction[T2]")
        (("2"
          (inst - "p!1"
           "LAMBDA (cseq2: csequence[T2]): EXISTS cseq: cseq2 = map(f!1, cseq) AND every(p!1 o f!1)(cseq)")
          (("2" (split)
            (("1" (inst - "map(f!1, cseq!1)")
              (("1" (assert) (("1" (inst + "cseq!1") nil nil)) nil)) nil)
             ("2" (delete -1 2)
              (("2" (skosimp*)
                (("2" (replace -1)
                  (("2" (hide -1)
                    (("2" (lift-if)
                      (("2" (ground)
                        (("1" (expand* "map" "o" "every")
                          (("1" (reduce) nil nil)) nil)
                         ("2" (use "map_empty")
                          (("2" (assert)
                            (("2" (rewrite "map_rest")
                              (("2" (inst + "rest(cseq!2)")
                                (("2" (expand "every" -)
                                  (("2" (flatten) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (T2 formal-type-decl nil csequence_map_props nil)
    (O const-decl "T3" function_props nil)
    (pred type-eq-decl nil defined_types nil)
    (csequence type-decl nil csequence_codt nil)
    (every coinductive-decl "boolean" csequence_codt nil)
    (map adt-def-decl "csequence[T1]" csequence_codt_map nil)
    (map_empty formula-decl nil csequence_map_props nil)
    (nonempty_csequence type-eq-decl nil csequence_props nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (map_rest formula-decl nil csequence_map_props nil)
    (every_coinduction formula-decl nil csequence_codt nil)
    (T1 formal-type-decl nil csequence_map_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil))
   shostak)))

