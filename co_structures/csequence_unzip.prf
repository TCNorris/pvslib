(csequence_unzip
 (unzip_left_struct_TCC1 0
  (unzip_left_struct_TCC1-1 nil 3513780110 ("" (subtype-tcc) nil nil) nil nil
   (unzip_left_struct subtype "csequence_unzip.cseq"
    "(csequence_codt[[csequence_unzip.T1, csequence_unzip.T2]].nonempty?)")))
 (unzip_finite 0
  (unzip_finite-1 nil 3513780110
   ("" (induct "fseq" :name "is_finite_induction[[T1, T2]]")
    (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)
     ("4" (assert) nil nil)
     ("5" (skosimp)
      (("5" (expand "is_finite" +)
        (("5" (expand* "unzip" "unzip_left_struct" "unzip_right_struct")
          (("5" (expand "coreduce" +) (("5" (reduce) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((unzip_left_struct const-decl "csequence_struct[T1, csequence[[T1, T2]]]"
     csequence_unzip nil)
    (unzip_right_struct const-decl "csequence_struct[T2, csequence[[T1, T2]]]"
     csequence_unzip nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (is_finite_induction formula-decl nil csequence_props nil)
    (T1 formal-type-decl nil csequence_unzip nil)
    (T2 formal-type-decl nil csequence_unzip nil)
    (unzip const-decl "[csequence[T1], csequence[T2]]" csequence_unzip nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (csequence type-decl nil csequence_codt nil))
   nil
   (unzip_finite subtype "csequence_unzip.unzip(csequence_unzip.fseq)"
    "[finite_csequence[T1], finite_csequence[T2]]")))
 (unzip_infinite 0
  (unzip_infinite-1 nil 3513780110
   (""
    (case "FORALL iseq, n: NOT has_length(unzip(iseq)`1, n) AND NOT has_length(unzip(iseq)`2, n)")
    (("1" (skolem!)
      (("1" (split)
        (("1" (rewrite "is_finite_def")
          (("1" (skolem!)
            (("1" (inst - "iseq!1" "n!1") (("1" (flatten) nil nil)) nil))
            nil))
          nil)
         ("2" (rewrite "is_finite_def")
          (("2" (skolem!)
            (("2" (inst - "iseq!1" "n!1") (("2" (flatten) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (delete 2)
      (("2" (induct "n")
        (("1" (skolem-typepred)
          (("1"
            (expand* "has_length" "unzip" "unzip_left_struct"
             "unzip_right_struct" "coreduce" "is_finite")
            (("1" (reduce) nil nil)) nil))
          nil)
         ("2" (skosimp* t)
          (("2" (expand "has_length" +)
            (("2" (expand "is_finite" +)
              (("2" (expand* "unzip" "unzip_left_struct" "unzip_right_struct")
                (("2" (expand "coreduce" +)
                  (("2" (smash)
                    (("1" (inst - "rest(iseq!1)") (("1" (flatten) nil nil))
                      nil)
                     ("2" (inst - "rest(iseq!1)") (("2" (flatten) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (unzip_left_struct const-decl "csequence_struct[T1, csequence[[T1, T2]]]"
     csequence_unzip nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (unzip_right_struct const-decl "csequence_struct[T2, csequence[[T1, T2]]]"
     csequence_unzip nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (is_finite_def formula-decl nil csequence_props nil)
    (T1 formal-type-decl nil csequence_unzip nil)
    (T2 formal-type-decl nil csequence_unzip nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (infinite_csequence type-eq-decl nil csequence_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (has_length def-decl "bool" csequence_props nil)
    (unzip const-decl "[csequence[T1], csequence[T2]]" csequence_unzip nil))
   nil
   (unzip_infinite subtype "csequence_unzip.unzip(csequence_unzip.iseq)"
    "[infinite_csequence[T1], infinite_csequence[T2]]")))
 (unzip_nonempty 0
  (unzip_nonempty-1 nil 3513780110
   ("" (expand* "unzip" "unzip_left_struct" "unzip_right_struct" "coreduce")
    nil nil)
   ((coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (unzip_right_struct const-decl "csequence_struct[T2, csequence[[T1, T2]]]"
     csequence_unzip nil)
    (unzip_left_struct const-decl "csequence_struct[T1, csequence[[T1, T2]]]"
     csequence_unzip nil)
    (unzip const-decl "[csequence[T1], csequence[T2]]" csequence_unzip nil))
   nil
   (unzip_nonempty subtype "csequence_unzip.unzip(csequence_unzip.nseq)"
    "[nonempty_csequence[T1], nonempty_csequence[T2]]")))
 (unzip_empty_left 0
  (unzip_empty_left-1 nil 3513780336
   ("" (expand* "unzip" "unzip_left_struct" "coreduce")
    (("" (reduce) nil nil)) nil)
   ((unzip const-decl "[csequence[T1], csequence[T2]]" csequence_unzip nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (unzip_left_struct const-decl "csequence_struct[T1, csequence[[T1, T2]]]"
     csequence_unzip nil))
   shostak))
 (unzip_empty_right 0
  (unzip_empty_right-1 nil 3513780348
   ("" (expand* "unzip" "unzip_right_struct" "coreduce")
    (("" (reduce) nil nil)) nil)
   ((unzip const-decl "[csequence[T1], csequence[T2]]" csequence_unzip nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (unzip_right_struct const-decl "csequence_struct[T2, csequence[[T1, T2]]]"
     csequence_unzip nil))
   shostak))
 (unzip_first_left 0
  (unzip_first_left-1 nil 3513780362
   ("" (expand* "unzip" "unzip_left_struct" "coreduce") nil nil)
   ((coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (unzip_left_struct const-decl "csequence_struct[T1, csequence[[T1, T2]]]"
     csequence_unzip nil)
    (unzip const-decl "[csequence[T1], csequence[T2]]" csequence_unzip nil))
   shostak))
 (unzip_first_right 0
  (unzip_first_right-1 nil 3513780369
   ("" (expand* "unzip" "unzip_right_struct" "coreduce") nil nil)
   ((coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (unzip_right_struct const-decl "csequence_struct[T2, csequence[[T1, T2]]]"
     csequence_unzip nil)
    (unzip const-decl "[csequence[T1], csequence[T2]]" csequence_unzip nil))
   shostak))
 (unzip_rest_left 0
  (unzip_rest_left-1 nil 3513780376
   ("" (expand* "unzip" "unzip_left_struct")
    (("" (expand "coreduce" 1 1) (("" (propax) nil nil)) nil)) nil)
   ((coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (unzip const-decl "[csequence[T1], csequence[T2]]" csequence_unzip nil)
    (unzip_left_struct const-decl "csequence_struct[T1, csequence[[T1, T2]]]"
     csequence_unzip nil))
   shostak))
 (unzip_rest_right 0
  (unzip_rest_right-1 nil 3513780388
   ("" (expand* "unzip" "unzip_right_struct")
    (("" (expand "coreduce" 1 1) (("" (propax) nil nil)) nil)) nil)
   ((coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (unzip const-decl "[csequence[T1], csequence[T2]]" csequence_unzip nil)
    (unzip_right_struct const-decl "csequence_struct[T2, csequence[[T1, T2]]]"
     csequence_unzip nil))
   shostak))
 (unzip_length_left 0
  (unzip_length_left-1 nil 3513780408
   ("" (induct "fseq" :name "is_finite_induction[[T1, T2]]")
    (("1" (assert) nil nil) ("2" (assert) nil nil)
     ("3" (skosimp)
      (("3" (expand "length" +)
        (("3" (expand* "unzip" "unzip_left_struct")
          (("3" (expand "coreduce" +) (("3" (reduce) nil nil)) nil)) nil))
        nil))
      nil)
     ("4" (skosimp)
      (("4" (assert)
        (("4" (lemma "unzip_finite" ("fseq" "fseq!2"))
          (("4" (flatten) nil nil)) nil))
        nil))
      nil))
    nil)
   ((unzip_finite judgement-tcc nil csequence_unzip nil)
    (unzip_finite application-judgement
     "[finite_csequence[T1], finite_csequence[T2]]" csequence_unzip nil)
    (unzip_left_struct const-decl "csequence_struct[T1, csequence[[T1, T2]]]"
     csequence_unzip nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (is_finite_induction formula-decl nil csequence_props nil)
    (T1 formal-type-decl nil csequence_unzip nil)
    (T2 formal-type-decl nil csequence_unzip nil)
    (length def-decl "{n | has_length(fseq, n)}" csequence_length nil)
    (has_length def-decl "bool" csequence_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (unzip const-decl "[csequence[T1], csequence[T2]]" csequence_unzip nil))
   shostak))
 (unzip_length_right 0
  (unzip_length_right-1 nil 3513780457
   ("" (induct "fseq" :name "is_finite_induction[[T1, T2]]")
    (("1" (assert) nil nil) ("2" (assert) nil nil)
     ("3" (skosimp)
      (("3" (expand "length" +)
        (("3" (expand* "unzip" "unzip_right_struct")
          (("3" (expand "coreduce" +) (("3" (reduce) nil nil)) nil)) nil))
        nil))
      nil)
     ("4" (skosimp)
      (("4" (assert)
        (("4" (lemma "unzip_finite" ("fseq" "fseq!2"))
          (("4" (flatten) nil nil)) nil))
        nil))
      nil))
    nil)
   ((unzip_finite judgement-tcc nil csequence_unzip nil)
    (unzip_finite application-judgement
     "[finite_csequence[T1], finite_csequence[T2]]" csequence_unzip nil)
    (unzip_right_struct const-decl "csequence_struct[T2, csequence[[T1, T2]]]"
     csequence_unzip nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (is_finite_induction formula-decl nil csequence_props nil)
    (T1 formal-type-decl nil csequence_unzip nil)
    (T2 formal-type-decl nil csequence_unzip nil)
    (length def-decl "{n | has_length(fseq, n)}" csequence_length nil)
    (has_length def-decl "bool" csequence_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (unzip const-decl "[csequence[T1], csequence[T2]]" csequence_unzip nil))
   shostak))
 (unzip_index_left 0
  (unzip_index_left-1 nil 3513780499
   ("" (skolem!)
    (("" (rewrite "index?_prop")
      (("" (rewrite "index?_prop")
        (("" (rewrite "unzip_length_left")
          (("" (ground)
            (("1" (use "unzip_finite") (("1" (flatten) nil nil)) nil)
             ("2" (use "unzip_infinite") (("2" (flatten) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((index?_prop formula-decl nil csequence_nth nil)
    (csequence type-decl nil csequence_codt nil)
    (T2 formal-type-decl nil csequence_unzip nil)
    (unzip const-decl "[csequence[T1], csequence[T2]]" csequence_unzip nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T1 formal-type-decl nil csequence_unzip nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (unzip_length_left formula-decl nil csequence_unzip nil)
    (unzip_infinite judgement-tcc nil csequence_unzip nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (infinite_csequence type-eq-decl nil csequence_props nil)
    (unzip_finite judgement-tcc nil csequence_unzip nil))
   shostak))
 (unzip_index_right 0
  (unzip_index_right-1 nil 3513780534
   ("" (skolem!)
    (("" (rewrite "index?_prop")
      (("" (rewrite "index?_prop")
        (("" (rewrite "unzip_length_right")
          (("" (ground)
            (("1" (use "unzip_finite") (("1" (flatten) nil nil)) nil)
             ("2" (use "unzip_infinite") (("2" (flatten) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((index?_prop formula-decl nil csequence_nth nil)
    (csequence type-decl nil csequence_codt nil)
    (T1 formal-type-decl nil csequence_unzip nil)
    (unzip const-decl "[csequence[T1], csequence[T2]]" csequence_unzip nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T2 formal-type-decl nil csequence_unzip nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (unzip_length_right formula-decl nil csequence_unzip nil)
    (unzip_infinite judgement-tcc nil csequence_unzip nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (infinite_csequence type-eq-decl nil csequence_props nil)
    (unzip_finite judgement-tcc nil csequence_unzip nil))
   shostak))
 (unzip_nth_left_TCC1 0
  (unzip_nth_left_TCC1-1 nil 3513780110
   ("" (skolem!) (("" (rewrite "unzip_index_left") nil nil)) nil)
   ((unzip_index_left formula-decl nil csequence_unzip nil)
    (T1 formal-type-decl nil csequence_unzip nil)
    (T2 formal-type-decl nil csequence_unzip nil)
    (csequence type-decl nil csequence_codt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (index? def-decl "bool" csequence_nth nil)
    (indexes type-eq-decl nil csequence_nth nil))
   nil
   (unzip_nth_left subtype "csequence_unzip.n"
    "csequence_nth[csequence_unzip.T1].indexes(csequence_unzip.unzip(csequence_unzip.cseq)`1)")))
 (unzip_nth_left 0
  (unzip_nth_left-1 nil 3513780751
   ("" (measure-induct+ "n" ("cseq" "n") :skolem-typepreds? t)
    (("1" (expand "index?" -)
      (("1" (expand "nth" +)
        (("1" (expand* "unzip" "unzip_left_struct")
          (("1" (expand "coreduce" +) (("1" (reduce) nil nil)) nil)) nil))
        nil))
      nil)
     ("2" (use "unzip_nth_left_TCC1") nil nil)
     ("3" (use "unzip_nth_left_TCC1") nil nil)
     ("4" (use "unzip_nth_left_TCC1") nil nil)
     ("5" (use "unzip_nth_left_TCC1") nil nil))
    nil)
   ((unzip_nth_left_TCC1 subtype-tcc nil csequence_unzip nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (unzip_left_struct const-decl "csequence_struct[T1, csequence[[T1, T2]]]"
     csequence_unzip nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (x!2 skolem-const-decl "indexes[[T1, T2]](x!1)" csequence_unzip nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (x!1 skolem-const-decl "csequence[[T1, T2]]" csequence_unzip nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nth def-decl "T" csequence_nth nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (unzip const-decl "[csequence[T1], csequence[T2]]" csequence_unzip nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (index? def-decl "bool" csequence_nth nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (csequence type-decl nil csequence_codt nil)
    (T2 formal-type-decl nil csequence_unzip nil)
    (T1 formal-type-decl nil csequence_unzip nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (unzip_nth_right_TCC1 0
  (unzip_nth_right_TCC1-1 nil 3513780110
   ("" (skolem!) (("" (rewrite "unzip_index_right") nil nil)) nil)
   ((unzip_index_right formula-decl nil csequence_unzip nil)
    (T1 formal-type-decl nil csequence_unzip nil)
    (T2 formal-type-decl nil csequence_unzip nil)
    (csequence type-decl nil csequence_codt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (index? def-decl "bool" csequence_nth nil)
    (indexes type-eq-decl nil csequence_nth nil))
   nil
   (unzip_nth_right subtype "csequence_unzip.n"
    "csequence_nth[csequence_unzip.T2].indexes(csequence_unzip.unzip(csequence_unzip.cseq)`2)")))
 (unzip_nth_right 0
  (unzip_nth_right-1 nil 3513780801
   ("" (measure-induct+ "n" ("cseq" "n") :skolem-typepreds? t)
    (("1" (expand "index?" -)
      (("1" (expand "nth" +)
        (("1" (expand* "unzip" "unzip_right_struct")
          (("1" (expand "coreduce" +) (("1" (reduce) nil nil)) nil)) nil))
        nil))
      nil)
     ("2" (use "unzip_nth_right_TCC1") nil nil)
     ("3" (use "unzip_nth_right_TCC1") nil nil)
     ("4" (use "unzip_nth_right_TCC1") nil nil)
     ("5" (use "unzip_nth_right_TCC1") nil nil))
    nil)
   ((unzip_nth_right_TCC1 subtype-tcc nil csequence_unzip nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (unzip_right_struct const-decl "csequence_struct[T2, csequence[[T1, T2]]]"
     csequence_unzip nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (x!2 skolem-const-decl "indexes[[T1, T2]](x!1)" csequence_unzip nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (x!1 skolem-const-decl "csequence[[T1, T2]]" csequence_unzip nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nth def-decl "T" csequence_nth nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (unzip const-decl "[csequence[T1], csequence[T2]]" csequence_unzip nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (index? def-decl "bool" csequence_nth nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (csequence type-decl nil csequence_codt nil)
    (T2 formal-type-decl nil csequence_unzip nil)
    (T1 formal-type-decl nil csequence_unzip nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (unzip_map 0
  (unzip_map-1 nil 3513780879
   ("" (skolem!)
    (("" (decompose-equality)
      (("1" (lemma "coinduction[T1]")
        (("1"
          (inst -
           "LAMBDA (cseq1, cseq2: csequence[T1]): EXISTS cseq: cseq1 = unzip(cseq)`1 AND cseq2 = map[[T1, T2], T1](PROJ_1, cseq)"
           "unzip(cseq!1)`1" "map[[T1, T2], T1](PROJ_1, cseq!1)")
          (("1" (assert) (("1" (inst + "cseq!1") nil nil)) nil)
           ("2" (delete 2)
            (("2" (expand "bisimulation?")
              (("2" (skosimp*)
                (("2" (replace*)
                  (("2" (hide -1 -2)
                    (("2"
                      (expand* "unzip" "unzip_left_struct" "coreduce" "map")
                      (("2" (smash)
                        (("2" (inst + "rest(cseq!2)")
                          (("2" (expand "map" 2 1)
                            (("2" (expand "coreduce" 2 1)
                              (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (lemma "coinduction[T2]")
        (("2"
          (inst -
           "LAMBDA (cseq1, cseq2: csequence[T2]): EXISTS cseq: cseq1 = unzip(cseq)`2 AND cseq2 = map[[T1, T2], T2](PROJ_2, cseq)"
           "unzip(cseq!1)`2" "map[[T1, T2], T2](PROJ_2, cseq!1)")
          (("1" (assert) (("1" (inst + "cseq!1") nil nil)) nil)
           ("2" (delete 2)
            (("2" (expand "bisimulation?")
              (("2" (skosimp*)
                (("2" (replace*)
                  (("2" (hide -1 -2)
                    (("2"
                      (expand* "unzip" "unzip_right_struct" "coreduce" "map")
                      (("2" (smash)
                        (("2" (inst + "rest(cseq!2)")
                          (("2" (expand "map" 2 1)
                            (("2" (expand "coreduce" 2 1)
                              (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((unzip const-decl "[csequence[T1], csequence[T2]]" csequence_unzip nil)
    (map adt-def-decl "csequence[T1]" csequence_codt_map nil)
    (T2 formal-type-decl nil csequence_unzip nil)
    (csequence type-decl nil csequence_codt nil)
    (T1 formal-type-decl nil csequence_unzip nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bisimulation? adt-def-decl "boolean" csequence_codt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (unzip_left_struct const-decl "csequence_struct[T1, csequence[[T1, T2]]]"
     csequence_unzip nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (coinduction formula-decl nil csequence_codt nil)
    (unzip_right_struct const-decl "csequence_struct[T2, csequence[[T1, T2]]]"
     csequence_unzip nil))
   shostak))
 (unzip_extensionality 0
  (unzip_extensionality-1 nil 3513781049
   ("" (skosimp)
    (("" (lemma "coinduction[[T1, T2]]")
      ((""
        (inst - "LAMBDA cseq1, cseq2: unzip(cseq1) = unzip(cseq2)" "cseq1!1"
         "cseq2!1")
        (("1" (assert) nil nil)
         ("2" (delete -1 2)
          (("2" (expand "bisimulation?")
            (("2" (skosimp)
              (("2" (reduce)
                (("1"
                  (expand* "unzip" "unzip_left_struct" "unzip_right_struct"
                   "coreduce")
                  nil nil)
                 ("2"
                  (expand* "unzip" "unzip_left_struct" "unzip_right_struct"
                   "coreduce")
                  nil nil)
                 ("3"
                  (expand* "unzip" "unzip_left_struct" "unzip_right_struct")
                  (("3" (expand "coreduce" -)
                    (("3" (reduce)
                      (("1" (decompose-equality -2) nil nil)
                       ("2" (decompose-equality) nil nil))
                      nil))
                    nil))
                  nil)
                 ("4"
                  (expand* "unzip" "unzip_left_struct" "unzip_right_struct"
                   "coreduce")
                  (("4" (reduce)
                    (("4" (reduce-with-ext)
                      (("1" (decompose-equality) nil nil)
                       ("2" (decompose-equality -2) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T2 formal-type-decl nil csequence_unzip nil)
    (T1 formal-type-decl nil csequence_unzip nil)
    (coinduction formula-decl nil csequence_codt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (first adt-accessor-decl "[(nonempty?) -> T]" csequence_codt nil)
    (add adt-constructor-decl "[[T, csequence] -> (nonempty?)]" csequence_codt
     nil)
    (csequence_struct type-decl nil csequence_codt_coreduce nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (inj_empty? adt-recognizer-decl "[csequence_struct -> boolean]"
     csequence_codt_coreduce nil)
    (empty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt nil)
    (inj_nonempty? adt-recognizer-decl "[csequence_struct -> boolean]"
     csequence_codt_coreduce nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (inj_empty_cseq adt-constructor-decl "(inj_empty?)"
     csequence_codt_coreduce nil)
    (inj_add adt-constructor-decl "[[T, domain] -> (inj_nonempty?)]"
     csequence_codt_coreduce nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (unzip_left_struct const-decl "csequence_struct[T1, csequence[[T1, T2]]]"
     csequence_unzip nil)
    (unzip_right_struct const-decl "csequence_struct[T2, csequence[[T1, T2]]]"
     csequence_unzip nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bisimulation? adt-def-decl "boolean" csequence_codt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (unzip const-decl "[csequence[T1], csequence[T2]]" csequence_unzip nil))
   shostak))
 (unzip_add 0
  (unzip_add-1 nil 3513781223
   ("" (expand* "unzip" "unzip_left_struct" "unzip_right_struct")
    (("" (expand "coreduce" 1 1)
      (("" (expand "coreduce" 1 1) (("" (propax) nil nil)) nil)) nil))
    nil)
   ((coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (unzip const-decl "[csequence[T1], csequence[T2]]" csequence_unzip nil)
    (unzip_right_struct const-decl "csequence_struct[T2, csequence[[T1, T2]]]"
     csequence_unzip nil)
    (unzip_left_struct const-decl "csequence_struct[T1, csequence[[T1, T2]]]"
     csequence_unzip nil))
   shostak))
 (unzip_last_left_TCC1 0
  (unzip_last_left_TCC1-1 nil 3513780110
   ("" (skolem!) (("" (use "unzip_nonempty") (("" (flatten) nil nil)) nil))
    nil)
   ((unzip_nonempty judgement-tcc nil csequence_unzip nil)
    (nonempty_finite_csequence type-eq-decl nil csequence_props nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (nonempty_csequence type-eq-decl nil csequence_props nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (boolean nonempty-type-decl nil booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (T2 formal-type-decl nil csequence_unzip nil)
    (T1 formal-type-decl nil csequence_unzip nil))
   nil
   (unzip_last_left subtype "csequence_unzip.unzip(csequence_unzip.nfseq)`1"
    "nonempty_finite_csequence[T1]")))
 (unzip_last_left 0
  (unzip_last_left-1 nil 3513781279
   ("" (skolem-typepred)
    (("" (rewrite "length_nonempty?_rew")
      (("" (expand "last")
        (("" (rewrite "unzip_length_left")
          (("" (rewrite "unzip_nth_left") nil nil)) nil))
        nil))
      nil))
    nil)
   ((length_nonempty?_rew formula-decl nil csequence_length nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (unzip_length_left formula-decl nil csequence_unzip nil)
    (length def-decl "{n | has_length(fseq, n)}" csequence_length nil)
    (has_length def-decl "bool" csequence_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (index? def-decl "bool" csequence_nth nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (unzip_nth_left formula-decl nil csequence_unzip nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (last const-decl "T" csequence_nth nil)
    (nonempty_finite_csequence type-eq-decl nil csequence_props nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (csequence type-decl nil csequence_codt nil)
    (T2 formal-type-decl nil csequence_unzip nil)
    (T1 formal-type-decl nil csequence_unzip nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (unzip_last_right_TCC1 0
  (unzip_last_right_TCC1-1 nil 3513780110
   ("" (skolem!) (("" (use "unzip_nonempty") (("" (flatten) nil nil)) nil))
    nil)
   ((unzip_nonempty judgement-tcc nil csequence_unzip nil)
    (nonempty_finite_csequence type-eq-decl nil csequence_props nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (nonempty_csequence type-eq-decl nil csequence_props nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (boolean nonempty-type-decl nil booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (T2 formal-type-decl nil csequence_unzip nil)
    (T1 formal-type-decl nil csequence_unzip nil))
   nil
   (unzip_last_right subtype "csequence_unzip.unzip(csequence_unzip.nfseq)`2"
    "nonempty_finite_csequence[T2]")))
 (unzip_last_right 0
  (unzip_last_right-1 nil 3513781314
   ("" (skolem-typepred)
    (("" (rewrite "length_nonempty?_rew")
      (("" (expand "last")
        (("" (rewrite "unzip_length_right")
          (("" (rewrite "unzip_nth_right") nil nil)) nil))
        nil))
      nil))
    nil)
   ((length_nonempty?_rew formula-decl nil csequence_length nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (unzip_length_right formula-decl nil csequence_unzip nil)
    (length def-decl "{n | has_length(fseq, n)}" csequence_length nil)
    (has_length def-decl "bool" csequence_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (index? def-decl "bool" csequence_nth nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (unzip_nth_right formula-decl nil csequence_unzip nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (last const-decl "T" csequence_nth nil)
    (nonempty_finite_csequence type-eq-decl nil csequence_props nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (csequence type-decl nil csequence_codt nil)
    (T2 formal-type-decl nil csequence_unzip nil)
    (T1 formal-type-decl nil csequence_unzip nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (unzip_some 0
  (unzip_some-1 nil 3513781344
   ("" (skolem!)
    (("" (use "nth_some[[T1, T2]]")
      (("" (use "nth_some[T2]")
        (("" (use "nth_some[T1]")
          (("" (smash)
            (("1" (skosimp* t)
              (("1" (rewrite "unzip_index_right")
                (("1" (inst + "i!2")
                  (("1" (flatten) (("1" (rewrite "unzip_nth_right") nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skolem-typepred)
              (("2" (rewrite "unzip_index_left")
                (("2" (inst 4 "i!1")
                  (("2" (flatten) (("2" (rewrite "unzip_nth_left") nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (skolem-typepred)
              (("3" (rewrite "unzip_index_right")
                (("3" (inst 4 "i!1")
                  (("3" (flatten) (("3" (rewrite "unzip_nth_right") nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("4" (skolem-typepred)
              (("4" (split)
                (("1" (rewrite "unzip_index_left" :dir rl)
                  (("1" (inst + "i!1")
                    (("1" (rewrite "unzip_nth_left") nil nil)) nil))
                  nil)
                 ("2" (rewrite "unzip_index_right" :dir rl)
                  (("2" (inst 4 "i!1")
                    (("2" (rewrite "unzip_nth_right") nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nth_some formula-decl nil csequence_nth nil)
    (T1 formal-type-decl nil csequence_unzip nil)
    (T2 formal-type-decl nil csequence_unzip nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (i!1 skolem-const-decl "indexes[[T1, T2]](cseq!1)" csequence_unzip nil)
    (i!1 skolem-const-decl "indexes[T2](unzip(cseq!1)`2)" csequence_unzip nil)
    (i!1 skolem-const-decl "indexes[T1](unzip(cseq!1)`1)" csequence_unzip nil)
    (unzip_nth_left formula-decl nil csequence_unzip nil)
    (unzip_index_left formula-decl nil csequence_unzip nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (index? def-decl "bool" csequence_nth nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (cseq!1 skolem-const-decl "csequence[[T1, T2]]" csequence_unzip nil)
    (i!2 skolem-const-decl "indexes[T2](unzip(cseq!1)`2)" csequence_unzip nil)
    (unzip_nth_right formula-decl nil csequence_unzip nil)
    (unzip_index_right formula-decl nil csequence_unzip nil)
    (unzip const-decl "[csequence[T1], csequence[T2]]" csequence_unzip nil))
   shostak))
 (unzip_every 0
  (unzip_every-1 nil 3513781474
   ("" (skolem!)
    (("" (use "nth_every[[T1, T2]]")
      (("" (use "nth_every[[T2]]")
        (("" (use "nth_every[[T1]]")
          (("" (smash)
            (("1" (skolem-typepred)
              (("1" (split)
                (("1" (rewrite "unzip_index_left" :dir rl)
                  (("1" (inst - "i!1")
                    (("1" (rewrite "unzip_nth_left" :dir rl) nil nil)) nil))
                  nil)
                 ("2" (rewrite "unzip_index_right" :dir rl)
                  (("2" (inst -5 "i!1")
                    (("2" (rewrite "unzip_nth_right" :dir rl) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (skolem-typepred)
              (("2" (rewrite "unzip_index_right")
                (("2" (inst -5 "i!1")
                  (("2" (flatten) (("2" (rewrite "unzip_nth_right") nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (skolem-typepred)
              (("3" (rewrite "unzip_index_left")
                (("3" (inst -5 "i!1")
                  (("3" (flatten) (("3" (rewrite "unzip_nth_left") nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("4" (skosimp* t)
              (("4" (rewrite "unzip_index_right")
                (("4" (inst - "i!2")
                  (("4" (flatten) (("4" (rewrite "unzip_nth_right") nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nth_every formula-decl nil csequence_nth nil)
    (T1 formal-type-decl nil csequence_unzip nil)
    (T2 formal-type-decl nil csequence_unzip nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (i!2 skolem-const-decl "indexes[T2](unzip(cseq!1)`2)" csequence_unzip nil)
    (i!1 skolem-const-decl "indexes[T1](unzip(cseq!1)`1)" csequence_unzip nil)
    (i!1 skolem-const-decl "indexes[T2](unzip(cseq!1)`2)" csequence_unzip nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (index? def-decl "bool" csequence_nth nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (unzip_index_right formula-decl nil csequence_unzip nil)
    (unzip_nth_right formula-decl nil csequence_unzip nil)
    (unzip_index_left formula-decl nil csequence_unzip nil)
    (unzip_nth_left formula-decl nil csequence_unzip nil)
    (i!1 skolem-const-decl "indexes[[T1, T2]](cseq!1)" csequence_unzip nil)
    (cseq!1 skolem-const-decl "csequence[[T1, T2]]" csequence_unzip nil)
    (unzip const-decl "[csequence[T1], csequence[T2]]" csequence_unzip nil))
   shostak)))

