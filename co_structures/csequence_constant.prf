(csequence_constant
 (constant_cseq_TCC1 0
  (constant_cseq_TCC1-1 nil 3513602349 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (constant_cseq subtype "(number_fields.-)(csequence_constant.n, 1)"
    "nat")))
 (constant_cseq_TCC2 0
  (constant_cseq_TCC2-1 nil 3513602349 ("" (termination-tcc) nil nil) nil nil
   (constant_cseq termination
    "csequence_constant.constant_cseq(csequence_constant.t, (number_fields.-)(csequence_constant.n, 1))"
    "nil")))
 (constant_cseq_TCC3 0
  (constant_cseq_TCC3-1 nil 3513602349
   ("" (expand "is_finite") (("" (propax) nil nil)) nil)
   ((is_finite inductive-decl "bool" csequence_props nil)) nil
   (constant_cseq subtype
    "csequence_codt[csequence_constant.T].add(csequence_constant.t, csequence_constant.constant_cseq(csequence_constant.t, (number_fields.-)(csequence_constant.n, 1)))"
    "finite_csequence[T]")))
 (constant_cseq_empty 0
  (constant_cseq_empty-1 nil 3513602385
   ("" (skolem!)
    (("" (expand "constant_cseq") (("" (lift-if) (("" (ground) nil nil)) nil))
      nil))
    nil)
   ((constant_cseq def-decl "finite_csequence" csequence_constant nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (constant_cseq_1 0
  (constant_cseq_1-1 nil 3513602407 ("" (grind) nil nil)
   ((constant_cseq def-decl "finite_csequence" csequence_constant nil)
    (T formal-type-decl nil csequence_constant nil)
    (singleton_cseq const-decl "(singleton_cseq?)" csequence_singleton nil))
   shostak))
 (constant_cseq_first_TCC1 0
  (constant_cseq_first_TCC1-1 nil 3513602349
   ("" (skosimp) (("" (expand "constant_cseq") (("" (assert) nil nil)) nil))
    nil)
   ((constant_cseq def-decl "finite_csequence" csequence_constant nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (constant_cseq_first subtype
    "csequence_constant.constant_cseq(csequence_constant.t, csequence_constant.n)"
    "(csequence_codt[csequence_constant.T].nonempty?)")))
 (constant_cseq_first 0
  (constant_cseq_first-1 nil 3513602464
   ("" (skosimp) (("" (expand "constant_cseq") (("" (assert) nil nil)) nil))
    nil)
   ((constant_cseq def-decl "finite_csequence" csequence_constant nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (constant_cseq_rest_TCC1 0
  (constant_cseq_rest_TCC1-1 nil 3513602349 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (constant_cseq_rest subtype "(number_fields.-)(csequence_constant.n, 1)"
    "nat")))
 (constant_cseq_rest 0
  (constant_cseq_rest-1 nil 3513602539
   ("" (skosimp)
    (("" (expand "constant_cseq" 1 1) (("" (assert) nil nil)) nil)) nil)
   ((constant_cseq def-decl "finite_csequence" csequence_constant nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (constant_cseq_length 0
  (constant_cseq_length-1 nil 3513602568
   ("" (induct "n")
    (("1" (expand* "constant_cseq" "length") nil nil)
     ("2" (skosimp*)
      (("2" (expand "constant_cseq" +)
        (("2" (expand "length" +) (("2" (inst - "t!1") nil nil)) nil)) nil))
      nil))
    nil)
   ((nat_induction formula-decl nil naturalnumbers nil)
    (constant_cseq def-decl "finite_csequence" csequence_constant nil)
    (length def-decl "{n | has_length(fseq, n)}" csequence_length nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (has_length def-decl "bool" csequence_props nil)
    (csequence type-decl nil csequence_codt nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil csequence_constant nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (constant_cseq_index 0
  (constant_cseq_index-1 nil 3513602615
   ("" (skolem!)
    (("" (rewrite "index?_finite")
      (("" (rewrite "constant_cseq_length") (("" (prop) nil nil)) nil)) nil))
    nil)
   ((index?_finite formula-decl nil csequence_nth nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (constant_cseq def-decl "finite_csequence" csequence_constant nil)
    (T formal-type-decl nil csequence_constant nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (constant_cseq_length formula-decl nil csequence_constant nil))
   shostak))
 (constant_cseq_nth_TCC1 0
  (constant_cseq_nth_TCC1-1 nil 3513602349
   ("" (skolem!)
    (("" (rewrite "index?_finite")
      (("" (rewrite "constant_cseq_length") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((index?_finite formula-decl nil csequence_nth nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (constant_cseq def-decl "finite_csequence" csequence_constant nil)
    (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil)
    (T formal-type-decl nil csequence_constant nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (constant_cseq_length formula-decl nil csequence_constant nil))
   nil
   (constant_cseq_nth subtype "csequence_constant.m"
    "csequence_nth[csequence_constant.T].indexes(csequence_constant.constant_cseq(csequence_constant.t, csequence_constant.n))")))
 (constant_cseq_nth 0
  (constant_cseq_nth-1 nil 3513602648
   ("" (induct "n")
    (("1" (skolem-typepred) nil nil)
     ("2" (skosimp*)
      (("2" (expand "constant_cseq" +)
        (("2" (expand "nth" +)
          (("2" (lift-if)
            (("2" (ground) (("2" (inst - "t!1" "m!1 - 1") nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skolem!) (("3" (use "constant_cseq_nth_TCC1") nil nil)) nil))
    nil)
   ((constant_cseq_nth_TCC1 subtype-tcc nil csequence_constant nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (nth def-decl "T" csequence_nth nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil csequence_constant nil)
    (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil)
    (csequence type-decl nil csequence_codt nil)
    (index? def-decl "bool" csequence_nth nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (constant_cseq def-decl "finite_csequence" csequence_constant nil))
   shostak))
 (constant_cseq_add 0
  (constant_cseq_add-1 nil 3513602705
   ("" (expand "constant_cseq" + 2) (("" (propax) nil nil)) nil)
   ((constant_cseq def-decl "finite_csequence" csequence_constant nil))
   shostak))
 (constant_cseq_last 0
  (constant_cseq_last-1 nil 3513602720
   ("" (induct "n")
    (("1" (skosimp) (("1" (assert) nil nil)) nil)
     ("2" (skosimp*)
      (("2" (expand "constant_cseq" +)
        (("2" (expand "last")
          (("2" (expand "nth" +)
            (("2" (expand "length" +)
              (("2" (lift-if)
                (("2" (inst - "t!1")
                  (("2" (expand "constant_cseq" 1 1)
                    (("2" (expand "length" 1 1) (("2" (ground) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skosimp)
      (("3" (use "constant_cseq_first_TCC1") (("3" (assert) nil nil)) nil))
      nil))
    nil)
   ((constant_cseq_first_TCC1 subtype-tcc nil csequence_constant nil)
    (length def-decl "{n | has_length(fseq, n)}" csequence_length nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (nth def-decl "T" csequence_nth nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (last const-decl "T" csequence_nth nil)
    (nonempty_finite_csequence type-eq-decl nil csequence_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil csequence_constant nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil)
    (csequence type-decl nil csequence_codt nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (constant_cseq def-decl "finite_csequence" csequence_constant nil))
   shostak))
 (constant_cseq_some 0
  (constant_cseq_some-1 nil 3513603136
   ("" (induct "n")
    (("1" (expand* "constant_cseq" "some") nil nil)
     ("2" (skosimp*)
      (("2" (inst - "t!1" "p!1")
        (("2" (expand "constant_cseq" +)
          (("2" (expand "some" +) (("2" (ground) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((nat_induction formula-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (constant_cseq def-decl "finite_csequence" csequence_constant nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (some inductive-decl "boolean" csequence_codt nil)
    (csequence type-decl nil csequence_codt nil)
    (PRED type-eq-decl nil defined_types nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-type-decl nil csequence_constant nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (constant_cseq_every 0
  (constant_cseq_every-1 nil 3513603181
   ("" (induct "n")
    (("1" (expand* "constant_cseq" "every") nil nil)
     ("2" (skosimp*)
      (("2" (inst - "t!1" "p!1")
        (("2" (expand "constant_cseq" +)
          (("2" (expand "every" +) (("2" (ground) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((nat_induction formula-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (constant_cseq def-decl "finite_csequence" csequence_constant nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (every coinductive-decl "boolean" csequence_codt nil)
    (csequence type-decl nil csequence_codt nil)
    (PRED type-eq-decl nil defined_types nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-type-decl nil csequence_constant nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (constant_cseq_TCC4 0
  (constant_cseq_TCC4-1 nil 3513602349
   ("" (skolem!)
    (("" (rewrite "is_finite_def")
      (("" (rewrite "not_exists")
        (("" (induct "x")
          (("1" (expand* "has_length" "constant_cseq_struct" "coreduce") nil
            nil)
           ("2" (skosimp)
            (("2" (expand "constant_cseq_struct")
              (("2" (expand "coreduce" -)
                (("2" (expand "has_length" -) (("2" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((is_finite_def formula-decl nil csequence_props nil)
    (csequence type-decl nil csequence_codt nil)
    (csequence_struct type-decl nil csequence_codt_coreduce nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (inj_empty? adt-recognizer-decl "[csequence_struct -> boolean]"
     csequence_codt_coreduce nil)
    (empty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt nil)
    (inj_nonempty? adt-recognizer-decl "[csequence_struct -> boolean]"
     csequence_codt_coreduce nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (constant_cseq_struct const-decl "csequence_struct[T, T]"
     csequence_constant nil)
    (T formal-type-decl nil csequence_constant nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (has_length def-decl "bool" csequence_props nil)
    (not_exists formula-decl nil quantifier_props nil))
   nil
   (constant_cseq subtype
    "csequence_codt_coreduce[csequence_constant.T, csequence_constant.T].coreduce(csequence_constant.constant_cseq_struct)(csequence_constant.t)"
    "infinite_csequence[T]")))
 (constant_cseq_inf_first 0
  (constant_cseq_inf_first-1 nil 3513603454
   ("" (expand* "constant_cseq" "constant_cseq_struct" "coreduce") nil nil)
   ((coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (constant_cseq_struct const-decl "csequence_struct[T, T]"
     csequence_constant nil)
    (constant_cseq const-decl "infinite_csequence" csequence_constant nil))
   shostak))
 (constant_cseq_inf_rest 0
  (constant_cseq_inf_rest-1 nil 3513603484
   ("" (expand* "constant_cseq" "constant_cseq_struct")
    (("" (expand "coreduce" 1 1) (("" (propax) nil nil)) nil)) nil)
   ((coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (constant_cseq const-decl "infinite_csequence" csequence_constant nil)
    (constant_cseq_struct const-decl "csequence_struct[T, T]"
     csequence_constant nil))
   shostak))
 (constant_cseq_inf_nth_TCC1 0
  (constant_cseq_inf_nth_TCC1-1 nil 3513602349
   ("" (skolem!) (("" (use "index?_infinite") nil nil)) nil)
   ((nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (constant_cseq const-decl "infinite_csequence" csequence_constant nil)
    (infinite_csequence type-eq-decl nil csequence_props nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (index?_infinite formula-decl nil csequence_nth nil)
    (T formal-type-decl nil csequence_constant nil))
   nil
   (constant_cseq_inf_nth subtype "csequence_constant.n"
    "csequence_nth[csequence_constant.T].indexes(csequence_constant.constant_cseq(csequence_constant.t))")))
 (constant_cseq_inf_nth 0
  (constant_cseq_inf_nth-1 nil 3513603542
   ("" (induct "n")
    (("1" (expand* "nth" "constant_cseq" "constant_cseq_struct" "coreduce")
      nil nil)
     ("2" (skosimp*)
      (("2" (inst - "t!1")
        (("2" (expand "nth" +)
          (("2" (expand* "constant_cseq" "constant_cseq_struct")
            (("2" (expand "coreduce" +) (("2" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil)
     ("3" (skolem!) (("3" (use "constant_cseq_inf_nth_TCC1") nil nil)) nil))
    nil)
   ((constant_cseq_inf_nth_TCC1 subtype-tcc nil csequence_constant nil)
    (constant_cseq_struct const-decl "csequence_struct[T, T]"
     csequence_constant nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (nth def-decl "T" csequence_nth nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil csequence_constant nil)
    (csequence type-decl nil csequence_codt nil)
    (index? def-decl "bool" csequence_nth nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (infinite_csequence type-eq-decl nil csequence_props nil)
    (constant_cseq const-decl "infinite_csequence" csequence_constant nil))
   shostak))
 (constant_cseq_inf_add 0
  (constant_cseq_inf_add-1 nil 3513603611
   ("" (expand* "constant_cseq" "constant_cseq_struct")
    (("" (expand "coreduce" 1 2) (("" (propax) nil nil)) nil)) nil)
   ((coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (constant_cseq const-decl "infinite_csequence" csequence_constant nil)
    (constant_cseq_struct const-decl "csequence_struct[T, T]"
     csequence_constant nil))
   shostak))
 (constant_cseq_inf_some 0
  (constant_cseq_inf_some-1 nil 3513603630
   ("" (skolem!)
    (("" (prop)
      (("1" (lemma "some_induction")
        (("1"
          (inst - "p!1"
           "LAMBDA (cseq: csequence): FORALL t: cseq = constant_cseq(t) IMPLIES p!1(t)")
          (("1" (split)
            (("1" (inst - "constant_cseq(t!1)")
              (("1" (assert) (("1" (inst - "t!1") nil nil)) nil)) nil)
             ("2" (delete -1 2)
              (("2" (skosimp*)
                (("2" (lift-if)
                  (("2" (ground)
                    (("1" (use "constant_cseq_inf_first")
                      (("1" (assert) nil nil)) nil)
                     ("2" (inst - "t!2")
                      (("2" (replace -3)
                        (("2" (rewrite "constant_cseq_inf_rest") nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand* "constant_cseq" "constant_cseq_struct" "coreduce" "some")
        (("2" (flatten) nil nil)) nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (pred type-eq-decl nil defined_types nil)
    (csequence type-decl nil csequence_codt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (infinite_csequence type-eq-decl nil csequence_props nil)
    (constant_cseq const-decl "infinite_csequence" csequence_constant nil)
    (constant_cseq_inf_rest formula-decl nil csequence_constant nil)
    (constant_cseq_inf_first formula-decl nil csequence_constant nil)
    (some_induction formula-decl nil csequence_codt nil)
    (T formal-type-decl nil csequence_constant nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (some inductive-decl "boolean" csequence_codt nil)
    (constant_cseq_struct const-decl "csequence_struct[T, T]"
     csequence_constant nil))
   shostak))
 (constant_cseq_inf_every 0
  (constant_cseq_inf_every-1 nil 3513603731
   ("" (skolem!)
    (("" (rewrite "every_some_rew")
      (("" (rewrite "constant_cseq_inf_some")
        (("" (expand "pred_NOT") (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((every_some_rew formula-decl nil csequence_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (csequence type-decl nil csequence_codt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (infinite_csequence type-eq-decl nil csequence_props nil)
    (constant_cseq const-decl "infinite_csequence" csequence_constant nil)
    (T formal-type-decl nil csequence_constant nil)
    (constant_cseq_inf_some formula-decl nil csequence_constant nil)
    (pred_NOT const-decl "bool" csequence_props nil))
   shostak)))

