(csequence_zip
 (zip_struct_TCC1 0
  (zip_struct_TCC1-1 nil 3513771483 ("" (subtype-tcc) nil nil) nil nil
   (zip_struct subtype "csequence_zip.state`1"
    "(csequence_codt[csequence_zip.T1].nonempty?)")))
 (zip_struct_TCC2 0
  (zip_struct_TCC2-1 nil 3513771483 ("" (subtype-tcc) nil nil) nil nil
   (zip_struct subtype "csequence_zip.state`2"
    "(csequence_codt[csequence_zip.T2].nonempty?)")))
 (zip_finite1 0
  (zip_finite1-1 nil 3513771483
   ("" (induct "fseq1" :name "is_finite_induction[T1]")
    (("1" (assert) nil nil) ("2" (assert) nil nil)
     ("3" (skosimp*)
      (("3" (expand "is_finite" +)
        (("3" (expand* "zip" "zip_struct")
          (("3" (expand "coreduce" +)
            (("3" (smash) (("3" (inst - "rest(cseq2!1)") nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((zip_struct const-decl
     "csequence_struct[[T1, T2], [csequence[T1], csequence[T2]]]"
     csequence_zip nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (is_finite_induction formula-decl nil csequence_props nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (zip const-decl "csequence[[T1, T2]]" csequence_zip nil)
    (T2 formal-type-decl nil csequence_zip nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (csequence type-decl nil csequence_codt nil))
   nil
   (zip_finite1 subtype
    "csequence_zip.zip(csequence_zip.fseq1, csequence_zip.cseq2)"
    "finite_csequence[[T1, T2]]")))
 (zip_finite2 0
  (zip_finite2-1 nil 3513771483
   ("" (induct "fseq2" :name "is_finite_induction[T2]")
    (("1" (assert) nil nil) ("2" (assert) nil nil)
     ("3" (skosimp*)
      (("3" (expand "is_finite" +)
        (("3" (expand* "zip" "zip_struct")
          (("3" (expand "coreduce" +)
            (("3" (smash) (("3" (inst - "rest(cseq1!1)") nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((zip_struct const-decl
     "csequence_struct[[T1, T2], [csequence[T1], csequence[T2]]]"
     csequence_zip nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (is_finite_induction formula-decl nil csequence_props nil)
    (T2 formal-type-decl nil csequence_zip nil)
    (zip const-decl "csequence[[T1, T2]]" csequence_zip nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (csequence type-decl nil csequence_codt nil))
   nil
   (zip_finite2 subtype
    "csequence_zip.zip(csequence_zip.cseq1, csequence_zip.fseq2)"
    "finite_csequence[[T1, T2]]")))
 (zip_infinite 0
  (zip_infinite-1 nil 3513771483
   ("" (lemma "is_finite_induction[[T1, T2]]")
    ((""
      (inst -
       "LAMBDA (cseq: csequence[[T1, T2]]): FORALL cseq1, cseq2: cseq = zip(cseq1, cseq2) IMPLIES (is_finite(cseq1) OR is_finite(cseq2))")
      (("" (split)
        (("1" (skolem!)
          (("1" (inst - "zip(iseq1!1, iseq2!1)")
            (("1" (assert)
              (("1" (inst - "iseq1!1" "iseq2!1") (("1" (assert) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (delete 2)
          (("2" (skosimp*)
            (("2" (replace -2)
              (("2" (hide -2)
                (("2" (expand "is_finite" +)
                  (("2" (ground)
                    (("1" (expand* "zip" "zip_struct" "coreduce") nil nil)
                     ("2" (expand* "zip" "zip_struct")
                      (("2" (expand "coreduce" -1)
                        (("2" (expand "coreduce" -2 1)
                          (("2" (inst - "rest(cseq1!1)" "rest(cseq2!1)")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (zip const-decl "csequence[[T1, T2]]" csequence_zip nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (zip_struct const-decl
     "csequence_struct[[T1, T2], [csequence[T1], csequence[T2]]]"
     csequence_zip nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (infinite_csequence type-eq-decl nil csequence_props nil)
    (is_finite_induction formula-decl nil csequence_props nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (T2 formal-type-decl nil csequence_zip nil))
   nil
   (zip_infinite subtype
    "csequence_zip.zip(csequence_zip.iseq1, csequence_zip.iseq2)"
    "infinite_csequence[[T1, T2]]")))
 (zip_nonempty 0
  (zip_nonempty-1 nil 3513771483
   ("" (expand* "zip" "zip_struct" "coreduce") nil nil)
   ((coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (zip_struct const-decl
     "csequence_struct[[T1, T2], [csequence[T1], csequence[T2]]]"
     csequence_zip nil)
    (zip const-decl "csequence[[T1, T2]]" csequence_zip nil))
   nil
   (zip_nonempty subtype
    "csequence_zip.zip(csequence_zip.nseq1, csequence_zip.nseq2)"
    "nonempty_csequence[[T1, T2]]")))
 (zip_empty 0
  (zip_empty-1 nil 3513772246
   ("" (expand* "zip" "zip_struct" "coreduce") (("" (reduce) nil nil)) nil)
   ((zip const-decl "csequence[[T1, T2]]" csequence_zip nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (zip_struct const-decl
     "csequence_struct[[T1, T2], [csequence[T1], csequence[T2]]]"
     csequence_zip nil))
   shostak))
 (zip_first 0
  (zip_first-1 nil 3513772259
   ("" (expand* "zip" "zip_struct" "coreduce") nil nil)
   ((coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (zip_struct const-decl
     "csequence_struct[[T1, T2], [csequence[T1], csequence[T2]]]"
     csequence_zip nil)
    (zip const-decl "csequence[[T1, T2]]" csequence_zip nil))
   shostak))
 (zip_rest 0
  (zip_rest-1 nil 3513772266
   ("" (expand* "zip" "zip_struct")
    (("" (expand "coreduce" 1 1) (("" (propax) nil nil)) nil)) nil)
   ((coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (zip const-decl "csequence[[T1, T2]]" csequence_zip nil)
    (zip_struct const-decl
     "csequence_struct[[T1, T2], [csequence[T1], csequence[T2]]]"
     csequence_zip nil))
   shostak))
 (zip_add 0
  (zip_add-1 nil 3513772432
   ("" (expand* "zip" "zip_struct")
    (("" (expand "coreduce" 1 1) (("" (propax) nil nil)) nil)) nil)
   ((coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (zip const-decl "csequence[[T1, T2]]" csequence_zip nil)
    (zip_struct const-decl
     "csequence_struct[[T1, T2], [csequence[T1], csequence[T2]]]"
     csequence_zip nil))
   shostak))
 (zip_length_TCC1 0
  (zip_length_TCC1-1 nil 3513771483
   ("" (skosimp) (("" (use "zip_infinite") nil nil)) nil)
   ((cseq1!1 skolem-const-decl "csequence[T1]" csequence_zip nil)
    (cseq2!1 skolem-const-decl "csequence[T2]" csequence_zip nil)
    (T2 formal-type-decl nil csequence_zip nil)
    (infinite_csequence type-eq-decl nil csequence_props nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (zip_infinite judgement-tcc nil csequence_zip nil))
   nil (zip_length subtype "csequence_zip.cseq2" "finite_csequence[T2]")))
 (zip_length 0
  (zip_length-1 nil 3513772751
   (""
    (measure-induct+
     "IF is_finite(zip(cseq1, cseq2)) THEN length(zip(cseq1, cseq2)) ELSE 0 ENDIF"
     ("cseq1" "cseq2"))
    (("1" (expand* "zip" "zip_struct")
      (("1" (expand "coreduce" (-2 +))
        (("1" (expand "is_finite" (-2 +))
          (("1" (expand "length" +)
            (("1" (expand "min")
              (("1" (expand "coreduce" -1 3)
                (("1" (expand "coreduce" -1 4)
                  (("1" (expand "is_finite" -1 2)
                    (("1" (expand "length" -1 2)
                      (("1" (smash)
                        (("1" (inst - "rest(x!1)" "rest(x!2)")
                          (("1" (assert) nil nil)) nil)
                         ("2" (inst - "rest(x!1)" "rest(x!2)")
                          (("2" (assert) nil nil)) nil)
                         ("3" (inst - "rest(x!1)" "rest(x!2)")
                          (("3" (assert) nil nil)) nil)
                         ("4" (inst - "rest(x!1)" "rest(x!2)")
                          (("4" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (use "zip_infinite") nil nil) ("3" (use "zip_infinite") nil nil)
     ("4" (use "zip_infinite") nil nil) ("5" (use "zip_infinite") nil nil))
    nil)
   ((cseq1!1 skolem-const-decl "csequence[T1]" csequence_zip nil)
    (cseq2!1 skolem-const-decl "csequence[T2]" csequence_zip nil)
    (y!1 skolem-const-decl "[csequence[T1], csequence[T2]]" csequence_zip nil)
    (x!1 skolem-const-decl "[csequence[T1], csequence[T2]]" csequence_zip nil)
    (y!1 skolem-const-decl "csequence[T1]" csequence_zip nil)
    (y!2 skolem-const-decl "csequence[T2]" csequence_zip nil)
    (infinite_csequence type-eq-decl nil csequence_props nil)
    (zip_infinite judgement-tcc nil csequence_zip nil)
    (zip_struct const-decl
     "csequence_struct[[T1, T2], [csequence[T1], csequence[T2]]]"
     csequence_zip nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "{n | has_length(fseq, n)}" csequence_length nil)
    (has_length def-decl "bool" csequence_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (zip const-decl "csequence[[T1, T2]]" csequence_zip nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (T2 formal-type-decl nil csequence_zip nil)
    (csequence type-decl nil csequence_codt nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (zip_index 0
  (zip_index-1 nil 3513778320
   ("" (induct "n")
    (("1" (expand* "index?" "zip" "zip_struct" "coreduce")
      (("1" (reduce) nil nil)) nil)
     ("2" (skosimp*)
      (("2" (expand "index?" +)
        (("2" (expand* "zip" "zip_struct")
          (("2" (expand "coreduce" +) (("2" (reduce) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (zip_struct const-decl
     "csequence_struct[[T1, T2], [csequence[T1], csequence[T2]]]"
     csequence_zip nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (zip const-decl "csequence[[T1, T2]]" csequence_zip nil)
    (index? def-decl "bool" csequence_nth nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (T2 formal-type-decl nil csequence_zip nil)
    (csequence type-decl nil csequence_codt nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (zip_nth_TCC1 0
  (zip_nth_TCC1-1 nil 3513771483
   ("" (skolem-typepred)
    (("" (rewrite "zip_index") (("" (flatten) nil nil)) nil)) nil)
   ((zip_index formula-decl nil csequence_zip nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (zip const-decl "csequence[[T1, T2]]" csequence_zip nil)
    (index? def-decl "bool" csequence_nth nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (csequence type-decl nil csequence_codt nil)
    (T2 formal-type-decl nil csequence_zip nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (zip_nth subtype "csequence_zip.n"
    "csequence_nth[csequence_zip.T1].indexes(csequence_zip.cseq1)")))
 (zip_nth_TCC2 0
  (zip_nth_TCC2-1 nil 3513771483
   ("" (skolem-typepred)
    (("" (rewrite "zip_index") (("" (flatten) nil nil)) nil)) nil)
   ((zip_index formula-decl nil csequence_zip nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (zip const-decl "csequence[[T1, T2]]" csequence_zip nil)
    (index? def-decl "bool" csequence_nth nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (csequence type-decl nil csequence_codt nil)
    (T2 formal-type-decl nil csequence_zip nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (zip_nth subtype "csequence_zip.n"
    "csequence_nth[csequence_zip.T2].indexes(csequence_zip.cseq2)")))
 (zip_nth 0
  (zip_nth-1 nil 3513778393
   ("" (measure-induct+ "n" ("cseq1" "cseq2" "n") :skolem-typepreds? t)
    (("1" (use "zip_index")
      (("1" (ground)
        (("1" (use "index?_nonempty[T2]")
          (("1" (use "index?_nonempty[T1]")
            (("1" (expand "nth" +)
              (("1" (lift-if)
                (("1" (ground)
                  (("1" (expand* "zip" "zip_struct" "coreduce") nil nil)
                   ("2" (inst - "rest(x!1)" "rest(x!2)" "x!3 - 1")
                    (("1" (assert)
                      (("1" (expand* "zip" "zip_struct")
                        (("1" (expand "coreduce" +) (("1" (propax) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand "index?" -6)
                      (("2" (flatten)
                        (("2" (expand* "zip" "zip_struct")
                          (("2" (expand "coreduce" -7)
                            (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (use "zip_nth_TCC2") nil nil) ("3" (use "zip_nth_TCC1") nil nil)
     ("4" (use "zip_nth_TCC2") nil nil) ("5" (use "zip_nth_TCC1") nil nil)
     ("6" (use "zip_nth_TCC2") nil nil) ("7" (use "zip_nth_TCC1") nil nil)
     ("8" (use "zip_nth_TCC2") nil nil) ("9" (use "zip_nth_TCC1") nil nil))
    nil)
   ((zip_nth_TCC1 subtype-tcc nil csequence_zip nil)
    (zip_nth_TCC2 subtype-tcc nil csequence_zip nil)
    (zip_index formula-decl nil csequence_zip nil)
    (index?_nonempty formula-decl nil csequence_nth nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (zip_struct const-decl
     "csequence_struct[[T1, T2], [csequence[T1], csequence[T2]]]"
     csequence_zip nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (x!3 skolem-const-decl "indexes[[T1, T2]](zip(x!1, x!2))" csequence_zip
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (x!2 skolem-const-decl "csequence[T2]" csequence_zip nil)
    (x!1 skolem-const-decl "csequence[T1]" csequence_zip nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nth def-decl "T" csequence_nth nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (zip const-decl "csequence[[T1, T2]]" csequence_zip nil)
    (index? def-decl "bool" csequence_nth nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (T2 formal-type-decl nil csequence_zip nil)
    (csequence type-decl nil csequence_codt nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (zip_last_TCC1 0
  (zip_last_TCC1-1 nil 3513771483 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (nonempty_csequence type-eq-decl nil csequence_props nil)
    (T2 formal-type-decl nil csequence_zip nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (length_lt const-decl "bool" csequence_length_comp nil)
    (zip const-decl "csequence[[T1, T2]]" csequence_zip nil))
   nil
   (zip_last subtype "csequence_zip.nseq1" "nonempty_finite_csequence[T1]")))
 (zip_last_TCC2 0
  (zip_last_TCC2-1 nil 3513771483 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (nonempty_csequence type-eq-decl nil csequence_props nil)
    (T2 formal-type-decl nil csequence_zip nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (length_lt const-decl "bool" csequence_length_comp nil)
    (zip const-decl "csequence[[T1, T2]]" csequence_zip nil))
   nil (zip_last subtype "csequence_zip.nseq1" "finite_csequence[T1]")))
 (zip_last_TCC3 0
  (zip_last_TCC3-1 nil 3513771483
   ("" (skosimp)
    (("" (expand "length_lt")
      (("" (use "length_nonempty?_rew[T1]")
        (("" (ground)
          (("1" (use "index?_infinite[T2]")
            (("1" (rewrite "index?_finite[T2]") nil nil)) nil)
           ("2" (use "index?_infinite[T2]") nil nil))
          nil))
        nil))
      nil))
    nil)
   ((length_lt const-decl "bool" csequence_length_comp nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (zip_nonempty application-judgement "nonempty_csequence[[T1, T2]]"
     csequence_zip nil)
    (index?_finite formula-decl nil csequence_nth nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (infinite_csequence type-eq-decl nil csequence_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (has_length def-decl "bool" csequence_props nil)
    (length def-decl "{n | has_length(fseq, n)}" csequence_length nil)
    (nseq2!1 skolem-const-decl "nonempty_csequence[T2]" csequence_zip nil)
    (index?_infinite formula-decl nil csequence_nth nil)
    (T2 formal-type-decl nil csequence_zip nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (nonempty_csequence type-eq-decl nil csequence_props nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (length_nonempty?_rew formula-decl nil csequence_length nil))
   nil
   (zip_last subtype
    "(number_fields.-)(csequence_length[csequence_zip.T1].length(csequence_zip.nseq1), 1)"
    "csequence_nth[csequence_zip.T2].indexes(csequence_zip.nseq2)")))
 (zip_last_TCC4 0
  (zip_last_TCC4-1 nil 3513771483 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (nonempty_csequence type-eq-decl nil csequence_props nil)
    (T2 formal-type-decl nil csequence_zip nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (length_gt const-decl "bool" csequence_length_comp nil)
    (length_lt const-decl "bool" csequence_length_comp nil)
    (zip const-decl "csequence[[T1, T2]]" csequence_zip nil))
   nil (zip_last subtype "csequence_zip.nseq2" "finite_csequence[T2]")))
 (zip_last_TCC5 0
  (zip_last_TCC5-1 nil 3513771483
   ("" (skosimp)
    (("" (expand "length_gt")
      (("" (use "length_nonempty?_rew[T2]")
        (("" (ground)
          (("1" (use "index?_infinite[T1]")
            (("1" (rewrite "index?_finite[T1]") nil nil)) nil)
           ("2" (use "index?_infinite[T1]") nil nil))
          nil))
        nil))
      nil))
    nil)
   ((length_gt const-decl "bool" csequence_length_comp nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (zip_nonempty application-judgement "nonempty_csequence[[T1, T2]]"
     csequence_zip nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (index?_finite formula-decl nil csequence_nth nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (infinite_csequence type-eq-decl nil csequence_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (has_length def-decl "bool" csequence_props nil)
    (length def-decl "{n | has_length(fseq, n)}" csequence_length nil)
    (nseq1!1 skolem-const-decl "nonempty_csequence[T1]" csequence_zip nil)
    (index?_infinite formula-decl nil csequence_nth nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (nonempty_csequence type-eq-decl nil csequence_props nil)
    (T2 formal-type-decl nil csequence_zip nil)
    (length_nonempty?_rew formula-decl nil csequence_length nil))
   nil
   (zip_last subtype
    "(number_fields.-)(csequence_length[csequence_zip.T2].length(csequence_zip.nseq2), 1)"
    "csequence_nth[csequence_zip.T1].indexes(csequence_zip.nseq1)")))
 (zip_last_TCC6 0
  (zip_last_TCC6-1 nil 3513771483 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (nonempty_csequence type-eq-decl nil csequence_props nil)
    (T2 formal-type-decl nil csequence_zip nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (length_gt const-decl "bool" csequence_length_comp nil)
    (length_lt const-decl "bool" csequence_length_comp nil)
    (zip const-decl "csequence[[T1, T2]]" csequence_zip nil))
   nil
   (zip_last subtype "csequence_zip.nseq2" "nonempty_finite_csequence[T2]")))
 (zip_last_TCC7 0
  (zip_last_TCC7-1 nil 3513771483
   ("" (skosimp)
    (("" (assert)
      (("" (use "zip_infinite")
        (("" (expand "length_gt") (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((zip_nonempty application-judgement "nonempty_csequence[[T1, T2]]"
     csequence_zip nil)
    (length_gt const-decl "bool" csequence_length_comp nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (infinite_csequence type-eq-decl nil csequence_props nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (nonempty_csequence type-eq-decl nil csequence_props nil)
    (T2 formal-type-decl nil csequence_zip nil)
    (nseq2!1 skolem-const-decl "nonempty_csequence[T2]" csequence_zip nil)
    (zip_infinite judgement-tcc nil csequence_zip nil))
   nil
   (zip_last subtype "csequence_zip.nseq1" "nonempty_finite_csequence[T1]")))
 (zip_last_TCC8 0
  (zip_last_TCC8-1 nil 3513771483
   ("" (skosimp)
    (("" (assert)
      (("" (use "zip_infinite")
        (("" (expand "length_lt") (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((zip_nonempty application-judgement "nonempty_csequence[[T1, T2]]"
     csequence_zip nil)
    (length_lt const-decl "bool" csequence_length_comp nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (infinite_csequence type-eq-decl nil csequence_props nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (nonempty_csequence type-eq-decl nil csequence_props nil)
    (T2 formal-type-decl nil csequence_zip nil)
    (nseq1!1 skolem-const-decl "nonempty_csequence[T1]" csequence_zip nil)
    (zip_infinite judgement-tcc nil csequence_zip nil))
   nil
   (zip_last subtype "csequence_zip.nseq2" "nonempty_finite_csequence[T2]")))
 (zip_last_TCC9 0
  (zip_last_TCC9-1 nil 3513771483 ("" (cond-disjoint-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (nonempty_csequence type-eq-decl nil csequence_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (zip const-decl "csequence[[T1, T2]]" csequence_zip nil)
    (T2 formal-type-decl nil csequence_zip nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (length_lt const-decl "bool" csequence_length_comp nil)
    (length_gt const-decl "bool" csequence_length_comp nil))
   nil
   (zip_last disjointness
    "COND csequence_length_comp[csequence_zip.T1, csequence_zip.T2].length_lt(csequence_zip.nseq1, csequence_zip.nseq2) -> (csequence_nth[csequence_zip.T1].last(csequence_zip.nseq1), csequence_nth[csequence_zip.T2].nth(csequence_zip.nseq2, (number_fields.-)(csequence_length[csequence_zip.T1].length(csequence_zip.nseq1), 1))), csequence_length_comp[csequence_zip.T1, csequence_zip.T2].length_gt(csequence_zip.nseq1, csequence_zip.nseq2) -> (csequence_nth[csequence_zip.T1].nth(csequence_zip.nseq1, (number_fields.-)(csequence_length[csequence_zip.T2].length(csequence_zip.nseq2), 1)), csequence_nth[csequence_zip.T2].last(csequence_zip.nseq2)), ELSE -> (csequence_nth[csequence_zip.T1].last(csequence_zip.nseq1), csequence_nth[csequence_zip.T2].last(csequence_zip.nseq2)) ENDCOND"
    "nil")))
 (zip_last 0
  (zip_last-1 nil 3513778776
   ("" (skosimp)
    (("" (expand* "length_lt" "length_gt" "last")
      (("" (use "length_empty?_rew[[T1, T2]]")
        (("" (auto-rewrite "zip_nth")
          (("" (auto-rewrite "zip_length")
            (("" (reduce)
              (("1" (expand "min") (("1" (propax) nil nil)) nil)
               ("2" (expand "min") (("2" (propax) nil nil)) nil)
               ("3" (rewrite "zip_length")
                (("3" (expand "min")
                  (("3" (lift-if) (("3" (ground) nil nil)) nil)) nil))
                nil)
               ("4" (rewrite "zip_length")
                (("4" (expand "min") (("4" (propax) nil nil)) nil)) nil)
               ("5" (expand "min") (("5" (propax) nil nil)) nil)
               ("6" (use "zip_infinite") nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((length_gt const-decl "bool" csequence_length_comp nil)
    (last const-decl "T" csequence_nth nil)
    (length_lt const-decl "bool" csequence_length_comp nil)
    (zip_nth formula-decl nil csequence_zip nil)
    (zip_nonempty application-judgement "nonempty_csequence[[T1, T2]]"
     csequence_zip nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (zip_length formula-decl nil csequence_zip nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs
     nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (zip_infinite judgement-tcc nil csequence_zip nil)
    (infinite_csequence type-eq-decl nil csequence_props nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (zip const-decl "csequence[[T1, T2]]" csequence_zip nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (nonempty_csequence type-eq-decl nil csequence_props nil)
    (T2 formal-type-decl nil csequence_zip nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (length_empty?_rew formula-decl nil csequence_length nil))
   shostak))
 (zip_extensionality 0
  (zip_extensionality-1 nil 3513778991
   ("" (skosimp)
    (("" (split)
      (("1" (lemma "coinduction[T1]")
        (("1"
          (inst -
           "LAMBDA (cseq1, cseq3: csequence[T1]): EXISTS (cseq2, cseq4: csequence[T2]): length_eq(cseq1, cseq2) AND length_eq(cseq3, cseq4) AND zip(cseq1, cseq2) = zip(cseq3, cseq4)"
           "cseq1!1" "cseq3!1")
          (("1" (assert)
            (("1" (inst + "cseq2!1" "cseq4!1") (("1" (assert) nil nil)) nil))
            nil)
           ("2" (delete -1 -2 -3 2)
            (("2" (expand "bisimulation?")
              (("2" (skosimp*)
                (("2"
                  (case "nonempty?(x!1) AND nonempty?(y!1) AND nonempty?(cseq2!2) AND nonempty?(cseq4!2)")
                  (("1" (smash)
                    (("1" (inst + "rest(cseq2!2)" "rest(cseq4!2)")
                      (("1" (lemma "length_eq_rest")
                        (("1" (inst-cp - "y!1" "cseq4!2")
                          (("1" (inst - "x!1" "cseq2!2")
                            (("1" (lemma "zip_rest")
                              (("1" (inst-cp - "y!1" "cseq4!2")
                                (("1" (inst - "x!1" "cseq2!2")
                                  (("1" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (lemma "zip_first")
                      (("2" (inst-cp - "y!1" "cseq4!2")
                        (("2" (inst - "x!1" "cseq2!2")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 3)
                    (("2" (lemma "zip_empty")
                      (("2" (inst-cp - "y!1" "cseq4!2")
                        (("2" (inst - "x!1" "cseq2!2")
                          (("2" (expand "length_eq")
                            (("2" (lemma "length_empty?_rew[T2]")
                              (("2" (inst-cp - "cseq4!2")
                                (("2" (inst - "cseq2!2")
                                  (("2" (lemma "length_empty?_rew[T1]")
                                    (("2" (inst-cp - "y!1")
                                      (("2"
                                        (inst - "x!1")
                                        (("2" (smash) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (lemma "coinduction[T2]")
        (("2"
          (inst -
           "LAMBDA (cseq2, cseq4: csequence[T2]): EXISTS (cseq1, cseq3: csequence[T1]): length_eq(cseq1, cseq2) AND length_eq(cseq3, cseq4) AND zip(cseq1, cseq2) = zip(cseq3, cseq4)"
           "cseq2!1" "cseq4!1")
          (("1" (assert)
            (("1" (inst + "cseq1!1" "cseq3!1") (("1" (assert) nil nil)) nil))
            nil)
           ("2" (delete -1 -2 -3 2)
            (("2" (expand "bisimulation?")
              (("2" (skosimp*)
                (("2"
                  (case "nonempty?(cseq1!2) AND nonempty?(cseq3!2) AND nonempty?(x!1) AND nonempty?(y!1)")
                  (("1" (smash)
                    (("1" (inst + "rest(cseq1!2)" "rest(cseq3!2)")
                      (("1" (lemma "length_eq_rest")
                        (("1" (inst-cp - "cseq3!2" "y!1")
                          (("1" (inst - "cseq1!2" "x!1")
                            (("1" (lemma "zip_rest")
                              (("1" (inst-cp - "cseq3!2" "y!1")
                                (("1" (inst - "cseq1!2" "x!1")
                                  (("1" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (lemma "zip_first")
                      (("2" (inst-cp - "cseq3!2" "y!1")
                        (("2" (inst - "cseq1!2" "x!1")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 3)
                    (("2" (lemma "zip_empty")
                      (("2" (inst-cp - "cseq3!2" "y!1")
                        (("2" (inst - "cseq1!2" "x!1")
                          (("2" (expand "length_eq")
                            (("2" (lemma "length_empty?_rew[T2]")
                              (("2" (inst-cp - "y!1")
                                (("2" (inst - "x!1")
                                  (("2" (lemma "length_empty?_rew[T1]")
                                    (("2" (inst-cp - "cseq3!2")
                                      (("2"
                                        (inst - "cseq1!2")
                                        (("2" (smash) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((zip const-decl "csequence[[T1, T2]]" csequence_zip nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length_eq const-decl "bool" csequence_length_comp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (T2 formal-type-decl nil csequence_zip nil)
    (bisimulation? adt-def-decl "boolean" csequence_codt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (zip_first formula-decl nil csequence_zip nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (nonempty_csequence type-eq-decl nil csequence_props nil)
    (zip_rest formula-decl nil csequence_zip nil)
    (length_eq_rest formula-decl nil csequence_length_comp nil)
    (zip_empty formula-decl nil csequence_zip nil)
    (length_empty?_rew formula-decl nil csequence_length nil)
    (coinduction formula-decl nil csequence_codt nil)
    (T1 formal-type-decl nil csequence_zip nil))
   shostak))
 (zip_some_TCC1 0
  (zip_some_TCC1-1 nil 3513771483 ("" (subtype-tcc) nil nil)
   ((T2 formal-type-decl nil csequence_zip nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (length_lt const-decl "bool" csequence_length_comp nil))
   nil (zip_some subtype "csequence_zip.cseq1" "finite_csequence[T1]")))
 (zip_some_TCC2 0
  (zip_some_TCC2-1 nil 3513771483 ("" (subtype-tcc) nil nil)
   ((T2 formal-type-decl nil csequence_zip nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (length_gt const-decl "bool" csequence_length_comp nil)
    (length_lt const-decl "bool" csequence_length_comp nil))
   nil (zip_some subtype "csequence_zip.cseq2" "finite_csequence[T2]")))
 (zip_some_TCC3 0
  (zip_some_TCC3-1 nil 3513771483 ("" (cond-disjoint-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (T2 formal-type-decl nil csequence_zip nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (length_lt const-decl "bool" csequence_length_comp nil)
    (length_gt const-decl "bool" csequence_length_comp nil))
   nil
   (zip_some disjointness
    "COND csequence_length_comp[csequence_zip.T1, csequence_zip.T2].length_lt(csequence_zip.cseq1, csequence_zip.cseq2) -> booleans.OR(csequence_codt[csequence_zip.T1].some(csequence_zip.p1)(csequence_zip.cseq1), (EXISTS (i: csequence_nth[csequence_zip.T2].indexes(csequence_zip.cseq2)): booleans.AND(reals.<(i, csequence_length[csequence_zip.T1].length(csequence_zip.cseq1)), csequence_zip.p2(csequence_nth[csequence_zip.T2].nth(csequence_zip.cseq2, i))))), csequence_length_comp[csequence_zip.T1, csequence_zip.T2].length_gt(csequence_zip.cseq1, csequence_zip.cseq2) -> booleans.OR((EXISTS (i: csequence_nth[csequence_zip.T1].indexes(csequence_zip.cseq1)): booleans.AND(reals.<(i, csequence_length[csequence_zip.T2].length(csequence_zip.cseq2)), csequence_zip.p1(csequence_nth[csequence_zip.T1].nth(csequence_zip.cseq1, i)))), csequence_codt[csequence_zip.T2].some(csequence_zip.p2)(csequence_zip.cseq2)), ELSE -> booleans.OR(csequence_codt[csequence_zip.T1].some(csequence_zip.p1)(csequence_zip.cseq1), csequence_codt[csequence_zip.T2].some(csequence_zip.p2)(csequence_zip.cseq2)) ENDCOND"
    "nil")))
 (zip_some 0
  (zip_some-1 nil 3513779390
   ("" (skolem!)
    (("" (use "nth_some[[T1, T2]]")
      (("" (smash)
        (("1" (skolem-typepred)
          (("1" (rewrite "zip_index")
            (("1" (prop)
              (("1" (use "nth_some[T1]")
                (("1" (assert)
                  (("1" (inst + "i!1")
                    (("1" (rewrite "zip_nth") (("1" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (inst + "i!1")
                (("2" (rewrite "zip_nth")
                  (("2" (assert) (("2" (rewrite "index?_finite") nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skolem-typepred)
          (("2" (rewrite "zip_index")
            (("2" (prop)
              (("1" (inst + "i!1")
                (("1" (rewrite "zip_nth")
                  (("1" (assert) (("1" (rewrite "index?_finite" -3) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (use "nth_some[T2]")
                (("2" (assert)
                  (("2" (inst + "i!1")
                    (("2" (rewrite "zip_nth") (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (skolem-typepred)
          (("3" (rewrite "zip_index")
            (("3" (prop)
              (("1" (use "nth_some[T1]")
                (("1" (assert)
                  (("1" (inst + "i!1")
                    (("1" (rewrite "zip_nth") (("1" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (use "nth_some[T2]")
                (("2" (assert)
                  (("2" (inst + "i!1")
                    (("2" (rewrite "zip_nth") (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("4" (use "nth_some[T1]")
          (("4" (assert)
            (("4" (skolem-typepred)
              (("4" (inst + "i!1")
                (("1" (flatten)
                  (("1" (rewrite "zip_nth") (("1" (assert) nil nil)) nil))
                  nil)
                 ("2" (rewrite "zip_index")
                  (("2" (expand "length_lt")
                    (("2" (prop)
                      (("1" (rewrite "index?_finite")
                        (("1" (rewrite "index?_finite")
                          (("1" (assert) nil nil)) nil))
                        nil)
                       ("2" (use "index?_infinite[T2]") nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("5" (skosimp :preds? t)
          (("5" (inst + "i!1")
            (("1" (flatten)
              (("1" (rewrite "zip_nth") (("1" (assert) nil nil)) nil)) nil)
             ("2" (rewrite "zip_index")
              (("2" (rewrite "index?_finite[T1]") nil nil)) nil))
            nil))
          nil)
         ("6" (use "nth_some[T2]")
          (("6" (assert)
            (("6" (skolem-typepred)
              (("6" (inst + "i!1")
                (("1" (flatten)
                  (("1" (rewrite "zip_nth") (("1" (assert) nil nil)) nil))
                  nil)
                 ("2" (rewrite "zip_index")
                  (("2" (expand "length_lt")
                    (("2" (prop)
                      (("1" (use "index?_infinite[T1]") nil nil)
                       ("2" (rewrite "index?_finite")
                        (("2" (rewrite "index?_finite")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("7" (use "nth_some[T1]")
          (("7" (assert)
            (("7" (skolem-typepred)
              (("7" (inst + "i!1")
                (("1" (flatten)
                  (("1" (rewrite "zip_nth") (("1" (assert) nil nil)) nil))
                  nil)
                 ("2" (rewrite "zip_index")
                  (("2" (expand "length_gt")
                    (("2" (prop)
                      (("1" (use "index?_infinite[T2]") nil nil)
                       ("2" (rewrite "index?_finite")
                        (("2" (rewrite "index?_finite")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("8" (skosimp :preds? t)
          (("8" (inst + "i!1")
            (("1" (flatten)
              (("1" (rewrite "zip_nth") (("1" (assert) nil nil)) nil)) nil)
             ("2" (rewrite "zip_index")
              (("2" (use "index?_finite[T2]") (("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nth_some formula-decl nil csequence_nth nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (T2 formal-type-decl nil csequence_zip nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (zip const-decl "csequence[[T1, T2]]" csequence_zip nil)
    (csequence type-decl nil csequence_codt nil)
    (i!1 skolem-const-decl "indexes[T1](cseq1!1)" csequence_zip nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length_gt const-decl "bool" csequence_length_comp nil)
    (i!1 skolem-const-decl "indexes[T1](cseq1!1)" csequence_zip nil)
    (i!1 skolem-const-decl "indexes[T2](cseq2!1)" csequence_zip nil)
    (i!1 skolem-const-decl "indexes[T2](cseq2!1)" csequence_zip nil)
    (index?_infinite formula-decl nil csequence_nth nil)
    (infinite_csequence type-eq-decl nil csequence_props nil)
    (length_lt const-decl "bool" csequence_length_comp nil)
    (i!1 skolem-const-decl "indexes[T1](cseq1!1)" csequence_zip nil)
    (i!1 skolem-const-decl "indexes[[T1, T2]](zip(cseq1!1, cseq2!1))"
     csequence_zip nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (index? def-decl "bool" csequence_nth nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (zip_nth formula-decl nil csequence_zip nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (index?_finite formula-decl nil csequence_nth nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (i!1 skolem-const-decl "indexes[[T1, T2]](zip(cseq1!1, cseq2!1))"
     csequence_zip nil)
    (cseq1!1 skolem-const-decl "csequence[T1]" csequence_zip nil)
    (cseq2!1 skolem-const-decl "csequence[T2]" csequence_zip nil)
    (zip_index formula-decl nil csequence_zip nil))
   shostak))
 (zip_every_TCC1 0
  (zip_every_TCC1-1 nil 3513771483 ("" (subtype-tcc) nil nil)
   ((T2 formal-type-decl nil csequence_zip nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (length_lt const-decl "bool" csequence_length_comp nil))
   nil (zip_every subtype "csequence_zip.cseq1" "finite_csequence[T1]")))
 (zip_every 0
  (zip_every-1 nil 3513779764
   ("" (skolem!)
    (("" (use "nth_every[[T1, T2]]")
      (("" (smash)
        (("1" (skosimp :preds? t)
          (("1" (inst - "i!1")
            (("1" (flatten)
              (("1" (rewrite "zip_nth") (("1" (assert) nil nil)) nil)) nil)
             ("2" (use "index?_finite[T1]")
              (("2" (assert) (("2" (rewrite "zip_index") nil nil)) nil)) nil))
            nil))
          nil)
         ("2" (use "nth_every[T1]")
          (("2" (assert)
            (("2" (skolem-typepred)
              (("2" (inst - "i!1")
                (("1" (flatten)
                  (("1" (rewrite "zip_nth") (("1" (assert) nil nil)) nil))
                  nil)
                 ("2" (rewrite "zip_index")
                  (("2" (expand "length_lt")
                    (("2" (prop)
                      (("1" (rewrite "index?_finite")
                        (("1" (rewrite "index?_finite")
                          (("1" (assert) nil nil)) nil))
                        nil)
                       ("2" (use "index?_infinite[T2]") nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (use "nth_every[T2]")
          (("3" (assert)
            (("3" (skolem-typepred)
              (("3" (inst - "i!1")
                (("1" (flatten)
                  (("1" (rewrite "zip_nth") (("1" (assert) nil nil)) nil))
                  nil)
                 ("2" (rewrite "zip_index")
                  (("2" (expand "length_lt")
                    (("2" (prop)
                      (("1" (use "index?_infinite[T1]") nil nil)
                       ("2" (rewrite "index?_finite")
                        (("2" (rewrite "index?_finite")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("4" (skosimp :preds? t)
          (("4" (inst - "i!1")
            (("1" (rewrite "zip_nth") (("1" (assert) nil nil)) nil)
             ("2" (use "index?_finite[T2]")
              (("2" (assert) (("2" (rewrite "zip_index") nil nil)) nil)) nil))
            nil))
          nil)
         ("5" (use "nth_every[T1]")
          (("5" (assert)
            (("5" (skolem-typepred)
              (("5" (inst - "i!1")
                (("1" (flatten)
                  (("1" (rewrite "zip_nth") (("1" (assert) nil nil)) nil))
                  nil)
                 ("2" (rewrite "zip_index")
                  (("2" (expand "length_gt")
                    (("2" (prop)
                      (("1" (use "index?_infinite[T2]") nil nil)
                       ("2" (rewrite "index?_finite")
                        (("2" (rewrite "index?_finite")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("6" (skolem-typepred)
          (("6" (rewrite "zip_index")
            (("6" (prop)
              (("1" (use "nth_every[T1]")
                (("1" (assert)
                  (("1" (inst - "i!1")
                    (("1" (rewrite "zip_nth") (("1" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (inst - "i!1")
                (("2" (rewrite "zip_nth")
                  (("2" (assert) (("2" (rewrite "index?_finite") nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("7" (skolem-typepred)
          (("7" (rewrite "zip_index")
            (("7" (prop)
              (("1" (use "nth_every[T1]")
                (("1" (assert)
                  (("1" (inst - "i!1")
                    (("1" (rewrite "zip_nth") (("1" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (use "nth_every[T2]")
                (("2" (assert)
                  (("2" (inst - "i!1")
                    (("2" (rewrite "zip_nth") (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("8" (skolem-typepred)
          (("8" (rewrite "zip_index")
            (("8" (prop)
              (("1" (inst - "i!1")
                (("1" (rewrite "zip_nth")
                  (("1" (assert) (("1" (rewrite "index?_finite" -2) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (use "nth_every[T2]")
                (("2" (assert)
                  (("2" (inst - "i!1")
                    (("2" (rewrite "zip_nth") (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nth_every formula-decl nil csequence_nth nil)
    (T1 formal-type-decl nil csequence_zip nil)
    (T2 formal-type-decl nil csequence_zip nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (zip const-decl "csequence[[T1, T2]]" csequence_zip nil)
    (csequence type-decl nil csequence_codt nil)
    (i!1 skolem-const-decl "indexes[[T1, T2]](zip(cseq1!1, cseq2!1))"
     csequence_zip nil)
    (i!1 skolem-const-decl "indexes[[T1, T2]](zip(cseq1!1, cseq2!1))"
     csequence_zip nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length_gt const-decl "bool" csequence_length_comp nil)
    (i!1 skolem-const-decl "indexes[T1](cseq1!1)" csequence_zip nil)
    (i!1 skolem-const-decl "indexes[T1](cseq1!1)" csequence_zip nil)
    (i!1 skolem-const-decl "indexes[T2](cseq2!1)" csequence_zip nil)
    (index?_infinite formula-decl nil csequence_nth nil)
    (infinite_csequence type-eq-decl nil csequence_props nil)
    (length_lt const-decl "bool" csequence_length_comp nil)
    (i!1 skolem-const-decl "indexes[T1](cseq1!1)" csequence_zip nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (index? def-decl "bool" csequence_nth nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (index?_finite formula-decl nil csequence_nth nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (finite_csequence nonempty-type-eq-decl nil csequence_props nil)
    (zip_index formula-decl nil csequence_zip nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (zip_nth formula-decl nil csequence_zip nil)
    (i!1 skolem-const-decl "indexes[T2](cseq2!1)" csequence_zip nil)
    (cseq2!1 skolem-const-decl "csequence[T2]" csequence_zip nil)
    (cseq1!1 skolem-const-decl "csequence[T1]" csequence_zip nil))
   shostak)))

