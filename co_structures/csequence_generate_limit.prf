(csequence_generate_limit
 (generate_empty 0
  (generate_empty-1 nil 3513557613
   ("" (expand* "generate" "generate_limit_struct" "coreduce")
    (("" (reduce) nil nil)) nil)
   ((generate const-decl "csequence" csequence_generate_limit nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (generate_limit_struct const-decl "csequence_struct"
     csequence_generate_limit nil))
   shostak))
 (generate_first_TCC1 0
  (generate_first_TCC1-1 nil 3513557590
   ("" (skosimp) (("" (use "generate_empty") (("" (assert) nil nil)) nil))
    nil)
   ((generate_empty formula-decl nil csequence_generate_limit nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil csequence_generate_limit nil))
   nil
   (generate_first subtype
    "csequence_generate_limit.generate(csequence_generate_limit.f, csequence_generate_limit.t, csequence_generate_limit.stop?)"
    "(csequence_codt[csequence_generate_limit.T].nonempty?)")))
 (generate_first 0
  (generate_first-1 nil 3513557666
   ("" (expand* "generate" "generate_limit_struct" "coreduce")
    (("" (reduce) nil nil)) nil)
   ((generate const-decl "csequence" csequence_generate_limit nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (generate_limit_struct const-decl "csequence_struct"
     csequence_generate_limit nil))
   shostak))
 (generate_rest 0
  (generate_rest-1 nil 3513557693
   ("" (expand* "generate" "generate_limit_struct")
    (("" (expand "coreduce" 1 1) (("" (reduce) nil nil)) nil)) nil)
   ((coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (generate const-decl "csequence" csequence_generate_limit nil)
    (generate_limit_struct const-decl "csequence_struct"
     csequence_generate_limit nil))
   shostak))
 (generate_has_length 0
  (generate_has_length-1 nil 3513557729
   ("" (induct "n")
    (("1" (skolem!)
      (("1" (expand* "has_length" "iterate")
        (("1" (rewrite "generate_empty")
          (("1" (prop) (("1" (skolem-typepred) nil nil)) nil)) nil))
        nil))
      nil)
     ("2" (skosimp*)
      (("2" (inst - "f!1" "f!1(t!1)" "stop?!1")
        (("2" (rewrite "iterate_add_one")
          (("2" (expand "has_length" +)
            (("2" (expand* "generate" "generate_limit_struct")
              (("2" (expand "coreduce" +)
                (("2" (smash)
                  (("1" (inst -6 0)
                    (("1" (expand "iterate" +) (("1" (propax) nil nil)) nil))
                    nil)
                   ("2" (hide 2)
                    (("2" (skolem!)
                      (("2" (expand "iterate" -4)
                        (("2" (ground)
                          (("2" (inst - "m!1 - 1")
                            (("2" (rewrite "iterate_add_one")
                              (("2" (expand "iterate" +)
                                (("2" (propax) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (inst -5 0)
                    (("3" (expand "iterate" +) (("3" (propax) nil nil)) nil))
                    nil)
                   ("4" (inst - 0)
                    (("4" (expand "iterate" +) (("4" (propax) nil nil)) nil))
                    nil)
                   ("5" (inst - 0)
                    (("5" (expand "iterate" +) (("5" (propax) nil nil)) nil))
                    nil)
                   ("6" (skolem!)
                    (("6" (rewrite "iterate_add_one")
                      (("6" (inst - "1 + m!1") nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((iterate_add_one formula-decl nil function_iterate nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (generate_limit_struct const-decl "csequence_struct"
     csequence_generate_limit nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (generate_empty formula-decl nil csequence_generate_limit nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil)
    (iterate def-decl "T" function_iterate nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (generate const-decl "csequence" csequence_generate_limit nil)
    (has_length def-decl "bool" csequence_props nil)
    (csequence type-decl nil csequence_codt nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-type-decl nil csequence_generate_limit nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (generate_finite 0
  (generate_finite-1 nil 3513557890
   ("" (skolem!)
    (("" (rewrite "is_finite_def")
      (("" (prop)
        (("1" (skolem!)
          (("1" (rewrite "generate_has_length")
            (("1" (flatten) (("1" (inst? +) nil nil)) nil)) nil))
          nil)
         ("2" (skolem!)
          (("2" (name "len" "min({n | stop?!1(iterate(f!1, n)(t!1))})")
            (("1" (inst + "len")
              (("1" (rewrite "generate_has_length")
                (("1" (rewrite "min_def")
                  (("1" (expand "minimum?")
                    (("1" (assert)
                      (("1" (skolem!)
                        (("1" (inst - "m!1") (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand* "nonempty?" "empty?" "member")
              (("2" (inst?) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((is_finite_def formula-decl nil csequence_props nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (generate const-decl "csequence" csequence_generate_limit nil)
    (T formal-type-decl nil csequence_generate_limit nil)
    (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil)
    (min_def formula-decl nil min_nat nil)
    (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil)
    (minimum? const-decl "bool" min_nat nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat
         nil)
    (iterate def-decl "T" function_iterate nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (generate_has_length formula-decl nil csequence_generate_limit nil))
   shostak))
 (generate_nth 0
  (generate_nth-1 nil 3513557974
   ("" (measure-induct+ "n" ("f" "t" "stop?" "n") :skolem-typepreds? t)
    (("" (expand "iterate" +)
      (("" (expand "nth" +)
        (("" (lift-if)
          (("" (ground)
            (("1" (hide -3)
              (("1"
                (expand* "generate" "generate_limit_struct" "coreduce"
                 "index?" "is_finite")
                (("1" (reduce) nil nil)) nil))
              nil)
             ("2" (inst - "x!1" "x!1(x!2)" "x!3" "x!4 - 1")
              (("1" (assert)
                (("1" (rewrite "iterate_invariant")
                  (("1" (use "generate_rest")
                    (("1" (ground)
                      (("1" (hide -3 2)
                        (("1"
                          (expand* "generate" "generate_limit_struct"
                           "coreduce" "index?")
                          nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand "index?" -)
                (("2" (flatten)
                  (("2" (use "generate_rest")
                    (("2" (assert)
                      (("2"
                        (expand* "generate" "generate_limit_struct"
                         "coreduce")
                        nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (x!1 skolem-const-decl "[T -> T]" csequence_generate_limit nil)
    (x!2 skolem-const-decl "T" csequence_generate_limit nil)
    (x!3 skolem-const-decl "pred[T]" csequence_generate_limit nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (x!4 skolem-const-decl "indexes[T](generate(x!1, x!2, x!3))"
     csequence_generate_limit nil)
    (iterate_invariant formula-decl nil function_iterate nil)
    (generate_rest formula-decl nil csequence_generate_limit nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil)
    (generate_limit_struct const-decl "csequence_struct"
     csequence_generate_limit nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (iterate def-decl "T" function_iterate nil)
    (nth def-decl "T" csequence_nth nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (indexes type-eq-decl nil csequence_nth nil)
    (generate const-decl "csequence" csequence_generate_limit nil)
    (index? def-decl "bool" csequence_nth nil)
    (csequence type-decl nil csequence_codt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (pred type-eq-decl nil defined_types nil)
    (T formal-type-decl nil csequence_generate_limit nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil))
   shostak))
 (generate_add 0
  (generate_add-1 nil 3513558077
   ("" (skosimp)
    (("" (expand* "generate" "generate_limit_struct")
      (("" (expand "coreduce" 2 2) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((generate_limit_struct const-decl "csequence_struct"
     csequence_generate_limit nil)
    (generate const-decl "csequence" csequence_generate_limit nil)
    (coreduce adt-def-decl "{c: csequence[T] |
   inj_empty?(op(x)) AND empty?(c) OR inj_nonempty?(op(x)) AND nonempty?(c)}"
     csequence_codt_coreduce nil))
   shostak))
 (generate_some 0
  (generate_some-1 nil 3513558137
   ("" (auto-rewrite "generate_nth")
    (("" (skolem!) (("" (use "nth_some") (("" (ground) nil nil)) nil)) nil))
    nil)
   ((generate_nth formula-decl nil csequence_generate_limit nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (generate const-decl "csequence" csequence_generate_limit nil)
    (T formal-type-decl nil csequence_generate_limit nil)
    (nth_some formula-decl nil csequence_nth nil))
   shostak))
 (generate_every 0
  (generate_every-1 nil 3513558163
   ("" (auto-rewrite "generate_nth")
    (("" (skolem!) (("" (use "nth_every") (("" (ground) nil nil)) nil)) nil))
    nil)
   ((generate_nth formula-decl nil csequence_generate_limit nil)
    (csequence type-decl nil csequence_codt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (generate const-decl "csequence" csequence_generate_limit nil)
    (T formal-type-decl nil csequence_generate_limit nil)
    (nth_every formula-decl nil csequence_nth nil))
   shostak)))

