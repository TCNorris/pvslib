(csequence_props
 (has_length_TCC1 0
  (has_length_TCC1-1 nil 3513451673 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (has_length subtype "csequence_props.cseq"
    "(csequence_codt[csequence_props.T].nonempty?)")))
 (has_length_TCC2 0
  (has_length_TCC2-1 nil 3513451673 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil (has_length subtype "(number_fields.-)(csequence_props.n, 1)" "nat")))
 (has_length_TCC3 0
  (has_length_TCC3-1 nil 3513451673 ("" (termination-tcc) nil nil) nil nil
   (has_length termination
    "csequence_props.has_length(csequence_codt[csequence_props.T].rest(csequence_props.cseq), (number_fields.-)(csequence_props.n, 1))"
    "nil")))
 (has_length_injective 0
  (has_length_injective-1 nil 3513451692
   ("" (induct "n")
    (("1" (skosimp) (("1" (expand "has_length") (("1" (ground) nil nil)) nil))
      nil)
     ("2" (skosimp*)
      (("2" (expand "has_length" (-2 -3))
        (("2" (ground)
          (("2" (inst - "rest(cseq!1)" "m!1 - 1") (("2" (assert) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (has_length def-decl "bool" csequence_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (T formal-type-decl nil csequence_props nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (is_finite_TCC1 0
  (is_finite_TCC1-1 nil 3513451673 ("" (subtype-tcc) nil nil) nil nil
   (is_finite subtype "csequence_props.cseq"
    "(csequence_codt[csequence_props.T].nonempty?)")))
 (is_finite_def 0
  (is_finite_def-1 nil 3513451736
   ("" (skolem!)
    (("" (prop)
      (("1" (generalize-skolem-constants)
        (("1" (induct "cseq_1" :name "is_finite_induction")
          (("1" (skosimp)
            (("1" (case "empty?(cseq!2)")
              (("1" (inst + 0)
                (("1" (expand "has_length") (("1" (assert) nil nil)) nil))
                nil)
               ("2" (ground)
                (("2" (skolem!)
                  (("2" (inst + "1 + n!1")
                    (("2" (expand "has_length" +) (("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skolem!)
        (("2" (generalize-skolem-constants)
          (("2" (induct "n_1")
            (("1" (skosimp)
              (("1" (expand* "has_length" "is_finite")
                (("1" (ground) nil nil)) nil))
              nil)
             ("2" (skosimp*)
              (("2" (expand "has_length" -2)
                (("2" (expand "is_finite" +)
                  (("2" (ground)
                    (("2" (inst - "rest(cseq!2)") (("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((is_finite_induction formula-decl nil csequence_props nil)
    (empty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-type-decl nil csequence_props nil)
    (csequence type-decl nil csequence_codt nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (has_length def-decl "bool" csequence_props nil)
    (rest adt-accessor-decl "[(nonempty?) -> csequence]" csequence_codt nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (finite_csequence_TCC1 0
  (finite_csequence_TCC1-1 nil 3513451673
   ("" (expand "is_finite") (("" (propax) nil nil)) nil)
   ((is_finite inductive-decl "bool" csequence_props nil)) nil
   (finite_csequence subtype "csequence_codt[csequence_props.T].empty_cseq"
    "finite_csequence")))
 (empty_csequence_is_finite 0
  (empty_csequence_is_finite-1 nil 3513451673
   ("" (skolem-typepred)
    (("" (expand "is_finite") (("" (propax) nil nil)) nil)) nil)
   ((is_finite inductive-decl "bool" csequence_props nil)
    (empty_csequence nonempty-type-eq-decl nil csequence_props nil)
    (empty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt nil)
    (csequence type-decl nil csequence_codt nil)
    (T formal-type-decl nil csequence_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (empty_csequence_is_finite subtype "csequence_props.x"
    "finite_csequence")))
 (infinite_csequence_is_nonempty 0
  (infinite_csequence_is_nonempty-1 nil 3513451673
   ("" (skolem-typepred)
    (("" (expand "is_finite") (("" (assert) nil nil)) nil)) nil)
   ((infinite_csequence type-eq-decl nil csequence_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (is_finite inductive-decl "bool" csequence_props nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (csequence type-decl nil csequence_codt nil)
    (T formal-type-decl nil csequence_props nil))
   nil
   (infinite_csequence_is_nonempty subtype "csequence_props.x"
    "nonempty_csequence")))
 (some_every_rew 0
  (some_every_rew-1 nil 3513452041
   ("" (skolem!)
    (("" (prop)
      (("1" (lemma "some_weak_induction")
        (("1" (inst - "p!1" "LAMBDA cseq: NOT every(pred_NOT(p!1))(cseq)")
          (("1" (split)
            (("1" (inst - "cseq!1") (("1" (assert) nil nil)) nil)
             ("2" (skosimp)
              (("2" (expand "every" -2)
                (("2" (expand "pred_NOT")
                  (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (lemma "every_weak_coinduction")
        (("2" (inst - "pred_NOT(p!1)" "LAMBDA cseq: NOT some(p!1)(cseq)")
          (("2" (split)
            (("1" (inst - "cseq!1") (("1" (assert) nil nil)) nil)
             ("2" (skosimp)
              (("2" (expand "some" 1)
                (("2" (expand "pred_NOT")
                  (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (pred type-eq-decl nil defined_types nil)
    (csequence type-decl nil csequence_codt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (every coinductive-decl "boolean" csequence_codt nil)
    (pred_NOT const-decl "bool" csequence_props nil)
    (some_weak_induction formula-decl nil csequence_codt nil)
    (T formal-type-decl nil csequence_props nil)
    (some inductive-decl "boolean" csequence_codt nil)
    (every_weak_coinduction formula-decl nil csequence_codt nil))
   shostak))
 (every_some_rew 0
  (every_some_rew-1 nil 3513452124
   ("" (skolem!)
    (("" (lemma "some_every_rew")
      (("" (inst - "pred_NOT(p!1)" "cseq!1")
        (("" (expand "pred_NOT")
          (("" (replace-eta "p!1") (("" (ground) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((some_every_rew formula-decl nil csequence_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (csequence type-decl nil csequence_codt nil)
    (pred_NOT const-decl "bool" csequence_props nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil csequence_props nil))
   shostak))
 (some_implies 0
  (some_implies-1 nil 3513452167
   ("" (induct "cseq" :name "some_induction")
    (("" (skosimp)
      (("" (inst - "p!1" "LAMBDA cseq: some(q!1)(cseq)")
        (("" (split)
          (("1" (inst - "cseq!1") (("1" (assert) nil nil)) nil)
           ("2" (delete -2 2)
            (("2" (skosimp)
              (("2" (expand "some" +)
                (("2" (expand "pred_IMPLIES")
                  (("2" (lift-if)
                    (("2" (ground)
                      (("2" (inst - "first(a!1)") (("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pred_IMPLIES const-decl "bool" csequence_props nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (first adt-accessor-decl "[(nonempty?) -> T]" csequence_codt nil)
    (some inductive-decl "boolean" csequence_codt nil)
    (csequence type-decl nil csequence_codt nil)
    (pred type-eq-decl nil defined_types nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (some_induction formula-decl nil csequence_codt nil)
    (T formal-type-decl nil csequence_props nil))
   shostak))
 (every_implies 0
  (every_implies-1 nil 3513452244
   ("" (induct "cseq" :name "every_coinduction")
    (("" (skosimp)
      (("" (inst - "q!1" "LAMBDA cseq: every(p!1)(cseq)")
        (("" (split)
          (("1" (inst - "cseq!1") (("1" (assert) nil nil)) nil)
           ("2" (delete -2 2)
            (("2" (skosimp)
              (("2" (expand "every" -)
                (("2" (expand "pred_IMPLIES")
                  (("2" (lift-if)
                    (("2" (ground)
                      (("2" (inst - "first(a!1)") (("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pred_IMPLIES const-decl "bool" csequence_props nil)
    (nonempty? adt-recognizer-decl "[csequence -> boolean]" csequence_codt
               nil)
    (first adt-accessor-decl "[(nonempty?) -> T]" csequence_codt nil)
    (every coinductive-decl "boolean" csequence_codt nil)
    (csequence type-decl nil csequence_codt nil)
    (pred type-eq-decl nil defined_types nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (every_coinduction formula-decl nil csequence_codt nil)
    (T formal-type-decl nil csequence_props nil))
   shostak)))

