(product_nat
 (IMP_product_TCC1 0
  (IMP_product_TCC1-1 nil 3351946780 ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (integer nonempty-type-from-decl nil integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (IMP_product assuming "product[nat].product"
    "connected_domain: ASSUMPTION (FORALL (x, y: product.T), (z: integers.integer): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), product.T_pred(z)))")))
 (int_is_T_high 0
  (int_is_T_high-2 "" 3790089457
   ("" (skosimp*) (("" (inst-cp + 0) (("" (assert) nil nil)) nil)) nil) nil
   shostak (int_is_T_high subtype "product_nat.x" "T_high[nat]"))
  (int_is_T_high-1 nil 3352138082
   ("" (skosimp*)
    (("" (inst-cp + 0)
      (("" (inst + "x!1") (("1" (assert) nil nil) ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil (int_is_T_high subtype "product_nat.x" "T_high[nat]")))
 (nat_is_T_low 0
  (nat_is_T_low-1 nil 3352138082 ("" (judgement-tcc) nil nil) nil nil
   (nat_is_T_low subtype "product_nat.x" "T_low[nat]")))
 (product_shift 0
  (product_shift-1 nil 3308675684
   ("" (skosimp*) (("" (rewrite "product_shift_T") nil nil)) nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (product_shift_T formula-decl nil product nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (T_high type-eq-decl nil product nil)
    (T_low type-eq-decl nil product nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   nil))
 (product_shift_neg_TCC1 0
  (product_shift_neg_TCC1-2 "" 3790089457 ("" (skosimp*) nil nil) nil shostak
   (product_shift_neg subtype
    "(number_fields.-)(product_nat.low, product_nat.m)" "T_low[nat]"))
  (product_shift_neg_TCC1-1 nil 3308675684
   ("" (skosimp*) (("" (inst + 0) (("" (assert) nil nil)) nil)) nil) nil nil
   (product_shift_neg subtype
    "(number_fields.-)(product_nat.low, product_nat.m)" "T_low[nat]")))
 (product_shift_neg_TCC2 0
  (product_shift_neg_TCC2-1 nil 3352138082 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (product_shift_neg subtype
    "(number_fields.-)(product_nat.n, product_nat.m)" "nat")))
 (product_shift_neg 0
  (product_shift_neg-1 nil 3308675684
   ("" (skosimp*)
    (("" (lemma "product_shift_T2")
      (("" (inst?)
        (("" (inst - "high!1" "low!1" "0 - m!1")
          (("" (assert)
            (("" (prop)
              (("1" (replace -1 :hide? t)
                (("1" (rewrite "product_eq")
                  (("1" (skosimp*) (("1" (assert) nil nil)) nil)) nil))
                nil)
               ("2" (case "high!1<low!1")
                (("1" (expand "product") (("1" (assert) nil nil)) nil)
                 ("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (product_shift_T2 formula-decl nil product nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (T_high type-eq-decl nil product nil)
    (T_low type-eq-decl nil product nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (product_eq formula-decl nil product nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (product def-decl "real" product nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil))
   nil))
 (product_shift_ng2 0
  (product_shift_ng2-1 nil 3308675684
   ("" (skosimp*)
    (("" (lemma "product_shift_T2")
      (("" (inst?)
        (("" (inst - "high!1" "low!1" "0-m!1")
          (("" (assert)
            (("" (prop)
              (("1" (replace -1 :hide? t)
                (("1" (rewrite "product_eq")
                  (("1" (expand "~")
                    (("1" (assert)
                      (("1" (skosimp*)
                        (("1" (assert)
                          (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (case "high!1<low!1")
                (("1" (expand "product") (("1" (assert) nil nil)) nil)
                 ("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (product_shift_T2 formula-decl nil product nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (T_high type-eq-decl nil product nil)
    (T_low type-eq-decl nil product nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (~ const-decl "nat" naturalnumbers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (product_eq formula-decl nil product nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (product def-decl "real" product nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (< const-decl "bool" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil))
   nil))
 (product_shift_i_TCC1 0
  (product_shift_i_TCC1-1 nil 3411831032 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (product_shift_i subtype
    "(number_fields.+)(product_nat.low, product_nat.i)" "T_low[nat]")))
 (product_shift_i_TCC2 0
  (product_shift_i_TCC2-1 nil 3411831032 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (product_shift_i subtype "(number_fields.+)(product_nat.n, product_nat.i)"
    "nat")))
 (product_shift_i 0
  (product_shift_i-1 nil 3411831064
   ("" (skosimp*)
    (("" (rewrite "product_shift_T2")
      (("1" (rewrite "product_restrict_eq")
        (("1" (hide 2)
          (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil)
         ("2" (skosimp*) (("2" (assert) nil nil)) nil))
        nil)
       ("2" (case "low!1 <= high!1")
        (("1" (assert) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((product_shift_T2 formula-decl nil product nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (T_high type-eq-decl nil product nil)
    (T_low type-eq-decl nil product nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (restrict const-decl "[T -> real]" product nil)
    (< const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (product_restrict_eq formula-decl nil product nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (product def-decl "real" product nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (product_first_ge 0
  (product_first_ge-1 nil 3308675684
   ("" (skosimp*) (("" (rewrite "product_first") nil nil)) nil)
   ((product_first formula-decl nil product nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (T_high type-eq-decl nil product nil)
    (T_low type-eq-decl nil product nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   nil))
 (product_split_ge_TCC1 0
  (product_split_ge_TCC1-1 nil 3352162210
   ("" (skosimp*) (("" (inst + 0) (("" (assert) nil nil)) nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil))
   nil
   (product_split_ge subtype "(number_fields.+)(product_nat.i, 1)"
    "T_low[nat]")))
 (product_split_ge 0
  (product_split_ge-1 nil 3308675684
   ("" (skosimp*) (("" (rewrite "product_split") nil nil)) nil)
   ((product_split formula-decl nil product nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (T_high type-eq-decl nil product nil)
    (T_low type-eq-decl nil product nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   nil))
 (product_reverse_TCC1 0
  (product_reverse_TCC1-1 nil 3620035296 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil))
   nil
   (product_reverse subtype
    "(number_fields.-)((number_fields.+)(product_nat.high, product_nat.low), product_nat.j)"
    "nat")))
 (product_reverse 0
  (product_reverse-2 "" 3790089460
   (""
    (case "FORALL (n:nat, F:[nat->real], high:int, low:nat): 
 (low <= high AND n = high-low) IMPLIES
         product(low, high, F) =
          product(low, high,
                  LAMBDA (j: nat):
                    IF high + low - j < 0 THEN 0
                    ELSE F(high + low - j)
                    ENDIF)")
    (("1" (skeep)
      (("1" (inst?)
        (("1" (inst -1 "high-low")
          (("1" (ground) nil nil) ("2" (ground) nil nil)) nil))
        nil))
      nil)
     ("2" (hide 2)
      (("2" (induct "n")
        (("1" (skeep)
          (("1" (both-sides "+" "low" -2)
            (("1" (simplify -2)
              (("1" (replace -2)
                (("1" (lemma "product_eq_arg")
                  (("1" (inst-cp -1 "F" "high")
                    (("1"
                      (inst-cp -1 "LAMBDA (j: nat):
                 IF high + high - j < 0 THEN 0
                 ELSE F(high + high - j)
                 ENDIF" "high")
                      (("1" (hide -1)
                        (("1" (replace -1)
                          (("1" (replace -2)
                            (("1" (lift-if 1)
                              (("1" (split 1)
                                (("1" (flatten) (("1" (ground) nil nil)) nil)
                                 ("2" (flatten) (("2" (ground) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (ground) nil nil)
                       ("3" (skeep) (("3" (ground) nil nil)) nil))
                      nil)
                     ("2" (ground) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (skeep)
            (("2" (lemma "product_first_ge")
              (("2" (inst -1 "F" "high" "low")
                (("2" (split -1)
                  (("1" (replace -1)
                    (("1" (lemma "product_split_ge")
                      (("1"
                        (inst -1 "LAMBDA (j: nat):
                 IF high + low - j < 0 THEN 0 ELSE F(high + low - j) ENDIF"
                         "high" "high-1" "low")
                        (("1" (split -1)
                          (("1" (replace -1)
                            (("1" (hide (-1 -2))
                              (("1" (simplify 1)
                                (("1" (rewrite "product_eq_arg")
                                  (("1" (case-replace "F(low) = 0")
                                    (("1" (ground) nil nil)
                                     ("2" (cancel-by 2 "F(low)")
                                      (("2"
                                        (hide (1 2))
                                        (("2"
                                          (lemma "product_shift")
                                          (("2"
                                            (inst -1 "F" "high-1" "low" "1")
                                            (("2"
                                              (simplify -1)
                                              (("2"
                                                (replace -1)
                                                (("2"
                                                  (name-replace
                                                   "G"
                                                   "LAMBDA (n: nat): F(1 + n)")
                                                  (("2"
                                                    (inst
                                                     -2
                                                     "G"
                                                     "high-1"
                                                     "low")
                                                    (("2"
                                                      (split -2)
                                                      (("1"
                                                        (replace -1)
                                                        (("1"
                                                          (lemma "product_eq")
                                                          (("1"
                                                            (inst
                                                             -1
                                                             "LAMBDA (j: nat):
                 IF high - 1 + low - j < 0 THEN 0
                 ELSE G(high - 1 + low - j)
                 ENDIF"
                                                             "LAMBDA (j: nat):
                  IF high - j + low < 0 THEN 0
                  ELSE F(high - j + low)
                  ENDIF"
                                                             "high-1"
                                                             "low")
                                                            (("1"
                                                              (hide (-2 -3))
                                                              (("1"
                                                                (split -1)
                                                                (("1"
                                                                  (propax)
                                                                  nil
                                                                  nil)
                                                                 ("2"
                                                                  (hide 2)
                                                                  (("2"
                                                                    (skeep)
                                                                    (("2"
                                                                      (lift-if
                                                                       1)
                                                                      (("2"
                                                                        (lift-if
                                                                         1)
                                                                        (("2"
                                                                          (lift-if
                                                                           1)
                                                                          (("2"
                                                                            (split
                                                                             1)
                                                                            (("1"
                                                                              (flatten)
                                                                              (("1"
                                                                                (split
                                                                                 1)
                                                                                (("1"
                                                                                  (propax)
                                                                                  nil
                                                                                  nil)
                                                                                 ("2"
                                                                                  (flatten)
                                                                                  (("2"
                                                                                    (ground)
                                                                                    nil
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (flatten)
                                                                              (("2"
                                                                                (split)
                                                                                (("1"
                                                                                  (flatten)
                                                                                  (("1"
                                                                                    (ground)
                                                                                    nil
                                                                                    nil))
                                                                                  nil)
                                                                                 ("2"
                                                                                  (flatten)
                                                                                  (("2"
                                                                                    (ground)
                                                                                    (("2"
                                                                                      (expand
                                                                                       "G")
                                                                                      (("2"
                                                                                        (propax)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (skeep)
                                                              (("2"
                                                                (ground)
                                                                nil
                                                                nil))
                                                              nil)
                                                             ("3"
                                                              (skeep)
                                                              (("3"
                                                                (ground)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2" (ground) nil nil)
                                                       ("3" (ground) nil nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (skeep) (("2" (ground) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (ground) nil nil) ("3" (ground) nil nil))
                          nil)
                         ("2" (skeep) (("2" (ground) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (ground) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (hide 2)
          (("3" (skeep) (("3" (skeep) (("3" (ground) nil nil)) nil)) nil))
          nil))
        nil))
      nil)
     ("3" (hide 2)
      (("3" (skeep) (("3" (skeep) (("3" (ground) nil nil)) nil)) nil)) nil))
    nil)
   nil shostak)
  (product_reverse-1 nil 3620035321
   (""
    (case "FORALL (n:nat, F:[nat->real], high:int, low:nat): 
 (low <= high AND n = high-low) IMPLIES
         product(low, high, F) =
          product(low, high,
                  LAMBDA (j: nat):
                    IF high + low - j < 0 THEN 0
                    ELSE F(high + low - j)
                    ENDIF)")
    (("1" (skeep)
      (("1" (inst?)
        (("1" (inst -1 "high-low")
          (("1" (ground) nil nil) ("2" (ground) nil nil)) nil))
        nil))
      nil)
     ("2" (hide 2)
      (("2" (induct "n")
        (("1" (skeep)
          (("1" (both-sides "+" "low" -2)
            (("1" (simplify -2)
              (("1" (replace -2)
                (("1" (lemma "product_eq_arg")
                  (("1" (inst-cp -1 "F" "high")
                    (("1"
                      (inst-cp -1 "LAMBDA (j: nat):
                 IF high + high - j < 0 THEN 0
                 ELSE F(high + high - j)
                 ENDIF" "high")
                      (("1" (hide -1)
                        (("1" (replace -1)
                          (("1" (replace -2)
                            (("1" (lift-if 1)
                              (("1" (split 1)
                                (("1" (flatten) (("1" (ground) nil nil)) nil)
                                 ("2" (flatten) (("2" (ground) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (ground) nil nil)
                       ("3" (skeep) (("3" (ground) nil nil)) nil))
                      nil)
                     ("2" (ground) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (skeep)
            (("2" (lemma "product_first_ge")
              (("2" (inst -1 "F" "high" "low")
                (("2" (split -1)
                  (("1" (replace -1)
                    (("1" (lemma "product_split_ge")
                      (("1"
                        (inst -1 "LAMBDA (j: nat):
                 IF high + low - j < 0 THEN 0 ELSE F(high + low - j) ENDIF"
                         "high" "high-1" "low")
                        (("1" (split -1)
                          (("1" (replace -1)
                            (("1" (hide (-1 -2))
                              (("1" (simplify 1)
                                (("1" (rewrite "product_eq_arg")
                                  (("1" (case-replace "F(low) = 0")
                                    (("1" (ground) nil nil)
                                     ("2" (cancel-by 2 "F(low)")
                                      (("2"
                                        (hide (1 2))
                                        (("2"
                                          (lemma "product_shift")
                                          (("2"
                                            (inst -1 "F" "high-1" "low" "1")
                                            (("2"
                                              (simplify -1)
                                              (("2"
                                                (replace -1)
                                                (("2"
                                                  (name-replace
                                                   "G"
                                                   "LAMBDA (n: nat): F(1 + n)")
                                                  (("2"
                                                    (inst
                                                     -2
                                                     "G"
                                                     "high-1"
                                                     "low")
                                                    (("2"
                                                      (split -2)
                                                      (("1"
                                                        (replace -1)
                                                        (("1"
                                                          (lemma "product_eq")
                                                          (("1"
                                                            (inst
                                                             -1
                                                             "LAMBDA (j: nat):
                 IF high - 1 + low - j < 0 THEN 0
                 ELSE G(high - 1 + low - j)
                 ENDIF"
                                                             "LAMBDA (j: nat):
                  IF high - j + low < 0 THEN 0
                  ELSE F(high - j + low)
                  ENDIF"
                                                             "high-1"
                                                             "low")
                                                            (("1"
                                                              (hide (-2 -3))
                                                              (("1"
                                                                (split -1)
                                                                (("1"
                                                                  (propax)
                                                                  nil
                                                                  nil)
                                                                 ("2"
                                                                  (hide 2)
                                                                  (("2"
                                                                    (skeep)
                                                                    (("2"
                                                                      (lift-if
                                                                       1)
                                                                      (("2"
                                                                        (lift-if
                                                                         1)
                                                                        (("2"
                                                                          (lift-if
                                                                           1)
                                                                          (("2"
                                                                            (split
                                                                             1)
                                                                            (("1"
                                                                              (flatten)
                                                                              (("1"
                                                                                (split
                                                                                 1)
                                                                                (("1"
                                                                                  (propax)
                                                                                  nil
                                                                                  nil)
                                                                                 ("2"
                                                                                  (flatten)
                                                                                  (("2"
                                                                                    (ground)
                                                                                    nil
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (flatten)
                                                                              (("2"
                                                                                (split)
                                                                                (("1"
                                                                                  (flatten)
                                                                                  (("1"
                                                                                    (ground)
                                                                                    nil
                                                                                    nil))
                                                                                  nil)
                                                                                 ("2"
                                                                                  (flatten)
                                                                                  (("2"
                                                                                    (ground)
                                                                                    (("2"
                                                                                      (expand
                                                                                       "G")
                                                                                      (("2"
                                                                                        (propax)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (skeep)
                                                              (("2"
                                                                (ground)
                                                                nil
                                                                nil))
                                                              nil)
                                                             ("3"
                                                              (skeep)
                                                              (("3"
                                                                (ground)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2" (ground) nil nil)
                                                       ("3" (ground) nil nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (skeep) (("2" (ground) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (ground) nil nil) ("3" (ground) nil nil))
                          nil)
                         ("2" (skeep) (("2" (ground) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (ground) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (hide 2)
          (("3" (skeep) (("3" (skeep) (("3" (ground) nil nil)) nil)) nil))
          nil)
         ("4" (hide 2) (("4" (skeep) (("4" (assert) nil nil)) nil)) nil))
        nil))
      nil)
     ("3" (hide 2)
      (("3" (skeep) (("3" (skeep) (("3" (ground) nil nil)) nil)) nil)) nil)
     ("4" (hide 2) (("4" (skeep) (("4" (grind) nil nil)) nil)) nil))
    nil)
   ((product_first_ge formula-decl nil product_nat nil)
    (product_split_ge formula-decl nil product_nat nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (/= const-decl "boolean" notequal nil)
    (div_192 skolem-const-decl "real" product_nat nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (both_sides_times1 formula-decl nil real_props nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (product_shift formula-decl nil product_nat nil)
    (product_eq formula-decl nil product nil)
    (G skolem-const-decl "[nat -> real]" product_nat nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (low skolem-const-decl "nat" product_nat nil)
    (high skolem-const-decl "int" product_nat nil)
    (product_eq_arg formula-decl nil product nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (high skolem-const-decl "int" product_nat nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (high skolem-const-decl "int" product_nat nil)
    (low skolem-const-decl "nat" product_nat nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (T_low type-eq-decl nil product nil) (T_high type-eq-decl nil product nil)
    (product def-decl "real" product nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (< const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil))
   shostak))
 (product_0_neg 0
  (product_0_neg-2 "" 3790089460
   ("" (skosimp*) (("" (expand "product") (("" (propax) nil nil)) nil)) nil)
   nil shostak)
  (product_0_neg-1 nil 3403521650
   ("" (skosimp*) (("" (expand "product") (("" (postpone) nil nil)) nil)) nil)
   ((product def-decl "real" product nil)) shostak)))

