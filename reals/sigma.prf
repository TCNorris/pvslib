(sigma (T_pred_lem 0 (T_pred_lem-1 nil 3352120046 ("" (skosimp* t) (("" (prop) (("1" (lemma "connected_domain") (("1" (inst - "low!1" "high!1" "z!1") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (lemma "connected_domain") (("2" (inst - "j!1" "high!1" "z!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (lemma "connected_domain") (("3" (inst - "low!1" "j!1" "z!1") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (skosimp*) (("4" (lemma "connected_domain") (("4" (inst - "low!1" "j!2" "z!1") (("1" (assert) nil nil) ("2" (lemma "connected_domain") (("2" (inst - "j!1" "j!2" "low!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((low!1 skolem-const-decl "T_low" sigma nil) (high!1 skolem-const-decl "T_high" sigma nil) (integer nonempty-type-from-decl nil integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (connected_domain formula-decl nil sigma nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil)) shostak)) (high_low_rewrite_TCC1 0 (high_low_rewrite_TCC1-1 nil 3352229091 ("" (skosimp*) (("" (inst + "high!1") (("1" (assert) nil nil) ("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil) ((high!1 skolem-const-decl "T_high" sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (T formal-subtype-decl nil sigma nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (T_low type-eq-decl nil sigma nil) (T_pred_lem formula-decl nil sigma nil)) nil (high_low_rewrite subtype "sigma.n" "T_high"))) (high_low_rewrite 0 (high_low_rewrite-1 nil 3352228842 ("" (skosimp*) (("" (inst?) (("" (prop) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (high!1 skolem-const-decl "T_high" sigma nil) (low!1 skolem-const-decl "T_low" sigma nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak)) (sigma_TCC1 0 (sigma_TCC1-2 nil 3403452046 ("" (skosimp* t) (("" (assert) (("" (skosimp*) (("" (typepred "j!1") (("" (lemma "connected_domain") (("" (inst - "low!1" "j!1" "high!1") (("1" (assert) nil nil) ("2" (prop) (("2" (skosimp*) (("2" (lemma "connected_domain") (("2" (assert) (("2" (inst - "j!2" "j!1" "low!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (low!1 skolem-const-decl "T_low" sigma nil) (integer nonempty-type-from-decl nil integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (connected_domain formula-decl nil sigma nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil)) nil (sigma subtype "sigma.high" "T")) (sigma_TCC1-1 nil 3255975799 ("" (skosimp*) (("" (use "T_pred_lem") (("" (assert) nil nil)) nil)) nil) nil nil (sigma subtype "sigma.high" "T"))) (sigma_TCC2 0 (sigma_TCC2-2 nil 3403452083 ("" (skosimp*) (("" (typepred "high!1") (("" (assert) (("" (prop) (("1" (inst + "high!1") (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (typepred "j!1") (("2" (inst + "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (high!1 skolem-const-decl "T_high" sigma nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (sigma subtype "(number_fields.-)(sigma.high, 1)" "T_high")) (sigma_TCC2-1 nil 3255975799 ("" (skosimp* t) (("" (assert) (("" (skosimp*) (("" (typepred "j!1") (("" (lemma "connected_domain") (("" (inst - "low!1" "j!1" "high!1") (("1" (assert) nil nil) ("2" (prop) (("2" (skosimp*) (("2" (lemma "connected_domain") (("2" (assert) (("2" (inst - "j!2" "j!1" "low!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (sigma subtype "(number_fields.-)(sigma.high, 1)" "T_high"))) (sigma_TCC3 0 (sigma_TCC3-1 nil 3255975799 ("" (skosimp*) (("" (grind) nil nil)) nil) ((abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (minus_int_is_int application-judgement "int" integers nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (sigma termination "sigma.sigma(sigma.low, (number_fields.-)(sigma.high, 1), sigma.F)" "nil"))) (old_sigma_TCC1 0 (old_sigma_TCC1-1 nil 3403451849 ("" (skosimp*) (("" (typepred "low!1") (("" (assert) (("" (skosimp*) (("" (replace -2) (("" (typepred "j!1") (("" (typepred "high!1") (("" (assert) (("" (skosimp*) (("" (lemma "connected_domain") (("" (inst - "j!1" "j!2" "low!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T_low type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (connected_domain formula-decl nil sigma nil) (integer nonempty-type-from-decl nil integers nil) (T_high type-eq-decl nil sigma nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (old_sigma subtype "sigma.low" "T"))) (sigma_rew 0 (sigma_rew-1 nil 3352522445 ("" (skosimp*) (("" (lift-if) (("" (ground) (("1" (expand "sigma") (("1" (propax) nil nil)) nil) ("2" (expand "sigma") (("2" (expand "sigma") (("2" (assert) nil nil)) nil)) nil) ("3" (expand "sigma" 2 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ((sigma def-decl "real" sigma nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil)) shostak)) (old_sigma_rew 0 (old_sigma_rew-1 nil 3403459500 ("" (skosimp*) (("" (case "FORALL (rng: nat): T_pred(low!1+rng) IMPLIES
                              sigma(low!1, low!1+rng, F!1) = old_sigma(low!1, low!1+rng, F!1)") (("1" (inst - "high!1-low!1") (("1" (assert) (("1" (typepred "high!1") (("1" (assert) (("1" (skosimp*) (("1" (typepred "j!1") (("1" (typepred "low!1") (("1" (lemma "connected_domain") (("1" (inst - "low!1" "j!1" "high!1") (("1" (assert) (("1" (expand "sigma") (("1" (expand "old_sigma") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (skosimp*) (("2" (lemma "connected_domain") (("2" (inst - "j!2" "j!1" "low!1") (("2" (assert) (("2" (expand "sigma") (("2" (expand "old_sigma") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "sigma") (("2" (expand "old_sigma") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "rng") (("1" (assert) (("1" (flatten) (("1" (expand "sigma") (("1" (expand "sigma") (("1" (expand "old_sigma") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (expand "sigma" 1) (("2" (expand "old_sigma" 1) (("2" (assert) (("2" (hide 2) (("2" (typepred "low!1") (("2" (typepred "j!1") (("2" (assert) (("2" (prop) (("1" (lemma "connected_domain") (("1" (inst - "low!1" "j!1+1+low!1" "j!1+low!1") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (lemma "connected_domain") (("2" (inst - "j!2" "j!1+1+low!1" "j!1+low!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) nil nil)) nil)) nil)) nil) ("3" (skosimp*) nil nil)) nil)) nil) ((old_sigma def-decl "real" sigma nil) (sigma def-decl "real" sigma nil) (T_high type-eq-decl nil sigma nil) (= const-decl "[T, T -> boolean]" equalities nil) (T_low type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (T formal-subtype-decl nil sigma nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (T_pred const-decl "[int -> boolean]" sigma nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (connected_domain formula-decl nil sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (integer nonempty-type-from-decl nil integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (low!1 skolem-const-decl "T_low" sigma nil) (high!1 skolem-const-decl "T_high" sigma nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil)) (sigma_spl_TCC1 0 (sigma_spl_TCC1-2 "" 3790088459 ("" (skosimp*) nil nil) nil shostak (sigma_spl subtype "(number_fields.+)((number_fields.+)(sigma.low, sigma.nn), sigma.rng)" "T_high")) (sigma_spl_TCC1-1 nil 3255975799 ("" (skosimp*) (("" (inst + "low!1 + nn!1 + rng!1") (("" (assert) nil nil)) nil)) nil) nil nil (sigma_spl subtype "(number_fields.+)((number_fields.+)(sigma.low, sigma.nn), sigma.rng)" "T_high"))) (sigma_spl_TCC2 0 (sigma_spl_TCC2-1 nil 3255975799 ("" (skosimp*) (("" (inst + "low!1 + nn!1 + rng!1") (("" (assert) nil nil)) nil)) nil) ((int_plus_int_is_int application-judgement "int" integers nil) (rng!1 skolem-const-decl "nat" sigma nil) (nn!1 skolem-const-decl "nat" sigma nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (low!1 skolem-const-decl "T_low" sigma nil) (T_low type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (T formal-subtype-decl nil sigma nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (sigma_spl subtype "(number_fields.+)(sigma.low, sigma.nn)" "T_high"))) (sigma_spl_TCC3 0 (sigma_spl_TCC3-1 nil 3351939915 ("" (skosimp* t) (("" (prop) (("1" (assert) (("1" (inst + "low!1") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (inst + "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_low type-eq-decl nil sigma nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (sigma_spl subtype "(number_fields.+)((number_fields.+)(sigma.low, sigma.nn), 1)" "T_low"))) (sigma_spl 0 (sigma_spl-1 nil 3255975799 ("" (induct "rng") (("1" (assert) (("1" (expand "sigma") (("1" (propax) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "sigma" + (1 3)) (("2" (inst?) (("2" (assert) (("2" (lemma "T_pred_lem") (("2" (inst?) (("2" (inst - "1+j!1+low!1+nn!1" "low!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (inst + "low!1+nn!1") (("1" (assert) nil nil) ("2" (lemma "T_pred_lem") (("2" (inst?) (("2" (inst - "low!1+nn!1+rng!2" "low!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (inst + "low!1+nn!1+rng!2") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) nil nil)) nil)) nil) ((low!1 skolem-const-decl "T_low" sigma nil) (nn!1 skolem-const-decl "nat" sigma nil) (rng!2 skolem-const-decl "nat" sigma nil) (low!1 skolem-const-decl "T_low" sigma nil) (nn!1 skolem-const-decl "nat" sigma nil) (rng!2 skolem-const-decl "nat" sigma nil) (T_pred_lem formula-decl nil sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (sigma def-decl "real" sigma nil) (T_high type-eq-decl nil sigma nil) (= const-decl "[T, T -> boolean]" equalities nil) (pred type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_low type-eq-decl nil sigma nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil)) nil)) (sigma_split_TCC1 0 (sigma_split_TCC1-1 nil 3255975799 ("" (skosimp* t) (("" (prop) (("1" (inst + "high!1") nil nil) ("2" (inst + "high!1") nil nil) ("3" (skosimp*) (("3" (inst + "j!1") (("3" (assert) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (inst + "j!2") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ((high!1 skolem-const-decl "T_high" sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil)) nil (sigma_split subtype "sigma.z" "T_high"))) (sigma_split_TCC2 0 (sigma_split_TCC2-1 nil 3351939915 ("" (skosimp* t) (("" (assert) (("" (prop) (("1" (inst + "low!1") (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (inst + "j!1") (("2" (assert) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (inst + "low!1") (("3" (assert) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (inst + "j!1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (low!1 skolem-const-decl "T_low" sigma nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil)) nil (sigma_split subtype "(number_fields.+)(sigma.z, 1)" "T_low"))) (sigma_split 0 (sigma_split-1 nil 3255975799 ("" (skosimp*) (("" (case "high!1<low!1") (("1" (expand "sigma") (("1" (assert) nil nil)) nil) ("2" (case-replace "z!1=low!1-1") (("1" (assert) (("1" (expand "sigma") (("1" (propax) nil nil)) nil)) nil) ("2" (lemma "sigma_spl") (("2" (inst - "F!1" "low!1" "z!1-low!1" "high!1-z!1") (("1" (assert) (("1" (hide-all-but (1 3)) (("1" (use "T_pred_lem") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma def-decl "real" sigma nil) (sigma_spl formula-decl nil sigma nil) (T_pred_lem formula-decl nil sigma nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (high!1 skolem-const-decl "T_high" sigma nil) (low!1 skolem-const-decl "T_low" sigma nil) (z!1 skolem-const-decl "int" sigma nil) (>= const-decl "bool" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil)) nil)) (sigma_diff 0 (sigma_diff-1 nil 3255975799 ("" (skosimp*) (("" (lemma "sigma_split") (("" (inst?) (("" (inst -1 "z!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((sigma_split formula-decl nil sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (int_plus_int_is_int application-judgement "int" integers nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (sigma_diff_neg 0 (sigma_diff_neg-1 nil 3255975799 ("" (skosimp*) (("" (lemma "sigma_diff") (("" (inst -1 "F!1" "high!1" "low!1" "z!1") (("" (assert) nil nil)) nil)) nil)) nil) ((sigma_diff formula-decl nil sigma nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (sigma_eq_arg 0 (sigma_eq_arg-1 nil 3255975799 ("" (skosimp*) (("" (expand "sigma") (("" (expand "sigma") (("" (propax) nil nil)) nil)) nil)) nil) ((sigma def-decl "real" sigma nil)) nil)) (sigma_first_TCC1 0 (sigma_first_TCC1-1 nil 3255975799 ("" (skosimp*) (("" (use "T_pred_lem") (("" (assert) nil nil)) nil)) nil) ((T_pred_lem formula-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (T_high type-eq-decl nil sigma nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (sigma_first subtype "sigma.low" "T"))) (sigma_first_TCC2 0 (sigma_first_TCC2-1 nil 3352113941 ("" (skosimp* t) (("" (prop) (("1" (inst + "low!1") (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (inst + "j!1") (("2" (assert) nil nil)) nil)) nil) ("3" (inst + "low!1") (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (inst + "j!1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (low!1 skolem-const-decl "T_low" sigma nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil)) nil (sigma_first subtype "(number_fields.+)(sigma.low, 1)" "T_low"))) (sigma_first 0 (sigma_first-1 nil 3255975799 ("" (skosimp*) (("" (lemma "sigma_split") (("" (inst?) (("" (inst -1 "low!1") (("" (rewrite "sigma_eq_arg") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((sigma_split formula-decl nil sigma nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sigma_eq_arg formula-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (sigma_last_TCC1 0 (sigma_last_TCC1-2 nil 3351941334 ("" (skosimp* t) (("" (prop) (("1" (inst + "high!1") (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (inst + "high!1") (("2" (assert) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (inst + "j!1") (("3" (assert) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (inst + "j!2") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (high!1 skolem-const-decl "T_high" sigma nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil)) nil (sigma_last subtype "(number_fields.-)(sigma.high, 1)" "T_high")) (sigma_last_TCC1-1 nil 3255975799 ("" (skosimp*) (("" (typepred "high!1") (("" (skosimp*) (("" (inst + "j!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil) nil nil (sigma_last subtype "(number_fields.-)(sigma.high, 1)" "T_high"))) (sigma_last_TCC2 0 (sigma_last_TCC2-1 nil 3351939915 ("" (skosimp*) (("" (use "T_pred_lem") (("" (assert) nil nil)) nil)) nil) ((T_pred_lem formula-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (T_low type-eq-decl nil sigma nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (sigma_last subtype "sigma.high" "T"))) (sigma_last 0 (sigma_last-2 "" 3790088460 ("" (skosimp*) (("" (rewrite "sigma") (("" (assert) nil nil)) nil)) nil) ((sigma def-decl "real" sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak) (sigma_last-1 nil 3255975799 ("" (skosimp*) (("" (rewrite "sigma") (("" (assert) (("" (lift-if) (("" (ground) (("" (expand "sigma") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil)) (sigma_middle_TCC1 0 (sigma_middle_TCC1-1 nil 3256039673 ("" (skosimp* t) (("" (prop) (("1" (inst + "high!1") (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (inst + "high!1") (("2" (assert) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (inst + "j!1") (("3" (assert) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (inst + "j!2") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (high!1 skolem-const-decl "T_high" sigma nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil)) shostak (sigma_middle subtype "(number_fields.-)(sigma.i, 1)" "T_high"))) (sigma_middle_TCC2 0 (sigma_middle_TCC2-1 nil 3256039673 ("" (skosimp*) (("" (inst + "i!1") (("" (assert) nil nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (sigma_middle subtype "(number_fields.+)(sigma.i, 1)" "T_low"))) (sigma_middle 0 (sigma_middle-2 "" 3790088461 ("" (skosimp*) (("" (lemma "sigma_split") (("" (inst?) (("" (inst -1 "i!1") (("" (assert) (("" (rewrite "sigma_rew" -) (("" (assert) (("" (replace -1) (("" (hide -1) (("" (assert) (("" (expand "sigma" 1 1) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sigma_split formula-decl nil sigma nil) (sigma_rew formula-decl nil sigma nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma def-decl "real" sigma nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak) (sigma_middle-1 nil 3256032001 ("" (skosimp*) (("" (lemma "sigma_split") (("" (inst?) (("" (inst -1 "i!1") (("" (assert) (("" (rewrite "sigma_rew" -) (("" (assert) (("" (replace -1) (("" (hide -1) (("" (assert) (("" (expand "sigma" 1 1) (("" (lift-if) (("" (ground) (("" (expand "sigma") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (sigma_const 0 (sigma_const-1 nil 3255975799 ("" (skolem 1 (_ _ x)) (("" (rewrite "high_low_rewrite") (("" (hide 2) (("" (skosimp*) (("" (prop) (("1" (expand "sigma") (("1" (assert) nil nil)) nil) ("2" (induct "n" 2) (("1" (rewrite "sigma_eq_arg") (("1" (assert) nil nil) ("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (expand "sigma" +) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (skosimp*) (("3" (inst + "high!1") (("1" (assert) nil nil) ("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((high_low_rewrite formula-decl nil sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (pred type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (sigma def-decl "real" sigma nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (>= const-decl "bool" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (low!1 skolem-const-decl "T_low" sigma nil) (high!1 skolem-const-decl "T_high" sigma nil) (subrange type-eq-decl nil integers nil) (subrange_induction formula-decl nil subrange_inductions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (T_pred_lem formula-decl nil sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (sigma_eq_arg formula-decl nil sigma nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (sigma_zero 0 (sigma_zero-1 nil 3255975799 ("" (skosimp*) (("" (rewrite "sigma_const") nil nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sigma_const formula-decl nil sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil)) nil)) (sigma_scal 0 (sigma_scal-1 nil 3255975799 ("" (skolem 1 ("F" "a" _ _)) (("" (rewrite "high_low_rewrite") (("" (hide 2) (("" (skosimp*) (("" (prop) (("1" (expand "sigma") (("1" (assert) nil nil)) nil) ("2" (induct "n" 2) (("1" (rewrite "sigma_eq_arg") (("1" (rewrite "sigma_eq_arg") nil nil) ("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (expand "sigma" +) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (inst + "high!1") (("1" (assert) nil nil) ("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (high_low_rewrite formula-decl nil sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (pred type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (sigma def-decl "real" sigma nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (low!1 skolem-const-decl "T_low" sigma nil) (high!1 skolem-const-decl "T_high" sigma nil) (subrange type-eq-decl nil integers nil) (subrange_induction formula-decl nil subrange_inductions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (>= const-decl "bool" reals nil) (T_pred_lem formula-decl nil sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (sigma_eq_arg formula-decl nil sigma nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (sigma_neg 0 (sigma_neg-1 nil 3719181406 ("" (skeep) (("" (lemma "sigma_scal") (("" (insteep -1 :but "a") (("" (inst -1 "-1") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((sigma_scal formula-decl nil sigma nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil)) shostak)) (sigma_scal_right 0 (sigma_scal_right-1 nil 3500821826 ("" (skeep) (("" (lemma "sigma_scal") (("" (inst - "F" "a" "high" "low") (("" (assert) nil nil)) nil)) nil)) nil) ((sigma_scal formula-decl nil sigma nil) (real_times_real_is_real application-judgement "real" reals nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (sigma_bound 0 (sigma_bound-1 nil 3255975799 ("" (skolem 1 ("B" "F" _ _)) (("" (rewrite "high_low_rewrite") (("" (hide 2) (("" (skosimp*) (("" (prop) (("1" (expand "sigma") (("1" (assert) nil nil)) nil) ("2" (induct "n" 2) (("1" (skosimp*) (("1" (rewrite "sigma_eq_arg") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide -1 2) (("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (expand "sigma" +) (("2" (prop) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (hide-all-but (1 2)) (("3" (typepred "n!2") (("3" (assert) (("3" (typepred "high!1") (("3" (prop) (("1" (inst + "high!1") nil nil) ("2" (skosimp*) (("2" (inst + "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (high_low_rewrite formula-decl nil sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (sigma def-decl "real" sigma nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_plus_real_is_real application-judgement "real" reals nil) (low!1 skolem-const-decl "T_low" sigma nil) (high!1 skolem-const-decl "T_high" sigma nil) (subrange type-eq-decl nil integers nil) (F skolem-const-decl "[T -> real]" sigma nil) (B skolem-const-decl "real" sigma nil) (subrange_induction formula-decl nil subrange_inductions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sigma_eq_arg formula-decl nil sigma nil) (T_pred_lem formula-decl nil sigma nil) (int_plus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil)) (sigma_abs 0 (sigma_abs-1 nil 3255975799 ("" (skolem 1 ("F" _ _)) (("" (rewrite "high_low_rewrite") (("" (hide 2) (("" (skosimp*) (("" (prop) (("1" (expand "sigma") (("1" (expand "abs") (("1" (assert) nil nil)) nil)) nil) ("2" (induct "n" 2) (("1" (rewrite "sigma_eq_arg") (("1" (rewrite "sigma_eq_arg") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (expand "sigma" +) (("2" (lemma "triangle") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (skosimp*) (("3" (inst + "high!1") (("1" (assert) nil nil) ("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((high_low_rewrite formula-decl nil sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (pred type-eq-decl nil defined_types nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (sigma def-decl "real" sigma nil) (low!1 skolem-const-decl "T_low" sigma nil) (high!1 skolem-const-decl "T_high" sigma nil) (subrange type-eq-decl nil integers nil) (subrange_induction formula-decl nil subrange_inductions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (T_pred_lem formula-decl nil sigma nil) (sigma_eq_arg formula-decl nil sigma nil) (triangle formula-decl nil real_props nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (minus_even_is_even application-judgement "even_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (sigma_ge_0_TCC1 0 (sigma_ge_0_TCC1-1 nil 3255975799 ("" (skosimp* t) (("" (prop) (("1" (use "T_pred_lem") (("1" (assert) nil nil)) nil) ("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil) ("3" (use "T_pred_lem") (("3" (assert) nil nil)) nil) ("4" (use "T_pred_lem") (("4" (assert) nil nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (T_pred_lem formula-decl nil sigma nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil)) nil (sigma_ge_0 subtype "sigma.n" "T"))) (sigma_ge_0 0 (sigma_ge_0-1 nil 3255975799 ("" (skolem 1 ("F" _ _)) (("" (rewrite "high_low_rewrite") (("1" (hide 2) (("1" (skosimp*) (("1" (prop) (("1" (expand "sigma") (("1" (assert) nil nil)) nil) ("2" (induct "n" 2) (("1" (skosimp*) (("1" (rewrite "sigma_eq_arg") (("1" (inst?) nil nil) ("2" (hide -1 2) (("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (expand "sigma" +) (("2" (prop) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (skosimp*) (("3" (inst + "high!1") (("1" (assert) nil nil) ("2" (hide -1) (("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (skosimp* t) (("4" (hide -1) (("4" (use "T_pred_lem") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp* t) (("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((high_low_rewrite formula-decl nil sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (sigma def-decl "real" sigma nil) (low!1 skolem-const-decl "T_low" sigma nil) (high!1 skolem-const-decl "T_high" sigma nil) (F skolem-const-decl "[T -> real]" sigma nil) (subrange_induction formula-decl nil subrange_inductions nil) (sigma_eq_arg formula-decl nil sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (T_pred_lem formula-decl nil sigma nil) (real_plus_real_is_real application-judgement "real" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (sigma_gt_0 0 (sigma_gt_0-1 nil 3255975799 ("" (skolem 1 ("F" _ _)) (("" (rewrite "high_low_rewrite") (("1" (hide 2) (("1" (skosimp*) (("1" (prop) (("1" (induct "n" 2) (("1" (rewrite "sigma_eq_arg") (("1" (flatten) (("1" (inst?) nil nil)) nil) ("2" (hide 2) (("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (hide 2) (("2" (expand "sigma" +) (("2" (prop) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (skosimp* t) (("3" (inst + "high!1") (("3" (assert) (("3" (hide -1 -2 -3) (("3" (use "T_pred_lem") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2 3) (("4" (skosimp* t) (("4" (hide -1) (("4" (use "T_pred_lem") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp) (("2" (skosimp* t) (("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((high_low_rewrite formula-decl nil sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (sigma def-decl "real" sigma nil) (low!1 skolem-const-decl "T_low" sigma nil) (high!1 skolem-const-decl "T_high" sigma nil) (F skolem-const-decl "[T -> real]" sigma nil) (subrange_induction formula-decl nil subrange_inductions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (>= const-decl "bool" reals nil) (T_pred_lem formula-decl nil sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_eq_arg formula-decl nil sigma nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil)) nil)) (sigma_shift_T_TCC1 0 (sigma_shift_T_TCC1-1 nil 3255975799 ("" (skosimp* t) (("" (prop) (("1" (inst - "low!1") nil nil) ("2" (skosimp*) (("2" (inst + "j!1+z!1") (("1" (assert) nil nil) ("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ((low!1 skolem-const-decl "T_low" sigma nil) (int_plus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (j!1 skolem-const-decl "T" sigma nil) (z!1 skolem-const-decl "int" sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_low type-eq-decl nil sigma nil)) nil (sigma_shift_T subtype "(number_fields.+)(sigma.low, sigma.z)" "T_low"))) (sigma_shift_T_TCC2 0 (sigma_shift_T_TCC2-1 nil 3351939915 ("" (skosimp* t) (("" (prop) (("1" (inst?) nil nil) ("2" (skosimp*) (("2" (inst + "z!1+j!1") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ((high!1 skolem-const-decl "T_high" sigma nil) (int_plus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (j!1 skolem-const-decl "T" sigma nil) (z!1 skolem-const-decl "int" sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil)) nil (sigma_shift_T subtype "(number_fields.+)(sigma.high, sigma.z)" "T_high"))) (sigma_shift_T_TCC3 0 (sigma_shift_T_TCC3-1 nil 3352113941 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (int_plus_int_is_int application-judgement "int" integers nil)) nil (sigma_shift_T subtype "(number_fields.+)(sigma.i, sigma.z)" "T"))) (sigma_shift_T 0 (sigma_shift_T-1 nil 3255975799 ("" (skolem 1 ("F" _ _ "z")) (("" (rewrite "high_low_rewrite") (("1" (hide 2) (("1" (skosimp*) (("1" (prop) (("1" (expand "sigma") (("1" (assert) nil nil)) nil) ("2" (induct "n" 2) (("1" (skosimp*) (("1" (rewrite "sigma_eq_arg") (("1" (rewrite "sigma_eq_arg") (("1" (hide -1 2) (("1" (use "T_pred_lem") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (inst?) (("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (expand "sigma" +) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) nil nil) ("4" (hide-all-but 1) (("4" (skosimp* t) (("4" (typepred "high!1") (("4" (prop) (("1" (inst + "high!1") nil nil) ("2" (skosimp*) (("2" (inst + "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide -1 2 3) (("5" (skosimp* t) (("5" (typepred "high!1") (("5" (prop) (("1" (inst + "high!1+z") (("1" (assert) nil nil) ("2" (inst?) nil nil)) nil) ("2" (skosimp*) (("2" (inst + "j!1+z") (("1" (assert) nil nil) ("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide -1 2 3) (("6" (skosimp* t) (("6" (assert) (("6" (typepred "low!1") (("6" (prop) (("1" (inst?) nil nil) ("2" (skosimp*) (("2" (inst + "j!1+z") (("1" (assert) nil nil) ("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) nil nil) ("3" (hide 2) (("3" (skosimp* t) (("3" (hide -1 -4) (("3" (assert) (("3" (prop) (("1" (typepred "high!1") (("1" (prop) (("1" (assert) (("1" (inst?) nil nil)) nil) ("2" (skosimp*) (("2" (inst + "j!1+z") (("1" (assert) nil nil) ("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (typepred "high!1") (("2" (prop) (("1" (inst?) nil nil) ("2" (skosimp*) (("2" (inst + "j!2+z") (("1" (assert) nil nil) ("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp* t) (("4" (hide -1) (("4" (inst?) (("4" (assert) (("4" (skosimp*) (("4" (reveal -1) (("4" (inst + "j!1+z") (("1" (assert) nil nil) ("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_plus_int_is_int application-judgement "int" integers nil) (high_low_rewrite formula-decl nil sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (sigma def-decl "real" sigma nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (low!1 skolem-const-decl "T_low" sigma nil) (high!1 skolem-const-decl "T_high" sigma nil) (subrange type-eq-decl nil integers nil) (z skolem-const-decl "int" sigma nil) (subrange_induction formula-decl nil subrange_inductions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (>= const-decl "bool" reals nil) (sigma_eq_arg formula-decl nil sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (T_pred_lem formula-decl nil sigma nil) (NOT const-decl "[bool -> bool]" booleans nil) (j!1 skolem-const-decl "T" sigma nil) (j!1 skolem-const-decl "T" sigma nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (high!1 skolem-const-decl "T_high" sigma nil) (j!2 skolem-const-decl "T" sigma nil) (j!1 skolem-const-decl "T" sigma nil) (low!1 skolem-const-decl "T_low" sigma nil) (j!1 skolem-const-decl "T" sigma nil)) nil)) (sigma_shift_T2_TCC1 0 (sigma_shift_T2_TCC1-3 "" 3790088464 ("" (skosimp*) nil nil) nil shostak (sigma_shift_T2 subtype "(number_fields.+)(sigma.low, sigma.z)" "T_low")) (sigma_shift_T2_TCC1-2 nil 3351941788 ("" (skosimp*) (("" (inst + "low!1+z!1") (("" (assert) nil nil)) nil)) nil) nil nil (sigma_shift_T2 subtype "(number_fields.+)(sigma.low, sigma.z)" "T_low")) (sigma_shift_T2_TCC1-1 nil 3351939915 ("" (skosimp*) (("" (typepred "high!1") (("" (skosimp*) (("" (inst + "z!1+high!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil) nil nil (sigma_shift_T2 subtype "(number_fields.+)(sigma.low, sigma.z)" "T_low"))) (sigma_shift_T2_TCC2 0 (sigma_shift_T2_TCC2-2 "" 3790088464 ("" (skosimp*) nil nil) nil shostak (sigma_shift_T2 subtype "(number_fields.+)(sigma.high, sigma.z)" "T_high")) (sigma_shift_T2_TCC2-1 nil 3352113941 ("" (skosimp*) (("" (inst + "high!1+z!1") (("" (assert) nil nil)) nil)) nil) nil nil (sigma_shift_T2 subtype "(number_fields.+)(sigma.high, sigma.z)" "T_high"))) (sigma_shift_T2 0 (sigma_shift_T2-1 nil 3304414785 ("" (skolem 1 ("F" _ _ "z")) (("" (rewrite "high_low_rewrite") (("1" (hide 2) (("1" (skosimp*) (("1" (prop) (("1" (expand "sigma") (("1" (assert) nil nil)) nil) ("2" (induct "n" 2) (("1" (flatten) (("1" (rewrite "sigma_eq_arg") (("1" (rewrite "sigma_eq_arg") (("1" (assert) nil nil) ("2" (hide -1 -2 2) (("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (expand "sigma" +) (("2" (assert) (("2" (prop) (("2" (hide -1 2) (("2" (lemma "connected_domain") (("2" (inst?) (("2" (inst - "low!1+z" "1+k!1+z") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skosimp* t) (("3" (typepred "high!1") (("3" (inst + "high!1") (("3" (assert) (("3" (skosimp*) (("3" (assert) (("3" (use "T_pred_lem") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (skosimp*) nil nil)) nil) ("5" (hide-all-but 1) (("5" (skosimp*) nil nil)) nil) ("6" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) nil nil)) nil) ("3" (hide 2) (("3" (skosimp*) nil nil)) nil)) nil)) nil) ((int_plus_int_is_int application-judgement "int" integers nil) (high_low_rewrite formula-decl nil sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (sigma def-decl "real" sigma nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (low!1 skolem-const-decl "T_low" sigma nil) (high!1 skolem-const-decl "T_high" sigma nil) (subrange type-eq-decl nil integers nil) (z skolem-const-decl "int" sigma nil) (subrange_induction formula-decl nil subrange_inductions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (>= const-decl "bool" reals nil) (sigma_eq_arg formula-decl nil sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (T_pred_lem formula-decl nil sigma nil) (real_plus_real_is_real application-judgement "real" reals nil) (integer nonempty-type-from-decl nil integers nil) (connected_domain formula-decl nil sigma nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (sigma_sum 0 (sigma_sum-1 nil 3255975799 ("" (skolem 1 ("F" "G" _ _)) (("" (rewrite "high_low_rewrite") (("" (hide 2) (("" (skosimp*) (("" (prop) (("1" (expand "sigma") (("1" (assert) nil nil)) nil) ("2" (induct "n" 2) (("1" (rewrite "sigma_eq_arg") (("1" (rewrite "sigma_eq_arg") (("1" (rewrite "sigma_eq_arg") nil nil)) nil) ("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (expand "sigma" +) (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skosimp* t) (("3" (typepred "high!1") (("3" (inst + "high!1") (("3" (assert) (("3" (skosimp*) (("3" (use "T_pred_lem") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_plus_real_is_real application-judgement "real" reals nil) (high_low_rewrite formula-decl nil sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (pred type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (sigma def-decl "real" sigma nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (low!1 skolem-const-decl "T_low" sigma nil) (high!1 skolem-const-decl "T_high" sigma nil) (subrange type-eq-decl nil integers nil) (subrange_induction formula-decl nil subrange_inductions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (>= const-decl "bool" reals nil) (T_pred_lem formula-decl nil sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (sigma_eq_arg formula-decl nil sigma nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (sigma_minus 0 (sigma_minus-1 nil 3255975799 ("" (skolem 1 ("F" "G" _ _)) (("" (rewrite "high_low_rewrite") (("" (hide 2) (("" (skosimp*) (("" (prop) (("1" (expand "sigma") (("1" (assert) nil nil)) nil) ("2" (induct "n" 2) (("1" (rewrite "sigma_eq_arg") (("1" (rewrite "sigma_eq_arg") (("1" (rewrite "sigma_eq_arg") nil nil)) nil) ("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (expand "sigma" +) (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skosimp* t) (("3" (typepred "high!1") (("3" (inst + "high!1") (("3" (assert) (("3" (skosimp*) (("3" (use "T_pred_lem") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_minus_real_is_real application-judgement "real" reals nil) (high_low_rewrite formula-decl nil sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (pred type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (sigma def-decl "real" sigma nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (low!1 skolem-const-decl "T_low" sigma nil) (high!1 skolem-const-decl "T_high" sigma nil) (subrange type-eq-decl nil integers nil) (subrange_induction formula-decl nil subrange_inductions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (>= const-decl "bool" reals nil) (T_pred_lem formula-decl nil sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (sigma_eq_arg formula-decl nil sigma nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (sigma_abs_bnd 0 (sigma_abs_bnd-2 "" 3790088466 ("" (skolem 1 ("F" "G" _ _)) (("" (rewrite "high_low_rewrite") (("1" (hide 2) (("1" (skosimp*) (("1" (prop) (("1" (expand "sigma") (("1" (assert) nil nil)) nil) ("2" (induct "n" 2) (("1" (flatten) (("1" (rewrite "sigma_eq_arg") (("1" (rewrite "sigma_eq_arg") (("1" (inst?) nil nil)) nil) ("2" (hide -1 2) (("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (expand "sigma" +) (("2" (prop) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skosimp* t) (("3" (typepred "high!1") (("3" (inst + "high!1") (("3" (assert) (("3" (skosimp*) (("3" (use "T_pred_lem") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (skosimp* t) (("4" (hide -1 -2) (("4" (use "T_pred_lem") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp* t) (("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((high_low_rewrite formula-decl nil sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (sigma def-decl "real" sigma nil) (low!1 skolem-const-decl "T_low" sigma nil) (high!1 skolem-const-decl "T_high" sigma nil) (F skolem-const-decl "[T -> real]" sigma nil) (G skolem-const-decl "[T -> real]" sigma nil) (subrange_induction formula-decl nil subrange_inductions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sigma_eq_arg formula-decl nil sigma nil) (T_pred_lem formula-decl nil sigma nil) (real_plus_real_is_real application-judgement "real" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak) (sigma_abs_bnd-1 nil 3255975799 ("" (skolem 1 ("F" "G" _ _)) (("" (rewrite "high_low_rewrite") (("1" (hide 2) (("1" (skosimp*) (("1" (prop) (("1" (expand "sigma") (("1" (assert) nil nil)) nil) ("2" (induct "n" 2) (("1" (flatten) (("1" (rewrite "sigma_eq_arg") (("1" (rewrite "sigma_eq_arg") (("1" (inst?) nil nil)) nil) ("2" (hide -1 2) (("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (expand "sigma" +) (("2" (prop) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skosimp* t) (("3" (typepred "high!1") (("3" (inst + "high!1") (("3" (assert) (("3" (skosimp*) (("3" (use "T_pred_lem") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (skosimp* t) (("4" (hide -1 -2) (("4" (use "T_pred_lem") (("1" (assert) nil nil) ("2" (lemma "T_pred_lem") (("2" (inst?) (("2" (inst - "high!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp* t) (("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) nil nil)) (sigma_restrict 0 (sigma_restrict-2 "" 3790088467 ("" (skolem 1 ("F" "h" _ "l" _)) (("" (rewrite "high_low_rewrite") (("" (hide 2) (("" (skosimp*) (("" (prop) (("1" (expand "sigma") (("1" (assert) nil nil)) nil) ("2" (induct "n" 2) (("1" (rewrite "sigma_eq_arg") (("1" (rewrite "sigma_eq_arg") (("1" (expand "restrict") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (expand "sigma" +) (("2" (rewrite "restrict") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (inst + "h") (("3" (assert) nil nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((high_low_rewrite formula-decl nil sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (sigma def-decl "real" sigma nil) (restrict const-decl "[T -> real]" sigma nil) (low!1 skolem-const-decl "T_low" sigma nil) (high!1 skolem-const-decl "T_high" sigma nil) (subrange type-eq-decl nil integers nil) (l skolem-const-decl "T" sigma nil) (h skolem-const-decl "T" sigma nil) (subrange_induction formula-decl nil subrange_inductions nil) (T_pred_lem formula-decl nil sigma nil) (sigma_eq_arg formula-decl nil sigma nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak) (sigma_restrict-1 nil 3255975799 ("" (skolem 1 ("F" "h" _ "l" _)) (("" (rewrite "high_low_rewrite") (("1" (hide 2) (("1" (skosimp*) (("1" (prop) (("1" (expand "sigma") (("1" (assert) nil nil)) nil) ("2" (induct "n" 2) (("1" (rewrite "sigma_eq_arg") (("1" (rewrite "sigma_eq_arg") (("1" (expand "restrict") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (expand "sigma" +) (("2" (rewrite "restrict") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (inst + "h") (("3" (assert) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (inst + "l") (("4" (assert) nil nil)) nil)) nil) ("5" (hide-all-but 1) (("5" (skosimp* t) (("5" (hide -3 -4) (("5" (inst + "n!2") (("1" (assert) nil nil) ("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (inst + "h") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (inst + "l") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) nil nil)) (sigma_restrict_to 0 (sigma_restrict_to-1 nil 3255975799 ("" (skosimp*) (("" (case "high!1 < low!1") (("1" (expand "sigma") (("1" (assert) nil nil)) nil) ("2" (rewrite "sigma_restrict") (("1" (use "T_pred_lem") (("1" (assert) nil nil)) nil) ("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma def-decl "real" sigma nil) (T_pred_lem formula-decl nil sigma nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (sigma_restrict formula-decl nil sigma nil)) nil)) (sigma_restrict_eq 0 (sigma_restrict_eq-1 nil 3255975799 ("" (skosimp*) (("" (case "high!1 < low!1") (("1" (expand "sigma") (("1" (assert) nil nil)) nil) ("2" (lemma "sigma_restrict") (("2" (inst?) (("2" (inst -1 "high!1" "low!1") (("1" (assert) (("1" (replace*) (("1" (hide -1 -2) (("1" (lemma "sigma_restrict") (("1" (inst -1 "G!1" "high!1" "high!1" "low!1" "low!1") (("1" (assert) nil nil) ("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil) ("3" (use "T_pred_lem") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil) ("3" (use "T_pred_lem") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma def-decl "real" sigma nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (T_pred_lem formula-decl nil sigma nil) (low!1 skolem-const-decl "T_low" sigma nil) (high!1 skolem-const-decl "T_high" sigma nil) (sigma_restrict formula-decl nil sigma nil)) nil)) (sigma_shift_fun_eq_TCC1 0 (sigma_shift_fun_eq_TCC1-1 nil 3500813619 ("" (skeep) (("" (skosimp*) (("" (typepred "low1") (("" (typepred "high1") (("" (case "(EXISTS (j: T): high1 <= j) AND (EXISTS (j: T): j <= low1)") (("1" (hide -2) (("1" (hide -2) (("1" (flatten) (("1" (skosimp*) (("1" (lemma "connected_domain") (("1" (inst - "j!2" "j!1" "low1+i!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split +) (("1" (split -1) (("1" (inst + "high1") (("1" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil) ("2" (split -2) (("1" (inst + "low1") (("1" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T_high type-eq-decl nil sigma nil) (high1 skolem-const-decl "T_high" sigma nil) (low1 skolem-const-decl "T_low" sigma nil) (connected_domain formula-decl nil sigma nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (integer nonempty-type-from-decl nil integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_low type-eq-decl nil sigma nil)) nil (sigma_shift_fun_eq subtype "(number_fields.+)(sigma.low1, sigma.i)" "T"))) (sigma_shift_fun_eq_TCC2 0 (sigma_shift_fun_eq_TCC2-1 nil 3500813619 ("" (skeep) (("" (skosimp*) (("" (typepred "low2") (("" (typepred "high2") (("" (case "(EXISTS (j: T): high2 <= j)
AND (EXISTS (j: T): j <= low2)") (("1" (hide -2) (("1" (hide -2) (("1" (flatten) (("1" (skosimp*) (("1" (lemma "connected_domain") (("1" (inst - "j!2" "j!1" "low2+i!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split +) (("1" (split -1) (("1" (inst + "high2") (("1" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil) ("2" (split -2) (("1" (inst + "low2") (("1" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T_high type-eq-decl nil sigma nil) (high2 skolem-const-decl "T_high" sigma nil) (low2 skolem-const-decl "T_low" sigma nil) (connected_domain formula-decl nil sigma nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (integer nonempty-type-from-decl nil integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_low type-eq-decl nil sigma nil)) nil (sigma_shift_fun_eq subtype "(number_fields.+)(sigma.low2, sigma.i)" "T"))) (sigma_shift_fun_eq 0 (sigma_shift_fun_eq-1 nil 3500813619 ("" (skeep) (("" (case "FORALL (jj:nat): low1+jj<=high1 IMPLIES sigma(low1,low1+jj,F) = sigma(low2,low2+jj,G)") (("1" (inst - "high1-low1") (("1" (assert) nil nil) ("2" (expand "sigma" +) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "jj") (("1" (assert) (("1" (flatten) (("1" (expand "sigma" +) (("1" (expand "sigma" +) (("1" (inst - "0") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (expand "sigma" +) (("2" (replace -1) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (lemma "connected_domain") (("3" (inst - "low2" "high2" "jj+low2") (("1" (assert) nil nil) ("2" (assert) (("2" (typepred "high2") (("2" (ground) (("2" (skosimp*) (("2" (inst + "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "high2") (("3" (ground) (("1" (inst + "high2") (("1" (ground) nil nil)) nil) ("2" (skosimp*) (("2" (inst + "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil) ("5" (hide 2) (("5" (skeep) (("5" (typepred "high1") (("5" (ground) (("1" (inst + "high1") nil nil) ("2" (skosimp*) (("2" (inst + "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (assert) nil nil)) nil)) nil) ("3" (skeep) (("3" (typepred "high2") (("3" (ground) (("1" (inst + "high2") (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (inst + "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (typepred "high1") (("4" (ground) (("1" (inst + "high1") nil nil) ("2" (skosimp*) (("2" (inst + "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sigma def-decl "real" sigma nil) (= const-decl "[T, T -> boolean]" equalities nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (low1 skolem-const-decl "T_low" sigma nil) (high1 skolem-const-decl "T_high" sigma nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (low2 skolem-const-decl "T_low" sigma nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (jj!1 skolem-const-decl "nat" sigma nil) (jj!1 skolem-const-decl "nat" sigma nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (high2 skolem-const-decl "T_high" sigma nil) (integer nonempty-type-from-decl nil integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (connected_domain formula-decl nil sigma nil)) shostak)) (sigma_const_restrict_eq 0 (sigma_const_restrict_eq-1 nil 3497351599 ("" (skeep) (("" (lemma "sigma_restrict_eq") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil) ((sigma_restrict_eq formula-decl nil sigma nil) (real_times_real_is_real application-judgement "real" reals nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (sigma_restrict_eq_0 0 (sigma_restrict_eq_0-1 nil 3491824268 ("" (skeep) (("" (lemma "sigma_restrict_eq") (("" (inst - "F" "(LAMBDA (tt:T): 0)" "high" "low") (("" (lemma "sigma_zero") (("" (inst?) (("" (assert) (("" (expand "restrict") (("" (decompose-equality) (("" (lift-if) (("" (inst - "x!1") (("1" (ground) nil nil) ("2" (assert) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sigma_restrict_eq formula-decl nil sigma nil) (sigma_zero formula-decl nil sigma nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (low skolem-const-decl "T_low" sigma nil) (x!1 skolem-const-decl "T" sigma nil) (high skolem-const-decl "T_high" sigma nil) (subrange type-eq-decl nil integers nil) (restrict const-decl "[T -> real]" sigma nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (sigma_triangle 0 (sigma_triangle-1 nil 3594138610 ("" (case "FORALL (F: [T -> real], high: T_high, low: T_low,k:nat):k<=high-low IMPLIES
               abs(sigma(low, low+k, F)) <=
                sigma(low, low+k, LAMBDA (n: T): abs(F(n)))") (("1" (skeep) (("1" (inst - "F" "high" "low" "high-low") (("1" (assert) nil nil) ("2" (assert) (("2" (expand "sigma" +) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "k") (("1" (skeep) (("1" (assert) (("1" (expand "sigma" +) (("1" (expand "sigma" +) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (inst - "F" "high" "low") (("2" (assert) (("2" (expand "sigma" +) (("2" (expand "abs") (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (assert) (("3" (typepred "high") (("3" (typepred "low") (("3" (lemma "connected_domain") (("3" (ground) (("1" (inst - "low" "high" "low+k") (("1" (assert) nil nil)) nil) ("2" (skeep -1) (("2" (inst - "low" "j" "k+low") (("2" (assert) nil nil)) nil)) nil) ("3" (skeep -) (("3" (inst - "j" "high" "k+low") (("3" (assert) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (inst - "j!2" "j!1" "k+low") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (assert) (("3" (typepred "high") (("3" (typepred "low") (("3" (lemma "connected_domain") (("3" (ground) (("1" (inst - "low" "high" "low+k") (("1" (assert) nil nil)) nil) ("2" (skeep -1) (("2" (inst - "low" "j" "k+low") (("2" (assert) nil nil)) nil)) nil) ("3" (skeep -) (("3" (inst - "j" "high" "k+low") (("3" (assert) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (inst - "j!2" "j!1" "k+low") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((integer nonempty-type-from-decl nil integers nil) (connected_domain formula-decl nil sigma nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (low skolem-const-decl "T_low" sigma nil) (high skolem-const-decl "T_high" sigma nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (sigma def-decl "real" sigma nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)) shostak)) (sigma_eq_one_arg_TCC1 0 (sigma_eq_one_arg_TCC1-1 nil 3497780826 ("" (skeep) (("" (typepred "high") (("" (typepred "low") (("" (case "(EXISTS (j: T): j <= low)
AND (EXISTS (j: T): high <= j)") (("1" (hide -2) (("1" (hide -2) (("1" (flatten) (("1" (skosimp*) (("1" (lemma "connected_domain") (("1" (inst - "j!1" "j!2" "i!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) (("1" (split -) (("1" (inst + "low") (("1" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (hide -1) (("2" (split -) (("1" (inst + "high") (("1" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (integer nonempty-type-from-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (connected_domain formula-decl nil sigma nil) (high skolem-const-decl "T_high" sigma nil) (low skolem-const-decl "T_low" sigma nil) (T_low type-eq-decl nil sigma nil)) nil (sigma_eq_one_arg subtype "sigma.i" "T"))) (sigma_eq_one_arg_TCC2 0 (sigma_eq_one_arg_TCC2-3 "" 3803790293 ("" (skeep) (("" (typepred "high") (("" (typepred "low") (("" (case "(EXISTS (j: T): j <= low)
                      AND (EXISTS (j: T): high <= j)") (("1" (hide -2) (("1" (hide -2) (("1" (flatten) (("1" (skosimp*) (("1" (lemma "connected_domain") (("1" (inst - "j!1" "j!2" "i!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) (("1" (split -) (("1" (inst + "low") (("1" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (hide -1) (("2" (split -) (("1" (inst + "high") (("1" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (sigma_eq_one_arg subtype "sigma.i" "T")) (sigma_eq_one_arg_TCC2-2 nil 3497781196 ("" (skeep) (("" (typepred "high") (("" (typepred "low") (("" (case "(EXISTS (j: T): j <= low)
               AND (EXISTS (j: T): high <= j)") (("1" (hide -2) (("1" (hide -2) (("1" (flatten) (("1" (skosimp*) (("1" (lemma "connected_domain") (("1" (inst - "j!1" "j!2" "i1!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) (("1" (split -) (("1" (inst + "low") (("1" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (hide -1) (("2" (split -) (("1" (inst + "high") (("1" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (integer nonempty-type-from-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (connected_domain formula-decl nil sigma nil) (high skolem-const-decl "T_high" sigma nil) (low skolem-const-decl "T_low" sigma nil) (T_low type-eq-decl nil sigma nil)) nil (sigma_eq_one_arg subtype "sigma.i" "T")) (sigma_eq_one_arg_TCC2-1 nil 3497780826 ("" (subtype-tcc) nil nil) nil nil (sigma_eq_one_arg subtype "sigma.i" "T"))) (sigma_eq_one_arg_TCC3 0 (sigma_eq_one_arg_TCC3-3 nil 3497781273 ("" (skeep) (("" (typepred "high") (("" (typepred "low") (("" (case "(EXISTS (j: T): j <= low)
                             AND (EXISTS (j: T): high <= j)") (("1" (hide -2) (("1" (hide -2) (("1" (flatten) (("1" (skosimp*) (("1" (lemma "connected_domain") (("1" (inst - "j!1" "j!2" "z") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) (("1" (split -) (("1" (inst + "low") (("1" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (hide -1) (("2" (split -) (("1" (inst + "high") (("1" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (integer nonempty-type-from-decl nil integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (connected_domain formula-decl nil sigma nil) (high skolem-const-decl "T_high" sigma nil) (low skolem-const-decl "T_low" sigma nil) (T_low type-eq-decl nil sigma nil)) nil (sigma_eq_one_arg subtype "sigma.z" "T")) (sigma_eq_one_arg_TCC3-2 nil 3497781249 (";;; Proof sigma_eq_one_arg_TCC2-2 for formula sigma.sigma_eq_one_arg_TCC2" (skeep) ((";;; Proof sigma_eq_one_arg_TCC2-2 for formula sigma.sigma_eq_one_arg_TCC2" (typepred "high") ((";;; Proof sigma_eq_one_arg_TCC2-2 for formula sigma.sigma_eq_one_arg_TCC2" (typepred "low") ((";;; Proof sigma_eq_one_arg_TCC2-2 for formula sigma.sigma_eq_one_arg_TCC2" (case "(EXISTS (j: T): j <= low)
               AND (EXISTS (j: T): high <= j)") (("1" (hide -2) (("1" (hide -2) (("1" (flatten) (("1" (skosimp*) (("1" (lemma "connected_domain") (("1" (inst - "j!1" "j!2" "i1!1") (("1" (assert) nil))))))))))))) ("2" (split) (("1" (assert) (("1" (split -) (("1" (inst + "low") (("1" (assert) nil))) ("2" (propax) nil))))) ("2" (hide -1) (("2" (split -) (("1" (inst + "high") (("1" (assert) nil))) ("2" (propax) nil)))))))))))))) ";;; developed with shostak decision procedures") nil nil (sigma_eq_one_arg subtype "sigma.z" "T")) (sigma_eq_one_arg_TCC3-1 nil 3497780826 ("" (subtype-tcc) nil nil) nil nil (sigma_eq_one_arg subtype "sigma.z" "T"))) (sigma_eq_one_arg 0 (sigma_eq_one_arg-1 nil 3497780826 ("" (skeep) (("" (lemma "sigma_split") (("" (inst - "F" "high" "low" "z") (("" (assert) (("" (replace -1 +) (("" (hide -1) (("" (lemma "sigma_split") (("" (inst - "F" "z" "low" "z-1") (("" (assert) (("" (replace -1) (("" (hide -1) (("" (case "sigma(1+z,high,F) = 0") (("1" (replace -1) (("1" (case "sigma(low,z-1,F) = 0") (("1" (replace -1) (("1" (expand "sigma" +) (("1" (expand "sigma" +) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (rewrite "sigma_restrict_eq_0") nil nil)) nil)) nil) ("2" (rewrite "sigma_restrict_eq_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sigma_split formula-decl nil sigma nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (sigma def-decl "real" sigma nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (sigma_restrict_eq_0 formula-decl nil sigma nil) (real_plus_real_is_real application-judgement "real" reals nil) (int_plus_int_is_int application-judgement "int" integers nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (sigma_eq_one_arg2_TCC1 0 (sigma_eq_one_arg2_TCC1-1 nil 3615045476 ("" (skeep) (("" (lemma "connected_domain") (("" (typepred "low") (("" (typepred "high") (("" (ground) (("1" (inst - "low" "high" "z") (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (inst - "j!1" "high" "z") (("2" (assert) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (inst - "low" "j!1" "z") (("3" (assert) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (inst - "j!1" "j!2" "z") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((connected_domain formula-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (integer nonempty-type-from-decl nil integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_low type-eq-decl nil sigma nil)) nil (sigma_eq_one_arg2 subtype "sigma.z" "T"))) (sigma_eq_one_arg2 0 (sigma_eq_one_arg2-1 nil 3615045478 ("" (skeep) (("" (lemma "sigma_eq_one_arg") (("" (inst?) (("" (assert) (("" (split) (("1" (skosimp*) (("1" (inst - "i!1") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (inst - "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sigma_eq_one_arg formula-decl nil sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (subrange type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (sigma_eq_two_args_TCC1 0 (sigma_eq_two_args_TCC1-4 nil 3615045724 ("" (skeep) (("" (lemma "connected_domain") (("" (typepred "low") (("" (typepred "high") (("" (ground) (("1" (inst - "low" "high" "z1") (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (inst - "j!1" "high" "z1") (("2" (assert) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (inst - "low" "j!1" "z1") (("3" (assert) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (inst - "j!1" "j!2" "z1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((connected_domain formula-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (integer nonempty-type-from-decl nil integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_low type-eq-decl nil sigma nil)) nil (sigma_eq_two_args subtype "sigma.z1" "T")) (sigma_eq_two_args_TCC1-3 nil 3615045684 ("" (skeep) (("" (skosimp*) (("" (lemma "connected_domain") (("" (typepred "low") (("" (typepred "high") (("" (ground) (("1" (inst - "low" "high" "z2") (("1" (assert) nil))) ("2" (skosimp*) (("2" (inst - "j!1" "high" "z2") (("2" (assert) nil))))) ("3" (skosimp*) (("3" (inst - "low" "j!1" "z2") (("3" (assert) nil))))) ("4" (skosimp*) (("4" (inst - "j!1" "j!2" "z2") (("4" (assert) nil)))))))))))))))) nil) nil nil (sigma_eq_two_args subtype "sigma.z1" "T")) (sigma_eq_two_args_TCC1-2 nil 3615045631 ("" (skeep) (("" (lemma "connected_domain") (("" (typepred "low") (("" (typepred "high") (("" (ground) (("1" (inst - "low" "high" "z1") (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (inst - "j!1" "high" "z1") (("2" (assert) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (inst - "low" "j!1" "z1") (("3" (assert) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (inst - "j!1" "j!2" "z1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (sigma_eq_two_args subtype "sigma.z1" "T")) (sigma_eq_two_args_TCC1-1 nil 3615043942 ("" (subtype-tcc) nil nil) nil nil (sigma_eq_two_args subtype "sigma.z1" "T"))) (sigma_eq_two_args_TCC2 0 (sigma_eq_two_args_TCC2-3 nil 3615045702 ("" (skeep) (("" (lemma "connected_domain") (("" (typepred "low") (("" (typepred "high") (("" (ground) (("1" (inst - "low" "high" "z2") (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (inst - "j!1" "high" "z2") (("2" (assert) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (inst - "low" "j!1" "z2") (("3" (assert) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (inst - "j!1" "j!2" "z2") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((connected_domain formula-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (integer nonempty-type-from-decl nil integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_low type-eq-decl nil sigma nil)) nil (sigma_eq_two_args subtype "sigma.z2" "T")) (sigma_eq_two_args_TCC2-2 nil 3615045619 ("" (skeep) (("" (skosimp*) (("" (lemma "connected_domain") (("" (typepred "low") (("" (typepred "high") (("" (ground) (("1" (inst - "low" "high" "z") (("1" (assert) nil))) ("2" (skosimp*) (("2" (inst - "j!1" "high" "z") (("2" (assert) nil))))) ("3" (skosimp*) (("3" (inst - "low" "j!1" "z") (("3" (assert) nil))))) ("4" (skosimp*) (("4" (inst - "j!1" "j!2" "z") (("4" (assert) nil)))))))))))))))) nil) nil nil (sigma_eq_two_args subtype "sigma.z2" "T")) (sigma_eq_two_args_TCC2-1 nil 3615043942 ("" (subtype-tcc) nil nil) nil nil (sigma_eq_two_args subtype "sigma.z2" "T"))) (sigma_eq_two_args 0 (sigma_eq_two_args-1 nil 3615043943 ("" (case "FORALL (F: [T -> real], high: T_high, low: T_low, z1, z2: int):
        (     low <= z1 AND z1 <= high AND low <= z2 AND z2 <= high
          AND z1 < z2
          AND FORALL (i: subrange(low, high)):
                i /= z1 AND i /= z2 IMPLIES F(i) = 0)
         IMPLIES sigma(low, high, F) = F(z1) + F(z2)") (("1" (skeep) (("1" (case "z1 < z2") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (inst - "F" "high" "low" "z2" "z1") (("2" (assert) (("2" (skosimp*) (("2" (inst - "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (lemma "sigma_split") (("2" (inst - "F" "high" "low" "z1") (("2" (assert) (("2" (replaces -1) (("2" (expand "sigma" + 2) (("2" (lemma "sigma_split") (("2" (inst - "F" "high" "1+z1" "z2") (("2" (assert) (("2" (replaces -1) (("2" (expand "sigma" + 1) (("2" (assert) (("2" (rewrite "sigma_restrict_eq_0") (("1" (rewrite "sigma_restrict_eq_0") (("1" (rewrite "sigma_restrict_eq_0") (("1" (skosimp*) (("1" (inst - "i!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst - "i!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst - "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (lemma "connected_domain") (("3" (typepred "high") (("3" (typepred "low") (("3" (ground) (("1" (inst - "low" "high" "z2") (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (inst - "low" "j!1" "z2") (("2" (ground) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (inst - "j!1" "high" "z2") (("3" (assert) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (inst - "j!2" "j!1" "z2") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (lemma "connected_domain") (("4" (typepred "low") (("4" (typepred "high") (("4" (ground) (("1" (inst - "low" "high" "z1") (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (inst - "j!1" "high" "z1") (("2" (assert) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (inst - "low" "j!1" "z1") (("3" (assert) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (inst - "j!1" "j!2" "z1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (lemma "connected_domain") (("5" (typepred "low") (("5" (typepred "high") (("5" (skosimp*) (("5" (ground) (("1" (inst - "low" "high" "i!1") (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (inst - "j!1" "high" "i!1") (("2" (assert) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (inst - "low" "j!1" "i!1") (("3" (assert) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (inst - "j!1" "j!2" "i!1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((connected_domain formula-decl nil sigma nil) (integer nonempty-type-from-decl nil integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (sigma_split formula-decl nil sigma nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (sigma_restrict_eq_0 formula-decl nil sigma nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (subrange type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (= const-decl "[T, T -> boolean]" equalities nil) (sigma def-decl "real" sigma nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)) shostak)) (sigma_const_restrict_eq_0 0 (sigma_const_restrict_eq_0-1 nil 3497351634 ("" (skeep) (("" (lemma "sigma_restrict_eq_0") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil) ((sigma_restrict_eq_0 formula-decl nil sigma nil) (real_times_real_is_real application-judgement "real" reals nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (sigma_eq 0 (sigma_eq-1 nil 3255975799 ("" (skosimp*) (("" (lemma "sigma_restrict_eq") (("" (inst?) (("" (assert) (("" (hide 2) (("" (expand "restrict") (("" (apply-extensionality 1 :hide? t) (("" (lift-if) (("" (ground) (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sigma_restrict_eq formula-decl nil sigma nil) (restrict const-decl "[T -> real]" sigma nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (sigma_le 0 (sigma_le-1 nil 3255975799 ("" (skosimp*) (("" (lemma "sigma_ge_0") (("" (inst -1 "(LAMBDA (t:T): G!1(t) - F!1(t))" "high!1" "low!1") (("" (split -1) (("1" (assert) (("1" (lemma "sigma_minus") (("1" (inst?) (("1" (replace -1 * rl) (("1" (hide -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sigma_ge_0 formula-decl nil sigma nil) (sigma_minus formula-decl nil sigma nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (subrange type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil)) (sigma_lt 0 (sigma_lt-1 nil 3255975799 ("" (skosimp*) (("" (lemma "sigma_gt_0") (("" (inst -1 "(LAMBDA (t:T): G!1(t) - F!1(t))" "high!1" "low!1") (("" (split -1) (("1" (assert) (("1" (lemma "sigma_minus") (("1" (inst?) (("1" (replace -1 * rl) (("1" (hide -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (skosimp*) (("3" (assert) (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sigma_gt_0 formula-decl nil sigma nil) (sigma_minus formula-decl nil sigma nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil)) (sigma_ge 0 (sigma_ge-1 nil 3492506755 ("" (skeep) (("" (lemma "sigma_le") (("" (inst - "G" "F" "high" "low") (("" (assert) nil nil)) nil)) nil)) nil) ((sigma_le formula-decl nil sigma nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (sigma_gt 0 (sigma_gt-1 nil 3492506775 ("" (skeep) (("" (lemma "sigma_lt") (("" (inst - "G" "F" "high" "low") (("" (assert) nil nil)) nil)) nil)) nil) ((sigma_lt formula-decl nil sigma nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (sigma_with 0 (sigma_with-2 "" 3790088472 ("" (skosimp*) (("" (case "i!1 = low!1") (("1" (rewrite "sigma_first") (("1" (lemma "sigma_first") (("1" (inst -1 "G!1" "high!1" "low!1") (("1" (assert) (("1" (assert) (("1" (replace -1) (("1" (replace -5) (("1" (hide -1 -5) (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (rewrite "sigma_eq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "i!1 = high!1") (("1" (rewrite "sigma_last") (("1" (lemma "sigma_last") (("1" (inst -1 "G!1" "high!1" "low!1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (replace -4) (("1" (assert) (("1" (rewrite "sigma_eq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst?) (("2" (inst -1 "i!1") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (lemma "sigma_split") (("2" (inst -1 "G!1" "high!1" "low!1" "i!1") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (lemma "sigma_last") (("2" (inst-cp -1 "F!1" "i!1" "low!1") (("2" (inst -1 "G!1" "i!1" "low!1") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (replace -1) (("2" (hide -1) (("2" (replace -3) (("2" (hide -3) (("2" (ground) (("2" (case-replace "sigma(low!1, i!1 - 1, G!1 WITH [i!1 := a!1]) = sigma(low!1, i!1 - 1, G!1)") (("1" (hide -1) (("1" (assert) (("1" (rewrite "sigma_eq") nil nil)) nil)) nil) ("2" (hide 4) (("2" (rewrite "sigma_eq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T_low type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (sigma_eq formula-decl nil sigma nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (T_high type-eq-decl nil sigma nil) (sigma_first formula-decl nil sigma nil) (sigma_split formula-decl nil sigma nil) (sigma def-decl "real" sigma nil) (sigma_last formula-decl nil sigma nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil)) shostak) (sigma_with-1 nil 3255975799 ("" (skosimp*) (("" (case "i!1 = low!1") (("1" (rewrite "sigma_first") (("1" (lemma "sigma_first") (("1" (inst -1 "G!1" "high!1" "low!1") (("1" (assert) (("1" (split -1) (("1" (assert) (("1" (replace -1) (("1" (replace -5) (("1" (hide -1 -5) (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (rewrite "sigma_eq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "sigma") (("2" (assert) (("2" (expand "sigma") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "sigma") (("2" (assert) (("2" (expand "sigma") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case-replace "i!1 = high!1") (("1" (rewrite "sigma_last") (("1" (lemma "sigma_last") (("1" (inst -1 "G!1" "high!1" "low!1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (replace -4) (("1" (assert) (("1" (rewrite "sigma_eq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst?) (("2" (inst -1 "i!1") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (lemma "sigma_split") (("2" (inst -1 "G!1" "high!1" "low!1" "i!1") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (lemma "sigma_last") (("2" (inst-cp -1 "F!1" "i!1" "low!1") (("2" (inst -1 "G!1" "i!1" "low!1") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (replace -1) (("2" (hide -1) (("2" (replace -3) (("2" (hide -3) (("2" (ground) (("2" (case-replace "sigma(low!1, i!1 - 1, G!1 WITH [i!1 := a!1]) = sigma(low!1, i!1 - 1, G!1)") (("1" (hide -1) (("1" (assert) (("1" (rewrite "sigma_eq") nil nil)) nil)) nil) ("2" (hide 4) (("2" (rewrite "sigma_eq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil)) (sigma_le_scal_TCC1 0 (sigma_le_scal_TCC1-1 nil 3496049375 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil)) nil (sigma_le_scal subtype "((number_fields.+)((number_fields.-)(sigma.high, sigma.low), 1))" "nznum"))) (sigma_le_scal 0 (sigma_le_scal-1 nil 3496049376 ("" (skeep) (("" (lemma "sigma_le") (("" (inst - "F" "LAMBDA (i:T): B/(high-low+1)" "high" "low") (("1" (split -) (("1" (case "FORALL (i:nat): i<= high-low IMPLIES sigma(low,low+i,LAMBDA (i:T):B/(high-low+1)) = (i+1)*B/(high-low+1)") (("1" (inst - "high-low") (("1" (case "(high-low+1)*B/(high-low+1) = B") (("1" (assert) nil nil) ("2" (field) nil nil) ("3" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (induct "i") (("1" (assert) (("1" (expand "sigma" +) (("1" (expand "sigma" +) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "sigma" +) (("2" (assert) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil) ("6" (assert) nil nil) ("7" (assert) nil nil) ("8" (assert) nil nil) ("9" (assert) nil nil) ("10" (assert) nil nil) ("11" (skosimp*) (("11" (lemma "T_pred_lem") (("11" (inst - "high" "low" "i!2 + low") (("11" (assert) nil nil)) nil)) nil)) nil) ("12" (skosimp*) (("12" (lemma "T_pred_lem") (("12" (inst - "high" "low" "i!2 + low") (("12" (assert) nil nil)) nil)) nil)) nil) ("13" (skosimp*) (("13" (lemma "T_pred_lem") (("13" (inst - "high" "low" "i!2 + low") (("13" (assert) nil nil)) nil)) nil)) nil) ("14" (skosimp*) (("14" (lemma "T_pred_lem") (("14" (inst - "high" "low" "i!2 + low") (("14" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (lemma "T_pred_lem") (("5" (inst - "high" "low" "i!1 + low") (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst - "n!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((sigma_le formula-decl nil sigma nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (i!1 skolem-const-decl "nat" sigma nil) (i!1 skolem-const-decl "nat" sigma nil) (i!1 skolem-const-decl "nat" sigma nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (T_pred_lem formula-decl nil sigma nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (sigma def-decl "real" sigma nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (subrange type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_low type-eq-decl nil sigma nil) (low skolem-const-decl "T_low" sigma nil) (T_high type-eq-decl nil sigma nil) (high skolem-const-decl "T_high" sigma nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)) (sigma_downwards_TCC1 0 (sigma_downwards_TCC1-1 nil 3766165883 ("" (skeep :preds? t) (("" (lemma "T_pred_lem") (("" (inst -1 "high" "low" "low+k") (("" (assert) nil nil)) nil)) nil)) nil) ((T_pred_lem formula-decl nil sigma nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_plus_int_is_int application-judgement "int" integers nil)) nil (sigma_downwards subtype "(number_fields.+)(sigma.low, sigma.k)" "T_high"))) (sigma_downwards_TCC2 0 (sigma_downwards_TCC2-1 nil 3766165883 ("" (skeep) (("" (lemma "T_pred_lem") (("" (inst? -1 :where 1) (("" (inst -1 "high" "low") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((T_pred_lem formula-decl nil sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (T_low type-eq-decl nil sigma nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (sigma_downwards subtype "(number_fields.-)(sigma.high, sigma.k)" "T_low"))) (sigma_downwards_TCC3 0 (sigma_downwards_TCC3-1 nil 3766165883 ("" (skeep) (("" (lemma "T_pred_lem") (("" (inst? -1 :where 1) (("" (inst -1 "high" "low") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((T_pred_lem formula-decl nil sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (T_high type-eq-decl nil sigma nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (T_low type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_plus_int_is_int application-judgement "int" integers nil)) nil (sigma_downwards subtype "(number_fields.+)(sigma.low, ((number_fields.-)(sigma.high, sigma.i)))" "T"))) (sigma_downwards 0 (sigma_downwards-1 nil 3766165888 ("" (skeep :but "k") (("" (induct "k") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (skeep 1 :preds? t) (("2" (assert) (("2" (lemma "sigma_last") (("2" (inst? -1 :where 1) (("2" (assert) (("2" (replace -1 :hide? t) (("2" (lemma "sigma_first") (("2" (inst -1 "LAMBDA (i: T):
               IF -1 - jt + high <= i AND i <= high THEN F(high - i + low)
               ELSE 0
               ENDIF" "high" "-1 - jt + high") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (replace -3 :hide? t) (("1" (assert) (("1" (case "FORALL(low: T_low, high: T_high, F,G: [T->real]): (FORALL (n: subrange(low,high)): F(n) = G(n))
                                IMPLIES sigma(low,high,F) = sigma(low,high,G)") (("1" (inst -1 "high - jt" "high" "LAMBDA (i: T):
              IF high - jt <= i AND i <= high THEN F(high - i + low)
              ELSE 0
              ENDIF" "LAMBDA (i: T):
               IF -1 - jt + high <= i AND i <= high THEN F(high - i + low)
               ELSE 0
               ENDIF") (("1" (split -1) (("1" (propax) nil nil) ("2" (hide 2) (("2" (skeep 1 :preds? t) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep 1 :preds? t) (("2" (hide 2) (("2" (lemma "T_pred_lem") (("2" (inst? -1 :where 1) (("2" (inst -1 "high" "low") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep 1 :preds? t) (("3" (lemma "T_pred_lem") (("3" (inst? -1 :where 1) (("3" (inst -1 "high" "low") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "sigma_eq") (("2" (skeep 1) (("2" (inst? -1 :where 1) (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep 1 :preds? t) (("3" (use "T_pred_lem") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep 1 :preds? t) (("2" (lemma "T_pred_lem") (("2" (inst? -1 :where 1) (("2" (inst -1 "high" "low") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep :preds? t) (("3" (lemma "T_pred_lem") (("3" (inst? -1 :where 1) (("3" (inst -1 "high" "low") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep :preds? t) (("4" (typepred "low") (("4" (split -) (("1" (inst 2 "low") (("1" (assert) nil nil)) nil) ("2" (skeep -1) (("2" (inst 2 "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep :preds? t) (("5" (typepred "high") (("5" (split -1) (("1" (inst 2 "high") (("1" (assert) nil nil)) nil) ("2" (skeep -1) (("2" (inst 2 "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (assert) nil nil)) nil)) nil) ((int_plus_int_is_int application-judgement "int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (low skolem-const-decl "T_low" sigma nil) (high skolem-const-decl "T_high" sigma nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (sigma def-decl "real" sigma nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (upto_induction formula-decl nil bounded_nat_inductions nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (>= const-decl "bool" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (- const-decl "[numfield -> numfield]" number_fields nil) (jt skolem-const-decl "upto(high - low)" sigma nil) (sigma_eq formula-decl nil sigma nil) (T_pred_lem formula-decl nil sigma nil) (subrange type-eq-decl nil integers nil) (sigma_first formula-decl nil sigma nil) (sigma_last formula-decl nil sigma nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak)) (sigma_nonneg 0 (sigma_nonneg-1 nil 3255975799 ("" (skolem 1 ("F" _ _)) (("" (rewrite "high_low_rewrite") (("" (hide 2) (("" (skosimp*) (("" (prop) (("1" (expand "sigma") (("1" (assert) nil nil)) nil) ("2" (induct "n" 2) (("1" (rewrite "sigma_eq_arg") (("1" (skosimp*) (("1" (inst?) nil nil)) nil) ("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (expand "sigma" +) (("2" (prop) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skosimp* t) (("3" (use "T_pred_lem") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((high_low_rewrite formula-decl nil sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (sigma def-decl "real" sigma nil) (F skolem-const-decl "[T -> real]" sigma nil) (subrange type-eq-decl nil integers nil) (high!1 skolem-const-decl "T_high" sigma nil) (low!1 skolem-const-decl "T_low" sigma nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange_induction formula-decl nil subrange_inductions nil) (T_pred_lem formula-decl nil sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (sigma_eq_arg formula-decl nil sigma nil) (real_plus_real_is_real application-judgement "real" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (sigma_nonpos 0 (sigma_nonpos-2 nil 3352253917 ("" (skolem 1 ("F" _ _)) (("" (rewrite "high_low_rewrite") (("" (hide 2) (("" (skosimp*) (("" (prop) (("1" (expand "sigma") (("1" (assert) nil nil)) nil) ("2" (induct "n" 2) (("1" (rewrite "sigma_eq_arg") (("1" (skosimp*) (("1" (inst?) nil nil)) nil) ("2" (hide 2) (("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (expand "sigma" +) (("2" (prop) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skosimp* t) (("3" (use "T_pred_lem") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((high_low_rewrite formula-decl nil sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (sigma def-decl "real" sigma nil) (F skolem-const-decl "[T -> real]" sigma nil) (subrange type-eq-decl nil integers nil) (high!1 skolem-const-decl "T_high" sigma nil) (low!1 skolem-const-decl "T_low" sigma nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange_induction formula-decl nil subrange_inductions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (>= const-decl "bool" reals nil) (T_pred_lem formula-decl nil sigma nil) (sigma_eq_arg formula-decl nil sigma nil) (real_plus_real_is_real application-judgement "real" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil) (sigma_nonpos-1 nil 3255975799 ("" (skosimp*) (("" (case "high!1 < low!1") (("1" (expand "sigma") (("1" (assert) nil nil)) nil) ("2" (case "(FORALL (rng:nat): T_pred(low!1+rng) IMPLIES sigma(low!1,low!1+rng, F!1) <= 0)") (("1" (inst -1 "high!1-low!1") (("1" (assert) (("1" (hide-all-but (1 2)) (("1" (use "T_pred_lem") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide 3) (("2" (induct "rng") (("1" (assert) (("1" (rewrite "sigma_eq_arg") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (split -1) (("1" (expand "sigma" 1) (("1" (assert) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "connected_domain") (("2" (inst -1 "low!1" "1 + j!1 + low!1" "j!1 + low!1") (("1" (assert) nil nil) ("2" (hide-all-but (1 4)) (("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (inst + "low!1 + rng!2") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (inst + "low!1 + rng!2") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (inst + "low!1 + rng!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) nil nil)) (sigma_Fnnr 0 (sigma_Fnnr-2 nil 3411475824 ("" (skosimp*) (("" (rewrite "sigma_nonneg") (("" (skosimp*) (("" (assert) nil nil)) nil)) nil)) nil) ((sigma_nonneg formula-decl nil sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil) (sigma_Fnnr-1 nil 3411475728 ("" (judgement-tcc) nil nil) nil nil)) (sigma_nnreal 0 (sigma_nnreal-2 nil 3501424358 ("" (skosimp*) (("" (rewrite "sigma_nonneg") (("" (skosimp*) (("" (assert) nil nil)) nil)) nil)) nil) ((sigma_nonneg formula-decl nil sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (sigma_nnreal subtype "sigma.sigma(sigma.low, sigma.high, sigma.Fnnr)" "nnreal")) (sigma_nnreal-1 nil 3501424319 ("" (judgement-tcc) nil nil) nil nil (sigma_nnreal subtype "sigma.sigma(sigma.low, sigma.high, sigma.Fnnr)" "nnreal"))) (sigma_nonpos_real 0 (sigma_nonpos_real-1 nil 3411475728 ("" (skosimp*) (("" (rewrite "sigma_nonpos") (("" (skosimp*) (("" (assert) nil nil)) nil)) nil)) nil) ((sigma_nonpos formula-decl nil sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (bool nonempty-type-eq-decl nil booleans nil) (<= const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (sigma_nonpos_real subtype "sigma.sigma(sigma.low, sigma.high, sigma.Fnpr)" "nonpos_real"))) (sigma_nat 0 (sigma_nat-3 nil 3411475912 ("" (auto-rewrite-theory "integers") (("" (auto-rewrite-theory "rationals") (("" (skosimp*) (("" (case "(FORALL (rng: nat): T_pred(low!1+rng) IMPLIES (rational_pred(sigma(low!1, low!1+rng, Fnat!1))             AND integer_pred(sigma(low!1, low!1+rng, Fnat!1)))       AND sigma(low!1, low!1+rng, Fnat!1) >= 0)") (("1" (inst -1 "high!1-low!1") (("1" (assert) (("1" (split -1) (("1" (propax) nil nil) ("2" (use "T_pred_lem") (("2" (assert) (("2" (expand "sigma") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "sigma") (("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "rng") (("1" (skosimp*) (("1" (rewrite "sigma_eq_arg") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "sigma" 1) (("2" (split -1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (lemma "T_pred_lem") (("2" (inst - "low!1+j!1" "low!1" "low!1+j!1") (("1" (assert) nil nil) ("2" (assert) (("2" (inst + "1+j!1+low!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) nil nil) ("4" (skosimp*) nil nil) ("5" (skosimp*) nil nil) ("6" (skosimp*) nil nil) ("7" (skosimp*) nil nil) ("8" (skosimp*) nil nil) ("9" (skosimp*) nil nil) ("10" (skosimp*) nil nil) ("11" (skosimp*) nil nil)) nil)) nil) ("3" (skosimp*) nil nil) ("4" (skosimp*) nil nil) ("5" (skosimp*) nil nil)) nil)) nil)) nil)) nil) ((sigma def-decl "real" sigma nil) (T_high type-eq-decl nil sigma nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T_low type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (T formal-subtype-decl nil sigma nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (T_pred const-decl "[int -> boolean]" sigma nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (sigma_nnreal application-judgement "nnreal" sigma nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (T_pred_lem formula-decl nil sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (low!1 skolem-const-decl "T_low" sigma nil) (high!1 skolem-const-decl "T_high" sigma nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (Fnat!1 skolem-const-decl "[T -> nat]" sigma nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (sigma_eq_arg formula-decl nil sigma nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (j!1 skolem-const-decl "nat" sigma nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (closed_plus formula-decl nil integers nil) (closed_plus formula-decl nil rationals nil)) nil (sigma_nat subtype "sigma.sigma(sigma.low, sigma.high, sigma.Fnat)" "nat")) (sigma_nat-2 nil 3411475883 (";;; Proof for formula sigma.sigma_TCC5" (skosimp*) ((";;; Proof for formula sigma.sigma_TCC5" (rewrite "sigma_nonpos") ((";;; Proof for formula sigma.sigma_TCC5" (skosimp*) ((";;; Proof for formula sigma.sigma_TCC5" (assert) nil)))))) "") nil nil (sigma_nat subtype "sigma.sigma(sigma.low, sigma.high, sigma.Fnat)" "nat")) (sigma_nat-1 nil 3411475728 ("" (judgement-tcc) nil nil) nil nil (sigma_nat subtype "sigma.sigma(sigma.low, sigma.high, sigma.Fnat)" "nat"))) (sigma_nonpos_int 0 (sigma_nonpos_int-3 "" 3790088476 ("" (auto-rewrite-theory "integers") (("" (auto-rewrite-theory "rationals") (("" (skosimp*) (("" (case "low!1<=high!1") (("1" (case "(FORALL (rng: nat): T_pred(low!1+rng) IMPLIES (rational_pred(sigma(low!1, low!1+rng, Fnpi!1))             AND integer_pred(sigma(low!1, low!1+rng, Fnpi!1)))       AND sigma(low!1, low!1+rng, Fnpi!1) <= 0)") (("1" (inst -1 "high!1-low!1") (("1" (assert) (("1" (split -) (("1" (propax) nil nil) ("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "rng" 1) (("1" (rewrite "sigma_eq_arg") (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (expand "sigma" +) (("2" (split -) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (lemma "T_pred_lem") (("2" (inst - "low!1+j!1" "low!1" "low!1+j!1") (("1" (assert) nil nil) ("2" (inst + "1+j!1+low!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) nil nil) ("4" (skosimp*) nil nil) ("5" (skosimp*) nil nil) ("6" (skosimp*) nil nil) ("7" (skosimp*) nil nil) ("8" (skosimp*) nil nil) ("9" (skosimp*) nil nil) ("10" (skosimp*) nil nil) ("11" (skosimp*) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) nil nil)) nil) ("4" (skosimp*) nil nil) ("5" (skosimp*) nil nil)) nil) ("2" (expand "sigma") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (closed_plus formula-decl nil rationals nil) (closed_plus formula-decl nil integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (j!1 skolem-const-decl "nat" sigma nil) (npreal_plus_npreal_is_npreal application-judgement "npreal" real_types nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (sigma_eq_arg formula-decl nil sigma nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (Fnpi!1 skolem-const-decl "[T -> nonpos_int]" sigma nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (high!1 skolem-const-decl "T_high" sigma nil) (low!1 skolem-const-decl "T_low" sigma nil) (T_pred_lem formula-decl nil sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (sigma_nonpos_real application-judgement "nonpos_real" sigma nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (sigma def-decl "real" sigma nil) (nonpos_int nonempty-type-eq-decl nil integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (sigma_nonpos_int subtype "sigma.sigma(sigma.low, sigma.high, sigma.Fnpi)" "nonpos_int")) (sigma_nonpos_int-2 nil 3411475945 ("" (auto-rewrite-theory "integers") (("" (auto-rewrite-theory "rationals") (("" (skosimp*) (("" (case "low!1<=high!1") (("1" (case "(FORALL (rng: nat): T_pred(low!1+rng) IMPLIES (rational_pred(sigma(low!1, low!1+rng, Fnpi!1))             AND integer_pred(sigma(low!1, low!1+rng, Fnpi!1)))       AND sigma(low!1, low!1+rng, Fnpi!1) <= 0)") (("1" (inst -1 "high!1-low!1") (("1" (assert) (("1" (split -) (("1" (propax) nil nil) ("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "rng" 1) (("1" (rewrite "sigma_eq_arg") (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "sigma" +) (("2" (split -) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (lemma "T_pred_lem") (("2" (inst - "low!1+j!1" "low!1" "low!1+j!1") (("1" (assert) nil nil) ("2" (inst + "1+j!1+low!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) nil nil) ("4" (skosimp*) nil nil) ("5" (skosimp*) nil nil) ("6" (skosimp*) nil nil) ("7" (skosimp*) nil nil) ("8" (skosimp*) nil nil) ("9" (skosimp*) nil nil) ("10" (skosimp*) nil nil) ("11" (skosimp*) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) nil nil)) nil) ("4" (skosimp*) nil nil) ("5" (skosimp*) nil nil)) nil) ("2" (expand "sigma") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) nil nil (sigma_nonpos_int subtype "sigma.sigma(sigma.low, sigma.high, sigma.Fnpi)" "nonpos_int")) (sigma_nonpos_int-1 nil 3411475728 ("" (judgement-tcc) nil nil) nil nil (sigma_nonpos_int subtype "sigma.sigma(sigma.low, sigma.high, sigma.Fnpi)" "nonpos_int"))) (sigma_posnat 0 (sigma_posnat-1 nil 3410183521 ("" (skolem 1 ("FF" _ _)) (("" (rewrite "high_low_rewrite") (("" (hide 2) (("" (skosimp*) (("" (prop) (("" (induct "n" 2) (("1" (rewrite "sigma_eq_arg") (("1" (use "T_pred_lem") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (expand "sigma" +) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skosimp* t) (("3" (use "T_pred_lem") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((high_low_rewrite formula-decl nil sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (sigma def-decl "real" sigma nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (low!1 skolem-const-decl "T_low" sigma nil) (high!1 skolem-const-decl "T_high" sigma nil) (subrange type-eq-decl nil integers nil) (subrange_induction formula-decl nil subrange_inductions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (T_pred_lem formula-decl nil sigma nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_nat application-judgement "nat" sigma nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_eq_arg formula-decl nil sigma nil) (int_plus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil)) nil)) (sigma_posreal 0 (sigma_posreal-1 nil 3412514934 ("" (skolem 1 ("FF" _ _)) (("" (rewrite "high_low_rewrite") (("" (hide 2) (("" (skosimp*) (("" (prop) (("" (induct "n" 2) (("1" (rewrite "sigma_eq_arg") (("1" (use "T_pred_lem") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (expand "sigma" +) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skosimp* t) (("3" (use "T_pred_lem") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((high_low_rewrite formula-decl nil sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (sigma def-decl "real" sigma nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (low!1 skolem-const-decl "T_low" sigma nil) (high!1 skolem-const-decl "T_high" sigma nil) (subrange type-eq-decl nil integers nil) (subrange_induction formula-decl nil subrange_inductions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (T_pred_lem formula-decl nil sigma nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_nnreal application-judgement "nnreal" sigma nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_eq_arg formula-decl nil sigma nil) (int_plus_int_is_int application-judgement "int" integers nil) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (NOT const-decl "[bool -> bool]" booleans nil)) nil)) (sigma_nonneg_eq_0 0 (sigma_nonneg_eq_0-1 nil 3255975799 ("" (skosimp*) (("" (lemma "sigma_middle") (("" (inst?) (("" (inst -1 "i!1") (("" (assert) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((sigma_middle formula-decl nil sigma nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (sigma_nnreal application-judgement "nnreal" sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil)) (sigma_nn_ge_comps 0 (sigma_nn_ge_comps-2 nil 3256040402 ("" (skosimp*) (("" (lemma "sigma_middle") (("" (inst?) (("" (inst -1 "i!1") (("" (assert) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((sigma_middle formula-decl nil sigma nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sigma_nnreal application-judgement "nnreal" sigma nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil) (sigma_nn_ge_comps-1 nil 3255975877 ("" (skosimp*) (("" (lemma "sigma_middle") (("" (inst?) (("" (inst -1 "i!1") (("" (assert) (("" (replace -1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (sigma_rat 0 (sigma_rat-1 nil 3709913892 ("" (auto-rewrite-theory "rationals") (("" (skosimp*) (("" (case "(FORALL (rng: nat): T_pred(low!1+rng) IMPLIES rational_pred(sigma(low!1, low!1+rng, Frat!1)))") (("1" (inst -1 "high!1 - low!1") (("1" (assert) (("1" (use "T_pred_lem") (("1" (assert) (("1" (expand "sigma") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "sigma") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "rng") (("1" (assert) (("1" (rewrite "sigma_eq_arg") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "sigma" 1) (("2" (split -1) (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "T_pred_lem") (("2" (inst - "low!1+j!1" "low!1" "low!1+j!1") (("1" (assert) nil nil) ("2" (assert) (("2" (inst + "1+j!1+low!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) nil nil)) nil)) nil) ("3" (skosimp*) nil nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (closed_plus formula-decl nil rationals nil) (j!1 skolem-const-decl "nat" sigma nil) (real_plus_real_is_real application-judgement "real" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (sigma_eq_arg formula-decl nil sigma nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (high!1 skolem-const-decl "T_high" sigma nil) (low!1 skolem-const-decl "T_low" sigma nil) (T_pred_lem formula-decl nil sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (T_pred const-decl "[int -> boolean]" sigma nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (sigma def-decl "real" sigma nil)) nil (sigma_rat subtype "sigma.sigma(sigma.low, sigma.high, sigma.Frat)" "rational"))) (sigma_int 0 (sigma_int-1 nil 3709915286 ("" (auto-rewrite-theory "integers") (("" (skosimp*) (("" (case "(FORALL (rng: nat): T_pred(low!1+rng) IMPLIES integer_pred(sigma(low!1, low!1+rng, Fint!1)))") (("1" (inst -1 "high!1 - low!1") (("1" (assert) (("1" (use "T_pred_lem") (("1" (assert) (("1" (expand "sigma") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "sigma") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "rng") (("1" (assert) (("1" (rewrite "sigma_eq_arg") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "sigma" 1) (("2" (split -1) (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "T_pred_lem") (("2" (inst -1 "low!1+j!1" "low!1" "low!1+j!1") (("1" (assert) nil nil) ("2" (assert) (("2" (inst + "1+j!1+low!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) nil nil)) nil)) nil) ("3" (skosimp*) nil nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (closed_plus formula-decl nil integers nil) (j!1 skolem-const-decl "nat" sigma nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (sigma_eq_arg formula-decl nil sigma nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (high!1 skolem-const-decl "T_high" sigma nil) (low!1 skolem-const-decl "T_low" sigma nil) (T_pred_lem formula-decl nil sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (sigma_rat application-judgement "rational" sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (T_pred const-decl "[int -> boolean]" sigma nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (sigma def-decl "real" sigma nil)) nil (sigma_int subtype "sigma.sigma(sigma.low, sigma.high, sigma.Fint)" "int"))) (sum_it_def_TCC1 0 (sum_it_def_TCC1-1 nil 3255975799 ("" (skosimp*) (("" (inst + "low!1") (("1" (assert) nil nil) ("2" (use "T_pred_lem") (("2" (assert) nil nil)) nil)) nil)) nil) ((low!1 skolem-const-decl "T_low" sigma nil) (T_low type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (T formal-subtype-decl nil sigma nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (T_pred const-decl "[int -> boolean]" sigma nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (T_high type-eq-decl nil sigma nil) (T_pred_lem formula-decl nil sigma nil)) nil (sum_it_def subtype "(number_fields.+)(sigma.low, 1)" "T_low"))) (sum_it_def_TCC2 0 (sum_it_def_TCC2-1 nil 3255975799 ("" (skosimp*) (("" (use "T_pred_lem") (("" (assert) nil nil)) nil)) nil) ((T_pred_lem formula-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (T_high type-eq-decl nil sigma nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (sum_it_def subtype "sigma.low" "T"))) (sum_it_def_TCC3 0 (sum_it_def_TCC3-1 nil 3352118808 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil)) nil (sum_it_def termination "sigma.sum_it_def((number_fields.+)(sigma.low, 1), sigma.high, sigma.F, (number_fields.+)(sigma.a, sigma.F(sigma.low)))" "nil"))) (sum_it_prop_TCC1 0 (sum_it_prop_TCC1-1 nil 3352142246 ("" (skosimp* t) (("" (prop) (("1" (inst + "low!1") (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (inst + "j!1") (("2" (assert) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (inst + "low!1") (("3" (assert) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (inst + "j!1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ((int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (low!1 skolem-const-decl "T_low" sigma nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" sigma nil) (T formal-subtype-decl nil sigma nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil)) nil (sum_it_prop subtype "(number_fields.+)(sigma.i, 1)" "T_low"))) (sum_it_prop 0 (sum_it_prop-2 "" 3790088478 ("" (skosimp*) (("" (case "high!1<low!1") (("1" (assert) (("1" (expand "sum_it_def") (("1" (expand "sigma") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma "subrange_induction[low!1,high!1]") (("1" (inst -1 "lambda(lh:T| low!1 <= lh AND lh <= high!1): sum_it_def((high!1-lh)+low!1, high!1, F!1, sigma(low!1,(high!1-lh)+low!1-1, F!1)) = sigma(low!1, high!1, F!1)") (("1" (expand "extend") (("1" (ground) (("1" (inst -1 "high!1-i!1+low!1-1") (("1" (ground) nil nil) ("2" (expand "sum_it_def") (("2" (expand "sigma") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4 3) (("2" (expand "sum_it_def") (("2" (expand "sum_it_def") (("2" (expand "sigma" + 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "sigma") (("3" (assert) (("3" (hide -1 -2 3) (("3" (use "T_pred_lem") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide -1 -2 3) (("4" (skosimp*) (("4" (ground) (("1" (expand "sum_it_def" 1) (("1" (expand "sigma" -) (("1" (assert) (("1" (expand "sigma" 1 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (lemma "T_pred_lem") (("2" (inst?) (("2" (inst - "high!1" "low!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst + "high!1 -lh!1 +low!1") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (lemma "T_pred_lem") (("2" (inst - "high!1" "low!1" "high!1-lh!1+low!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skosimp*) (("3" (typepred "high!1") (("3" (typepred "low!1") (("3" (assert) (("3" (lemma "T_pred_lem") (("3" (inst - "high!1" "low!1" "(high!1 - lh!1) + low!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (sum_it_def def-decl "real" sigma nil) (sigma def-decl "real" sigma nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (high!1 skolem-const-decl "T_high" sigma nil) (low!1 skolem-const-decl "T_low" sigma nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (pred type-eq-decl nil defined_types nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (i!1 skolem-const-decl "T" sigma nil) (T_pred_lem formula-decl nil sigma nil) (lh!1 skolem-const-decl "{lh: T | low!1 <= lh AND lh <= high!1}" sigma nil) (NOT const-decl "[bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (subrange_induction formula-decl nil subrange_inductions nil)) shostak) (sum_it_prop-1 nil 3255975799 ("" (skosimp*) (("" (case "high!1<low!1") (("1" (assert) (("1" (expand "sum_it_def") (("1" (expand "sigma") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma "subrange_induction[low!1,high!1]") (("1" (inst -1 "lambda(lh:T| low!1 <= lh AND lh <= high!1): sum_it_def((high!1-lh)+low!1, high!1, F!1, sigma(low!1,(high!1-lh)+low!1-1, F!1)) = sigma(low!1, high!1, F!1)") (("1" (expand "extend") (("1" (ground) (("1" (inst -1 "high!1-i!1+low!1-1") (("1" (ground) nil nil) ("2" (expand "sum_it_def") (("2" (expand "sigma") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (ground) (("2" (hide -2 -3 -4 3) (("2" (expand "sum_it_def") (("2" (expand "sum_it_def") (("2" (expand "sigma" + 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (ground) (("3" (expand "sigma") (("3" (assert) (("3" (hide -1 -2 3) (("3" (use "T_pred_lem") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -1 -2 3) (("4" (skosimp*) (("4" (ground) (("1" (expand "sum_it_def" 1) (("1" (expand "sigma" -) (("1" (assert) (("1" (expand "sigma" 1 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (lemma "T_pred_lem") (("2" (inst?) (("2" (inst - "high!1" "low!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst + "high!1 -lh!1 +low!1") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (lemma "T_pred_lem") (("2" (inst - "high!1" "low!1" "high!1-lh!1+low!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skosimp*) (("3" (typepred "high!1") (("3" (typepred "low!1") (("3" (assert) (("3" (lemma "T_pred_lem") (("3" (inst - "high!1" "low!1" "(high!1 - lh!1) + low!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) nil nil)) (sum_it_sigma 0 (sum_it_sigma-1 nil 3255975799 ("" (skolem 1 ("F" "high" "low")) (("" (case "low > high") (("1" (expand "sum_it") (("1" (expand "sum_it_def") (("1" (expand "sigma") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "sum_it") (("2" (expand "sum_it_def") (("2" (assert) (("2" (lemma "sum_it_prop") (("2" (inst -1 "F" "high" "low" "low") (("2" (assert) (("2" (rewrite "sigma_eq_arg") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (T formal-subtype-decl nil sigma nil) (T_pred const-decl "[int -> boolean]" sigma nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (sum_it_def def-decl "real" sigma nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma def-decl "real" sigma nil) (sum_it const-decl "real" sigma nil) (sum_it_prop formula-decl nil sigma nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (sigma_eq_arg formula-decl nil sigma nil) (int_plus_int_is_int application-judgement "int" integers nil)) nil)))
