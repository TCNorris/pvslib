(stirling
 (IMP_sigma_TCC1 0
  (IMP_sigma_TCC1-1 nil 3714492335 ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (integer nonempty-type-from-decl nil integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (IMP_sigma assuming "sigma[nat].sigma"
    "connected_domain: ASSUMPTION (FORALL (x, y: sigma.T), (z: integers.integer): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), sigma.T_pred(z)))")))
 (S2_recur_TCC1 0
  (S2_recur_TCC1-1 nil 3709996521 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil (S2_recur subtype "(number_fields.-)(stirling.m, 1)" "nat")))
 (S2_recur_TCC2 0
  (S2_recur_TCC2-1 nil 3709996521 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil (S2_recur subtype "(number_fields.-)(stirling.n, 1)" "nat")))
 (S2_recur_TCC3 0
  (S2_recur_TCC3-1 nil 3709996521 ("" (termination-tcc) nil nil) nil nil
   (S2_recur termination
    "stirling.S2_recur((number_fields.-)(stirling.m, 1), (number_fields.-)(stirling.n, 1))"
    "nil")))
 (S2_recur_00 0
  (S2_recur_00-1 nil 3709996847
   ("" (expand "S2_recur") (("" (propax) nil nil)) nil)
   ((S2_recur def-decl "nat" stirling nil)) shostak))
 (S2_recur_0n 0
  (S2_recur_0n-1 nil 3709996861
   ("" (skeep) (("" (expand "S2_recur") (("" (propax) nil nil)) nil)) nil)
   ((S2_recur def-decl "nat" stirling nil)) shostak))
 (S2_recur_n0 0
  (S2_recur_n0-1 nil 3710501838
   ("" (skeep)
    (("" (assert) (("" (expand "S2_recur") (("" (propax) nil nil)) nil)) nil))
    nil)
   ((S2_recur def-decl "nat" stirling nil)) shostak))
 (S2_recur_n0_1 0
  (S2_recur_n0_1-1 nil 3710501855
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "S2_recur")
          (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil))
        nil)
       ("2" (flatten)
        (("2" (replace -1)
          (("2" (lemma "S2_recur_00") (("2" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((S2_recur def-decl "nat" stirling nil)
    (S2_recur_00 formula-decl nil stirling nil))
   shostak))
 (S2_recur_0n_1 0
  (S2_recur_0n_1-1 nil 3710501956
   ("" (skeep)
    (("" (split)
      (("1" (flatten) (("1" (expand "S2_recur") (("1" (assert) nil nil)) nil))
        nil)
       ("2" (flatten)
        (("2" (replace -1)
          (("2" (assert)
            (("2" (lemma "S2_recur_00") (("2" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((S2_recur def-decl "nat" stirling nil)
    (S2_recur_00 formula-decl nil stirling nil))
   shostak))
 (S2_recur_nn 0
  (S2_recur_nn-1 nil 3709996874
   ("" (induct "n")
    (("1" (expand "S2_recur") (("1" (propax) nil nil)) nil)
     ("2" (skeep) (("2" (grind) nil nil)) nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (S2_recur def-decl "nat" stirling nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (S2_recur_n1 0
  (S2_recur_n1-1 nil 3709997388
   ("" (induct "m")
    (("1" (expand "S2_recur") (("1" (assert) nil nil)) nil)
     ("2" (assert) nil nil) ("3" (skeep) (("3" (grind) nil nil)) nil))
    nil)
   ((nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (odd_times_odd_is_odd application-judgement "odd_int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (S2_recur def-decl "nat" stirling nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (S2_recur_n2 0
  (S2_recur_n2-1 nil 3710075937
   ("" (induct "m")
    (("1" (assert) nil nil) ("2" (assert) nil nil)
     ("3" (skeep)
      (("3" (expand "S2_recur" 1)
        (("3" (lift-if)
          (("3" (assert)
            (("3" (split)
              (("1" (replace -1)
                (("1" (lemma "S2_recur_n1")
                  (("1" (inst -1 "j")
                    (("1" (replace -1)
                      (("1" (field)
                        (("1" (case "NOT  (2 * (2 ^ j - 1)) = 2*2^j-2")
                          (("1" (field) nil nil)
                           ("2" (replace -1)
                            (("2" (lemma "expt_plus")
                              (("2" (inst -1 "1" "j" "2")
                                (("2" (replace -1)
                                  (("2" (assert)
                                    (("2" (lemma "expt_x1")
                                      (("2"
                                        (inst -1 "2")
                                        (("2"
                                          (replace -1)
                                          (("2" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (assert)
                (("2" (typepred "j") (("2" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((S2_recur_n1 formula-decl nil stirling nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (even_minus_even_is_even application-judgement "even_int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (expt_plus formula-decl nil exponentiation nil)
    (expt_x1 formula-decl nil exponentiation nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (int_times_even_is_even application-judgement "even_int" integers nil)
    (both_sides_times1 formula-decl nil real_props nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (div_cancel2 formula-decl nil real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rat_plus_rat_is_rat application-judgement "rat" rationals nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (^ const-decl "real" exponentiation nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (S2_recur def-decl "nat" stirling nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (S2_recur_n2_alt 0
  (S2_recur_n2_alt-1 nil 3710077947
   ("" (induct m)
    (("1" (assert) nil nil) ("2" (assert) nil nil)
     ("3" (skeep)
      (("3" (expand "S2_recur" 1)
        (("3" (lift-if)
          (("3" (assert)
            (("3" (split)
              (("1" (replace -1)
                (("1" (lemma "S2_recur_n1")
                  (("1" (inst -1 "j")
                    (("1" (replace -1)
                      (("1" (field)
                        (("1" (case "NOT  2 * (2 ^ (j - 1) - 1) = 2^j -2")
                          (("1"
                            (case "NOT 2 * (2 ^ (j - 1) - 1) = 2*2^(j-1) - 2")
                            (("1" (field) nil nil)
                             ("2" (replace -1)
                              (("2" (lemma "expt_plus")
                                (("2" (inst -1 "1" "j-1" "2")
                                  (("2" (replace -1)
                                    (("2" (lemma "expt_x1")
                                      (("2"
                                        (inst -1 "2")
                                        (("2"
                                          (replace -1)
                                          (("2" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (replace -1) (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((S2_recur_n1 formula-decl nil stirling nil)
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (expt_x1 formula-decl nil exponentiation nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers nil)
    (expt_plus formula-decl nil exponentiation nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat" rationals
     nil)
    (rat_plus_rat_is_rat application-judgement "rat" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (expt def-decl "real" exponentiation nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (S2_recur def-decl "nat" stirling nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (S2_recur_n3 0
  (S2_recur_n3-1 nil 3710080297
   ("" (induct "m")
    (("1" (assert) nil nil) ("2" (assert) nil nil)
     ("3" (skeep)
      (("3" (expand "S2_recur" 1)
        (("3" (lift-if)
          (("3" (assert)
            (("3" (split -1)
              (("1" (replace -1)
                (("1" (lemma "S2_recur_n2")
                  (("1" (inst -1 "j")
                    (("1" (replace -1)
                      (("1" (field)
                        (("1" (mult-by 1 "3")
                          (("1"
                            (case "NOT (((1 * (3 ^ (1 + j))) / 3 - (2 ^ (1 + j))) * 3) = 3^(1+j) -  (2 ^ (1 + j)) * 3")
                            (("1" (field) nil nil)
                             ("2" (replace -1)
                              (("2" (lemma "expt_plus")
                                (("2" (inst -1 "j" "1" "2")
                                  (("2" (replace -1)
                                    (("2" (lemma "expt_x1")
                                      (("2"
                                        (inst -1 "2")
                                        (("2"
                                          (replace -1)
                                          (("2"
                                            (lemma "expt_plus")
                                            (("2"
                                              (inst -1 "1" "j" "3")
                                              (("2"
                                                (replace -1)
                                                (("2"
                                                  (lemma "expt_x1")
                                                  (("2"
                                                    (inst -1 "3")
                                                    (("2"
                                                      (replace -1)
                                                      (("2" (field) nil nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((S2_recur_n2 formula-decl nil stirling nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (expt_x1 formula-decl nil exponentiation nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (int_times_even_is_even application-judgement "even_int" integers nil)
    (expt_plus formula-decl nil exponentiation nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (times_div2 formula-decl nil real_props nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (both_sides_times1 formula-decl nil real_props nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (rat_plus_rat_is_rat application-judgement "rat" rationals nil)
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat" rationals
     nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (^ const-decl "real" exponentiation nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (S2_recur def-decl "nat" stirling nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (S2_recur_n_nminus1_TCC1 0
  (S2_recur_n_nminus1_TCC1-1 nil 3710074687 ("" (subtype-tcc) nil nil) nil nil
   (S2_recur_n_nminus1 subtype "(number_fields.-)(stirling.n, 1)" "nat")))
 (S2_recur_n_nminus1_TCC2 0
  (S2_recur_n_nminus1_TCC2-1 nil 3710074687 ("" (subtype-tcc) nil nil) nil nil
   (S2_recur_n_nminus1 subtype "2"
    "{i: naturalnumbers.nat | reals.<=(i, stirling.n)}")))
 (S2_recur_n_nminus1 0
  (S2_recur_n_nminus1-1 nil 3710076518
   ("" (induct "n")
    (("1" (assert) nil nil) ("2" (assert) nil nil)
     ("3" (skeep)
      (("3" (expand "S2_recur" 1)
        (("3" (lift-if)
          (("3" (assert)
            (("3" (split)
              (("1" (replace -1)
                (("1" (lemma "S2_recur_nn")
                  (("1" (inst -1 "j")
                    (("1" (replace -1)
                      (("1" (lemma "C_1")
                        (("1" (inst -1 "j")
                          (("1" (case "NOT C(j,1) = j*1")
                            (("1" (assert) nil nil)
                             ("2" (case "NOT C(j,2) + j*1 = C(j,2) + C(j,1)")
                              (("1" (assert) nil nil)
                               ("2" (replace -1)
                                (("2" (lemma "C_n_plus_1")
                                  (("2" (inst -1 "j" "2")
                                    (("2" (assert) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skeep) (("4" (assert) nil nil)) nil)
     ("5" (skeep) (("5" (assert) nil nil)) nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (S2_recur_nn formula-decl nil stirling nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (C_n_plus_1 formula-decl nil binomial nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (C_1 formula-decl nil binomial nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (factorial def-decl "posnat" factorial ints)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (C const-decl "posnat" binomial nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (S2_recur def-decl "nat" stirling nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil) (<= const-decl "bool" reals nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (S2_TCC1 0
  (S2_TCC1-1 nil 3709655946 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (S2 subtype "stirling.i"
    "{i: naturalnumbers.nat | reals.<=(i, stirling.n)}")))
 (S2_TCC2 0
  (S2_TCC2-1 nil 3709655946 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (S2 subtype "stirling.m"
    "{i_1: integers.int | booleans.OR(((number_fields.-)(stirling.n, stirling.i)) /= 0, reals.>=(i_1, 0))}")))
 (St2_TCC1 0
  (St2_TCC1-1 nil 3710003319 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (St2 subtype "stirling.i"
    "{i: naturalnumbers.nat | reals.<=(i, stirling.n)}")))
 (St2_TCC2 0
  (St2_TCC2-1 nil 3710003319 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (St2 subtype "stirling.m"
    "{i_1: integers.int | booleans.OR(((number_fields.-)(stirling.n, stirling.i)) /= 0, reals.>=(i_1, 0))}")))
 (S2_00 0
  (S2_00-1 nil 3709997541
   ("" (expand "S2") (("" (assert) (("" (grind) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (sigma_int application-judgement "int" sigma_nat nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (factorial_0 formula-decl nil factorial ints)
    (int_times_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (sigma_nat application-judgement "nat" sigma_nat nil)
    (sigma def-decl "real" sigma nil) (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (C const-decl "posnat" binomial nil)
    (factorial def-decl "posnat" factorial ints)
    (S2 const-decl "rat" stirling nil))
   shostak))
 (S2_n1_TCC1 0
  (S2_n1_TCC1-1 nil 3709997517 ("" (subtype-tcc) nil nil) nil nil
   (S2_n1 subtype "1" "{i: naturalnumbers.nat | reals.<=(i, stirling.m)}")))
 (S2_n1 0
  (S2_n1-1 nil 3709999279
   ("" (skeep)
    (("" (expand "S2")
      (("" (assert)
        (("" (lemma "sigma_first")
          (("" (inst?)
            (("1" (split)
              (("1" (replace -1)
                (("1" (assert)
                  (("1" (lemma "sigma_eq_arg")
                    (("1" (inst?)
                      (("1" (replace -1)
                        (("1" (assert)
                          (("1" (lemma "C_0")
                            (("1" (inst?)
                              (("1" (replace -1)
                                (("1" (lemma "C_1")
                                  (("1" (inst?)
                                    (("1" (replace -1)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (lemma "expt_eq_0")
                                          (("1"
                                            (inst?)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (replace -1)
                                                (("1"
                                                  (lemma "expt_x0")
                                                  (("1"
                                                    (inst?)
                                                    (("1"
                                                      (replace -1)
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (lemma "expt_1i")
                                                          (("1"
                                                            (inst?)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (skeep) (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (assert) nil nil))
              nil)
             ("2" (skeep) (("2" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((S2 const-decl "rat" stirling nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (sigma_first formula-decl nil sigma nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (int_exp application-judgement "int" exponentiation nil)
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nat_exp application-judgement "nat" exponentiation nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers nil)
    (C_1 formula-decl nil binomial nil)
    (expt_eq_0 formula-decl nil exponentiation nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (expt_1i formula-decl nil exponentiation nil)
    (C_0 formula-decl nil binomial nil)
    (sigma_eq_arg formula-decl nil sigma nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (C const-decl "posnat" binomial nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (<= const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (factorial_1 formula-decl nil factorial ints)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (sigma_int application-judgement "int" sigma_nat nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (St2_00 0
  (St2_00-1 nil 3710081989
   ("" (assert)
    (("" (expand "St2")
      (("" (assert)
        (("" (lemma "sigma_eq_arg")
          (("" (inst?)
            (("1" (replace -1)
              (("1" (assert)
                (("1" (lemma "C_0")
                  (("1" (inst -1 "0")
                    (("1" (replace -1)
                      (("1" (lemma "expt_x0")
                        (("1" (inst -1 "0")
                          (("1" (replace -1)
                            (("1" (lemma "expt_x0")
                              (("1" (inst -1 "-1")
                                (("1" (replace -1) (("1" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skeep) (("2" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((St2 const-decl "rat" stirling nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (sigma_eq_arg formula-decl nil sigma nil)
    (C_0 formula-decl nil binomial nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_exp application-judgement "int" exponentiation nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (int_times_even_is_even application-judgement "even_int" integers nil)
    (nat_exp application-judgement "nat" exponentiation nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (C const-decl "posnat" binomial nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (<= const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (factorial_0 formula-decl nil factorial ints)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (sigma_int application-judgement "int" sigma_nat nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (St2_n1 0
  (St2_n1-1 nil 3710082151
   ("" (skeep)
    (("" (expand "St2")
      (("" (assert)
        (("" (lemma "sigma_first")
          (("" (inst?)
            (("1" (split)
              (("1" (replace -1)
                (("1" (assert)
                  (("1" (lemma "sigma_eq_arg")
                    (("1" (inst?)
                      (("1" (replace -1)
                        (("1" (assert)
                          (("1" (lemma "C_0")
                            (("1" (inst -1 "1")
                              (("1" (replace -1)
                                (("1" (lemma "C_1")
                                  (("1" (inst -1 "1")
                                    (("1" (replace -1)
                                      (("1"
                                        (lemma "expt_1i")
                                        (("1"
                                          (inst -1 "m")
                                          (("1"
                                            (replace -1)
                                            (("1"
                                              (lemma "expt_x0")
                                              (("1"
                                                (inst -1 "-1")
                                                (("1"
                                                  (replace -1)
                                                  (("1"
                                                    (lemma "expt_eq_0")
                                                    (("1"
                                                      (inst -1 "m" "0")
                                                      (("1" (assert) nil nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (skeep) (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (assert) nil nil))
              nil)
             ("2" (skeep) (("2" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((St2 const-decl "rat" stirling nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (sigma_first formula-decl nil sigma nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (int_exp application-judgement "int" exponentiation nil)
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nat_exp application-judgement "nat" exponentiation nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers nil)
    (C_1 formula-decl nil binomial nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (expt_eq_0 formula-decl nil exponentiation nil)
    (expt_1i formula-decl nil exponentiation nil)
    (C_0 formula-decl nil binomial nil)
    (sigma_eq_arg formula-decl nil sigma nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (C const-decl "posnat" binomial nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (<= const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (factorial_1 formula-decl nil factorial ints)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (sigma_int application-judgement "int" sigma_nat nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (SS1_recur_00 0
  (SS1_recur_00-1 nil 3710177513
   ("" (expand "SS1_recur") (("" (propax) nil nil)) nil)
   ((SS1_recur def-decl "int" stirling nil)) shostak))
 (SS1_recur_0n 0
  (SS1_recur_0n-1 nil 3710177525
   ("" (induct "n")
    (("1" (assert) nil nil) ("2" (assert) nil nil)
     ("3" (skeep) (("3" (expand "SS1_recur" 1) (("3" (propax) nil nil)) nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (SS1_recur def-decl "int" stirling nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (SS1_recur_nn 0
  (SS1_recur_nn-1 nil 3710177550
   ("" (induct "n")
    (("1" (lemma "SS1_recur_00") (("1" (propax) nil nil)) nil)
     ("2" (skeep)
      (("2" (expand "SS1_recur" 1)
        (("2" (replace -1) (("2" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (SS1_recur_00 formula-decl nil stirling nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (SS1_recur def-decl "int" stirling nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (SS1_recur_n0 0
  (SS1_recur_n0-1 nil 3710502395
   ("" (skeep) (("" (expand "SS1_recur") (("" (propax) nil nil)) nil)) nil)
   ((SS1_recur def-decl "int" stirling nil)) shostak))
 (SS1_recur_n0_1 0
  (SS1_recur_n0_1-1 nil 3710502412
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "SS1_recur") (("1" (assert) nil nil)) nil)) nil)
       ("2" (flatten)
        (("2" (replace -1)
          (("2" (lemma "SS1_recur_00") (("2" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((SS1_recur def-decl "int" stirling nil)
    (SS1_recur_00 formula-decl nil stirling nil))
   shostak))
 (SS1_recur_0n_1 0
  (SS1_recur_0n_1-1 nil 3710502460
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "SS1_recur") (("1" (assert) nil nil)) nil)) nil)
       ("2" (flatten)
        (("2" (replace -1)
          (("2" (lemma "SS1_recur_00") (("2" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((SS1_recur def-decl "int" stirling nil)
    (SS1_recur_00 formula-decl nil stirling nil))
   shostak))
 (S1_recur_TCC1 0
  (S1_recur_TCC1-1 nil 3710178962
   ("" (skeep)
    (("" (case "m=0")
      (("1" (grind) nil nil)
       ("2" (lemma "nnint_times_nnint_is_nnint")
        (("2" (inst -1 "(m-1)" "v(m-1,n)")
          (("1" (lemma "nnint_plus_nnint_is_nnint")
            (("1" (inst -1 "v(m-1,n-1)" " (m - 1) * v(m - 1, n) ")
              (("1" (field) nil nil) ("2" (assert) nil nil)
               ("3" (assert) nil nil))
              nil))
            nil)
           ("2" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (m skolem-const-decl "nat" stirling nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (n skolem-const-decl "nat" stirling nil)
    (v skolem-const-decl "[{z: [nat, nat] | z`1 < m} -> nat]" stirling nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (nnint_plus_nnint_is_nnint judgement-tcc nil integers nil)
    (nnint_times_nnint_is_nnint judgement-tcc nil integers nil))
   nil
   (S1_recur subtype
    "(number_fields.+)(stirling.S1_recur((number_fields.-)(stirling.m, 1), (number_fields.-)(stirling.n, 1)), number_fields.*(((number_fields.-)(stirling.m, 1)), stirling.S1_recur((number_fields.-)(stirling.m, 1), stirling.n)))"
    "nat")))
 (S1_recur_00 0
  (S1_recur_00-1 nil 3710172730
   ("" (expand "S1_recur") (("" (propax) nil nil)) nil)
   ((S1_recur def-decl "nat" stirling nil)) shostak))
 (S1_recur_0n 0
  (S1_recur_0n-1 nil 3710172742
   ("" (induct "n")
    (("1" (expand "S1_recur") (("1" (propax) nil nil)) nil)
     ("2" (assert) nil nil)
     ("3" (skeep) (("3" (expand "S1_recur") (("3" (propax) nil nil)) nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (S1_recur def-decl "nat" stirling nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (S1_recur_n0 0
  (S1_recur_n0-1 nil 3710502493
   ("" (skeep) (("" (expand "S1_recur") (("" (propax) nil nil)) nil)) nil)
   ((S1_recur def-decl "nat" stirling nil)) shostak))
 (S1_recur_n0_1 0
  (S1_recur_n0_1-1 nil 3710502507
   ("" (skeep)
    (("" (split)
      (("1" (flatten) (("1" (expand "S1_recur") (("1" (assert) nil nil)) nil))
        nil)
       ("2" (flatten)
        (("2" (replace -1)
          (("2" (lemma "S1_recur_00") (("2" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((S1_recur def-decl "nat" stirling nil)
    (S1_recur_00 formula-decl nil stirling nil))
   shostak))
 (S1_recur_0n_1 0
  (S1_recur_0n_1-1 nil 3710502531
   ("" (skeep)
    (("" (split)
      (("1" (flatten) (("1" (expand "S1_recur") (("1" (assert) nil nil)) nil))
        nil)
       ("2" (flatten)
        (("2" (replace -1)
          (("2" (lemma "S1_recur_00") (("2" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((S1_recur def-decl "nat" stirling nil)
    (S1_recur_00 formula-decl nil stirling nil))
   shostak))
 (S1_recur_nn 0
  (S1_recur_nn-1 nil 3710172773
   ("" (induct "n")
    (("1" (assert) (("1" (expand "S1_recur") (("1" (propax) nil nil)) nil))
      nil)
     ("2" (skeep)
      (("2" (expand "S1_recur" 1)
        (("2" (replace -1) (("2" (assert) (("2" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (S1_recur def-decl "nat" stirling nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (S1_recur_n1_TCC1 0
  (S1_recur_n1_TCC1-1 nil 3710665383 ("" (subtype-tcc) nil nil) nil nil
   (S1_recur_n1 subtype "(number_fields.-)(stirling.n, 1)" "nat")))
 (S1_recur_n1 0
  (S1_recur_n1-1 nil 3710179193
   ("" (induct "n")
    (("1" (assert) nil nil) ("2" (assert) nil nil)
     ("3" (skeep)
      (("3" (assert)
        (("3" (expand "S1_recur" 1)
          (("3" (case "j=0")
            (("1" (assert) (("1" (grind) nil nil)) nil)
             ("2" (split)
              (("1" (lemma "factorial_n")
                (("1" (inst -1 "j")
                  (("1" (split)
                    (("1" (replace -1)
                      (("1" (replace -2)
                        (("1" (assert) (("1" (grind) nil nil)) nil)) nil))
                      nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skeep) (("4" (assert) nil nil)) nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (factorial_n formula-decl nil factorial ints)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (factorial def-decl "posnat" factorial ints)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (S1_recur def-decl "nat" stirling nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (S1_recur_n_nminus1 0
  (S1_recur_n_nminus1-1 nil 3710179305
   ("" (induct "n")
    (("1" (assert) nil nil) ("2" (assert) nil nil)
     ("3" (skeep)
      (("3" (assert)
        (("3" (case "j=2")
          (("1" (assert) (("1" (grind) nil nil)) nil)
           ("2" (split)
            (("1" (expand "S1_recur" 2)
              (("1" (replace -1)
                (("1" (lemma "S1_recur_nn")
                  (("1" (inst -1 "j")
                    (("1" (replace -1)
                      (("1" (case "NOT C(j,2) +j*1 = C(j,2) + C(j,1)")
                        (("1" (lemma "C_1")
                          (("1" (inst -1 "j") (("1" (assert) nil nil)) nil))
                          nil)
                         ("2" (replace -1)
                          (("2" (lemma "C_n_plus_1")
                            (("2" (inst -1 "j" "2")
                              (("2" (replace -1) (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skeep) (("4" (assert) nil nil)) nil)
     ("5" (skeep) (("5" (assert) nil nil)) nil))
    nil)
   ((factorial def-decl "posnat" factorial ints)
    (even_minus_even_is_even application-judgement "even_int" integers nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (S1_recur_nn formula-decl nil stirling nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers nil)
    (C_n_plus_1 formula-decl nil binomial nil)
    (C_1 formula-decl nil binomial nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (C const-decl "posnat" binomial nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (S1_recur def-decl "nat" stirling nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil) (<= const-decl "bool" reals nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (S1_recur_n_nminus2_TCC1 0
  (S1_recur_n_nminus2_TCC1-1 nil 3710179771 ("" (subtype-tcc) nil nil) nil nil
   (S1_recur_n_nminus2 subtype "(number_fields.-)(stirling.n, 2)" "nat")))
 (S1_recur_n_nminus2_TCC2 0
  (S1_recur_n_nminus2_TCC2-1 nil 3710179771 ("" (subtype-tcc) nil nil) nil nil
   (S1_recur_n_nminus2 subtype "3"
    "{i: naturalnumbers.nat | reals.<=(i, stirling.n)}")))
 (S1_recur_n_nminus2 0
  (S1_recur_n_nminus2-1 nil 3710179988
   ("" (induct "n")
    (("1" (assert) nil nil) ("2" (assert) nil nil)
     ("3" (skeep)
      (("3" (assert)
        (("3" (expand "S1_recur" 1)
          (("3" (split)
            (("1" (replace -1)
              (("1" (lemma "S1_recur_n_nminus1")
                (("1" (inst -1 "j")
                  (("1" (replace -1)
                    (("1" (lemma "C_n_plus_1")
                      (("1" (inst -1 "j" "3")
                        (("1" (replace -1)
                          (("1" (assert)
                            (("1" (field)
                              (("1" (lemma "C_2")
                                (("1" (inst -1 "j")
                                  (("1" (replace -1)
                                    (("1" (field)
                                      (("1"
                                        (both-sides "+" "(2*C(j,3))" 1)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (case
                                             "NOT 6 * C(j, 3) = 2 * (3*C(j,3))")
                                            (("1" (assert) nil nil)
                                             ("2"
                                              (replace -1)
                                              (("2"
                                                (case
                                                 "NOT 3*C(j,3) = j*C(j-1,2)")
                                                (("1"
                                                  (lemma "binom_absorption")
                                                  (("1"
                                                    (inst -1 "3" "j")
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (case "j=3")
                                                        (("1"
                                                          (replace -1)
                                                          (("1"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (typepred "j")
                                                          (("2"
                                                            (case "j<3")
                                                            (("1"
                                                              (case "j=2")
                                                              (("1"
                                                                (assert)
                                                                (("1"
                                                                  (replace -1)
                                                                  (("1"
                                                                    (hide-all-but
                                                                     -5)
                                                                    (("1"
                                                                      (assert)
                                                                      (("1"
                                                                        (expand
                                                                         "C")
                                                                        (("1"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (case "j=1")
                                                              (("1"
                                                                (replace -1)
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (replace -1)
                                                  (("2"
                                                    (lemma "C_2")
                                                    (("2"
                                                      (inst -1 "j-1")
                                                      (("1"
                                                        (replace -1)
                                                        (("1"
                                                          (field)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (assert)
                                                        (("2"
                                                          (case "j=2")
                                                          (("1"
                                                            (replace -1)
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (expand "C")
                                                                (("1"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("3"
                                                  (assert)
                                                  (("3"
                                                    (case "j=2")
                                                    (("1"
                                                      (replace -1)
                                                      (("1"
                                                        (expand "C")
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2" (assert) nil nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (case "j=2")
                (("1" (replace -1)
                  (("1" (assert) (("1" (grind) nil nil)) nil)) nil)
                 ("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skeep) (("4" (assert) nil nil)) nil)
     ("5" (skeep) (("5" (assert) nil nil)) nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (factorial def-decl "posnat" factorial ints)
    (C_n_plus_1 formula-decl nil binomial nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (int_times_even_is_even application-judgement "even_int" integers nil)
    (even_plus_even_is_even application-judgement "even_int" integers nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (times_div2 formula-decl nil real_props nil)
    (div_distributes formula-decl nil real_props nil)
    (add_div formula-decl nil real_props nil)
    (div_cancel4 formula-decl nil real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (div_cancel2 formula-decl nil real_props nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (both_sides_times1 formula-decl nil real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (even_minus_even_is_even application-judgement "even_int" integers nil)
    (j skolem-const-decl "nat" stirling nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers nil)
    (factorial_1 formula-decl nil factorial ints)
    (binom_absorption formula-decl nil binomial_identities nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (factorial_0 formula-decl nil factorial ints)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (< const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (even? const-decl "bool" integers nil) (C_2 formula-decl nil binomial nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers nil)
    (rat_plus_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_plus_nnrat_is_posrat application-judgement "posrat" rationals nil)
    (nnrat_plus_posrat_is_posrat application-judgement "posrat" rationals nil)
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (S1_recur_n_nminus1 formula-decl nil stirling nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat" rationals
     nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (C const-decl "posnat" binomial nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (S1_recur def-decl "nat" stirling nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil) (<= const-decl "bool" reals nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (S1_recur_sum 0
  (S1_recur_sum-1 nil 3710252714
   ("" (induct "m")
    (("1" (assert) (("1" (grind) nil nil)) nil)
     ("2" (skeep)
      (("2" (case "j=0")
        (("1" (assert)
          (("1" (replace -1)
            (("1" (lemma "sigma_first")
              (("1" (lemma "sigma_eq_arg")
                (("1" (inst?)
                  (("1" (assert)
                    (("1" (replace -1)
                      (("1"
                        (inst -2 "LAMBDA (k: nat): S1_recur(1, k)" "1" "0")
                        (("1" (split)
                          (("1" (replace -1)
                            (("1" (assert)
                              (("1" (lemma "sigma_eq_arg")
                                (("1"
                                  (inst -1 "LAMBDA (k: nat): S1_recur(1, k)"
                                   "1")
                                  (("1" (replace -1) (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "S1_recur" 2)
          (("2" (assert)
            (("2" (lemma "sigma_first")
              (("2"
                (inst -1 "LAMBDA (k: nat):
              IF (k > 1 + j OR k = 0) THEN 0
              ELSE S1_recur(j, k - 1) + j * S1_recur(j, k) ENDIF" "1+j" "0")
                (("1" (split)
                  (("1" (replace -1)
                    (("1" (assert)
                      (("1" (lemma "sigma_sum")
                        (("1"
                          (inst -1
                           "LAMBDA (k:nat): IF (k> 1+j OR k=0) THEN 0 ELSE S1_recur(j,k-1) ENDIF"
                           "LAMBDA (k:nat): IF (k>1+j OR k=0) THEN 0 ELSE j*S1_recur(j,k) ENDIF"
                           "1+j" "1")
                          (("1"
                            (case "NOT  sigma(1, 1 + j,
            LAMBDA (k: nat):
              IF (k > 1 + j OR k = 0) THEN 0
              ELSE S1_recur(j, k - 1) + j * S1_recur(j, k)
              ENDIF) =  sigma(1, 1 + j,
             LAMBDA (i: nat):
               IF (i > 1 + j OR i = 0) THEN 0 ELSE S1_recur(j, i - 1) ENDIF
                +
                IF (i > 1 + j OR i = 0) THEN 0
                ELSE j * S1_recur(j, i)
                ENDIF)")
                            (("1" (hide-all-but 1)
                              (("1" (lemma "sigma_eq")
                                (("1" (inst?)
                                  (("1" (split)
                                    (("1" (propax) nil nil)
                                     ("2" (assert) nil nil))
                                    nil)
                                   ("2" (assert)
                                    (("2" (skeep) (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (replace -1)
                              (("2" (replace -2 :dir RL)
                                (("2" (lemma "sigma_scal")
                                  (("2"
                                    (inst -1
                                     "LAMBDA (k:nat): IF (k>1+j OR k=0) THEN 0 ELSE S1_recur(j,k) ENDIF"
                                     "j" "1+j" "1")
                                    (("2"
                                      (case
                                       "NOT  sigma(1, 1 + j,
             LAMBDA (k: nat):
               IF (k > 1 + j OR k = 0) THEN 0
               ELSE j * S1_recur(j, k)
               ENDIF) =  sigma(1, 1 + j,
            LAMBDA (i: nat):
              j * IF (i > 1 + j OR i = 0) THEN 0 ELSE S1_recur(j, i) ENDIF)")
                                      (("1"
                                        (hide-all-but 1)
                                        (("1"
                                          (lemma "sigma_eq")
                                          (("1"
                                            (inst?)
                                            (("1"
                                              (split)
                                              (("1" (propax) nil nil)
                                               ("2"
                                                (skeep)
                                                (("2" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (replace -1)
                                        (("2"
                                          (replace -2)
                                          (("2"
                                            (case
                                             "NOT  sigma(0, j, LAMBDA (k: nat): S1_recur(j, k)) = sigma(1, 1 + j,
              LAMBDA (k: nat):
                IF (k > 1 + j OR k = 0) THEN 0 ELSE S1_recur(j, k) ENDIF)")
                                            (("1"
                                              (hide-all-but 1)
                                              (("1"
                                                (lemma "sigma_first")
                                                (("1"
                                                  (inst?)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (replace -1)
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (case
                                                           "NOT S1_recur(j,0) = 0")
                                                          (("1"
                                                            (expand
                                                             "S1_recur"
                                                             1)
                                                            (("1"
                                                              (propax)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (replace -1)
                                                            (("2"
                                                              (assert)
                                                              (("2"
                                                                (lemma
                                                                 "sigma_last")
                                                                (("2"
                                                                  (inst
                                                                   -1
                                                                   "LAMBDA (k: nat):
               IF (k > 1 + j OR k = 0) THEN 0 ELSE S1_recur(j, k) ENDIF"
                                                                   "1+j"
                                                                   "1")
                                                                  (("2"
                                                                    (assert)
                                                                    (("2"
                                                                      (replace
                                                                       -1)
                                                                      (("2"
                                                                        (case
                                                                         "NOT S1_recur(j,1+j) = 0")
                                                                        (("1"
                                                                          (hide-all-but
                                                                           1)
                                                                          (("1"
                                                                            (expand
                                                                             "S1_recur")
                                                                            (("1"
                                                                              (propax)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (replace
                                                                           -1)
                                                                          (("2"
                                                                            (assert)
                                                                            (("2"
                                                                              (lemma
                                                                               "sigma_eq")
                                                                              (("2"
                                                                                (inst?)
                                                                                (("2"
                                                                                  (split)
                                                                                  (("1"
                                                                                    (propax)
                                                                                    nil
                                                                                    nil)
                                                                                   ("2"
                                                                                    (skeep)
                                                                                    (("2"
                                                                                      (assert)
                                                                                      nil
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (replace -1 :dir RL)
                                              (("2"
                                                (replace -7)
                                                (("2"
                                                  (case
                                                   "NOT sigma(1, 1 + j,
            LAMBDA (k: nat):
              IF (k > 1 + j OR k = 0) THEN 0 ELSE S1_recur(j, k - 1) ENDIF) =  sigma(0, j, LAMBDA (k: nat): S1_recur(j, k))")
                                                  (("1"
                                                    (hide-all-but 1)
                                                    (("1"
                                                      (lemma
                                                       "sigma_shift_fun_eq")
                                                      (("1"
                                                        (inst?)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (skeep)
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (replace -1)
                                                    (("2"
                                                      (replace -8)
                                                      (("2"
                                                        (lemma "factorial_n")
                                                        (("2"
                                                          (inst -1 "1+j")
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("3" (skeep) (("3" (assert) nil nil)) nil))
                            nil)
                           ("2" (skeep) (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil)
                 ("2" (skeep) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (sigma_scal formula-decl nil sigma nil)
    (sigma_shift_fun_eq formula-decl nil sigma nil)
    (factorial_n formula-decl nil factorial ints)
    (even_minus_odd_is_odd application-judgement "odd_int" integers nil)
    (sigma_last formula-decl nil sigma nil)
    (sigma_eq formula-decl nil sigma nil)
    (sigma_sum formula-decl nil sigma nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (j skolem-const-decl "nat" stirling nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (sigma_first formula-decl nil sigma nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (factorial_1 formula-decl nil factorial ints)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (sigma_eq_arg formula-decl nil sigma nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (sigma_nat application-judgement "nat" sigma_nat nil)
    (factorial_0 formula-decl nil factorial ints)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (factorial def-decl "posnat" factorial ints)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (S1_recur def-decl "nat" stirling nil) (sigma def-decl "real" sigma nil)
    (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (Bell_0 0
  (Bell_0-1 nil 3710585938
   ("" (expand "Bell")
    (("" (lemma "sigma_eq_arg")
      (("" (inst?)
        (("" (replace -1)
          (("" (lemma "S2_recur_00") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (sigma_eq_arg formula-decl nil sigma nil)
    (S2_recur_00 formula-decl nil stirling nil)
    (S2_recur def-decl "nat" stirling nil)
    (Bell const-decl "nat" stirling nil))
   shostak))
 (Bell_1 0
  (Bell_1-1 nil 3710586076
   ("" (expand "Bell")
    (("" (lemma "sigma_first")
      (("" (inst?)
        (("" (split)
          (("1" (replace -1)
            (("1" (assert)
              (("1" (hide -1)
                (("1" (lemma "sigma_eq_arg")
                  (("1" (inst?)
                    (("1" (replace -1)
                      (("1" (lemma "S2_recur_n0")
                        (("1" (inst -1 "1")
                          (("1" (replace -1)
                            (("1" (lemma "S2_recur_nn")
                              (("1" (inst -1 "1")
                                (("1" (replace -1) (("1" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (sigma_first formula-decl nil sigma nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (sigma_eq_arg formula-decl nil sigma nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (S2_recur_nn formula-decl nil stirling nil)
    (S2_recur_n0 formula-decl nil stirling nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (S2_recur def-decl "nat" stirling nil)
    (sigma_nat application-judgement "nat" sigma_nat nil)
    (Bell const-decl "nat" stirling nil))
   shostak))
 (Bell_2 0
  (Bell_2-1 nil 3710586215
   ("" (expand "Bell")
    (("" (lemma "sigma_first")
      (("" (inst?)
        (("" (split)
          (("1" (replace -1)
            (("1" (lemma "sigma_first")
              (("1" (hide -2)
                (("1" (inst?)
                  (("1" (split)
                    (("1" (replace -1)
                      (("1" (assert)
                        (("1" (lemma "sigma_eq_arg")
                          (("1" (inst?)
                            (("1" (replace -1)
                              (("1" (lemma "S2_recur_n0")
                                (("1" (inst -1 "2")
                                  (("1" (replace -1)
                                    (("1" (lemma "S2_recur_nn")
                                      (("1"
                                        (inst -1 "2")
                                        (("1"
                                          (replace -1)
                                          (("1"
                                            (expand "S2_recur" 1)
                                            (("1"
                                              (lemma "S2_recur_n0")
                                              (("1"
                                                (inst -1 "1")
                                                (("1"
                                                  (replace -1)
                                                  (("1"
                                                    (lemma "S2_recur_nn")
                                                    (("1"
                                                      (inst -1 "1")
                                                      (("1"
                                                        (replace -1)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (sigma_first formula-decl nil sigma nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (sigma_eq_arg formula-decl nil sigma nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (S2_recur_nn formula-decl nil stirling nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (S2_recur_n0 formula-decl nil stirling nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers nil)
    (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (S2_recur def-decl "nat" stirling nil)
    (sigma_nat application-judgement "nat" sigma_nat nil)
    (Bell const-decl "nat" stirling nil))
   shostak))
 (Bell_3 0
  (Bell_3-1 nil 3710586419
   ("" (expand "Bell")
    (("" (lemma "sigma_first")
      (("" (copy -1)
        (("" (inst?)
          (("" (split)
            (("1" (replace -1)
              (("1" (hide -1)
                (("1" (copy -1)
                  (("1" (inst?)
                    (("1" (split)
                      (("1" (replace -1)
                        (("1" (hide -1)
                          (("1" (inst?)
                            (("1" (split)
                              (("1" (replace -1)
                                (("1" (assert)
                                  (("1" (hide -1)
                                    (("1" (lemma "sigma_eq_arg")
                                      (("1"
                                        (inst?)
                                        (("1"
                                          (replace -1)
                                          (("1"
                                            (lemma "S2_recur_n0")
                                            (("1"
                                              (copy -1)
                                              (("1"
                                                (inst?)
                                                (("1"
                                                  (replace -1)
                                                  (("1"
                                                    (lemma "S2_recur_nn")
                                                    (("1"
                                                      (inst-cp -1 "3")
                                                      (("1"
                                                        (replace -2)
                                                        (("1"
                                                          (expand
                                                           "S2_recur"
                                                           1)
                                                          (("1"
                                                            (inst-cp -4 "2")
                                                            (("1"
                                                              (replace -5)
                                                              (("1"
                                                                (inst-cp
                                                                 -1
                                                                 "2")
                                                                (("1"
                                                                  (replace -2)
                                                                  (("1"
                                                                    (expand
                                                                     "S2_recur"
                                                                     1)
                                                                    (("1"
                                                                      (inst
                                                                       -1
                                                                       "1")
                                                                      (("1"
                                                                        (replace
                                                                         -1)
                                                                        (("1"
                                                                          (inst
                                                                           -5
                                                                           "1")
                                                                          (("1"
                                                                            (replace
                                                                             -5)
                                                                            (("1"
                                                                              (assert)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (sigma_first formula-decl nil sigma nil)
    (sigma_nat application-judgement "nat" sigma_nat nil)
    (S2_recur def-decl "nat" stirling nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil)
    (T_low type-eq-decl nil sigma nil)
    (sigma_eq_arg formula-decl nil sigma nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (int_times_even_is_even application-judgement "even_int" integers nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (S2_recur_nn formula-decl nil stirling nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (S2_recur_n0 formula-decl nil stirling nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (Bell const-decl "nat" stirling nil))
   shostak))
 (Bell_4 0
  (Bell_4-1 nil 3710586735 ("" (grind) nil nil)
   ((sigma_nat application-judgement "nat" sigma_nat nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (even_plus_even_is_even application-judgement "even_int" integers nil)
    (Bell const-decl "nat" stirling nil) (sigma def-decl "real" sigma nil)
    (S2_recur def-decl "nat" stirling nil))
   shostak))
 (Bell_5 0
  (Bell_5-1 nil 3710586768 ("" (grind) nil nil)
   ((sigma_nat application-judgement "nat" sigma_nat nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (even_plus_even_is_even application-judgement "even_int" integers nil)
    (Bell const-decl "nat" stirling nil) (sigma def-decl "real" sigma nil)
    (S2_recur def-decl "nat" stirling nil))
   shostak))
 (Bell_recur_TCC1 0
  (Bell_recur_TCC1-1 nil 3710588697 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil (Bell_recur subtype "(number_fields.-)(stirling.n, 1)" "nat")))
 (Bell_recur_TCC2 0
  (Bell_recur_TCC2-1 nil 3710588697 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (Bell_recur subtype "stirling.k"
    "{i: naturalnumbers.nat | reals.<=(i, (number_fields.-)(stirling.n, 1))}")))
 (Bell_recur_TCC3 0
  (Bell_recur_TCC3-1 nil 3710588697 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil (Bell_recur termination "stirling.Bell_recur(stirling.k)" "nil")))
 (Bell_recur_0 0
  (Bell_recur_0-1 nil 3710591894
   ("" (expand "Bell_recur") (("" (propax) nil nil)) nil)
   ((Bell_recur def-decl "nat" stirling nil)) shostak))
 (Bell_recur_1 0
  (Bell_recur_1-1 nil 3710591905
   ("" (expand "Bell_recur")
    (("" (lemma "sigma_eq_arg")
      (("" (inst?)
        (("1" (replace -1)
          (("1" (assert)
            (("1" (lemma "C_n")
              (("1" (inst -1 "0")
                (("1" (replace -1)
                  (("1" (lemma "Bell_recur_0")
                    (("1" (replace -1) (("1" (propax) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep) (("2" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (sigma_eq_arg formula-decl nil sigma nil)
    (C_n formula-decl nil binomial nil)
    (Bell_recur_0 formula-decl nil stirling nil)
    (sigma_nat application-judgement "nat" sigma_nat nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (C const-decl "posnat" binomial nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (Bell_recur def-decl "nat" stirling nil))
   shostak))
 (Bell_recur_2 0
  (Bell_recur_2-1 nil 3710591983 ("" (grind) nil nil)
   ((sigma_nat application-judgement "nat" sigma_nat nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (rat_plus_rat_is_rat application-judgement "rat" rationals nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (sigma_rat application-judgement "rational" sigma_nat nil)
    (sigma def-decl "real" sigma nil) (Bell_recur def-decl "nat" stirling nil)
    (C const-decl "posnat" binomial nil)
    (factorial def-decl "posnat" factorial ints))
   shostak))
 (Bell_recur_3 0
  (Bell_recur_3-1 nil 3710591999 ("" (grind) nil nil)
   ((sigma_nat application-judgement "nat" sigma_nat nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (rat_plus_rat_is_rat application-judgement "rat" rationals nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (sigma_rat application-judgement "rational" sigma_nat nil)
    (sigma def-decl "real" sigma nil) (Bell_recur def-decl "nat" stirling nil)
    (C const-decl "posnat" binomial nil)
    (factorial def-decl "posnat" factorial ints))
   shostak))
 (Bell_recur_4 0
  (Bell_recur_4-1 nil 3710592007 ("" (grind) nil nil)
   ((sigma_nat application-judgement "nat" sigma_nat nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (rat_plus_rat_is_rat application-judgement "rat" rationals nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (sigma_rat application-judgement "rational" sigma_nat nil)
    (sigma def-decl "real" sigma nil) (Bell_recur def-decl "nat" stirling nil)
    (C const-decl "posnat" binomial nil)
    (factorial def-decl "posnat" factorial ints))
   shostak))
 (Bell_recur_5 0
  (Bell_recur_5-1 nil 3710592011 ("" (grind) nil nil)
   ((sigma_nat application-judgement "nat" sigma_nat nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (rat_plus_rat_is_rat application-judgement "rat" rationals nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (sigma_rat application-judgement "rational" sigma_nat nil)
    (sigma def-decl "real" sigma nil) (Bell_recur def-decl "nat" stirling nil)
    (C const-decl "posnat" binomial nil)
    (factorial def-decl "posnat" factorial ints))
   shostak)))

