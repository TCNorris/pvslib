(product_fseq_posnat
 (len0 0
  (len0-1 nil 3407849052 ("" (grind) nil nil)
   ((product const-decl "posnat" product_fseq_posnat nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (product_fseq_shift_TCC1 0
  (product_fseq_shift_TCC1-1 nil 3410606942 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (product_fseq_shift subtype
    "(number_fields.-)(product_fseq_posnat.n, product_fseq_posnat.l1)"
    "nat")))
 (product_fseq_shift 0
  (product_fseq_shift-1 nil 3410261125
   ("" (skeep)
    (("" (lemma "product_shift")
      (("" (inst - "fs`seq" "l2 - 1" "0" "l1")
        (("" (assert)
          (("" (hide -1)
            (("" (lemma "product_shift_i")
              (("" (inst - "_" "l1 - 1 + l2" "_" "l1")
                (("" (inst - "fs`seq" "-l1")
                  (("" (assert)
                    (("" (replace -1)
                      (("" (hide -1)
                        (("" (real-props :simple? t)
                          (("" (rewrite "product_restrict_eq")
                            (("1" (hide 2)
                              (("1" (expand "restrict")
                                (("1" (propax) nil nil)) nil))
                              nil)
                             ("2" (hide 2) (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((product_shift formula-decl nil product_nat nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (prod_posnat application-judgement "posnat" product_nat nil)
    (product_shift_i formula-decl nil product_nat nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (add_neg formula-decl nil extra_tegies nil)
    (prod_nat application-judgement "nat" product_nat nil)
    (TRUE const-decl "bool" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (restrict const-decl "[T -> real]" product nil)
    (product_restrict_eq formula-decl nil product nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (< const-decl "bool" reals nil) (fsq type-eq-decl nil fsq structures)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (T_high type-eq-decl nil product nil)
    (T_low type-eq-decl nil product nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (fseq type-eq-decl nil fseqs structures)
    (barray type-eq-decl nil fseqs structures)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (product_fseq_concat 0
  (product_fseq_concat-2 "" 3790089480
   ("" (skeep)
    (("" (expand "product")
      (("" (lift-if)
        (("" (lift-if)
          (("" (lift-if)
            (("" (lift-if)
              (("" (expand "o ")
                (("" (lift-if)
                  (("" (lift-if)
                    (("" (lift-if)
                      (("" (ground)
                        (("1" (replace -1)
                          (("1" (assert)
                            (("1" (lemma "product_restrict_eq")
                              (("1"
                                (inst - "LAMBDA (n: nat):
                IF n < fs2`length THEN fs2`seq(n) ELSE default ENDIF"
                                 "fs2`seq" "length(fs2)-1" "0")
                                (("1" (assert)
                                  (("1" (expand "restrict")
                                    (("1" (propax) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (replace -1)
                          (("2" (hide -1)
                            (("2" (assert)
                              (("2" (lemma "product_restrict_eq")
                                (("2" (inst?)
                                  (("2" (assert)
                                    (("2" (expand "restrict")
                                      (("2" (propax) nil nil)) nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (lemma "product_split")
                          (("3" (inst?)
                            (("1" (inst - "length(fs1) - 1")
                              (("1" (assert)
                                (("1" (replace -1)
                                  (("1" (hide -1)
                                    (("1" (lemma "product_restrict_eq")
                                      (("1"
                                        (inst?)
                                        (("1"
                                          (inst - "fs1`seq")
                                          (("1"
                                            (split -1)
                                            (("1"
                                              (replace -1)
                                              (("1"
                                                (hide -1)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (cancel-by
                                                     2
                                                     "product(0, length(fs1) - 1, fs1`seq)")
                                                    (("1"
                                                      (lemma
                                                       "product_fseq_shift")
                                                      (("1"
                                                        (inst
                                                         -
                                                         "fs2"
                                                         "l(fs1)"
                                                         "l(fs2)"
                                                         "fs1")
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (replace -1 + rl)
                                                            (("1"
                                                              (hide -1)
                                                              (("1"
                                                                (lemma
                                                                 "product_restrict_eq")
                                                                (("1"
                                                                  (inst?)
                                                                  (("1"
                                                                    (assert)
                                                                    (("1"
                                                                      (hide 4)
                                                                      (("1"
                                                                        (expand
                                                                         "restrict")
                                                                        (("1"
                                                                          (propax)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (skosimp*)
                                                                    (("2"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil)
                                                                   ("3"
                                                                    (skosimp*)
                                                                    (("3"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (assert)
                                              (("2"
                                                (hide 3)
                                                (("2"
                                                  (expand "restrict")
                                                  (("2" (propax) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (skosimp*)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (skosimp*) (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (product_fseq_concat-1 nil 3411837139
   ("" (skeep)
    (("" (expand "product")
      (("" (lift-if)
        (("" (lift-if)
          (("" (lift-if)
            (("" (lift-if)
              (("" (expand "o ")
                (("" (lift-if)
                  (("" (lift-if)
                    (("" (lift-if)
                      (("" (ground)
                        (("1" (replace -1)
                          (("1" (assert)
                            (("1" (lemma "product_restrict_eq")
                              (("1"
                                (inst - "LAMBDA (n: nat):
                IF n < fs2`length THEN fs2`seq(n) ELSE default ENDIF"
                                 "fs2`seq" "length(fs2)-1" "0")
                                (("1" (assert)
                                  (("1" (expand "restrict")
                                    (("1" (propax) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (replace -1)
                          (("2" (hide -1)
                            (("2" (assert)
                              (("2" (assert)
                                (("2" (lemma "product_restrict_eq")
                                  (("2" (inst?)
                                    (("2" (assert)
                                      (("2"
                                        (expand "restrict")
                                        (("2" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (lemma "product_split")
                          (("3" (inst?)
                            (("1" (inst - "length(fs1) - 1")
                              (("1" (assert)
                                (("1" (replace -1)
                                  (("1" (hide -1)
                                    (("1" (lemma "product_restrict_eq")
                                      (("1"
                                        (inst?)
                                        (("1"
                                          (inst - "fs1`seq")
                                          (("1"
                                            (split -1)
                                            (("1"
                                              (replace -1)
                                              (("1"
                                                (hide -1)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (cancel-by
                                                     2
                                                     "product(0, length(fs1) - 1, fs1`seq)")
                                                    (("1"
                                                      (lemma
                                                       "product_fseq_shift")
                                                      (("1"
                                                        (inst
                                                         -
                                                         "fs2"
                                                         "l(fs1)"
                                                         "l(fs2)"
                                                         "fs1")
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (replace -1 + rl)
                                                            (("1"
                                                              (hide -1)
                                                              (("1"
                                                                (lemma
                                                                 "product_restrict_eq")
                                                                (("1"
                                                                  (inst?)
                                                                  (("1"
                                                                    (assert)
                                                                    (("1"
                                                                      (hide 4)
                                                                      (("1"
                                                                        (expand
                                                                         "restrict")
                                                                        (("1"
                                                                          (propax)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (skosimp*)
                                                                    (("2"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil)
                                                                   ("3"
                                                                    (skosimp*)
                                                                    (("3"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (skosimp*)
                                                      (("2" (assert) nil nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (assert)
                                              (("2"
                                                (hide 3)
                                                (("2"
                                                  (expand "restrict")
                                                  (("2" (propax) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (skosimp*)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (skosimp*) (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((product const-decl "posnat" product_fseq_posnat nil)
    (product_split formula-decl nil product nil)
    (product_fseq_shift formula-decl nil product_fseq_posnat nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (fsq type-eq-decl nil fsq structures)
    (posrat_times_posrat_is_posrat application-judgement "posrat" rationals
     nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (both_sides_times1 formula-decl nil real_props nil)
    (/= const-decl "boolean" notequal nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (product def-decl "real" product nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (fs1 skolem-const-decl "fseq[posnat]" product_fseq_posnat nil)
    (fs2 skolem-const-decl "fseq[posnat]" product_fseq_posnat nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (product_restrict_eq formula-decl nil product nil)
    (restrict const-decl "[T -> real]" product nil)
    (T_low type-eq-decl nil product nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (T_high type-eq-decl nil product nil) (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (default const-decl "T" fseqs structures)
    (fseq type-eq-decl nil fseqs structures)
    (barray type-eq-decl nil fseqs structures) (< const-decl "bool" reals nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (odd_times_odd_is_odd application-judgement "odd_int" integers nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (O const-decl "fseq" fseqs structures)
    (prod_posnat application-judgement "posnat" product_nat nil))
   nil))
 (product_fseq_empty_seq 0
  (product_fseq_empty_seq-1 nil 3410603231 ("" (grind) nil nil)
   ((posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (default const-decl "T" fseqs structures)
    (empty_seq const-decl "fsq" fseqs structures)
    (product const-decl "posnat" product_fseq_posnat nil)
    (empty_seq_fseq name-judgement "fseq[posnat]" product_fseq_posnat nil))
   shostak))
 (product_fseq_split_TCC1 0
  (product_fseq_split_TCC1-1 nil 3410602985 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (product_fseq_split subtype
    "(number_fields.-)(length(product_fseq_posnat.fs), 2)" "nat")))
 (product_fseq_split_TCC2 0
  (product_fseq_split_TCC2-1 nil 3410602985 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (product_fseq_split subtype
    "(number_fields.-)(length(product_fseq_posnat.fs), 1)" "nat")))
 (product_fseq_split 0
  (product_fseq_split-2 "" 3790089480
   ("" (skosimp*)
    (("" (expand "product")
      (("" (lift-if)
        (("" (lift-if)
          (("" (expand "^")
            (("" (expand "empty_seq")
              (("" (assert)
                (("" (lemma "product_last")
                  (("" (inst?)
                    (("" (assert)
                      (("" (replace -1)
                        (("" (hide -1)
                          (("" (lemma "product_restrict_eq")
                            (("" (inst?)
                              ((""
                                (inst - "(               LAMBDA (x: nat):
                 IF x < length(fs!1) - 1 THEN fs!1`seq(x)
                 ELSE default
                 ENDIF)")
                                (("" (assert)
                                  (("" (hide 2)
                                    (("" (expand "restrict")
                                      (("" (propax) nil nil)) nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (product_fseq_split-1 nil 3410603287
   ("" (skosimp*)
    (("" (expand "product")
      (("" (lift-if)
        (("" (lift-if)
          (("" (expand "^")
            (("" (expand "empty_seq")
              (("" (expand "min")
                (("" (assert)
                  (("" (lemma "product_last")
                    (("" (inst?)
                      (("" (assert)
                        (("" (replace -1)
                          (("" (hide -1)
                            (("" (lemma "product_restrict_eq")
                              (("" (inst?)
                                ((""
                                  (inst - "(               LAMBDA (x: nat):
                 IF x < length(fs!1) - 1 THEN fs!1`seq(x)
                 ELSE default
                 ENDIF)")
                                  (("" (assert)
                                    (("" (hide 2)
                                      ((""
                                        (expand "restrict")
                                        (("" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((product const-decl "posnat" product_fseq_posnat nil)
    (empty_seq const-decl "fsq" fseqs structures)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (product_last formula-decl nil product nil)
    (restrict const-decl "[T -> real]" product nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (< const-decl "bool" reals nil) (default const-decl "T" fseqs structures)
    (product_restrict_eq formula-decl nil product nil)
    (T_low type-eq-decl nil product nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (T_high type-eq-decl nil product nil) (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (fseq type-eq-decl nil fseqs structures)
    (barray type-eq-decl nil fseqs structures)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (^ const-decl "fseq" fseqs structures)
    (prod_posnat application-judgement "posnat" product_nat nil))
   nil))
 (product_fseq_ge 0
  (product_ge-3 nil 3410529255
   ("" (skosimp*)
    (("" (typepred "n!1")
      (("" (case "n!1 = length(fs!1) - 1")
        (("1" (expand "product")
          (("1" (lemma "product_last")
            (("1" (inst?)
              (("1" (assert)
                (("1" (replace -1)
                  (("1" (hide -1)
                    (("1" (replace -1 + rl)
                      (("1" (cancel-by 1 "fs!1`seq(n!1)")
                        (("1" (lemma "prod_posnat")
                          (("1" (inst?)
                            (("1" (lemma "prod_nat")
                              (("1" (inst?)
                                (("1" (flatten)
                                  (("1"
                                    (name-replace "II"
                                     "product(0, length(fs!1) - 2, fs!1`seq)")
                                    (("1" (assert) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "product")
          (("2" (lemma "product_middle")
            (("2" (inst?)
              (("2" (inst - "n!1")
                (("2" (assert)
                  (("2" (case "seq(fs!1)(n!1) = 0")
                    (("1" (assert) nil nil)
                     ("2" (replace -1)
                      (("2" (hide -1)
                        (("2" (cancel-by 3 "seq(fs!1)(n!1)")
                          (("2" (lemma "prod_posnat")
                            (("2" (inst?)
                              (("2" (lemma "prod_nat")
                                (("2" (inst?)
                                  (("2" (flatten)
                                    (("2" (lemma "prod_posnat")
                                      (("2"
                                        (inst - "_" "length(fs!1)-1" "1+n!1")
                                        (("2"
                                          (inst?)
                                          (("2"
                                            (lemma "prod_nat")
                                            (("2"
                                              (inst?)
                                              (("2"
                                                (flatten)
                                                (("2"
                                                  (name-replace
                                                   "II"
                                                   "product(0, n!1 - 1, fs!1`seq)")
                                                  (("2"
                                                    (name-replace
                                                     "JJ"
                                                     "product(1 + n!1, length(fs!1) - 1, fs!1`seq)")
                                                    (("2" (assert) nil nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (fseq type-eq-decl nil fseqs structures)
    (barray type-eq-decl nil fseqs structures)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers nil)
    (product_middle formula-decl nil product nil)
    (product const-decl "posnat" product_fseq_posnat nil)
    (T_low type-eq-decl nil product nil) (T_high type-eq-decl nil product nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (prod_posnat judgement-tcc nil product nil)
    (prod_nat judgement-tcc nil product nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat" rationals
     nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (both_sides_times_pos_ge1 formula-decl nil real_props nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (product def-decl "real" product nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (prod_posnat application-judgement "posnat" product_nat nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (product_last formula-decl nil product nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil))
   nil)
  (product_fseq_ge-2 nil 3410529222
   (";;; Proof product_ge-1 for formula product_seq.product_ge" (skosimp*)
    ((";;; Proof product_ge-1 for formula product_seq.product_ge"
      (lemma "product_mult")
      ((";;; Proof product_ge-1 for formula product_seq.product_ge"
        (inst -1 "fs!1^^(0,n!1)" "fs!1^^(n!1+1,length(fs!1)-1)")
        ((";;; Proof product_ge-1 for formula product_seq.product_ge"
          (case-replace
           "fs!1 ^^ (0, n!1) o fs!1 ^^ (n!1 + 1, length(fs!1) - 1) = fs!1")
          (("1" (hide -1)
            (("1" (hide -1)
              (("1" (expand "product")
                (("1" (lemma "product_middle")
                  (("1" (inst?)
                    (("1" (inst - "n!1")
                      (("1" (assert)
                        (("1" (replace -1)
                          (("1" (hide -1)
                            (("1" (cancel-by 1 "seq(fs!1)(n!1)")
                              nil)))))))))))))))))))
           ("2" (hide -1 2) (("2" (grind) nil))))))))))
    ";;; developed with shostak decision procedures")
   nil nil)
  (product_fseq_ge-1 nil 3407849048
   ("" (skosimp*)
    (("" (lemma "product_mult")
      (("" (inst -1 "fs!1^(0,n!1)" "fs!1^(n!1+1,length(fs!1)-1)")
        ((""
          (case-replace
           "fs!1 ^ (0, n!1) o fs!1 ^ (n!1 + 1, length(fs!1) - 1) = fs!1")
          (("1" (hide -1)
            (("1" (hide -1)
              (("1" (expand "product")
                (("1" (lemma "product_middle")
                  (("1" (inst?)
                    (("1" (inst - "n!1")
                      (("1" (assert)
                        (("1" (replace -1)
                          (("1" (hide -1)
                            (("1" (cancel-by 1 "seq(fs!1)(n!1)") nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (hide -1 2) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   nil nil))
 (product_fseq_concat1 0
  (product_fseq_concat1-3 "" 3790089483
   ("" (skeep)
    (("" (expand "product")
      (("" (expand "o")
        (("" (lift-if)
          (("" (lift-if)
            (("" (ground)
              (("1" (grind) nil nil)
               ("2" (lemma "product_const")
                (("2" (inst?)
                  (("2" (hide -1) (("2" (ground) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("3" (expand "fseq1")
                (("3" (expand "product" 2 2)
                  (("3" (cancel-by 2 "nn")
                    (("3" (lemma "product_eq")
                      (("3"
                        (inst - "fs`seq" "(LAMBDA (n: nat):
                     IF n < fs`length THEN fs`seq(n)
                     ELSIF n < 1 + fs`length THEN nn
                     ELSE default
                     ENDIF)" "fs`length-1" "0")
                        (("3" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (product_fseq_concat1-2 nil 3410607268
   ("" (skeep)
    (("" (expand "product")
      (("" (expand "o")
        (("" (lift-if)
          (("" (lift-if)
            (("" (ground)
              (("1" (replace -1) (("1" (grind) nil nil)) nil)
               ("2" (lemma "product_const")
                (("2" (inst?)
                  (("2" (hide -1) (("2" (ground) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("3" (expand "fseq1")
                (("3" (expand "product" 2 2)
                  (("3" (cancel-by 2 "nn")
                    (("3" (lemma "product_eq")
                      (("3"
                        (inst - "fs`seq" "(LAMBDA (n: nat):
                     IF n < fs`length THEN fs`seq(n)
                     ELSIF n < 1 + fs`length THEN nn
                     ELSE default
                     ENDIF)" "fs`length-1" "0")
                        (("3" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((product const-decl "posnat" product_fseq_posnat nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (prod_posnat application-judgement "posnat" product_nat nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (default const-decl "T" fseqs structures)
    (fseq1 const-decl "fseq" fseqs structures)
    (T_low type-eq-decl nil product nil) (T_high type-eq-decl nil product nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (product def-decl "real" product nil)
    (product_const formula-decl nil product nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (product_eq formula-decl nil product nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat" rationals
     nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (both_sides_times1 formula-decl nil real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fseq type-eq-decl nil fseqs structures)
    (barray type-eq-decl nil fseqs structures)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (O const-decl "fseq" fseqs structures))
   nil)
  (product_concat1-2 nil 3410528886
   ("" (skeep)
    (("" (expand "product")
      (("" (expand "++")
        (("" (lift-if)
          (("" (lift-if)
            (("" (ground)
              (("1" (replace -1) (("1" (grind) nil nil)) nil)
               ("2" (expand "gn1")
                (("2" (lemma "product_const")
                  (("2" (inst?)
                    (("2" (replace -1)
                      (("2" (hide -1)
                        (("2" (lift-if)
                          (("2" (ground)
                            (("2" (replace -2)
                              (("2" (assert) (("2" (grind) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (expand "gn1")
                (("3" (lemma "product_eq")
                  (("3" (inst?)
                    (("3"
                      (inst - "(LAMBDA (n: nat):
                         IF n < fs`length THEN fs`seq(n) ELSE nn ENDIF)")
                      (("3" (split -1)
                        (("1" (assert)
                          (("1" (expand "product" 2 2)
                            (("1" (assert) nil nil)) nil))
                          nil)
                         ("2" (skosimp*) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil nil)
  (product_fseq_concat1-1 nil 3407849048
   ("" (skeep)
    (("" (expand "product")
      (("" (expand "o ")
        (("" (expand "fseq1")
          (("" (lift-if)
            (("" (lift-if)
              (("" (ground)
                (("1" (replace -1) (("1" (grind) nil nil)) nil)
                 ("2" (lemma "product_eq")
                  (("2" (inst?)
                    (("2"
                      (inst - "(LAMBDA (n: nat):
                 IF n < fs`length THEN fs`seq(n) ELSE nn ENDIF)")
                      (("2" (split -1)
                        (("1" (assert)
                          (("1" (expand "product" 2 2)
                            (("1" (assert) nil nil)) nil))
                          nil)
                         ("2" (hide 3)
                          (("2" (skosimp*)
                            (("2" (lift-if) (("2" (ground) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil nil))
 (product_fseq1 0
  (product_fseq1-1 nil 3410609736 ("" (grind) nil nil)
   ((posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (default const-decl "T" fseqs structures)
    (fseq1 const-decl "fseq" fseqs structures)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (product def-decl "real" product nil)
    (product const-decl "posnat" product_fseq_posnat nil))
   shostak)))

