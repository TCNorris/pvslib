(log_int (log_int_TCC1 0 (log_int_TCC1-1 nil 3626601277 ("" (subtype-tcc) nil nil) nil nil (log_int subtype "z" "{i: integers.int | booleans.OR(log_int.p /= 0, reals.>=(i, 0))}"))) (log_int_TCC2 0 (log_int_TCC2-1 nil 3626601277 ("" (skeep) (("" (field) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (div_mult_pos_ge1 formula-decl nil real_props nil)) nil (log_int subtype "number_fields./(1, log_int.x)" "{x: reals.real | reals.>=(x, 1)}"))) (log_int_TCC3 0 (log_int_TCC3-2 "" 3790089015 ("" (skeep) (("" (skeep) (("" (typepred "LN`2") (("" (ground) (("" (replaces -4) (("" (ground) (("" (expand "^") (("" (ground) (("" (typepred "LN`1") (("" (lift-if 1) (("" (ground) (("1" (case "LN`1 = 0") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (-1 -2 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (cross-mult) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (div_cancel4 formula-decl nil real_props nil) (div_cancel3 formula-decl nil real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat nil) (expt def-decl "real" exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (TRUE const-decl "bool" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil)) shostak (log_int subtype "1" "{y: reals.real | booleans.AND(reals.<(y, log_int.p), booleans.AND(reals.>=(y, 1), log_int.x = number_fields.*(exponentiation.^(log_int.p, (number_fields.-)(log_int.LN`1)), y)))}")) (log_int_TCC3-1 nil 3626601277 ("" (skeep) (("" (skeep) (("" (typepred "LN`2") (("" (ground) (("" (replaces -4) (("" (ground) (("" (expand "^") (("" (ground) (("" (typepred "LN`1") (("" (lift-if 1) (("" (ground) (("1" (case "LN`1 = 0") (("1" (replaces -1) (("1" (ground) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 -2 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (cross-mult) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (log_int subtype "1" "{y: reals.real | booleans.AND(reals.<(y, log_int.p), booleans.AND(reals.>=(y, 1), log_int.x = number_fields.*(exponentiation.^(log_int.p, (number_fields.-)(log_int.LN`1)), y)))}"))) (log_int_TCC4 0 (log_int_TCC4-1 nil 3626601277 ("" (subtype-tcc) nil nil) ((posint_exp application-judgement "posint" exponentiation nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil)) nil (log_int subtype "log_int.LN`2" "nznum"))) (log_int_TCC5 0 (log_int_TCC5-2 "" 3803800237 ("" (skeep) (("" (skeep) (("" (case "FORALL (ll:{ z:real| z>1 AND z<p}): p/ll<p AND p/ll>=1") (("1" (inst -1 "LN`2") (("1" (ground) (("1" (typepred "LN`2") (("1" (expand "^") (("1" (expand "expt" 1) (("1" (simplify 1) (("1" (case-replace "-(-LN`1 - 1) - 1 = LN`1") (("1" (cross-mult) nil nil) ("2" (hide-all-but 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "LN`2") (("2" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (hide-all-but 1) (("2" (typepred "ll") (("2" (grind-reals) (("2" (typepred (p)) (("2" (both-sides "*" "p" -2) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (log_int subtype "number_fields./(log_int.p, log_int.LN`2)" "{y: reals.real | booleans.AND(reals.<(y, log_int.p), booleans.AND(reals.>=(y, 1), log_int.x = number_fields.*(exponentiation.^(log_int.p, (number_fields.-)((number_fields.-)(log_int.LN`1), 1)), y)))}")) (log_int_TCC5-1 nil 3626601277 ("" (skeep) (("" (skeep) (("" (case "FORALL (ll:{ z:real| z>1 AND z<p}): p/ll<p AND p/ll>=1") (("1" (inst -1 "LN`2") (("1" (ground) (("1" (typepred "LN`2") (("1" (expand "^") (("1" (expand "expt" 1) (("1" (simplify 1) (("1" (case-replace "-(-LN`1 - 1) - 1 = LN`1") (("1" (cross-mult) nil nil) ("2" (hide-all-but 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "LN`2") (("2" (ground) nil nil)) nil)) nil) ("2" (skeep) (("2" (hide-all-but 1) (("2" (typepred "ll") (("2" (grind-reals) (("2" (typepred (p)) (("2" (both-sides "*" "p" -2) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((gt_times_gt_pos2 formula-decl nil real_props nil) (both_sides_times_pos_gt1 formula-decl nil real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (LN skolem-const-decl "[n: nat, {y | y < p AND 1 / x = p ^ n * y}]" log_int nil) (^ const-decl "real" exponentiation nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (x skolem-const-decl "posreal" log_int nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (p skolem-const-decl "above(1)" log_int nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (expt def-decl "real" exponentiation nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_times_real_is_real application-judgement "real" reals nil) (div_cancel4 formula-decl nil real_props nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (div_mult_pos_ge1 formula-decl nil real_props nil) (div_cancel3 formula-decl nil real_props nil) (times_div2 formula-decl nil real_props nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (times_div1 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (posint_exp application-judgement "posint" exponentiation nil)) nil (log_int subtype "number_fields./(log_int.p, log_int.LN`2)" "{y: reals.real | booleans.AND(reals.<(y, log_int.p), booleans.AND(reals.>=(y, 1), log_int.x = number_fields.*(exponentiation.^(log_int.p, (number_fields.-)((number_fields.-)(log_int.LN`1), 1)), y)))}"))) (log_int_bounds_TCC1 0 (log_int_bounds_TCC1-1 nil 3626602204 ("" (subtype-tcc) nil nil) ((posrat_exp application-judgement "posrat" exponentiation nil)) nil (log_int_bounds subtype "log_int.z" "{i: integers.int | booleans.OR(log_int.p /= 0, reals.>=(i, 0))}"))) (log_int_bounds_TCC2 0 (log_int_bounds_TCC2-1 nil 3626602204 ("" (subtype-tcc) nil nil) ((posrat_exp application-judgement "posrat" exponentiation nil)) nil (log_int_bounds subtype "((number_fields.+)(log_int.z, 1))" "{i: integers.int | booleans.OR(log_int.p /= 0, reals.>=(i, 0))}"))) (log_int_bounds 0 (log_int_bounds-1 nil 3626603383 ("" (skeep) (("" (beta) (("" (typepred "log_int(x,p)`2") (("" (name-replace "yy" "log_int(x,p)`2") (("" (name-replace "zz" "log_int(x,p)`1") (("" (replace -3) (("" (split) (("1" (cancel-by 1 "p^zz") nil nil) ("2" (rewrite "expt_plus") (("2" (rewrite "expt_x1") (("2" (cancel-by 1 "p^zz") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nzreal nonempty-type-eq-decl nil reals nil) (expt_plus formula-decl nil exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (expt_x1 formula-decl nil exponentiation nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posrat nonempty-type-eq-decl nil rationals nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (real_times_real_is_real application-judgement "real" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (log_int const-decl "[z: int, {y: real | y < p AND y >= 1 AND x = p ^ z * y}]" log_int nil) (posrat_exp application-judgement "posrat" exponentiation nil)) shostak)) (log_int_incr 0 (log_int_incr-2 nil 3626603737 ("" (skeep :preds? t) (("" (lemma "log_int_bounds") (("" (inst-cp -1 "p" "x") (("" (inst -1 "p" "y") (("" (beta) (("" (flatten) (("" (name-replace "xx" "log_int(x, p)`1") (("" (name-replace "yy" "log_int(y, p)`1") (("" (lemma "both_sides_expt_gt1_lt") (("" (inst -1 "p" "xx" "yy") (("" (assert) (("" (hide 2) (("" (mult-by -3 "p") (("" (rewrite "expt_plus" -3) (("" (rewrite "expt_x1" -3) (("" (mult-by 1 "p") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((log_int_bounds formula-decl nil log_int nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzreal nonempty-type-eq-decl nil reals nil) (expt_plus formula-decl nil exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (expt_x1 formula-decl nil exponentiation nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (both_sides_expt_gt1_lt formula-decl nil exponentiation nil) (log_int const-decl "[z: int, {y: real | y < p AND y >= 1 AND x = p ^ z * y}]" log_int nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (posrat_exp application-judgement "posrat" exponentiation nil)) nil) (log_int_incr-1 nil 3626603664 ("" (postpone) nil nil) nil shostak)) (log_int_le 0 (log_int_le-1 nil 3626603768 ("" (skeep :preds? t) (("" (lemma "log_int_bounds") (("" (inst-cp -1 "p" "x") (("" (inst -1 "p" "y") (("" (beta) (("" (name-replace "zx" "log_int(x, p)`1") (("" (name-replace "zy" "log_int(y, p)`1") (("" (flip-ineq 1) (("" (case "zx>=zy+1") (("1" (hide -2) (("1" (lemma "both_sides_expt_gt1_le") (("1" (inst -1 "p" "zy+1" "zx") (("1" (flatten) (("1" (hide -1) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((log_int_bounds formula-decl nil log_int nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (log_int const-decl "[z: int, {y: real | y < p AND y >= 1 AND x = p ^ z * y}]" log_int nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (both_sides_expt_gt1_le formula-decl nil exponentiation nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (posrat_exp application-judgement "posrat" exponentiation nil)) shostak)))
