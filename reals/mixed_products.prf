(mixed_products (IMP_product_TCC1 0 (IMP_product_TCC1-1 nil 3569783305 ("" (lemma "connected_domain1") (("" (propax) nil nil)) nil) ((connected_domain1 formula-decl nil mixed_products nil)) nil (IMP_product assuming "product[T].product" "connected_domain: ASSUMPTION (FORALL (x, y: product.T), (z: integers.integer): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), product.T_pred(z)))"))) (IMP_product_TCC2 0 (IMP_product_TCC2-1 nil 3569783305 ("" (lemma "connected_domain2") (("" (propax) nil nil)) nil) ((connected_domain2 formula-decl nil mixed_products nil)) nil (IMP_product assuming "product[H].product" "connected_domain: ASSUMPTION (FORALL (x, y: product.T), (z: integers.integer): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), product.T_pred(z)))"))) (mixed_products_const_eq_TCC1 0 (mixed_products_const_eq_TCC1-1 nil 3537802727 ("" (skeep) (("" (lemma "T_pred_lem[T]") (("" (skeep) (("" (inst - "thigh" "tlow" "tlow + i") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((T formal-subtype-decl nil mixed_products nil) (T_pred const-decl "[int -> boolean]" mixed_products nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (T_pred_lem formula-decl nil product nil) (int_plus_int_is_int application-judgement "int" integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil product nil) (T_low type-eq-decl nil product nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (mixed_products_const_eq subtype "(number_fields.+)(mixed_products.tlow, mixed_products.i)" "T"))) (mixed_products_const_eq_TCC2 0 (mixed_products_const_eq_TCC2-2 nil 3537802968 ("" (skeep) (("" (lemma "T_pred_lem[H]") (("" (skeep) (("" (inst - "hhigh" "hlow" "hlow + i") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((H formal-subtype-decl nil mixed_products nil) (H_pred const-decl "[int -> boolean]" mixed_products nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (T_pred_lem formula-decl nil product nil) (int_plus_int_is_int application-judgement "int" integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil product nil) (T_low type-eq-decl nil product nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (mixed_products_const_eq subtype "(number_fields.+)(mixed_products.hlow, mixed_products.i)" "H")) (mixed_products_const_eq_TCC2-1 nil 3537802727 ("" (subtype-tcc) nil nil) nil nil (mixed_products_const_eq subtype "(number_fields.+)(mixed_products.hlow, mixed_products.i)" "H"))) (mixed_products_const_eq 0 (mixed_products_const_eq-2 "" 3803788273 ("" (case "FORALL (F: [T -> real], G: [H -> real], hhigh: T_high[H],
                                          hlow: T_low[H], thigh: T_high[T], tlow: T_low[T]):
                                    (thigh - tlow = hhigh - hlow AND
                                      (FORALL (i: nat):
                                         i <= thigh - tlow IMPLIES F(tlow + i) = G(hlow + i)))
                                     IMPLIES (FORALL (i: nat):
                                         i <= thigh - tlow IMPLIES product[T](tlow, tlow+i, F) = product[H](hlow, hlow+i, G))") (("1" (skeep) (("1" (inst - "F" "G" "hhigh" "hlow" "thigh" "tlow") (("1" (assert) (("1" (replace -3) (("1" (inst - "thigh-tlow") (("1" (assert) nil nil) ("2" (assert) (("2" (expand "product" +) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (induct "i") (("1" (assert) (("1" (flatten) (("1" (expand "product" +) (("1" (expand "product" +) (("1" (inst - "0") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (expand "product" +) (("2" (inst - "1+j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (lemma "T_pred_lem[H]") (("3" (inst - "hhigh" "hlow" "i+hlow") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (skeep) (("4" (lemma "T_pred_lem[T]") (("4" (inst - "thigh" "tlow" "i+tlow") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (lemma "T_pred_lem[H]") (("3" (assert) (("3" (inst - "hhigh" "hlow" "hlow + i") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) (("4" (lemma "T_pred_lem[T]") (("4" (inst - "thigh" "tlow" "i+tlow") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (skeep) (("5" (lemma "T_pred_lem[H]") (("5" (inst - "hhigh" "hlow" "hlow + i") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (lemma "T_pred_lem[T]") (("6" (inst - "thigh" "tlow" "i+tlow") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (mixed_products_const_eq-1 nil 3537802738 ("" (case "FORALL (F: [T -> real], G: [H -> real], hhigh: T_high[H],
                                   hlow: T_low[H], thigh: T_high[T], tlow: T_low[T]):
                             (thigh - tlow = hhigh - hlow AND
                               (FORALL (i: nat):
                                  i <= thigh - tlow IMPLIES F(tlow + i) = G(hlow + i)))
                              IMPLIES (FORALL (i: nat):
                                  i <= thigh - tlow IMPLIES product[T](tlow, tlow+i, F) = product[H](hlow, hlow+i, G))") (("1" (skeep) (("1" (inst - "F" "G" "hhigh" "hlow" "thigh" "tlow") (("1" (assert) (("1" (replace -3) (("1" (inst - "thigh-tlow") (("1" (assert) nil nil) ("2" (assert) (("2" (expand "product" +) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (induct "i") (("1" (assert) (("1" (flatten) (("1" (expand "product" +) (("1" (expand "product" +) (("1" (inst - "0") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (expand "product" +) (("2" (inst - "1+j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (lemma "T_pred_lem[H]") (("3" (inst - "hhigh" "hlow" "i+hlow") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (skeep) (("4" (lemma "T_pred_lem[T]") (("4" (inst - "thigh" "tlow" "i+tlow") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (lemma "T_pred_lem[H]") (("3" (inst - "hhigh" "hlow" "hlow + i1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) (("4" (lemma "T_pred_lem[T]") (("4" (inst - "thigh" "tlow" "i1+tlow") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (skeep) (("5" (lemma "T_pred_lem[H]") (("5" (inst - "hhigh" "hlow" "hlow + i") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (lemma "T_pred_lem[T]") (("6" (inst - "thigh" "tlow" "i+tlow") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((thigh skolem-const-decl "T_high[T]" mixed_products nil) (tlow skolem-const-decl "T_low[T]" mixed_products nil) (hlow skolem-const-decl "T_low[H]" mixed_products nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (T_pred_lem formula-decl nil product nil) (real_times_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (thigh skolem-const-decl "T_high[T]" mixed_products nil) (tlow skolem-const-decl "T_low[T]" mixed_products nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (T_pred const-decl "[int -> boolean]" mixed_products nil) (T formal-subtype-decl nil mixed_products nil) (H_pred const-decl "[int -> boolean]" mixed_products nil) (H formal-subtype-decl nil mixed_products nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil product nil) (T_low type-eq-decl nil product nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (product def-decl "real" product nil)) nil)) (mixed_products_eq 0 (mixed_products_eq-1 nil 3537802747 ("" (lemma "mixed_products_const_eq") (("" (inst - _ _ _ _ _ _ 1) (("" (assert) (("" (case "FORALL (aa:real): 1*aa = aa") (("1" (rewrite -1) (("1" (rewrite -1) nil nil)) nil) ("2" (hide-all-but 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_times_real_is_real application-judgement "real" reals nil) (mixed_products_const_eq formula-decl nil mixed_products nil)) nil)))
