(product_props
 (product_unfolding_theory_instantiation_TCC1 0
  (product_unfolding_theory_instantiation_TCC1-1 nil 3688124429
   ("" (subtype-tcc) nil nil) nil nil
   (product_unfolding_theory_instantiation subtype "product_props.low"
    "T_low[subrange(low_th, 1 + high_th)]")))
 (product_unfolding_theory_instantiation_TCC2 0
  (product_unfolding_theory_instantiation_TCC2-1 nil 3688124429
   ("" (subtype-tcc) nil nil) nil nil
   (product_unfolding_theory_instantiation subtype "product_props.high"
    "T_high[subrange(low_th, 1 + high_th)]")))
 (product_unfolding_theory_instantiation_TCC3 0
  (product_unfolding_theory_instantiation_TCC3-1 nil 3688124429
   ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (subrange type-eq-decl nil integers nil)
    (integer nonempty-type-from-decl nil integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (product_unfolding_theory_instantiation assuming
    "product[integers.subrange(product_props.low_th, (number_fields.+)(1, product_props.high_th))].product"
    "connected_domain: ASSUMPTION (FORALL (x, y: product.T), (z: integers.integer): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), product.T_pred(z)))")))
 (product_unfolding_theory_instantiation_TCC4 0
  (product_unfolding_theory_instantiation_TCC4-1 nil 3688124429
   ("" (subtype-tcc) nil nil) nil nil
   (product_unfolding_theory_instantiation subtype "product_props.low"
    "T_low[subrange(low_th, high_th)]")))
 (product_unfolding_theory_instantiation_TCC5 0
  (product_unfolding_theory_instantiation_TCC5-1 nil 3688124429
   ("" (subtype-tcc) nil nil) nil nil
   (product_unfolding_theory_instantiation subtype "product_props.high"
    "T_high[subrange(low_th, high_th)]")))
 (product_unfolding_theory_instantiation_TCC6 0
  (product_unfolding_theory_instantiation_TCC6-1 nil 3688124429
   ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (subrange type-eq-decl nil integers nil)
    (integer nonempty-type-from-decl nil integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (product_unfolding_theory_instantiation assuming
    "product[integers.subrange(product_props.low_th, product_props.high_th)].product"
    "connected_domain: ASSUMPTION (FORALL (x, y: product.T), (z: integers.integer): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), product.T_pred(z)))")))
 (product_unfolding_theory_instantiation 0
  (product_unfolding_theory_instantiation-2 "" 3790089464
   ("" (skeep :preds? t)
    (("" (generalize "high" "highG" "nat" :subterms-only? nil)
      (("1" (induct "highG")
        (("1" (flatten)
          (("1" (expand "product")
            (("1" (assert)
              (("1" (expand "product") (("1" (propax) nil nil)) nil)) nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (case "low=j+1")
            (("1" (expand "product" 1)
              (("1" (assert)
                (("1" (expand "product" 1) (("1" (propax) nil nil)) nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (expand "product" 2) (("2" (assert) nil nil)) nil)) nil))
            nil))
          nil)
         ("3" (skeep) (("3" (assert) nil nil)) nil)
         ("4" (skeep) (("4" (assert) nil nil)) nil))
        nil)
       ("2" (skeep) (("2" (assert) nil nil)) nil)
       ("3" (skeep) (("3" (assert) nil nil)) nil))
      nil))
    nil)
   nil shostak)
  (product_unfolding_theory_instantiation-1 nil 3688124430
   ("" (skeep :preds? t)
    (("" (generalize "high" "highG" "nat" :subterms-only? nil)
      (("1" (induct "highG")
        (("1" (flatten)
          (("1" (expand "product")
            (("1" (assert)
              (("1" (expand "product") (("1" (propax) nil nil)) nil)) nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (case "low=j+1")
            (("1" (expand "product" 1)
              (("1" (assert)
                (("1" (expand "product" 1) (("1" (propax) nil nil)) nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (expand "product" 2) (("2" (assert) nil nil)) nil)) nil))
            nil))
          nil)
         ("3" (skeep)
          (("3" (assert) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil))
          nil)
         ("4" (skeep) (("4" (assert) nil nil)) nil)
         ("5" (skeep) (("5" (skeep) (("5" (assert) nil nil)) nil)) nil)
         ("6" (skeep) (("6" (assert) nil nil)) nil))
        nil)
       ("2" (skeep)
        (("2" (assert) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)
       ("3" (skeep) (("3" (assert) nil nil)) nil)
       ("4" (skeep) (("4" (skeep) (("4" (assert) nil nil)) nil)) nil)
       ("5" (skeep) (("5" (assert) nil nil)) nil)
       ("6" (skeep) (("6" (assert) nil nil)) nil)
       ("7" (skeep) (("7" (assert) nil nil)) nil))
      nil))
    nil)
   ((product def-decl "real" product nil)
    (T_high type-eq-decl nil product nil) (T_low type-eq-decl nil product nil)
    (subrange type-eq-decl nil integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (high_th skolem-const-decl "{high_th: nat | high_th >= high}"
     product_props nil)
    (high skolem-const-decl "{high: nat | low <= high}" product_props nil)
    (low skolem-const-decl "{low: nat | low_th <= low}" product_props nil)
    (low_th skolem-const-decl "nat" product_props nil))
   shostak))
 (product_constrains_theory_TCC1 0
  (product_constrains_theory_TCC1-1 nil 3688124429 ("" (subtype-tcc) nil nil)
   nil nil
   (product_constrains_theory subtype "product_props.low" "T_low[nat]")))
 (product_constrains_theory_TCC2 0
  (product_constrains_theory_TCC2-1 nil 3688124429 ("" (subtype-tcc) nil nil)
   nil nil
   (product_constrains_theory subtype "product_props.high" "T_high[nat]")))
 (product_constrains_theory_TCC3 0
  (product_constrains_theory_TCC3-1 nil 3688124429 ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (integer nonempty-type-from-decl nil integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (product_constrains_theory assuming "product[nat].product"
    "connected_domain: ASSUMPTION (FORALL (x, y: product.T), (z: integers.integer): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), product.T_pred(z)))")))
 (product_constrains_theory_TCC4 0
  (product_constrains_theory_TCC4-1 nil 3688124429 ("" (subtype-tcc) nil nil)
   nil nil
   (product_constrains_theory subtype "product_props.low"
    "T_low[subrange(low, high)]")))
 (product_constrains_theory_TCC5 0
  (product_constrains_theory_TCC5-1 nil 3688124429 ("" (subtype-tcc) nil nil)
   nil nil
   (product_constrains_theory subtype "product_props.high"
    "T_high[subrange(low, high)]")))
 (product_constrains_theory_TCC6 0
  (product_constrains_theory_TCC6-1 nil 3688124429 ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (subrange type-eq-decl nil integers nil)
    (integer nonempty-type-from-decl nil integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (product_constrains_theory assuming
    "product[integers.subrange(product_props.low, product_props.high)].product"
    "connected_domain: ASSUMPTION (FORALL (x, y: product.T), (z: integers.integer): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), product.T_pred(z)))")))
 (product_constrains_theory 0
  (product_constrains_theory-2 "" 3790089465
   ("" (skeep)
    (("" (name "diff" "high-low")
      (("" (case "high = low + diff")
        (("1" (hide -2)
          (("1" (replace -1 * :actuals? t :hide? t)
            (("1"
              (case "(LAMBDA (x: subrange(low, high)): F(x))=(LAMBDA (x: subrange(low,low + diff)): F(x))")
              (("1" (hide -1)
                (("1" (generalize "diff" "diffG" "nat" :subterms-only? nil)
                  (("1" (expand "product" 2) (("1" (assert) nil nil)) nil)
                   ("2" (induct "diffG")
                    (("1" (expand "product" 1)
                      (("1" (expand "product" 1) (("1" (propax) nil nil))
                        nil))
                      nil)
                     ("2" (skeep)
                      (("2" (expand "product" 1)
                        (("2" (replace -1 1 :hide? t)
                          (("2"
                            (lemma "product_unfolding_theory_instantiation")
                            (("2"
                              (inst -1 "low" "low" "low + j" "low + j" "F")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("3" (skeep) (("3" (skeep) (("3" (assert) nil nil)) nil))
                      nil))
                    nil)
                   ("3" (skeep) (("3" (skeep) (("3" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (reveal -1)
                (("2" (hide 2)
                  (("2" (apply-extensionality)
                    (("2" (skeep)
                      (("2" (replace -1 1) (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (skeep)
                (("3" (reveal -1)
                  (("3" (replace -1 1) (("3" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   nil shostak)
  (product_constrains_theory-1 nil 3688124495
   ("" (skeep)
    (("" (name "diff" "high-low")
      (("" (case "high = low + diff")
        (("1" (hide -2)
          (("1" (replace -1 * :actuals? t :hide? t)
            (("1"
              (case "(LAMBDA (x: subrange(low, high)): F(x))=(LAMBDA (x: subrange(low,low + diff)): F(x))")
              (("1" (replace -1 1)
                (("1" (hide -1)
                  (("1" (generalize "diff" "diffG" "nat" :subterms-only? nil)
                    (("1" (expand "product" 2) (("1" (assert) nil nil)) nil)
                     ("2" (induct "diffG")
                      (("1" (expand "product" 1)
                        (("1" (expand "product" 1) (("1" (propax) nil nil))
                          nil))
                        nil)
                       ("2" (skeep)
                        (("2" (expand "product" 1)
                          (("2" (replace -1 1 :hide? t)
                            (("2"
                              (lemma "product_unfolding_theory_instantiation")
                              (("2"
                                (inst -1 "low" "low" "low + j" "low + j" "F")
                                (("2" (assert) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (skeep)
                        (("3" (skeep) (("3" (assert) nil nil)) nil)) nil))
                      nil)
                     ("3" (skeep) (("3" (skeep) (("3" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (reveal -1)
                (("2" (hide 2)
                  (("2" (apply-extensionality)
                    (("2" (skeep)
                      (("2" (replace -1 1) (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (skeep)
                (("3" (reveal -1)
                  (("3" (replace -1 1) (("3" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (subrange type-eq-decl nil integers nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (integer nonempty-type-from-decl nil integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (T_low type-eq-decl nil product nil) (T_high type-eq-decl nil product nil)
    (product def-decl "real" product nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (diff skolem-const-decl "int" product_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (product_unfolding_theory_instantiation formula-decl nil product_props
     nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (low skolem-const-decl "nat" product_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (high skolem-const-decl "{high: nat | low <= high}" product_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil))
   shostak)))

