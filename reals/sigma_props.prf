(sigma_props
 (sigma_unfolding_theory_instantiation_TCC1 0
  (sigma_unfolding_theory_instantiation_TCC1-1 nil 3688123610
   ("" (subtype-tcc) nil nil) nil nil
   (sigma_unfolding_theory_instantiation subtype "sigma_props.low"
    "T_low[subrange(low_th, 1 + high_th)]")))
 (sigma_unfolding_theory_instantiation_TCC2 0
  (sigma_unfolding_theory_instantiation_TCC2-1 nil 3688123610
   ("" (subtype-tcc) nil nil) nil nil
   (sigma_unfolding_theory_instantiation subtype "sigma_props.high"
    "T_high[subrange(low_th, 1 + high_th)]")))
 (sigma_unfolding_theory_instantiation_TCC3 0
  (sigma_unfolding_theory_instantiation_TCC3-1 nil 3688123610
   ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (subrange type-eq-decl nil integers nil)
    (integer nonempty-type-from-decl nil integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (sigma_unfolding_theory_instantiation assuming
    "sigma[integers.subrange(sigma_props.low_th, (number_fields.+)(1, sigma_props.high_th))]"
    "connected_domain: ASSUMPTION (FORALL (x, y: sigma.T), (z: integers.integer): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), sigma.T_pred(z)))")))
 (sigma_unfolding_theory_instantiation_TCC4 0
  (sigma_unfolding_theory_instantiation_TCC4-1 nil 3688123610
   ("" (subtype-tcc) nil nil) nil nil
   (sigma_unfolding_theory_instantiation subtype "sigma_props.low"
    "T_low[subrange(low_th, high_th)]")))
 (sigma_unfolding_theory_instantiation_TCC5 0
  (sigma_unfolding_theory_instantiation_TCC5-1 nil 3688123610
   ("" (subtype-tcc) nil nil) nil nil
   (sigma_unfolding_theory_instantiation subtype "sigma_props.high"
    "T_high[subrange(low_th, high_th)]")))
 (sigma_unfolding_theory_instantiation_TCC6 0
  (sigma_unfolding_theory_instantiation_TCC6-1 nil 3688123610
   ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (subrange type-eq-decl nil integers nil)
    (integer nonempty-type-from-decl nil integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (sigma_unfolding_theory_instantiation assuming
    "sigma[integers.subrange(sigma_props.low_th, sigma_props.high_th)]"
    "connected_domain: ASSUMPTION (FORALL (x, y: sigma.T), (z: integers.integer): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), sigma.T_pred(z)))")))
 (sigma_unfolding_theory_instantiation 0
  (sigma_unfolding_theory_instantiation-1 nil 3688123611
   ("" (skeep :preds? t)
    (("" (generalize "high" "highG" "nat" :subterms-only? nil)
      (("1" (induct "highG")
        (("1" (flatten)
          (("1" (expand "sigma")
            (("1" (assert)
              (("1" (expand "sigma") (("1" (propax) nil nil)) nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (case "low=j+1")
            (("1" (expand "sigma" 1)
              (("1" (assert)
                (("1" (expand "sigma" 1) (("1" (propax) nil nil)) nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (expand "sigma" 2) (("2" (propax) nil nil)) nil))
              nil))
            nil))
          nil)
         ("3" (skeep)
          (("3" (assert) (("3" (skeep) (("3" (assert) nil nil)) nil))
            nil))
          nil)
         ("4" (skeep) (("4" (assert) nil nil)) nil)
         ("5" (skeep) (("5" (skeep) (("5" (assert) nil nil)) nil)) nil)
         ("6" (skeep) (("6" (assert) nil nil)) nil))
        nil)
       ("2" (skeep)
        (("2" (assert) (("2" (skeep) (("2" (assert) nil nil)) nil))
          nil))
        nil)
       ("3" (skeep) (("3" (assert) nil nil)) nil)
       ("4" (skeep) (("4" (skeep) (("4" (assert) nil nil)) nil)) nil)
       ("5" (skeep) (("5" (assert) nil nil)) nil)
       ("6" (skeep) (("6" (assert) nil nil)) nil)
       ("7" (skeep) (("7" (assert) nil nil)) nil))
      nil))
    nil)
   ((sigma def-decl "real" sigma nil)
    (T_high type-eq-decl nil sigma nil)
    (T_low type-eq-decl nil sigma nil)
    (subrange type-eq-decl nil integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (integer nonempty-type-from-decl nil integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (high_th skolem-const-decl "{high_th: nat | high_th >= high}"
     sigma_props nil)
    (high skolem-const-decl "{high: nat | low <= high}" sigma_props
     nil)
    (low skolem-const-decl "{low: nat | low_th <= low}" sigma_props
     nil)
    (low_th skolem-const-decl "nat" sigma_props nil))
   shostak))
 (sigma_constrains_theory_TCC1 0
  (sigma_constrains_theory_TCC1-1 nil 3688123610
   ("" (subtype-tcc) nil nil) nil nil
   (sigma_constrains_theory subtype "sigma_props.low" "T_low[nat]")))
 (sigma_constrains_theory_TCC2 0
  (sigma_constrains_theory_TCC2-1 nil 3688123610
   ("" (subtype-tcc) nil nil) nil nil
   (sigma_constrains_theory subtype "sigma_props.high" "T_high[nat]")))
 (sigma_constrains_theory_TCC3 0
  (sigma_constrains_theory_TCC3-1 nil 3688123610
   ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (integer nonempty-type-from-decl nil integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (sigma_constrains_theory assuming "sigma[nat]"
    "connected_domain: ASSUMPTION (FORALL (x, y: sigma.T), (z: integers.integer): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), sigma.T_pred(z)))")))
 (sigma_constrains_theory_TCC4 0
  (sigma_constrains_theory_TCC4-1 nil 3688123610
   ("" (subtype-tcc) nil nil) nil nil
   (sigma_constrains_theory subtype "sigma_props.low"
    "T_low[subrange(low, high)]")))
 (sigma_constrains_theory_TCC5 0
  (sigma_constrains_theory_TCC5-1 nil 3688123610
   ("" (subtype-tcc) nil nil) nil nil
   (sigma_constrains_theory subtype "sigma_props.high"
    "T_high[subrange(low, high)]")))
 (sigma_constrains_theory_TCC6 0
  (sigma_constrains_theory_TCC6-1 nil 3688123610
   ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (subrange type-eq-decl nil integers nil)
    (integer nonempty-type-from-decl nil integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (sigma_constrains_theory assuming
    "sigma[integers.subrange(sigma_props.low, sigma_props.high)]"
    "connected_domain: ASSUMPTION (FORALL (x, y: sigma.T), (z: integers.integer): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), sigma.T_pred(z)))")))
 (sigma_constrains_theory 0
  (sigma_constrains_theory-2 "" 3744690915
   ("" (skeep)
    (("" (name "diff" "high-low")
      (("" (case "high = low + diff")
        (("1" (hide -2)
          (("1" (replace -1 * :actuals? t :hide? t)
            (("1" (generalize "diff" "diffG" "nat" :subterms-only? nil)
              (("1" (expand "sigma" 2) (("1" (assert) nil nil)) nil)
               ("2" (induct "diffG")
                (("1" (expand "sigma" 1)
                  (("1" (expand "sigma" 1) (("1" (propax) nil nil))
                    nil))
                  nil)
                 ("2" (skeep)
                  (("2" (expand "sigma" 1)
                    (("2" (replace -1 1 :hide? t)
                      (("2"
                        (lemma "sigma_unfolding_theory_instantiation")
                        (("2"
                          (inst -1 "low" "low" "low + j" "low + j" "F")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (skeep)
                  (("3" (skeep) (("3" (assert) nil nil)) nil)) nil))
                nil)
               ("3" (skeep)
                (("3" (skeep) (("3" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   nil shostak)
  (sigma_constrains_theory-1 nil 3688123699
   ("" (skeep)
    (("" (name "diff" "high-low")
      (("" (case "high = low + diff")
        (("1" (hide -2)
          (("1" (replace -1 * :actuals? t :hide? t)
            (("1"
              (case "(LAMBDA (x: subrange(low, high)): F(x))=(LAMBDA (x: subrange(low,low + diff)): F(x))")
              (("1" (replace -1 1)
                (("1" (hide -1)
                  (("1"
                    (generalize "diff" "diffG" "nat" :subterms-only?
                     nil)
                    (("1" (expand "sigma" 2) (("1" (assert) nil nil))
                      nil)
                     ("2" (induct "diffG")
                      (("1" (expand "sigma" 1)
                        (("1" (expand "sigma" 1)
                          (("1" (propax) nil nil)) nil))
                        nil)
                       ("2" (skeep)
                        (("2" (expand "sigma" 1)
                          (("2" (replace -1 1 :hide? t)
                            (("2"
                              (lemma
                               "sigma_unfolding_theory_instantiation")
                              (("2"
                                (inst
                                 -1
                                 "low"
                                 "low"
                                 "low + j"
                                 "low + j"
                                 "F")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (skeep)
                        (("3" (skeep) (("3" (assert) nil nil)) nil))
                        nil))
                      nil)
                     ("3" (skeep)
                      (("3" (skeep) (("3" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (reveal -1)
                (("2" (hide 2)
                  (("2" (apply-extensionality)
                    (("2" (skeep)
                      (("2" (replace -1 1) (("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (skeep)
                (("3" (reveal -1)
                  (("3" (replace -1 1) (("3" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (integer nonempty-type-from-decl nil integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (T_low type-eq-decl nil sigma nil)
    (T_high type-eq-decl nil sigma nil)
    (sigma def-decl "real" sigma nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (diff skolem-const-decl "int" sigma_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma_unfolding_theory_instantiation formula-decl nil sigma_props
     nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (low skolem-const-decl "nat" sigma_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil))
   shostak)))

