(permutation
 (inverse_id_TCC1 0
  (inverse_id_TCC1-1 nil 3281096170
   ("" (flatten) (("" (inst + "0") (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (N formal-const-decl "nat" permutation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak (inverse_id existence "" "naturalnumbers.below(permutation.N)")))
 (inverse_id 0
  (inverse_id-1 nil 3271175992
   ("" (flatten)
    (("" (decompose-equality)
      (("1" (typepred "inverse[below(N), below(N)](id)(x!1)")
        (("1" (expand "id") (("1" (propax) nil nil)) nil)
         ("2" (inst + "0") nil nil))
        nil)
       ("2" (inst + "0") nil nil))
      nil))
    nil)
   ((unique_bijective_inverse application-judgement "{x: D | f(x) = y}"
     function_inverse nil)
    (bijective_inverse_is_bijective application-judgement "(bijective?[R, D])"
     function_inverse nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (TRUE const-decl "bool" booleans nil)
    (inverse const-decl "D" function_inverse nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (below type-eq-decl nil naturalnumbers nil)
    (N formal-const-decl "nat" permutation nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   nil))
 (inverse_composition 0
  (inverse_composition-1 nil 3271175963
   ("" (skosimp*)
    (("" (decompose-equality)
      (("1" (typepred "pi!1 o rho!1")
        (("1" (expand "bijective?")
          (("1" (flatten)
            (("1" (hide -2)
              (("1" (expand "injective?")
                (("1" (inst?)
                  (("1" (assert)
                    (("1" (hide 2)
                      (("1" (typepred "inverse(pi!1 o rho!1)(x!1)")
                        (("1" (replace*)
                          (("1" (hide-all-but 1)
                            (("1" (expand "o ")
                              (("1"
                                (typepred
                                 "inverse(rho!1)(inverse(pi!1)(x!1))")
                                (("1" (typepred "inverse(pi!1)(x!1)")
                                  (("1" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (inst + "0") nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inst + "0") nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (inst + "0") nil nil))
      nil))
    nil)
   ((unique_bijective_inverse application-judgement "{x: D | f(x) = y}"
     function_inverse nil)
    (composition_bijective application-judgement "(bijective?[T1, T3])"
     function_props nil)
    (bijective_inverse_is_bijective application-judgement "(bijective?[R, D])"
     function_inverse nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (TRUE const-decl "bool" booleans nil)
    (inverse const-decl "D" function_inverse nil)
    (O const-decl "T3" function_props nil)
    (bijective? const-decl "bool" functions nil)
    (permutation nonempty-type-eq-decl nil permutation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (N formal-const-decl "nat" permutation nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (injective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   nil))
 (transpose_TCC1 0
  (transpose_TCC1-1 nil 3262705134
   ("" (skosimp*)
    (("" (expand "bijective?")
      (("" (split)
        (("1" (expand "injective?")
          (("1" (skosimp*)
            (("1" (lift-if)
              (("1" (lift-if)
                (("1" (assert)
                  (("1" (lift-if)
                    (("1" (ground)
                      (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "surjective?")
          (("2" (skosimp*)
            (("2"
              (inst +
               "IF y!1 = j!1 THEN i!1 ELSIF y!1 = i!1 THEN j!1 ELSE y!1 ENDIF")
              (("2" (lift-if) (("2" (lift-if) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((bijective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (N formal-const-decl "nat" permutation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (injective? const-decl "bool" functions nil))
   shostak
   (transpose subtype
    "LAMBDA k: IF permutation.k = permutation.j THEN permutation.i ELSIF permutation.k = permutation.i THEN permutation.j ELSE permutation.k ENDIF"
    "permutation")))
 (involutorian_transpose 0
  (involutorian_transpose-1 nil 3262704983
   ("" (skosimp*)
    (("" (expand "transpose")
      (("" (lift-if) (("" (lift-if) (("" (assert) nil nil)) nil)) nil)) nil))
    nil)
   ((transpose const-decl "permutation" permutation nil)) nil)))

