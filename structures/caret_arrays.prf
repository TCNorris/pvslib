(caret_arrays
 (caret_TCC1 0
  (caret_TCC1-1 nil 3506271670 ("" (subtype-tcc) nil nil)
   ((int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (caret subtype
    "(number_fields.+)((number_fields.-)(1, caret_arrays.p`1), caret_arrays.p`2)"
    "nat")))
 (caret_TCC2 0
  (caret_TCC2-1 nil 3506271670 ("" (same-name-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (N formal-const-decl "nat" caret_arrays nil)
    (below type-eq-decl nil nat_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil))
   nil
   (caret subtype
    "(number_fields.-)((number_fields.+)(1, caret_arrays.n), caret_arrays.m)"
    "nat")))
 (caret_TCC3 0
  (caret_TCC3-1 nil 3506271670 ("" (subtype-tcc) nil nil)
   ((posint_plus_nnint_is_posint application-judgement "posint" integers nil))
   nil
   (caret subtype "(number_fields.+)(caret_arrays.x, caret_arrays.m)"
    "naturalnumbers.below(caret_arrays.N)")))
 (caret_TCC4 0
  (caret_TCC4-1 nil 3506271670 ("" (same-name-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (N formal-const-decl "nat" caret_arrays nil)
    (below type-eq-decl nil nat_types nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil))
   nil
   (caret subtype
    "(LAMBDA (x: nat_types[(number_fields.+)((number_fields.-)(caret_arrays.n, caret_arrays.m), 1)].below): caret_arrays.A((number_fields.+)(x, caret_arrays.m)))"
    "below_array[LET (m, n) = p IN IF m > n THEN 0 ELSE n - m + 1 ENDIF, T]")))
 (caret_TCC5 0
  (caret_TCC5-1 nil 3506271670 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (N formal-const-decl "nat" caret_arrays nil)
    (below type-eq-decl nil nat_types nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (caret subtype "empty_array_def[caret_arrays.T].empty_array"
    "below_array[LET (m, n) = p IN IF m > n THEN 0 ELSE n - m + 1 ENDIF, T]")))
 (caret_all_TCC1 0
  (caret_all_TCC1-1 nil 3506271670 ("" (subtype-tcc) nil nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil (caret_all subtype "(number_fields.-)(caret_arrays.N, 1)" "below[N]")))
 (caret_all_TCC2 0
  (caret_all_TCC2-1 nil 3506271670 ("" (subtype-tcc) nil nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (caret_all subtype "caret_arrays.A"
    "below_array[IF 0 > N - 1 THEN 0 ELSE N ENDIF, T]")))
 (caret_all 0
  (caret_all-2 "" 3790081411
   ("" (skosimp*)
    (("" (apply-extensionality 1 :hide? t) (("" (grind) nil nil)) nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (> const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (N formal-const-decl "nat" caret_arrays nil)
    (below type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil caret_arrays nil)
    (^ const-decl
     "below_array[LET (m, n) = p IN IF m > n THEN 0 ELSE n - m + 1 ENDIF, T]"
     caret_arrays nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil nat_types nil)
    (below_array type-eq-decl nil below_arrays nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   shostak)
  (caret_all-1 nil 3506271670
   ("" (skosimp*)
    (("" (apply-extensionality 1 :hide? t)
      (("1" (grind) nil)
       ("2" (skosimp*)
        (("2" (assert)
          (("2" (typepred "y1!1")
            (("2" (lift-if) (("2" (ground) nil))))))))))))
    nil)
   ((below_array type-eq-decl nil below_arrays nil)) nil))
 (caret_ii_0 0
  (caret_ii_0-2 "" 3790081411 ("" (skosimp*) (("" (grind) nil nil)) nil)
   ((^ const-decl
     "below_array[LET (m, n) = p IN IF m > n THEN 0 ELSE n - m + 1 ENDIF, T]"
     caret_arrays nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   shostak)
  (caret_ii_0-1 nil 3506271670 ("" (skosimp*) (("" (grind) nil)) nil) nil
   nil))
 (caret_elim_TCC1 0
  (caret_elim_TCC1-1 nil 3506271670 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (N formal-const-decl "nat" caret_arrays nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil))
   nil
   (caret_elim subtype "caret_arrays.k"
    "naturalnumbers.below(IF reals.>(caret_arrays.i, caret_arrays.j) THEN 0 ELSE (number_fields.-)((number_fields.+)(1, caret_arrays.j), caret_arrays.i) ENDIF)")))
 (caret_elim_TCC2 0
  (caret_elim_TCC2-1 nil 3506271670 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (N formal-const-decl "nat" caret_arrays nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil))
   nil
   (caret_elim subtype "(number_fields.+)(caret_arrays.j, caret_arrays.k)"
    "naturalnumbers.below(caret_arrays.N)")))
 (caret_elim 0
  (caret_elim-2 "" 3790081412 ("" (skosimp*) (("" (grind) nil nil)) nil)
   ((^ const-decl
     "below_array[LET (m, n) = p IN IF m > n THEN 0 ELSE n - m + 1 ENDIF, T]"
     caret_arrays nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   shostak)
  (caret_elim-1 nil 3506271670 ("" (skosimp*) (("" (grind) nil)) nil) nil
   nil)))

