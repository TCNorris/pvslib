(map_with_index
 (map_with_index_rec_TCC1 0
  (map_with_index_rec_TCC1-2 "" 3790088396
   ("" (skeep :preds? t)
    (("" (expand "length" -2) (("" (assert) nil nil)) nil)) nil)
   nil shostak
   (map_with_index_rec subtype "map_with_index.i" "below[length[T1](r)]"))
  (map_with_index_rec_TCC1-1 nil 3686417320
   ("" (skeep :preds? t)
    (("" (replace -3 -2)
      (("" (expand "length" -2) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((length def-decl "nat" list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (map_with_index_rec subtype "map_with_index.i" "below[length[T1](r)]")))
 (map_with_index_rec_TCC2 0
  (map_with_index_rec_TCC2-2 "" 3790088396
   ("" (skeep :preds? t) (("" (assert) nil nil)) nil) nil shostak
   (map_with_index_rec subtype
    "(number_fields.+)(map_with_index.i, map_with_index.index)" "nat"))
  (map_with_index_rec_TCC2-1 nil 3686417320
   ("" (skeep :preds? t)
    (("" (replace -3 -2)
      (("" (replace -3 1 :hide? t)
        (("" (expand "length" -2)
          (("" (expand "length" 1 2) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (map_with_index_rec subtype
    "(number_fields.+)(map_with_index.i, map_with_index.index)" "nat")))
 (map_with_index_rec_TCC3 0
  (map_with_index_rec_TCC3-1 nil 3686594885 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (T formal-type-decl nil map_with_index nil)
    (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (subrange type-eq-decl nil integers nil)
    (T1 formal-type-decl nil map_with_index nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil))
   nil (map_with_index_rec subtype "map_with_index.i" "below[length[T](a)]")))
 (map_with_index_rec_TCC4 0
  (map_with_index_rec_TCC4-1 nil 3686594885
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (expand "length") (("1" (assert) nil nil)) nil)
       ("2" (skeep :preds? t)
        (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (length def-decl "nat" list_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (map_with_index_rec subtype "list_adt[map_with_index.T1].null"
    "{r: list_adt[map_with_index.T1].list | booleans.AND(list_props[map_with_index.T1].length(r) = list_props[map_with_index.T].length(map_with_index.a), FORALL (i: integers.subrange(0, (number_fields.-)(list_props[map_with_index.T1].length(r), 1))): list_props[map_with_index.T1].nth(r, i) = map_with_index.f((number_fields.+)(i, map_with_index.index), list_props[map_with_index.T].nth(map_with_index.a, i)))}")))
 (map_with_index_rec_TCC5 0
  (map_with_index_rec_TCC5-1 nil 3686594885 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (T formal-type-decl nil map_with_index nil)
    (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil))
   nil
   (map_with_index_rec subtype "map_with_index.cons2_var"
    "{a: list_adt[map_with_index.T].list | reals.<=(list_props[map_with_index.T].length(a), map_with_index.len)}")))
 (map_with_index_rec_TCC6 0
  (map_with_index_rec_TCC6-1 nil 3686594885
   ("" (skeep :preds? t)
    (("" (expand "length" 1 2)
      (("" (replace -3 1) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (map_with_index_rec termination
    "map_with_index.map_with_index_rec(map_with_index.len, naturalnumbers.succ(map_with_index.index), map_with_index.f, map_with_index.cons2_var)"
    "nil")))
 (map_with_index_rec_TCC7 0
  (map_with_index_rec_TCC7-1 nil 3686594985
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (replace -4 1)
        (("1" (expand "length" 1)
          (("1" (typepred "v(len,succ(index),f,cons2_var)")
            (("1" (propax) nil nil) ("2" (assert) nil nil)) nil))
          nil))
        nil)
       ("2" (skeep :preds? t)
        (("2" (expand "nth" 1 1)
          (("2" (case "i=0")
            (("1" (assert)
              (("1" (replace -1 1)
                (("1" (replace -7 1)
                  (("1" (expand "nth" 1) (("1" (propax) nil nil)) nil)) nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (typepred "v(len, succ(index), f, cons2_var)")
                (("1" (inst - "i-1")
                  (("1" (expand "succ" -2 2)
                    (("1" (replace -8 2)
                      (("1" (expand "nth" 2 2) (("1" (propax) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (expand "length" -3) (("2" (assert) nil nil)) nil))
                  nil)
                 ("2" (replace -6 -5)
                  (("2" (expand "length" -5) (("2" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((length def-decl "nat" list_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T1 formal-type-decl nil map_with_index nil)
    (list type-decl nil list_adt nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil map_with_index nil)
    (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (subrange type-eq-decl nil integers nil)
    (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (succ const-decl "nat" naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (i skolem-const-decl "subrange(0,
         length(cons(f(index, cons1_var),
                     v(len, succ(index), f, cons2_var)))
          - 1)" map_with_index nil)
    (cons2_var skolem-const-decl "list[T]" map_with_index nil)
    (v skolem-const-decl "[d1:
   {z: [len: nat, nat, [[nat, T] -> T1], {a: list[T] | length(a) <= len}] |
      length(z`4) < length(a)} ->
   {r: list[T1] |
      length(r) = length(d1`4) AND
       FORALL (i: subrange(0, length(r) - 1)):
         nth(r, i) = d1`3(i + d1`2, nth(d1`4, i))}]" map_with_index nil)
    (a skolem-const-decl "{a: list[T] | length(a) <= len}" map_with_index nil)
    (len skolem-const-decl "nat" map_with_index nil)
    (cons1_var skolem-const-decl "T" map_with_index nil)
    (index skolem-const-decl "nat" map_with_index nil)
    (f skolem-const-decl "[[nat, T] -> T1]" map_with_index nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil))
   nil
   (map_with_index_rec subtype
    "list_adt[map_with_index.T1].cons(map_with_index.f(map_with_index.index, map_with_index.cons1_var), map_with_index.map_with_index_rec(map_with_index.len, naturalnumbers.succ(map_with_index.index), map_with_index.f, map_with_index.cons2_var))"
    "{r: list_adt[map_with_index.T1].list | booleans.AND(list_props[map_with_index.T1].length(r) = list_props[map_with_index.T].length(map_with_index.a), FORALL (i: integers.subrange(0, (number_fields.-)(list_props[map_with_index.T1].length(r), 1))): list_props[map_with_index.T1].nth(r, i) = map_with_index.f((number_fields.+)(i, map_with_index.index), list_props[map_with_index.T].nth(map_with_index.a, i)))}")))
 (map_with_index_rec__relaxes_length_TCC1 0
  (map_with_index_rec__relaxes_length_TCC1-1 nil 3686587333
   ("" (subtype-tcc) nil nil) nil nil
   (map_with_index_rec__relaxes_length subtype "map_with_index.a"
    "{a: list_adt[map_with_index.T].list | reals.<=(list_props[map_with_index.T].length(a), map_with_index.len)}")))
 (map_with_index_rec__relaxes_length_TCC2 0
  (map_with_index_rec__relaxes_length_TCC2-1 nil 3686587333
   ("" (subtype-tcc) nil nil) ((succ const-decl "nat" naturalnumbers nil)) nil
   (map_with_index_rec__relaxes_length subtype "map_with_index.a"
    "{a: list_adt[map_with_index.T].list | reals.<=(list_props[map_with_index.T].length(a), naturalnumbers.succ(map_with_index.len))}")))
 (map_with_index_rec__relaxes_length 0
  (map_with_index_rec__relaxes_length-1 nil 3686587354
   ("" (skolem 1 ("f" "_" "_" "_"))
    (("" (induct "a")
      (("1" (skeep)
        (("1" (expand "map_with_index_rec") (("1" (propax) nil nil)) nil))
        nil)
       ("2" (skeep)
        (("2" (skeep :preds? t)
          (("2" (expand "map_with_index_rec" 1)
            (("2" (inst -3 "succ(i)" "len")
              (("1" (replace -3 1 :hide? t) (("1" (propax) nil nil)) nil)
               ("2" (hide 2)
                (("2" (expand "length" -2) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (skeep :preds? t)
        (("3" (expand "succ" 1) (("3" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((succ const-decl "nat" naturalnumbers nil)
    (length def-decl "nat" list_props nil) (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (T1 formal-type-decl nil map_with_index nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (subrange type-eq-decl nil integers nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (map_with_index_rec def-decl "{r: list[T1] |
   length(r) = length(a) AND
    FORALL (i: subrange(0, length(r) - 1)):
      nth(r, i) = f(index + i, nth(a, i))}" map_with_index nil)
    (T formal-type-decl nil map_with_index nil)
    (list_induction formula-decl nil list_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (cons2_var skolem-const-decl "list[T]" map_with_index nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons1_var skolem-const-decl "T" map_with_index nil)
    (len skolem-const-decl
     "{len: nat | length(cons(cons1_var, cons2_var)) <= len}" map_with_index
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil))
   shostak))
 (map_with_index_rec__preserves_length_TCC1 0
  (map_with_index_rec__preserves_length_TCC1-1 nil 3686586948
   ("" (subtype-tcc) nil nil) nil nil
   (map_with_index_rec__preserves_length subtype "map_with_index.a"
    "{a_1: list_adt[map_with_index.T].list | reals.<=(list_props[map_with_index.T].length(a_1), list_props[map_with_index.T].length(map_with_index.a))}")))
 (map_with_index_rec__preserves_length 0
  (map_with_index_rec__preserves_length-1 nil 3686495609
   ("" (skolem 1 ("f" "_" "_"))
    (("" (induct "a")
      (("1" (skeep)
        (("1" (expand "length")
          (("1" (expand "map_with_index_rec") (("1" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (skeep)
        (("2" (skeep)
          (("2" (expand "map_with_index_rec" 1)
            (("2" (expand "length" 1)
              (("2" (inst - "succ(i)")
                (("2" (lemma "map_with_index_rec__relaxes_length")
                  (("2" (inst - "f" "cons2_var" "succ(i)" "length(cons2_var)")
                    (("2" (replace -1 -2 :hide? t)
                      (("2" (expand "succ") (("2" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (T1 formal-type-decl nil map_with_index nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (subrange type-eq-decl nil integers nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (map_with_index_rec def-decl "{r: list[T1] |
   length(r) = length(a) AND
    FORALL (i: subrange(0, length(r) - 1)):
      nth(r, i) = f(index + i, nth(a, i))}" map_with_index nil)
    (T formal-type-decl nil map_with_index nil)
    (list_induction formula-decl nil list_adt nil)
    (map_with_index_rec__relaxes_length formula-decl nil map_with_index nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (succ const-decl "nat" naturalnumbers nil))
   shostak))
 (map_with_index__preserves_length 0
  (map_with_index__preserves_length-1 nil 3686488020
   ("" (expand "map_with_index")
    (("" (lemma "map_with_index_rec__preserves_length")
      (("" (skeep) (("" (inst - "f" "a" "0") nil nil)) nil)) nil))
    nil)
   ((map_with_index_rec__preserves_length formula-decl nil map_with_index nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil map_with_index nil)
    (T1 formal-type-decl nil map_with_index nil)
    (list type-decl nil list_adt nil)
    (map_with_index const-decl "list[T1]" map_with_index nil))
   shostak))
 (map_with_index__nth_TCC1 0
  (map_with_index__nth_TCC1-2 "" 3790088398
   ("" (skeep :preds? t)
    (("" (lemma "map_with_index__preserves_length")
      (("" (inst - "f" "a") (("" (replace -1 -3) (("" (propax) nil nil)) nil))
        nil))
      nil))
    nil)
   nil shostak
   (map_with_index__nth subtype "map_with_index.i"
    "below[length[T1](map_with_index(f)(a))]"))
  (map_with_index__nth_TCC1-1 nil 3686506217
   ("" (skeep :preds? t)
    (("" (lemma "map_with_index__preserves_length")
      (("" (inst - "f" "a") (("" (replace -1 -3) (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((map_with_index__preserves_length formula-decl nil map_with_index nil)
    (list type-decl nil list_adt nil)
    (T1 formal-type-decl nil map_with_index nil)
    (T formal-type-decl nil map_with_index nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil
   (map_with_index__nth subtype "map_with_index.i"
    "below[length[T1](map_with_index(f)(a))]")))
 (map_with_index__nth 0
  (map_with_index__nth-1 nil 3686588268
   ("" (skeep :preds? t)
    (("" (expand "map_with_index")
      (("" (typepred "map_with_index_rec(length(a), 0, f, a)")
        (("" (inst - "i") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((map_with_index const-decl "list[T1]" map_with_index nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (i skolem-const-decl "nat" map_with_index nil)
    (a skolem-const-decl "list[T]" map_with_index nil)
    (f skolem-const-decl "[[nat, T] -> T1]" map_with_index nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T1 formal-type-decl nil map_with_index nil)
    (list type-decl nil list_adt nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (T formal-type-decl nil map_with_index nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (subrange type-eq-decl nil integers nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (map_with_index_rec def-decl "{r: list[T1] |
   length(r) = length(a) AND
    FORALL (i: subrange(0, length(r) - 1)):
      nth(r, i) = f(index + i, nth(a, i))}" map_with_index nil))
   shostak)))

