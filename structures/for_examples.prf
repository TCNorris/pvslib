(for_examples
 (expit_TCC1 0
  (expit_TCC1-1 nil 3759603117 ("" (subtype-tcc) nil nil) nil nil
   (expit subtype
    "LAMBDA (i: naturalnumbers.below(for_examples.n), a: reals.real): number_fields.*(a, for_examples.x)"
    "for_iterate[real].ForBody(0, (number_fields.-)(for_examples.n, 1))")))
 (expit_test 0
  (expit_test-1 nil 3505593379 ("" (grind) nil nil)
   ((for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate nil)
    (for const-decl "T" for_iterate nil)
    (expit const-decl "real" for_examples nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   shostak))
 (expit_inv_TCC1 0
  (expit_inv_TCC1-1 nil 3759583715 ("" (subtype-tcc) nil nil) nil nil
   (expit_inv subtype "for_examples.i"
    "{i: integers.int | booleans.OR(for_examples.x /= 0, reals.>=(i, 0))}")))
 (expit_post_TCC1 0
  (expit_post_TCC1-1 nil 3759586342 ("" (subtype-tcc) nil nil) nil nil
   (expit_post subtype "for_examples.n"
    "{i: integers.int | booleans.OR(for_examples.x /= 0, reals.>=(i, 0))}")))
 (expit_sound 0
  (expit_sound-1 nil 3508441066
   ("" (skeep)
    (("" (expand "expit")
      (("" (lemma "for_invariant[real]")
        (("" (inst?)
          (("1" (inst -1 "expit_inv(x,n)")
            (("1" (rewrite "expt_x0")
              (("1" (assert)
                (("1" (hide 2) (("1" (grind) nil nil)) nil)) nil))
              nil)
             ("2" (hide 2) (("2" (grind) nil nil)) nil))
            nil)
           ("2" (hide 2) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((ForBody type-eq-decl nil for_iterate nil)
    (for_invariant formula-decl nil for_iterate nil))
   shostak))
 (factit_test 0
  (factit_test-1 nil 3505593275 ("" (grind) nil nil)
   ((for_down const-decl "T" for_iterate nil)
    (for const-decl "T" for_iterate nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate nil))
   shostak))
 (factit_sound 0
  (factit_sound-1 nil 3508421087
   ("" (skeep)
    (("" (case "n=0")
      (("1" (grind) nil nil)
       ("2" (expand "factit")
        (("2" (lemma "for_down_invariant[posnat]")
          (("2" (inst? -1)
            (("1" (inst -1 "factit_inv(n)")
              (("1" (assert)
                (("1" (hide 3)
                  (("1" (skeep)
                    (("1" (expand "factorial" -1 2)
                      (("1" (grind-reals) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide 3) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((factorial def-decl "posnat" factorial ints)
    (for_down const-decl "T" for_iterate nil)
    (for const-decl "T" for_iterate nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate nil)
    (for_down_invariant formula-decl nil for_iterate nil)
    (factorial_1 formula-decl nil factorial ints)
    (ForBody type-eq-decl nil for_iterate nil))
   shostak))
 (sum_array_logic_TCC1 0
  (sum_array_logic_TCC1-1 nil 3759586521 ("" (subtype-tcc) nil nil) nil
   nil
   (sum_array_logic subtype "(number_fields.-)(for_examples.i, 1)"
    "naturalnumbers.below(for_examples.n)")))
 (sum_array_logic_TCC2 0
  (sum_array_logic_TCC2-1 nil 3759586521 ("" (subtype-tcc) nil nil) nil
   nil
   (sum_array_logic subtype "(number_fields.-)(for_examples.i, 1)"
    "naturalnumbers.upto(for_examples.n)")))
 (sum_array_logic_TCC3 0
  (sum_array_logic_TCC3-1 nil 3759586521 ("" (termination-tcc) nil nil)
   nil nil
   (sum_array_logic termination
    "for_examples.sum_array_logic(for_examples.n, for_examples.A)((number_fields.-)(for_examples.i, 1))"
    "nil")))
 (sum_array_post_TCC1 0
  (sum_array_post_TCC1-1 nil 3759586521 ("" (subtype-tcc) nil nil) nil
   nil
   (sum_array_post subtype "for_examples.n"
    "naturalnumbers.upto(for_examples.n)")))
 (sum_array_sound 0
  (sum_array_sound-3 nil 3759589303
   ("" (skeep)
    (("" (expand "sum_array")
      (("" (lemma "for_invariant[real]")
        (("" (inst?)
          (("1" (inst -1 "sum_array_inv(n,A)")
            (("1" (assert)
              (("1" (hide 2)
                (("1" (split)
                  (("1" (grind) nil nil)
                   ("2" (skeep)
                    (("2" (lift-if)
                      (("2" (split)
                        (("1" (flatten)
                          (("1" (expand "sum_array_logic" +)
                            (("1" (assert) nil nil)) nil))
                          nil)
                         ("2" (flatten)
                          (("2" (expand "sum_array_logic" +)
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide 2) (("2" (grind) nil nil)) nil))
            nil)
           ("2" (hide 2) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((ForBody type-eq-decl nil for_iterate nil)
    (Maybe type-decl nil Maybe nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe nil)
    (for_invariant formula-decl nil for_iterate nil))
   nil)
  (sum_array_sound-2 nil 3759586570
   ("" (skeep)
    (("" (expand "expit")
      (("" (lemma "for_induction[real]")
        (("" (inst?)
          (("" (inst -1 "expit_inv(x,n)")
            (("" (rewrite "expt_x0")
              (("" (assert)
                (("" (hide 2)
                  (("" (skeep)
                    (("" (case-replace "x=0")
                      (("1" (grind) nil)
                       ("2" (rewrite "expt_plus")
                        (("2" (rewrite "expt_x1")
                          (("2" (assert) nil))))))))))))))))))))))))
    nil)
   nil nil)
  (sum_array_sound-1 nil 3759586538
   ("" (skeep)
    (("" (lemma "for_induction[real]")
      (("" (inst?) (("" (assert) (("" (postpone) nil nil)) nil)) nil))
      nil))
    nil)
   nil shostak))
 (maxit_TCC1 0
  (maxit_TCC1-1 nil 3505593581 ("" (grind) nil nil) nil nil
   (maxit subtype
    "(number_fields.-)(list_props[real].length(for_examples.l), 1)"
    "integers.upfrom(0)")))
 (maxit_TCC2 0
  (maxit_TCC2-1 nil 3508362429 ("" (subtype-tcc) nil nil) nil nil
   (maxit subtype
    "LAMBDA (i: naturalnumbers.below(list_props[real].length(for_examples.l))): list_props[real].nth(for_examples.l, i)"
    "for_iterate[real].IterateBody(0, (number_fields.-)(list_props[real].length(for_examples.l), 1))")))
 (maxit_test 0
  (maxit_test-1 nil 3505593776 ("" (grind) nil nil)
   ((for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate nil)
    (for const-decl "T" for_iterate nil)
    (iterate_left const-decl "T" for_iterate nil))
   shostak))
 (maxit_inv_TCC1 0
  (maxit_inv_TCC1-1 nil 3759694339 ("" (subtype-tcc) nil nil) nil nil
   (maxit_inv subtype "for_examples.k" "below[length[real](l)]")))
 (maxit_sound 0
  (maxit_sound-1 nil 3508424536
   ("" (skeep)
    (("" (expand "maxit")
      (("" (lemma "iterate_left_invariant[real]")
        (("" (inst? -1)
          (("1" (inst -1 "maxit_inv(l)")
            (("1" (split -1)
              (("1" (skeep) (("1" (insteep) nil nil)) nil)
               ("2" (hide 2) (("2" (grind) nil nil)) nil)
               ("3" (hide 2)
                (("3" (skosimp*)
                  (("3" (rewrite "max_ge")
                    (("3" (flatten)
                      (("3" (inst?) (("3" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide 2) (("2" (grind) nil nil)) nil))
            nil)
           ("2" (hide 2) (("2" (grind) nil nil)) nil)
           ("3" (hide 2) (("3" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((IterateBody type-eq-decl nil for_iterate nil)
    (iterate_left_invariant formula-decl nil for_iterate nil))
   shostak))
 (minit_test 0
  (minit_test-1 nil 3508284859 ("" (grind) nil nil)
   ((for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate nil)
    (for const-decl "T" for_iterate nil)
    (for_down const-decl "T" for_iterate nil)
    (iterate_right const-decl "T" for_iterate nil))
   shostak))
 (minit_inv_TCC1 0
  (minit_inv_TCC1-1 nil 3759745861 ("" (subtype-tcc) nil nil) nil nil
   (minit_inv subtype "for_examples.k" "below[length[real](l)]")))
 (minit_sound 0
  (minit_sound-1 nil 3508461473
   ("" (skeep)
    (("" (expand "minit")
      (("" (lemma "iterate_right_invariant[real]")
        (("" (inst?)
          (("1" (inst -1 "minit_inv(l)")
            (("1" (split -1)
              (("1" (skeep) (("1" (insteep) nil nil)) nil)
               ("2" (hide 2) (("2" (grind) nil nil)) nil)
               ("3" (hide 2)
                (("3" (skosimp*)
                  (("3" (rewrite "min_le")
                    (("3" (flatten)
                      (("3" (inst?) (("3" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide 2) (("2" (grind) nil nil)) nil))
            nil)
           ("2" (hide 2) (("2" (grind) nil nil)) nil)
           ("3" (hide 2) (("3" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((IterateBody type-eq-decl nil for_iterate nil)
    (iterate_right_invariant formula-decl nil for_iterate nil))
   shostak))
 (forall_and_upto_TCC1 0
  (forall_and_upto_TCC1-1 nil 3720484860 ("" (subtype-tcc) nil nil) nil
   nil
   (forall_and_upto subtype "for_examples.P"
    "for_iterate[booleans.bool].IterateBody(0, for_examples.n)")))
 (forall_and_upto 0
  (forall_and_upto-1 nil 3720484878
   ("" (skeep)
    (("" (lemma "iterate_left_induction[bool]")
      (("" (inst?)
        ((""
          (inst -1
           "LAMBDA(j:upto(n),a:bool):(FORALL(k:upto(j)):P(k)) = a")
          (("" (split -1)
            (("1" (propax) nil nil)
             ("2" (hide 2) (("2" (grind) nil nil)) nil)
             ("3" (hide 2)
              (("3" (skolem 1 ("kk" "ak"))
                (("3" (flatten)
                  (("3" (replaces -1 :dir rl)
                    (("3" (iff)
                      (("3" (split)
                        (("1" (flatten)
                          (("1" (split)
                            (("1" (skeep) (("1" (inst -1 "k") nil nil))
                              nil)
                             ("2" (inst -1 "kk+1")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2" (skeep)
                            (("2" (inst -1 "k")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((iterate_left_induction formula-decl nil for_iterate nil)
    (IterateBody type-eq-decl nil for_iterate nil))
   shostak))
 (forall_and_below_TCC1 0
  (forall_and_below_TCC1-1 nil 3720484986 ("" (subtype-tcc) nil nil)
   nil nil
   (forall_and_below subtype "(number_fields.-)(for_examples.n, 1)"
    "integers.upfrom(0)")))
 (forall_and_below 0
  (forall_and_below-1 nil 3720485076
   ("" (skeep)
    (("" (lemma "forall_and_upto")
      (("" (iff)
        (("" (inst -1 "n-1" "P")
          (("1" (split)
            (("1" (flatten)
              (("1" (assert)
                (("1" (skeep) (("1" (insteep) nil nil)) nil)) nil))
              nil)
             ("2" (flatten)
              (("2" (replaces -2 :dir rl)
                (("2" (skeep) (("2" (insteep) nil nil)) nil)) nil))
              nil))
            nil)
           ("2" (skeep)
            (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   nil nil))
 (forall_and_subrange 0
  (forall_and_subrange-2 nil 3720486550
   ("" (skeep)
    (("" (lemma "iterate_left_induction[bool]")
      (("" (inst?)
        ((""
          (inst -1
           "LAMBDA(j:upto(n-m),a:bool):(FORALL(k:subrange(m,m+j)):P(k)) = a")
          (("" (split -1)
            (("1" (propax) nil nil)
             ("2" (hide 2) (("2" (grind) nil nil)) nil)
             ("3" (hide 2)
              (("3" (skolem 1 ("kk" "ak"))
                (("3" (flatten)
                  (("3" (replaces -1 :dir rl)
                    (("3" (iff)
                      (("3" (split)
                        (("1" (flatten)
                          (("1" (split)
                            (("1" (skeep) (("1" (inst -1 "k") nil nil))
                              nil)
                             ("2" (inst -1 "kk+m+1")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2" (skeep)
                            (("2" (inst -1 "k")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((iterate_left_induction formula-decl nil for_iterate nil)
    (IterateBody type-eq-decl nil for_iterate nil))
   nil)
  (forall_and_subrange-1 nil 3720486166
   ("" (skeep)
    (("" (lemma "forall_and_upto")
      (("" (iff)
        (("" (inst -1 "n-1" "P")
          (("1" (split)
            (("1" (flatten)
              (("1" (assert) (("1" (skeep) (("1" (insteep) nil)))))))
             ("2" (flatten)
              (("2" (replaces -2 :dir rl)
                (("2" (skeep) (("2" (insteep) nil)))))))))
           ("2" (skeep)
            (("2" (hide-all-but 1) (("2" (grind) nil))))))))))))
    nil)
   nil nil))
 (exists_or_upto 0
  (exists_or_upto-1 nil 3782424154
   ("" (skeep)
    (("" (lemma "iterate_left_induction[bool]")
      (("" (inst?)
        ((""
          (inst -1
           "LAMBDA(j:upto(n),a:bool):(EXISTS(k:upto(j)):P(k)) = a")
          (("" (split -1)
            (("1" (propax) nil nil)
             ("2" (hide 2) (("2" (grind) nil nil)) nil)
             ("3" (hide 2)
              (("3" (skolem 1 ("kk" "ak"))
                (("3" (flatten)
                  (("3" (replaces -1 :dir rl)
                    (("3" (iff)
                      (("3" (split)
                        (("1" (flatten)
                          (("1" (skeep)
                            (("1" (insteep) (("1" (assert) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2" (split)
                            (("1" (skeep) (("1" (insteep) nil nil))
                              nil)
                             ("2" (inst 1 "kk+1")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (subrange type-eq-decl nil integers nil)
    (IterateBody type-eq-decl nil for_iterate nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (n skolem-const-decl "nat" for_examples nil)
    (kk skolem-const-decl "below(n)" for_examples nil)
    (k skolem-const-decl "upto(1 + kk)" for_examples nil)
    (PRED type-eq-decl nil defined_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (iterate_left_induction formula-decl nil for_iterate nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   nil))
 (exists_or_below 0
  (exists_or_below-1 nil 3782424249
   ("" (skeep)
    (("" (lemma "exists_or_upto")
      (("" (iff)
        (("" (inst -1 "n-1" "P")
          (("1" (split)
            (("1" (flatten)
              (("1" (assert)
                (("1" (skeep) (("1" (insteep) nil nil)) nil)) nil))
              nil)
             ("2" (flatten)
              (("2" (replaces -2 :dir rl)
                (("2" (skeep) (("2" (insteep) nil nil)) nil)) nil))
              nil))
            nil)
           ("2" (skeep)
            (("2" (hide-all-but 1)
              (("2" (split)
                (("1" (flatten) (("1" (assert) nil nil)) nil)
                 ("2" (flatten) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil nil))
 (exists_or_subrange 0
  (exists_or_subrange-1 nil 3782424343
   ("" (skeep)
    (("" (lemma "iterate_left_induction[bool]")
      (("" (inst?)
        ((""
          (inst -1
           "LAMBDA(j:upto(n-m),a:bool):(EXISTS(k:subrange(m,m+j)):P(k)) = a")
          (("" (split -1)
            (("1" (propax) nil nil)
             ("2" (hide 2)
              (("2" (iff)
                (("2" (split)
                  (("1" (flatten)
                    (("1" (skeep) (("1" (assert) nil nil)) nil)) nil)
                   ("2" (flatten) (("2" (inst 1 "m") nil nil)) nil))
                  nil))
                nil))
              nil)
             ("3" (hide 2)
              (("3" (skolem 1 ("kk" "ak"))
                (("3" (flatten)
                  (("3" (replaces -1 :dir rl)
                    (("3" (iff)
                      (("3" (split)
                        (("1" (flatten)
                          (("1" (skeep)
                            (("1" (insteep) (("1" (assert) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2" (split)
                            (("1" (skeep) (("1" (insteep) nil nil))
                              nil)
                             ("2" (inst 1 "kk+m+1")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (iterate_left_induction formula-decl nil for_iterate nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil nil (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (TRUE const-decl "bool" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IterateBody type-eq-decl nil for_iterate nil)
    (subrange type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil))
   nil)))

