(array2list
 (array2list_it_TCC1 0
  (array2list_it_TCC1-1 nil 3504888241 ("" (subtype-tcc) nil nil) nil nil
   (array2list_it subtype "array2list.j" "nat")))
 (array2list_it_TCC2 0
  (array2list_it_TCC2-1 nil 3504888241 ("" (subtype-tcc) nil nil) nil nil
   (array2list_it subtype "(number_fields.-)(array2list.j, array2list.i)"
    "below[length[T](l)]")))
 (array2list_it_TCC3 0
  (array2list_it_TCC3-1 nil 3504888241 ("" (subtype-tcc) nil nil) nil nil
   (array2list_it subtype "(number_fields.-)(array2list.n, array2list.i)"
    "naturalnumber")))
 (array2list_it_TCC4 0
  (array2list_it_TCC4-1 nil 3504888241 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (listn_0 name-judgement "listn[T](0)" array2list nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (array2list_it subtype "list_adt[array2list.T].null"
    "{l: listn[array2list.T].listn((number_fields.-)(array2list.n, array2list.i)) | FORALL (j: integers.subrange(array2list.i, (number_fields.-)(array2list.n, 1))): array2list.a(j) = list_props[array2list.T].nth(l, (number_fields.-)(j, array2list.i))}")))
 (array2list_it_TCC5 0
  (array2list_it_TCC5-1 nil 3504888241 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (array2list_it subtype "(number_fields.+)(array2list.i, 1)"
    "naturalnumbers.upto(array2list.n)")))
 (array2list_it_TCC6 0
  (array2list_it_TCC6-1 nil 3504888241 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)) nil
   (array2list_it termination
    "array2list.array2list_it(array2list.a, array2list.n, (number_fields.+)(array2list.i, 1))"
    "nil")))
 (array2list_it_TCC7 0
  (array2list_it_TCC7-1 nil 3504888741
   ("" (skosimp* :preds? t)
    (("" (name-replace "V23__" "v!1(a!1, n!1, i!1 + 1)" :hide? t)
      (("1" (typepred "V23__")
        (("1" (assert)
          (("1" (expand "length" 2)
            (("1" (skosimp 2)
              (("1" (expand "nth" 2)
                (("1" (case-replace "i!1=j!1")
                  (("1" (assert) nil nil)
                   ("2" (assert)
                    (("2" (inst -2 "j!1") (("2" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (assert) nil nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (T formal-nonempty-type-decl nil array2list nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil) (listn type-eq-decl nil listn nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (subrange type-eq-decl nil integers nil)
    (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (listn_0 name-judgement "listn[T](0)" array2list nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil))
   nil
   (array2list_it subtype
    "list_adt[array2list.T].cons(array2list.a(array2list.i), array2list.array2list_it(array2list.a, array2list.n, (number_fields.+)(array2list.i, 1)))"
    "{l: listn[array2list.T].listn((number_fields.-)(array2list.n, array2list.i)) | FORALL (j: integers.subrange(array2list.i, (number_fields.-)(array2list.n, 1))): array2list.a(j) = list_props[array2list.T].nth(l, (number_fields.-)(j, array2list.i))}")))
 (array2list_TCC1 0
  (array2list_TCC1-1 nil 3504888241 ("" (subtype-tcc) nil nil) nil nil
   (array2list subtype "array2list.i" "below[length[T](l)]")))
 (array2list_TCC2 0
  (array2list_TCC2-1 nil 3506897009 ("" (subtype-tcc) nil nil) nil nil
   (array2list subtype "0" "naturalnumbers.upto(array2list.n)")))
 (array2list_TCC3 0
  (array2list_TCC3-1 nil 3506897009
   ("" (skosimp*)
    (("" (typepred "array2list_it(a!1, n!1, 0)") (("" (inst?) nil nil)) nil))
    nil)
   ((array2list_it def-decl
     "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}"
     array2list nil)
    (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil) (subrange type-eq-decl nil integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (listn type-eq-decl nil listn nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil) (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (list type-decl nil list_adt nil)
    (T formal-nonempty-type-decl nil array2list nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (below type-eq-decl nil naturalnumbers nil))
   nil
   (array2list subtype
    "array2list.array2list_it(array2list.a, array2list.n, 0)"
    "{l: listn[array2list.T].listn(array2list.n) | FORALL (i: naturalnumbers.below(array2list.n)): array2list.a(i) = list_props[array2list.T].nth(l, i)}")))
 (list2array_TCC1 0
  (list2array_TCC1-1 nil 3546876078 ("" (subtype-tcc) nil nil)
   ((listn_0 name-judgement "listn[T](0)" array2list nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil (list2array subtype "array2list.l" "(list_adt[array2list.T].cons?)")))
 (list2array_TCC2 0
  (list2array_TCC2-1 nil 3546876078 ("" (subtype-tcc) nil nil)
   ((listn_0 name-judgement "listn[T](0)" array2list nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil (list2array subtype "array2list.l" "(list_adt[array2list.T].cons?)")))
 (list2array_TCC3 0
  (list2array_TCC3-1 nil 3546876078 ("" (termination-tcc) nil nil)
   ((listn_0 name-judgement "listn[T](0)" array2list nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (list2array termination
    "array2list.list2array(array2list.t)(list_adt[array2list.T].cdr(array2list.l))"
    "nil")))
 (list2array_TCC4 0
  (list2array_TCC4-1 nil 3546876078 ("" (subtype-tcc) nil nil)
   ((listn_0 name-judgement "listn[T](0)" array2list nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil (list2array subtype "(number_fields.-)(array2list.i, 1)" "nat")))
 (list2array_sound 0
  (list2array_sound-1 nil 3546876588
   ("" (induct "l")
    (("1" (grind) nil nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (lift-if)
          (("2" (split 1)
            (("1" (flatten)
              (("1" (expand "list2array")
                (("1" (case-replace "i=0")
                  (("1" (expand "nth") (("1" (propax) nil nil)) nil)
                   ("2" (replace 1)
                    (("2" (case-replace "null?(cons2_var)")
                      (("1" (hide -3 2) (("1" (grind) nil nil)) nil)
                       ("2" (replace 1)
                        (("2" (expand "length" -1)
                          (("2" (inst -2 "t" "i-1")
                            (("1" (assert)
                              (("1" (case-replace "i=1")
                                (("1" (assert)
                                  (("1" (expand "nth")
                                    (("1" (expand "list2array")
                                      (("1"
                                        (expand "nth")
                                        (("1" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert)
                                  (("2" (expand "list2array" 4)
                                    (("2" (expand "nth" 4)
                                      (("2" (propax) nil nil)) nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (expand "list2array" 2)
                (("2" (expand "length" 1)
                  (("2" (case-replace "i=0")
                    (("1" (assert) nil nil)
                     ("2" (assert)
                      (("2" (inst -1 "t" "i-1") (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers nil)
    (i skolem-const-decl "nat" array2list nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (listn_0 name-judgement "listn[T](0)" array2list nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-nonempty-type-decl nil array2list nil)
    (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil)
    (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (list2array def-decl "T" array2list nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (default_TCC1 0
  (default_TCC1-1 nil 3507123244 ("" (subtype-tcc) nil nil)
   ((member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil))
   nil
   (default subtype "{t: array2list.T | booleans.TRUE}"
    "(sets[array2list.T].nonempty?)")))
 (array2list_inv 0
  (array2list_inv-1 nil 3504897842
   ("" (skosimp :preds? t)
    (("" (rewrite "list2array_sound")
      (("" (typepred "array2list(n!1)(a!1)")
        (("" (inst? -) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((list2array_sound formula-decl nil array2list nil)
    (T formal-nonempty-type-decl nil array2list nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil) (listn type-eq-decl nil listn nil)
    (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil)
    (array2list const-decl
     "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list nil)
    (listn_0 name-judgement "listn[T](0)" array2list nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil))
   shostak))
 (list2array_inv_TCC1 0
  (list2array_inv_TCC1-1 nil 3504898126 ("" (subtype-tcc) nil nil)
   ((listn_0 name-judgement "listn[T](0)" array2list nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-nonempty-type-decl nil array2list nil)
    (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (array2list const-decl
     "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list nil))
   nil
   (list2array_inv subtype "array2list.i"
    "below[length[T](array2list(length[T](l))(list2array(t)(l)))]")))
 (list2array_inv 0
  (list2array_inv-1 nil 3504898148
   ("" (skosimp :preds? t)
    (("" (typepred "array2list(length(l!1))(list2array(t!1)(l!1))")
      (("" (inst? -)
        (("" (rewrite "list2array_sound") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((list2array def-decl "T" array2list nil)
    (array2list const-decl
     "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list nil)
    (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil)
    (listn type-eq-decl nil listn nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list2array_sound formula-decl nil array2list nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (listn_0 name-judgement "listn[T](0)" array2list nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-nonempty-type-decl nil array2list nil)
    (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil))
   shostak))
 (list2array_inv_ext 0
  (list2array_inv_ext-1 nil 3601720921
   ("" (skeep)
    (("" (lemma "list_extensionality[T]")
      (("" (inst?)
        (("" (assert)
          (("" (hide 2)
            (("" (skeep)
              (("" (lemma "list2array_inv") (("" (inst?) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-nonempty-type-decl nil array2list nil)
    (list_extensionality formula-decl nil more_list_props nil)
    (list2array_inv formula-decl nil array2list nil)
    (list2array def-decl "T" array2list nil)
    (array2list const-decl
     "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list nil)
    (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (listn type-eq-decl nil listn nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (listn_0 name-judgement "listn[T](0)" array2list nil))
   shostak))
 (fill_TCC1 0
  (fill_TCC1-2 nil 3546876565
   ("" (skosimp*)
    (("" (typepred "array2list(n!1)(LAMBDA (n: nat): t!1)")
      (("" (inst?) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((array2list const-decl
     "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list nil)
    (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (listn type-eq-decl nil listn nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (list type-decl nil list_adt nil)
    (T formal-nonempty-type-decl nil array2list nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (listn_0 name-judgement "listn[T](0)" array2list nil))
   nil
   (fill subtype
         "array2list.array2list(array2list.n)(LAMBDA (n: naturalnumbers.nat): array2list.t)"
     "{l: listn[array2list.T].listn(array2list.n) | FORALL (i: naturalnumbers.below(array2list.n)): list_props[array2list.T].nth(l, i) = array2list.t}"))
  (fill_TCC1-1 nil 3506901574 ("" (grind) nil nil) nil nil
   (fill subtype
         "array2list.array2list(array2list.n)(LAMBDA (n: naturalnumbers.nat): array2list.t)"
     "{l: listn[array2list.T].listn(array2list.n) | FORALL (i: naturalnumbers.below(array2list.n)): list_props[array2list.T].nth(l, i) = array2list.t}"))))

