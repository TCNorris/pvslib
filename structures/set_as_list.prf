(set_as_list
 (empty_sl_is_empty 0
  (empty_sl_is_empty-1 nil 3591613697
   ("" (skosimp*)
    (("" (split)
      (("1" (skosimp*)
        (("1" (expand "empty_sl?")
          (("1" (rewrite -1)
            (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil))
          nil))
        nil)
       ("2" (generalize "l!1" l)
        (("2" (induct l)
          (("1" (expand "empty_sl?") (("1" (propax) nil nil)) nil)
           ("2" (skosimp*)
            (("2" (inst -2 "cons1_var!1")
              (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((empty_sl? const-decl "bool" set_as_list nil)
    (member def-decl "bool" list_props nil)
    (list_induction formula-decl nil list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil set_as_list nil))
   shostak))
 (subset_sl?_TCC1 0
  (subset_sl?_TCC1-1 nil 3569678532
   ("" (skeep)
    (("" (rewrite -1) (("" (expand "member") (("" (propax) nil nil)) nil))
      nil))
    nil)
   ((member def-decl "bool" list_props nil)) nil
   (subset_sl? subtype "booleans.TRUE"
    "{b: booleans.bool | booleans.IFF(b, FORALL x: booleans.=>(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2)))}")))
 (subset_sl?_TCC2 0
  (subset_sl?_TCC2-1 nil 3569678532 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)) nil
   (subset_sl? termination
    "set_as_list.subset_sl?(set_as_list.q, set_as_list.l2)" "nil")))
 (subset_sl?_TCC3 0
  (subset_sl?_TCC3-1 nil 3569678532
   ("" (skeep)
    (("" (typepred "v(q, l2)")
      (("1" (split 1)
        (("1" (skosimp*)
          (("1" (assert)
            (("1" (rewrite -6)
              (("1" (expand "member" -3)
                (("1" (inst -4 "x!1") (("1" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil)
         ("2" (skosimp*)
          (("2" (assert)
            (("2" (inst-cp -1 "a")
              (("2" (rewrite -5)
                (("2" (expand "member" -2 1)
                  (("2" (assert)
                    (("2" (skosimp*)
                      (("2" (expand "member" -1 1)
                        (("2" (inst -1 "x!1") (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (rewrite -1) (("2" (expand <<) (("2" (propax) nil nil)) nil))
        nil))
      nil))
    nil)
   ((member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (T formal-type-decl nil set_as_list nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (subset_sl? subtype
    "booleans.AND(list_props[set_as_list.T].member(set_as_list.a, set_as_list.l2), set_as_list.subset_sl?(set_as_list.q, set_as_list.l2))"
    "{b: booleans.bool | booleans.IFF(b, FORALL x: booleans.=>(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2)))}")))
 (add_sl_TCC1 0
  (add_sl_TCC1-1 nil 3569678532
   ("" (skosimp*)
    (("" (expand "nonempty_sl?")
      (("" (expand "empty_sl?")
        (("" (rewrite -1)
          (("" (expand "member" 1 2)
            (("" (expand "member" 1)
              (("" (expand "member" 1)
                (("" (assert)
                  (("" (skosimp*)
                    (("" (split 1)
                      (("1" (ground) nil nil) ("2" (ground) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nonempty_sl? const-decl "bool" set_as_list nil)
    (member def-decl "bool" list_props nil)
    (empty_sl? const-decl "bool" set_as_list nil))
   nil
   (add_sl subtype "(: set_as_list.x :)"
    "{ll: (set_as_list.nonempty_sl?) | FORALL y: booleans.IFF(list_props[set_as_list.T].member(set_as_list.y, ll), (booleans.OR(set_as_list.x = set_as_list.y, list_props[set_as_list.T].member(set_as_list.y, set_as_list.l))))}")))
 (add_sl_TCC2 0
  (add_sl_TCC2-1 nil 3569678532
   ("" (skeep)
    (("" (rewrite -2)
      (("" (split 1)
        (("1" (grind) nil nil)
         ("2" (skosimp*)
          (("2" (expand "member" 1) (("2" (ground) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((member def-decl "bool" list_props nil)
    (nonempty_sl? const-decl "bool" set_as_list nil)
    (empty_sl? const-decl "bool" set_as_list nil))
   nil
   (add_sl subtype "set_as_list.l"
    "{ll: (set_as_list.nonempty_sl?) | FORALL y: booleans.IFF(list_props[set_as_list.T].member(set_as_list.y, ll), (booleans.OR(set_as_list.x = set_as_list.y, list_props[set_as_list.T].member(set_as_list.y, set_as_list.l))))}")))
 (add_sl_TCC3 0
  (add_sl_TCC3-1 nil 3569678532
   ("" (skeep)
    (("" (rewrite -1) (("" (expand <<) (("" (propax) nil nil)) nil)) nil))
    nil)
   ((<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)) nil
   (add_sl termination "set_as_list.add_sl(set_as_list.x, set_as_list.q)"
    "nil")))
 (add_sl_TCC4 0
  (add_sl_TCC4-1 nil 3569679497
   ("" (skeep)
    (("" (ground)
      (("1" (grind) nil nil)
       ("2" (typepred "v(x, q)")
        (("1" (skeep)
          (("1" (expand "member" 1 1)
            (("1" (inst -2 "y")
              (("1" (rewrite -2)
                (("1" (rewrite -3)
                  (("1" (hide -2)
                    (("1" (expand "member" 1 2) (("1" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (rewrite -1) (("2" (expand <<) (("2" (propax) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((empty_sl? const-decl "bool" set_as_list nil)
    (nonempty_sl? const-decl "bool" set_as_list nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil set_as_list nil) (list type-decl nil list_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   nil
   (add_sl subtype
    "list_adt[set_as_list.T].cons(set_as_list.a, set_as_list.add_sl(set_as_list.x, set_as_list.q))"
    "{ll: (set_as_list.nonempty_sl?) | FORALL y: booleans.IFF(list_props[set_as_list.T].member(set_as_list.y, ll), (booleans.OR(set_as_list.x = set_as_list.y, list_props[set_as_list.T].member(set_as_list.y, set_as_list.l))))}")))
 (remove_sl_TCC1 0
  (remove_sl_TCC1-1 nil 3569678532
   ("" (skeep)
    (("" (rewrite -1) (("" (expand "member") (("" (propax) nil nil)) nil))
      nil))
    nil)
   ((member def-decl "bool" list_props nil)) nil
   (remove_sl subtype "list_adt[set_as_list.T].null"
    "{ll: list_adt[set_as_list.T].list | FORALL y: booleans.IFF(list_props[set_as_list.T].member(set_as_list.y, ll), (booleans.AND(set_as_list.x /= set_as_list.y, list_props[set_as_list.T].member(set_as_list.y, set_as_list.l))))}")))
 (remove_sl_TCC2 0
  (remove_sl_TCC2-1 nil 3569678532 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)) nil
   (remove_sl termination
    "set_as_list.remove_sl(set_as_list.x, set_as_list.q)" "nil")))
 (remove_sl_TCC3 0
  (remove_sl_TCC3-1 nil 3569678532
   ("" (skeep)
    (("" (skeep)
      (("" (typepred "v(x, q)")
        (("" (inst -1 "y")
          (("" (rewrite -3)
            (("" (expand "member" 1 2)
              (("" (rewrite -1) (("" (hide -1) (("" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil set_as_list nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil) (member def-decl "bool" list_props nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil))
   nil
   (remove_sl subtype "set_as_list.remove_sl(set_as_list.x, set_as_list.q)"
    "{ll: list_adt[set_as_list.T].list | FORALL y: booleans.IFF(list_props[set_as_list.T].member(set_as_list.y, ll), (booleans.AND(set_as_list.x /= set_as_list.y, list_props[set_as_list.T].member(set_as_list.y, set_as_list.l))))}")))
 (remove_sl_TCC4 0
  (remove_sl_TCC4-1 nil 3569678532
   ("" (skeep)
    (("" (skeep)
      (("" (typepred "v(x, q)")
        (("" (inst -1 "y")
          (("" (rewrite -2)
            (("" (expand "member" 2)
              (("" (rewrite -1) (("" (hide -1) (("" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil set_as_list nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil) (member def-decl "bool" list_props nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil))
   nil
   (remove_sl subtype
    "list_adt[set_as_list.T].cons(set_as_list.a, set_as_list.remove_sl(set_as_list.x, set_as_list.q))"
    "{ll: list_adt[set_as_list.T].list | FORALL y: booleans.IFF(list_props[set_as_list.T].member(set_as_list.y, ll), (booleans.AND(set_as_list.x /= set_as_list.y, list_props[set_as_list.T].member(set_as_list.y, set_as_list.l))))}")))
 (equal_sl_TCC1 0
  (equal_sl_TCC1-1 nil 3569678532
   ("" (skeep)
    (("" (typepred "subset_sl?(l1, l2)")
      (("" (typepred "subset_sl?(l2, l1)") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((subset_sl? def-decl
     "{b: bool | b IFF FORALL x: member(x, l1) => member(x, l2)}" set_as_list
     nil)
    (member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil) (T formal-type-decl nil set_as_list nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (equal_sl subtype
    "booleans.AND(set_as_list.subset_sl?(set_as_list.l1, set_as_list.l2), set_as_list.subset_sl?(set_as_list.l2, set_as_list.l1))"
    "{b: booleans.bool | booleans.IFF(b, FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2)))}")))
 (strict_subset_sl?_TCC1 0
  (strict_subset_sl?_TCC1-1 nil 3569678532
   ("" (skeep) (("" (expand "equal_sl") (("" (grind) nil nil)) nil)) nil)
   ((equal_sl const-decl
     "{b: bool | b IFF FORALL x: member(x, l1) IFF member(x, l2)}" set_as_list
     nil))
   nil
   (strict_subset_sl? subtype
    "booleans.&(set_as_list.subset_sl?(set_as_list.l1, set_as_list.l2), (booleans.NOT)(set_as_list.subset_sl?(set_as_list.l2, set_as_list.l1)))"
    "{b: booleans.bool | booleans.IFF(b, booleans.&(set_as_list.subset_sl?(set_as_list.l1, set_as_list.l2), (booleans.NOT)(set_as_list.equal_sl(set_as_list.l2, set_as_list.l1))))}")))
 (union_sl_TCC1 0
  (union_sl_TCC1-1 nil 3569678532
   ("" (skeep)
    (("" (rewrite -1) (("" (expand "member" 1 2) (("" (propax) nil nil)) nil))
      nil))
    nil)
   ((member def-decl "bool" list_props nil)) nil
   (union_sl subtype "set_as_list.l2"
    "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.OR(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2))))}")))
 (union_sl_TCC2 0
  (union_sl_TCC2-1 nil 3569678532 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)) nil
   (union_sl termination "set_as_list.union_sl(set_as_list.q, set_as_list.l2)"
    "nil")))
 (union_sl_TCC3 0
  (union_sl_TCC3-1 nil 3569678532
   ("" (skeep)
    (("" (skeep)
      (("" (typepred "v(q, l2)")
        (("" (typepred "add_sl(a, v(q, l2))")
          (("" (rewrite -4)
            (("" (inst -2 "x")
              (("" (inst -3 "x")
                (("" (rewrite -2)
                  (("" (rewrite -3)
                    (("" (expand "member" 1 3)
                      (("" (assert)
                        (("" (hide -1 -2 -3) (("" (ground) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((add_sl def-decl
     "{ll: (nonempty_sl?) | FORALL y: member(y, ll) IFF (x = y OR member(y, l))}"
     set_as_list nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nonempty_sl? const-decl "bool" set_as_list nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil set_as_list nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil) (member def-decl "bool" list_props nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil))
   nil
   (union_sl subtype
    "set_as_list.add_sl(set_as_list.a, set_as_list.union_sl(set_as_list.q, set_as_list.l2))"
    "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.OR(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2))))}")))
 (intersection_sl_TCC1 0
  (intersection_sl_TCC1-1 nil 3569678532
   ("" (skosimp*)
    (("" (rewrite -1)
      (("" (expand "member" 1 (1 2)) (("" (propax) nil nil)) nil)) nil))
    nil)
   ((member def-decl "bool" list_props nil)) nil
   (intersection_sl subtype "list_adt[set_as_list.T].null"
    "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.AND(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2))))}")))
 (intersection_sl_TCC2 0
  (intersection_sl_TCC2-1 nil 3569678532
   ("" (skeep)
    (("" (skeep)
      (("" (typepred "v(q, l2)")
        (("" (expand "member" 1 1)
          (("" (inst -1 "x")
            (("" (rewrite -1)
              (("" (hide -1)
                (("" (rewrite -2)
                  (("" (expand "member" 1 3) (("" (ground) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil set_as_list nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil) (member def-decl "bool" list_props nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil))
   nil
   (intersection_sl subtype
    "list_adt[set_as_list.T].cons(set_as_list.a, set_as_list.intersection_sl(set_as_list.q, set_as_list.l2))"
    "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.AND(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2))))}")))
 (intersection_sl_TCC3 0
  (intersection_sl_TCC3-1 nil 3569678532
   ("" (skeep)
    (("" (skeep)
      (("" (typepred "v(q, l2)")
        (("" (rewrite -2)
          (("" (inst -1 "x")
            (("" (rewrite -1)
              (("" (hide -1)
                (("" (expand "member" 2 3) (("" (ground) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil set_as_list nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil) (member def-decl "bool" list_props nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil))
   nil
   (intersection_sl subtype
    "set_as_list.intersection_sl(set_as_list.q, set_as_list.l2)"
    "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.AND(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2))))}")))
 (difference_sl_TCC1 0
  (difference_sl_TCC1-1 nil 3569678532
   ("" (skeep)
    (("" (skeep)
      (("" (rewrite -1) (("" (expand "member" 1) (("" (propax) nil nil)) nil))
        nil))
      nil))
    nil)
   ((member def-decl "bool" list_props nil)) nil
   (difference_sl subtype "list_adt[set_as_list.T].null"
    "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.AND(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), (booleans.NOT)(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2)))))}")))
 (difference_sl_TCC2 0
  (difference_sl_TCC2-1 nil 3569678532
   ("" (skeep)
    (("" (skeep)
      (("" (typepred "v(q, l2)")
        (("" (rewrite -3)
          (("" (inst -1 "x")
            (("" (rewrite -1)
              (("" (hide -1)
                (("" (expand "member" 1 3) (("" (ground) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil set_as_list nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil) (member def-decl "bool" list_props nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil))
   nil
   (difference_sl subtype
    "set_as_list.difference_sl(set_as_list.q, set_as_list.l2)"
    "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.AND(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), (booleans.NOT)(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2)))))}")))
 (difference_sl_TCC3 0
  (difference_sl_TCC3-1 nil 3569678532
   ("" (skeep)
    (("" (skeep)
      (("" (typepred "v(q, l2)")
        (("" (inst -1 "x")
          (("" (rewrite -2)
            (("" (expand "member" 2 (1 2))
              (("" (rewrite -1) (("" (hide -1) (("" (ground) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil set_as_list nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil) (member def-decl "bool" list_props nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil))
   nil
   (difference_sl subtype
    "list_adt[set_as_list.T].cons(set_as_list.a, set_as_list.difference_sl(set_as_list.q, set_as_list.l2))"
    "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.AND(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), (booleans.NOT)(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2)))))}")))
 (list2set_TCC1 0
  (list2set_TCC1-1 nil 3569678532
   ("" (skeep)
    (("" (rewrite -1)
      (("" (expand "member" 1)
        (("" (ground) (("" (expand "emptyset") (("" (propax) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set" set_as_list nil)
    (emptyset const-decl "set" sets nil)
    (member def-decl "bool" list_props nil))
   nil
   (list2set subtype "sets[set_as_list.T].emptyset"
    "{s: finite_sets[set_as_list.T].finite_set | s = {x | list_props[set_as_list.T].member(set_as_list.x, set_as_list.l)}}")))
 (list2set_TCC2 0
  (list2set_TCC2-1 nil 3569678532
   ("" (skeep)
    (("" (expand "add")
      (("" (typepred "v(q)")
        (("1" (rewrite -3)
          (("1" (expand "member" 1 2)
            (("1" (rewrite -2)
              (("1" (expand "member" 1 1)
                (("1" (assert)
                  (("1" (lemma "extensionality[T]")
                    (("1" (inst? -1)
                      (("1" (split -1)
                        (("1" (propax) nil nil)
                         ("2" (hide 2)
                          (("2" (skeep)
                            (("2" (expand "member" 1 (1 3))
                              (("2" (ground) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (rewrite -1) (("2" (expand <<) (("2" (propax) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((add const-decl "(nonempty?)" sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (extensionality formula-decl nil sets_lemmas nil)
    (member const-decl "bool" sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil set_as_list nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (list type-decl nil list_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (member def-decl "bool" list_props nil))
   nil
   (list2set subtype
    "sets[set_as_list.T].add(set_as_list.a, set_as_list.list2set(set_as_list.q))"
    "{s: finite_sets[set_as_list.T].finite_set | s = {x | list_props[set_as_list.T].member(set_as_list.x, set_as_list.l)}}")))
 (set2list_TCC1 0
  (set2list_TCC1-1 nil 3656356303
   ("" (skeep)
    (("" (use "empty_card")
      (("" (assert)
        (("" (replace -1) (("" (expand "length") (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((empty_card formula-decl nil finite_sets nil)
    (T formal-type-decl nil set_as_list nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (member def-decl "bool" list_props nil)
    (length def-decl "nat" list_props nil))
   nil
   (set2list subtype "list_adt[set_as_list.T].null"
    "{l: list_adt[set_as_list.T].list | booleans.AND(list_props[set_as_list.T].length(l) = finite_sets[set_as_list.T].card(set_as_list.s), FORALL (x: set_as_list.T): booleans.IFF(set_as_list.s(x), list_props[set_as_list.T].member(x, l)))}")))
 (set2list_TCC2 0
  (set2list_TCC2-1 nil 3656356303 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil set_as_list nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil))
   nil (set2list subtype "set_as_list.s" "(sets[set_as_list.T].nonempty?)")))
 (set2list_TCC3 0
  (set2list_TCC3-1 nil 3656356303
   ("" (skeep) (("" (use "card_rest") (("" (assert) nil nil)) nil)) nil)
   ((card_rest formula-decl nil finite_sets nil)
    (T formal-type-decl nil set_as_list nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (finite_rest application-judgement "finite_set[T]" set_as_list nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (set2list termination
    "set_as_list.set2list(sets[set_as_list.T].rest(set_as_list.s))" "nil")))
 (set2list_TCC4 0
  (set2list_TCC4-1 nil 3656356303
   ("" (skeep*)
    (("" (typepred "v(rest(s))")
      (("1" (split 2)
        (("1" (expand "length" 1 1)
          (("1" (replace -1 :hide? t)
            (("1" (use "card_rest") (("1" (assert) nil nil)) nil)) nil))
          nil)
         ("2" (skeep)
          (("2" (expand "member" 1 1)
            (("2" (ground)
              (("1" (use "choose_rest_or[T]")
                (("1" (expand "member" -1)
                  (("1" (inst -4 "x") (("1" (assert) nil nil)) nil)) nil))
                nil)
               ("2" (inst -3 "x")
                (("2" (assert)
                  (("2" (use "rest_member[T]")
                    (("2" (expand "member" -1) (("2" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (use "card_rest") (("2" (assert) nil nil)) nil))
      nil))
    nil)
   ((rest const-decl "set" sets nil) (member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil) (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (list type-decl nil list_adt nil) (T formal-type-decl nil set_as_list nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_rest application-judgement "finite_set[T]" set_as_list nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (member const-decl "bool" sets nil)
    (choose_rest_or formula-decl nil sets_lemmas nil)
    (rest_member formula-decl nil sets_lemmas nil)
    (card_rest formula-decl nil finite_sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (set2list subtype
    "list_adt[set_as_list.T].cons(sets[set_as_list.T].choose(set_as_list.s), set_as_list.set2list(sets[set_as_list.T].rest(set_as_list.s)))"
    "{l: list_adt[set_as_list.T].list | booleans.AND(list_props[set_as_list.T].length(l) = finite_sets[set_as_list.T].card(set_as_list.s), FORALL (x: set_as_list.T): booleans.IFF(set_as_list.s(x), list_props[set_as_list.T].member(x, l)))}")))
 (card_sl_TCC1 0
  (card_sl_TCC1-1 nil 3569678532
   ("" (skeep)
    (("" (rewrite -1)
      (("" (expand "list2set")
        (("" (lemma "card_emptyset") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((T formal-type-decl nil set_as_list nil)
    (card_emptyset formula-decl nil finite_sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set" set_as_list nil)
    (list2set def-decl "{s: finite_set[T] | s = {x | member(x, l)}}"
     set_as_list nil))
   nil
   (card_sl subtype "0"
    "{n: naturalnumbers.nat | n = finite_sets[set_as_list.T].Card(set_as_list.list2set(set_as_list.l))}")))
 (card_sl_TCC2 0
  (card_sl_TCC2-1 nil 3569678532
   ("" (skeep)
    (("" (typepred "v(q)")
      (("" (typepred "list2set(l)")
        (("" (typepred "list2set(q)")
          (("" (rewrite -5)
            (("" (case "list2set(q) = list2set(l)")
              (("1" (assert) nil nil)
               ("2" (hide 2)
                (("2" (rewrite -2)
                  (("2" (rewrite -3)
                    (("2" (apply-extensionality 1)
                      (("2" (hide 2)
                        (("2" (rewrite -4)
                          (("2" (expand "member" 1 2)
                            (("2" (case "x!1 = a")
                              (("1" (assert) nil nil) ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list2set def-decl "{s: finite_set[T] | s = {x | member(x, l)}}"
     set_as_list nil)
    (member def-decl "bool" list_props nil)
    (Card const-decl "nat" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (T formal-type-decl nil set_as_list nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (card_sl subtype "set_as_list.card_sl(set_as_list.q)"
    "{n: naturalnumbers.nat | n = finite_sets[set_as_list.T].Card(set_as_list.list2set(set_as_list.l))}")))
 (card_sl_TCC3 0
  (card_sl_TCC3-1 nil 3569678532
   ("" (skeep)
    (("" (typepred "list2set(q)")
      (("" (lemma "card_add")
        (("" (inst -1 "{x | member(x, q)}" "a")
          (("1" (typepred "list2set(l)")
            (("1" (rewrite -2)
              (("1" (rewrite -5)
                (("1" (expand "member" 2)
                  (("1" (hide -1)
                    (("1" (expand "add" -1)
                      (("1" (expand "member" -1 1)
                        (("1"
                          (case "{y: T | a = y OR member(y, q)} = {x | x = a OR member(x, q)}")
                          (("1" (rewrite -1) (("1" (assert) nil nil)) nil)
                           ("2" (apply-extensionality 1)
                            (("2" (case "x!1 = a")
                              (("1" (assert) nil nil) ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((list2set def-decl "{s: finite_set[T] | s = {x | member(x, l)}}"
     set_as_list nil)
    (member def-decl "bool" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (list type-decl nil list_adt nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (T formal-type-decl nil set_as_list nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (q skolem-const-decl "list[T]" set_as_list nil)
    (add const-decl "(nonempty?)" sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (member const-decl "bool" sets nil)
    (card_add formula-decl nil finite_sets nil))
   nil
   (card_sl subtype "(number_fields.+)(1, set_as_list.card_sl(set_as_list.q))"
    "{n: naturalnumbers.nat | n = finite_sets[set_as_list.T].Card(set_as_list.list2set(set_as_list.l))}")))
 (reduce_sl_TCC1 0
  (reduce_sl_TCC1-1 nil 3569739643
   ("" (expand "equal_sl")
    (("" (skosimp*)
      (("" (rewrite -1)
        (("" (expand "subset_sl?") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((subset_sl? def-decl
     "{b: bool | b IFF FORALL x: member(x, l1) => member(x, l2)}" set_as_list
     nil)
    (card_sl def-decl "{n: nat | n = Card(list2set(l))}" set_as_list nil)
    (length def-decl "nat" list_props nil)
    (equal_sl const-decl
     "{b: bool | b IFF FORALL x: member(x, l1) IFF member(x, l2)}" set_as_list
     nil))
   nil
   (reduce_sl subtype "list_adt[set_as_list.T].null"
    "{ll: list_adt[set_as_list.T].list | booleans.&(set_as_list[set_as_list.T].equal_sl(set_as_list.l, ll), set_as_list.card_sl(ll) = list_props[set_as_list.T].length(ll))}")))
 (reduce_sl_TCC2 0
  (reduce_sl_TCC2-1 nil 3569739643
   ("" (skosimp*)
    (("" (typepred "v!1(q!1)")
      (("1" (split)
        (("1" (expand "equal_sl" 1)
          (("1" (expand "equal_sl" -1)
            (("1" (flatten)
              (("1" (split)
                (("1" (expand "subset_sl?" 1)
                  (("1" (rewrite -5)
                    (("1" (assert)
                      (("1" (typepred "subset_sl?(q!1,v!1(q!1))")
                        (("1" (assert)
                          (("1" (inst? -1) (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (rewrite -5)
                  (("2" (typepred "subset_sl?(v!1(q!1), cons(a!1, q!1))")
                    (("2" (split -2)
                      (("1" (propax) nil nil)
                       ("2" (typepred "subset_sl?(v!1(q!1), q!1)")
                        (("2" (skosimp*)
                          (("2" (expand "member" 1)
                            (("2" (assert)
                              (("2" (flatten)
                                (("2" (inst? -1) (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (propax) nil nil))
        nil)
       ("2" (rewrite -2) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((length def-decl "nat" list_props nil)
    (card_sl def-decl "{n: nat | n = Card(list2set(l))}" set_as_list nil)
    (list2set def-decl "{s: finite_set[T] | s = {x | member(x, l)}}"
     set_as_list nil)
    (Card const-decl "nat" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (equal_sl const-decl
     "{b: bool | b IFF FORALL x: member(x, l1) IFF member(x, l2)}" set_as_list
     nil)
    (member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil) (T formal-type-decl nil set_as_list nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (subset_sl? def-decl
     "{b: bool | b IFF FORALL x: member(x, l1) => member(x, l2)}" set_as_list
     nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   nil
   (reduce_sl subtype "set_as_list.reduce_sl(set_as_list.q)"
    "{ll: list_adt[set_as_list.T].list | booleans.&(set_as_list[set_as_list.T].equal_sl(set_as_list.l, ll), set_as_list.card_sl(ll) = list_props[set_as_list.T].length(ll))}")))
 (reduce_sl_TCC3 0
  (reduce_sl_TCC3-1 nil 3569739643
   ("" (skosimp*)
    (("" (typepred "v!1(q!1)")
      (("1" (rewrite -3)
        (("1" (split)
          (("1" (typepred "equal_sl[T](q!1, v!1(q!1))")
            (("1"
              (typepred "equal_sl[T](cons(a!1, q!1), cons[T](a!1, v!1(q!1)))")
              (("1" (assert)
                (("1" (skosimp*)
                  (("1" (hide -1)
                    (("1" (hide -2)
                      (("1" (expand "member" 1)
                        (("1" (inst? -1) (("1" (grind) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand "card_sl" 1)
            (("2" (assert)
              (("2" (typepred "equal_sl[T](q!1, v!1(q!1))")
                (("2" (assert)
                  (("2" (hide -2)
                    (("2" (inst? -1)
                      (("2" (assert)
                        (("2" (expand "length" 2) (("2" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (rewrite -1) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((length def-decl "nat" list_props nil)
    (card_sl def-decl "{n: nat | n = Card(list2set(l))}" set_as_list nil)
    (list2set def-decl "{s: finite_set[T] | s = {x | member(x, l)}}"
     set_as_list nil)
    (Card const-decl "nat" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (equal_sl const-decl
     "{b: bool | b IFF FORALL x: member(x, l1) IFF member(x, l2)}" set_as_list
     nil)
    (member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil) (T formal-type-decl nil set_as_list nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil))
   nil
   (reduce_sl subtype
    "list_adt[set_as_list.T].cons(set_as_list.a, set_as_list.reduce_sl(set_as_list.q))"
    "{ll: list_adt[set_as_list.T].list | booleans.&(set_as_list[set_as_list.T].equal_sl(set_as_list.l, ll), set_as_list.card_sl(ll) = list_props[set_as_list.T].length(ll))}")))
 (equal_sl_card 0
  (equal_sl_card-1 nil 3569741498
   ("" (skeep)
    (("" (typepred "equal_sl(l1,l2)")
      (("" (assert)
        (("" (hide -2 -3)
          (("" (typepred "card_sl(l1)")
            (("" (typepred "card_sl(l2)")
              (("" (typepred "list2set(l1)")
                (("" (typepred "list2set(l2)")
                  (("" (hide -1 -3)
                    (("" (rewrite -1)
                      (("" (rewrite -1)
                        (("" (rewrite -1)
                          (("" (rewrite -1)
                            ((""
                              (case "{x | member(x, l1)} = {x | member(x, l2)}")
                              (("1" (assert) nil nil)
                               ("2" (hide 2)
                                (("2" (apply-extensionality 1)
                                  (("2" (inst? -1)
                                    (("2" (rewrite -1) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equal_sl const-decl
     "{b: bool | b IFF FORALL x: member(x, l1) IFF member(x, l2)}" set_as_list
     nil)
    (member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil) (T formal-type-decl nil set_as_list nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (list2set def-decl "{s: finite_set[T] | s = {x | member(x, l)}}"
     set_as_list nil)
    (card_sl def-decl "{n: nat | n = Card(list2set(l))}" set_as_list nil))
   shostak))
 (member_sl 0
  (member_sl-1 nil 3681834201
   ("" (expand "member" 1 2)
    (("" (measure-induct+ "length(l)" "l")
      (("" (skeep)
        (("" (expand "list2set" 1)
          (("" (lift-if)
            (("" (prop)
              (("1" (hide -2) (("1" (grind) nil nil)) nil)
               ("2" (expand "add")
                (("2" (expand "reduce_sl" -2)
                  (("2" (assert)
                    (("2" (lift-if)
                      (("2" (prop)
                        (("1" (inst -3 "cdr(x!1)")
                          (("1" (inst -3 "x")
                            (("1" (assert)
                              (("1" (expand "member" 3)
                                (("1" (assert)
                                  (("1" (hide-all-but (4 1))
                                    (("1" (grind) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand "member" -1)
                          (("2" (inst -2 "cdr(x!1)")
                            (("2" (inst -2 "x")
                              (("2" (expand "member" 4)
                                (("2" (assert)
                                  (("2" (hide-all-but (5 2))
                                    (("2" (grind) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (measure_induction formula-decl nil measure_induction nil)
    (T formal-type-decl nil set_as_list nil) (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (equal_sl const-decl
     "{b: bool | b IFF FORALL x: member(x, l1) IFF member(x, l2)}" set_as_list
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (list2set def-decl "{s: finite_set[T] | s = {x | member(x, l)}}"
     set_as_list nil)
    (card_sl def-decl "{n: nat | n = Card(list2set(l))}" set_as_list nil)
    (reduce_sl def-decl
     "{ll: list[T] | equal_sl[T](l, ll) & card_sl(ll) = length(ll)}"
     set_as_list nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set" set_as_list nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil))
   shostak)))

