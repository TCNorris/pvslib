(count_functions (listrep_TCC1 0 (listrep_TCC1-1 nil 3603116913 ("" (subtype-tcc) nil nil) nil nil (listrep subtype "1" "count_functions.I(count_functions.m)"))) (listrep_TCC2 0 (listrep_TCC2-1 nil 3603116913 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (listrep subtype "(number_fields.+)(count_functions.i, 1)" "count_functions.I(count_functions.n)"))) (listrep_TCC3 0 (listrep_TCC3-1 nil 3603116913 ("" (skeep) (("" (inst + "1") nil nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (I type-eq-decl nil count_functions nil)) nil (listrep existence "" "count_functions.I(count_functions.m)"))) (listrep_test_TCC1 0 (listrep_test_TCC1-1 nil 3603117107 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (I type-eq-decl nil count_functions nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) nil (listrep_test subtype "real_defs.min(count_functions.i, 3)" "count_functions.I(3)"))) (listrep_test 0 (listrep_test-1 nil 3603117108 ("" (grind) nil nil) ((min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list nil) (listrep const-decl "listn[I(m)](n)" count_functions nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_min application-judgement "{k: posint | k <= i AND k <= j}" real_defs nil)) shostak)) (FunEqSet_TCC1 0 (FunEqSet_TCC1-1 nil 3603122103 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (I type-eq-decl nil count_functions nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (FunEqSet subtype "count_functions.k" "count_functions.I(count_functions.n)"))) (collect_funs_TCC1 0 (collect_funs_TCC1-3 "" 3803617391 ("" (skeep) (("" (expand "update") (("" (inst + "LAMBDA (h:(FunEqSet(n, m)(P,i, j, f))): 0") (("" (assert) (("" (case "NOT FunEqSet(n, m)(P,i, j, f) = (LAMBDA (hh:FinFun(n,m)): hh=g)") (("1" (hide 2) (("1" (decompose-equality 1) (("1" (iff) (("1" (ground) (("1" (expand "FunEqSet") (("1" (flatten) (("1" (decompose-equality 1) (("1" (inst - "x!2") (("1" (ground) (("1" (replaces -4) (("1" (assert) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (replaces -3) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "FunEqSet") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (skolem 1 "gg") (("1" (expand "nth" + 1) (("1" (assert) (("1" (typepred "gg") (("1" (assert) (("1" (replace -2 -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bijective?") (("2" (split) (("1" (expand "injective?") (("1" (skosimp*) (("1" (typepred "x1!1") (("1" (typepred "x2!1") (("1" (replace -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?") (("2" (skosimp*) (("2" (case "NOT y!1 = 0") (("1" (typepred "y!1") (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (inst + "g") (("2" (assert) (("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((update const-decl "FinFun(n, m)" count_functions nil) (nth def-decl "T" list_props nil) (injective? const-decl "bool" functions nil) (g skolem-const-decl "FinFun(n, m)" count_functions nil) (f skolem-const-decl "FinFun(n, m)" count_functions nil) (j skolem-const-decl "I(m)" count_functions nil) (i skolem-const-decl "I(n)" count_functions nil) (P skolem-const-decl "pred[FinFun(n, m)]" count_functions nil) (m skolem-const-decl "posnat" count_functions nil) (n skolem-const-decl "posnat" count_functions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (surjective? const-decl "bool" functions nil) (bijective? const-decl "bool" functions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (listrep const-decl "listn[I(m)](n)" count_functions nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (listn type-eq-decl nil listn nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (FunEqSet const-decl "set[FinFun(n, m)]" count_functions nil) (set type-eq-decl nil sets nil) (pred type-eq-decl nil defined_types nil) (FinFun type-eq-decl nil count_functions nil) (I type-eq-decl nil count_functions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (length_singleton formula-decl nil more_list_props nil)) shostak (collect_funs subtype "(: count_functions.listrep(count_functions.n, count_functions.m)(count_functions.g) :)" "{l: list_adt[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].list | EXISTS (bij: [(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)) -> naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))]): booleans.AND(FORALL (g: (count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f))): list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].nth(l, bij(g)) = count_functions.listrep(count_functions.n, count_functions.m)(g), functions[(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)), naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))].bijective?(bij))}")) (collect_funs_TCC1-2 "" 3790088331 ("" (skeep) (("" (expand "update") (("" (inst + "LAMBDA (h:(FunEqSet(n, m)(P,i, j, f))): 0") (("" (assert) (("" (case "NOT FunEqSet(n, m)(P,i, j, f) = (LAMBDA (hh:FinFun(n,m)): hh=g)") (("1" (hide 2) (("1" (decompose-equality 1) (("1" (iff) (("1" (ground) (("1" (expand "FunEqSet") (("1" (flatten) (("1" (decompose-equality 1) (("1" (inst - "x!2") (("1" (ground) (("1" (replaces -7) (("1" (assert) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (replaces -6) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "FunEqSet") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (skolem 1 "gg") (("1" (expand "nth" + 1) (("1" (assert) (("1" (typepred "gg") (("1" (assert) (("1" (replace -2 -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bijective?") (("2" (split) (("1" (expand "injective?") (("1" (skosimp*) (("1" (typepred "x1!1") (("1" (typepred "x2!1") (("1" (replace -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?") (("2" (skosimp*) (("2" (case "NOT y!1 = 0") (("1" (typepred "y!1") (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (inst + "g") (("2" (assert) (("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((listn type-eq-decl nil listn nil) (length_singleton formula-decl nil more_list_props nil)) shostak (collect_funs subtype "(: count_functions.listrep(count_functions.n, count_functions.m)(count_functions.g) :)" "{l: list_adt[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].list | EXISTS (bij: [(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)) -> naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))]): booleans.AND(FORALL (g: (count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f))): list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].nth(l, bij(g)) = count_functions.listrep(count_functions.n, count_functions.m)(g), functions[(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)), naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))].bijective?(bij))}")) (collect_funs_TCC1-1 nil 3603122166 ("" (skeep) (("" (expand "update") (("" (inst + "LAMBDA (h:(FunEqSet(n, m)(P,i, j, f))): 0") (("" (assert) (("" (case "NOT FunEqSet(n, m)(P,i, j, f) = (LAMBDA (hh:FinFun(n,m)): hh=g)") (("1" (hide 2) (("1" (decompose-equality 1) (("1" (iff) (("1" (ground) (("1" (expand "FunEqSet") (("1" (flatten) (("1" (decompose-equality 1) (("1" (inst - "x!2") (("1" (ground) (("1" (replaces -7) (("1" (assert) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (replaces -6) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "FunEqSet") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (skolem 1 "gg") (("1" (expand "nth" + 1) (("1" (assert) (("1" (typepred "gg") (("1" (assert) (("1" (replace -2 -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bijective?") (("2" (split) (("1" (expand "injective?") (("1" (skosimp*) (("1" (typepred "x1!1") (("1" (typepred "x2!1") (("1" (replace -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?") (("2" (skosimp*) (("2" (case "NOT y!1 = 0") (("1" (typepred "y!1") (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (inst + "g") (("2" (assert) (("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((listn type-eq-decl nil listn nil) (length_singleton formula-decl nil more_list_props nil)) nil (collect_funs subtype "(: count_functions.listrep(count_functions.n, count_functions.m)(count_functions.g) :)" "{l: list_adt[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].list | EXISTS (bij: [(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)) -> naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))]): booleans.AND(FORALL (g: (count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f))): list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].nth(l, bij(g)) = count_functions.listrep(count_functions.n, count_functions.m)(g), functions[(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)), naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))].bijective?(bij))}"))) (collect_funs_TCC2 0 (collect_funs_TCC2-2 "" 3803617853 ("" (skeep) (("" (expand "update") (("" (assert) (("" (inst + "LAMBDA (h:(FunEqSet(n, m)(P,i, j, f))): 0") (("1" (split) (("1" (skolem 1 "gg") (("1" (typepred "gg") (("1" (hide 2) (("1" (expand "FunEqSet") (("1" (flatten) (("1" (case "NOT gg = g") (("1" (decompose-equality 1) (("1" (inst - "x!1") (("1" (assert) (("1" (replace -4) (("1" (assert) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bijective?") (("2" (split) (("1" (expand "injective?") (("1" (skosimp*) (("1" (typepred "x1!1") (("1" (expand "FunEqSet") (("1" (flatten) (("1" (case "x1!1 = g") (("1" (assert) nil nil) ("2" (decompose-equality 1) (("2" (inst - "x!1") (("2" (replace -4) (("2" (assert) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?") (("2" (skosimp*) (("2" (typepred "y!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "h") (("2" (expand "FunEqSet") (("2" (flatten) (("2" (case "h = g") (("1" (assert) nil nil) ("2" (decompose-equality 1) (("2" (inst - "x!1") (("2" (replace -4) (("2" (ground) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((update const-decl "FinFun(n, m)" count_functions nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (listn type-eq-decl nil listn nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (< const-decl "bool" reals nil) (f skolem-const-decl "FinFun(n, m)" count_functions nil) (j skolem-const-decl "I(m)" count_functions nil) (i skolem-const-decl "I(n)" count_functions nil) (P skolem-const-decl "pred[FinFun(n, m)]" count_functions nil) (FunEqSet const-decl "set[FinFun(n, m)]" count_functions nil) (set type-eq-decl nil sets nil) (pred type-eq-decl nil defined_types nil) (FinFun type-eq-decl nil count_functions nil) (m skolem-const-decl "posnat" count_functions nil) (I type-eq-decl nil count_functions nil) (n skolem-const-decl "posnat" count_functions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil naturalnumbers nil) (bijective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak (collect_funs subtype "(: :)" "{l: list_adt[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].list | EXISTS (bij: [(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)) -> naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))]): booleans.AND(FORALL (g: (count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f))): list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].nth(l, bij(g)) = count_functions.listrep(count_functions.n, count_functions.m)(g), functions[(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)), naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))].bijective?(bij))}")) (collect_funs_TCC2-1 nil 3603122166 ("" (skeep) (("" (expand "update") (("" (assert) (("" (inst + "LAMBDA (h:(FunEqSet(n, m)(P,i, j, f))): 0") (("1" (split) (("1" (skolem 1 "gg") (("1" (typepred "gg") (("1" (hide 2) (("1" (expand "FunEqSet") (("1" (flatten) (("1" (case "NOT gg = g") (("1" (decompose-equality 1) (("1" (inst - "x!1") (("1" (assert) (("1" (replace -6) (("1" (assert) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bijective?") (("2" (split) (("1" (expand "injective?") (("1" (skosimp*) (("1" (typepred "x1!1") (("1" (expand "FunEqSet") (("1" (flatten) (("1" (case "x1!1 = g") (("1" (assert) nil nil) ("2" (decompose-equality 1) (("2" (inst - "x!1") (("2" (replace -6) (("2" (assert) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?") (("2" (skosimp*) (("2" (typepred "y!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "h") (("2" (expand "FunEqSet") (("2" (flatten) (("2" (case "h = g") (("1" (assert) nil nil) ("2" (decompose-equality 1) (("2" (inst - "x!1") (("2" (replace -6) (("2" (ground) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((listn type-eq-decl nil listn nil)) nil (collect_funs subtype "(: :)" "{l: list_adt[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].list | EXISTS (bij: [(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)) -> naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))]): booleans.AND(FORALL (g: (count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f))): list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].nth(l, bij(g)) = count_functions.listrep(count_functions.n, count_functions.m)(g), functions[(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)), naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))].bijective?(bij))}"))) (collect_funs_TCC3 0 (collect_funs_TCC3-1 nil 3603122166 ("" (subtype-tcc) nil nil) nil nil (collect_funs subtype "1" "count_functions.I(count_functions.n)"))) (collect_funs_TCC4 0 (collect_funs_TCC4-1 nil 3603122166 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (I type-eq-decl nil count_functions nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (collect_funs subtype "(number_fields.-)(count_functions.j, 1)" "count_functions.I(count_functions.m)"))) (collect_funs_TCC5 0 (collect_funs_TCC5-1 nil 3603122166 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (I type-eq-decl nil count_functions nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil)) nil (collect_funs termination "count_functions.collect_funs(count_functions.n, count_functions.m)(count_functions.P, count_functions.f, 1, (number_fields.-)(count_functions.j, 1))" "nil"))) (collect_funs_TCC6 0 (collect_funs_TCC6-3 "" 3803628146 ("" (skeep) (("" (assert) (("" (hide 2) (("" (expand "update") (("" (typepred "v(n, m)(P, f, 1, j - 1)") (("" (hide -1) (("" (copy -1) (("" (skolem - "bijv") (("" (name "bij" "LAMBDA (gg:(FunEqSet(n, m)(P, i, j, f))): IF gg=g THEN 0 ELSE bijv(gg)+1 ENDIF") (("1" (inst + "bij") (("1" (split) (("1" (skolem 1 "gg") (("1" (expand "nth" 1 1) (("1" (lift-if) (("1" (ground) (("1" (expand "bij" -1) (("1" (assert) nil nil)) nil) ("2" (case "gg = g") (("1" (expand "bij" 1) (("1" (assert) nil nil)) nil) ("2" (expand "bij" 3) (("2" (assert) (("2" (inst - "gg") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "bijective?" +) (("2" (split +) (("1" (expand "injective?" +) (("1" (skolem 1 ("g1" "g2")) (("1" (flatten) (("1" (expand "bij" -1) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (inst - "g1") (("1" (expand "bijective?" -4) (("1" (flatten) (("1" (expand "injective?" -4) (("1" (inst - "g1" "g2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?" 1) (("2" (skeep) (("2" (case "y = 0") (("1" (inst + "g") (("1" (expand "bij" 1) (("1" (assert) nil nil)) nil) ("2" (expand "FunEqSet" 1) (("2" (skosimp*) (("2" (replace -7 +) (("2" (assert) (("2" (skosimp*) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bijective?" -3) (("2" (flatten) (("2" (expand "surjective?") (("2" (inst -4 "y-1") (("1" (skosimp*) (("1" (inst + "x!1") (("1" (expand "bij" +) (("1" (assert) (("1" (replace -7 +) (("1" (lift-if) (("1" (ground) (("1" (typepred "x!1") (("1" (expand "FunEqSet") (("1" (flatten) (("1" (assert) (("1" (replace -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x!1") (("2" (expand "FunEqSet" (-1 1)) (("2" (flatten) (("2" (assert) (("2" (skeep) (("2" (inst - "k") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "y") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (typepred "x1!1") (("2" (expand "length" 1) (("2" (expand "bij") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (skeep) (("2" (typepred "gg") (("2" (expand "FunEqSet" (-1 2)) (("2" (flatten) (("2" (assert) (("2" (replace -8) (("2" (replace -2) (("2" (assert) (("2" (decompose-equality 1) (("2" (inst - "x!1") (("2" (assert) (("2" (case "x!1 = 1") (("1" (replaces -1) (("1" (assert) (("1" (replace -7) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace -7) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((update const-decl "FinFun(n, m)" count_functions nil) (TRUE const-decl "bool" booleans nil) (v skolem-const-decl "[d1: [posnat, posnat] ->
   [d2:
      {z:
         [pred[FinFun(d1`1, d1`2)], FinFun(d1`1, d1`2), I(d1`1), I(d1`2)] |
         d1`2 * z`3 + z`3 + z`4 < i * m + i + j} ->
      {l: list[listn[I(d1`2)](d1`1)] |
         EXISTS (bij:
                   [(FunEqSet(d1`1, d1`2)(d2`1, d2`3, d2`4, d2`2)) ->
                      below(length(l))]):
           (FORALL (g: (FunEqSet(d1`1, d1`2)(d2`1, d2`3, d2`4, d2`2))):
              nth(l, bij(g)) = listrep(d1`1, d1`2)(g))
            AND bijective?(bij)}]]" count_functions nil) (g skolem-const-decl "FinFun(n, m)" count_functions nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (bij skolem-const-decl "[(FunEqSet(n, m)(P, i, j, f)) -> nat]" count_functions nil) (f skolem-const-decl "FinFun(n, m)" count_functions nil) (j skolem-const-decl "I(m)" count_functions nil) (i skolem-const-decl "I(n)" count_functions nil) (P skolem-const-decl "pred[FinFun(n, m)]" count_functions nil) (m skolem-const-decl "posnat" count_functions nil) (n skolem-const-decl "posnat" count_functions nil) (injective? const-decl "bool" functions nil) (x!1 skolem-const-decl "(FunEqSet(n, m)(P, 1, j - 1, f))" count_functions nil) (y skolem-const-decl "below(length(cons(listrep(n, m)(g), v(n, m)(P, f, 1, j - 1))))" count_functions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (surjective? const-decl "bool" functions nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (<= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (I type-eq-decl nil count_functions nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (FinFun type-eq-decl nil count_functions nil) (pred type-eq-decl nil defined_types nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (listn type-eq-decl nil listn nil) (set type-eq-decl nil sets nil) (FunEqSet const-decl "set[FinFun(n, m)]" count_functions nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (listrep const-decl "listn[I(m)](n)" count_functions nil) (bijective? const-decl "bool" functions nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak (collect_funs subtype "list_adt[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].cons(count_functions.listrep(count_functions.n, count_functions.m)(count_functions.g), count_functions.collect_funs(count_functions.n, count_functions.m)(count_functions.P, count_functions.f, 1, (number_fields.-)(count_functions.j, 1)))" "{l: list_adt[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].list | EXISTS (bij: [(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)) -> naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))]): booleans.AND(FORALL (g: (count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f))): list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].nth(l, bij(g)) = count_functions.listrep(count_functions.n, count_functions.m)(g), functions[(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)), naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))].bijective?(bij))}")) (collect_funs_TCC6-2 "" 3790088334 ("" (skeep) (("" (assert) (("" (hide 2) (("" (expand "update") (("" (typepred "v(n, m)(P, f, 1, j - 1)") (("" (hide -1) (("" (copy -1) (("" (skolem - "bijv") (("" (name "bij" "LAMBDA (gg:(FunEqSet(n, m)(P, i, j, f))): IF gg=g THEN 0 ELSE bijv(gg)+1 ENDIF") (("1" (inst + "bij") (("1" (split) (("1" (skolem 1 "gg") (("1" (expand "nth" 1 1) (("1" (lift-if) (("1" (ground) (("1" (expand "bij" -1) (("1" (assert) nil nil)) nil) ("2" (case "gg = g") (("1" (expand "bij" 1) (("1" (assert) nil nil)) nil) ("2" (expand "bij" 3) (("2" (assert) (("2" (inst - "gg") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "bijective?" +) (("2" (split +) (("1" (expand "injective?" +) (("1" (skolem 1 ("g1" "g2")) (("1" (flatten) (("1" (expand "bij" -1) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (inst - "g1") (("1" (expand "bijective?" -4) (("1" (flatten) (("1" (expand "injective?" -4) (("1" (inst - "g1" "g2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?" 1) (("2" (skeep) (("2" (case "y = 0") (("1" (inst + "g") (("1" (expand "bij" 1) (("1" (assert) nil nil)) nil) ("2" (expand "FunEqSet" 1) (("2" (skosimp*) (("2" (replace -9 +) (("2" (assert) (("2" (skosimp*) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bijective?" -3) (("2" (flatten) (("2" (expand "surjective?") (("2" (inst -4 "y-1") (("1" (skosimp*) (("1" (inst + "x!1") (("1" (expand "bij" +) (("1" (assert) (("1" (replace -9 +) (("1" (lift-if) (("1" (ground) (("1" (typepred "x!1") (("1" (expand "FunEqSet") (("1" (flatten) (("1" (assert) (("1" (replace -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x!1") (("2" (expand "FunEqSet" (-1 1)) (("2" (flatten) (("2" (assert) (("2" (skeep) (("2" (inst - "k") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "y") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (typepred "x1!1") (("2" (expand "length" 1) (("2" (expand "bij") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (skeep) (("2" (typepred "gg") (("2" (expand "FunEqSet" (-1 2)) (("2" (flatten) (("2" (assert) (("2" (replace -7) (("2" (replace -2) (("2" (assert) (("2" (decompose-equality 1) (("2" (inst - "x!1") (("2" (assert) (("2" (case "x!1 = 1") (("1" (replaces -1) (("1" (assert) (("1" (replace -9) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace -9) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((listn type-eq-decl nil listn nil)) shostak (collect_funs subtype "list_adt[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].cons(count_functions.listrep(count_functions.n, count_functions.m)(count_functions.g), count_functions.collect_funs(count_functions.n, count_functions.m)(count_functions.P, count_functions.f, 1, (number_fields.-)(count_functions.j, 1)))" "{l: list_adt[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].list | EXISTS (bij: [(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)) -> naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))]): booleans.AND(FORALL (g: (count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f))): list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].nth(l, bij(g)) = count_functions.listrep(count_functions.n, count_functions.m)(g), functions[(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)), naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))].bijective?(bij))}")) (collect_funs_TCC6-1 nil 3603122166 ("" (skeep) (("" (assert) (("" (hide 2) (("" (expand "update") (("" (typepred "v(n, m)(P, f, 1, j - 1)") (("" (hide -1) (("" (copy -1) (("" (skolem - "bijv") (("" (name "bij" "LAMBDA (gg:(FunEqSet(n, m)(P, i, j, f))): IF gg=g THEN 0 ELSE bijv(gg)+1 ENDIF") (("1" (inst + "bij") (("1" (split) (("1" (skolem 1 "gg") (("1" (expand "nth" 1 1) (("1" (lift-if) (("1" (ground) (("1" (expand "bij" -1) (("1" (assert) nil nil)) nil) ("2" (case "gg = g") (("1" (expand "bij" 1) (("1" (assert) nil nil)) nil) ("2" (expand "bij" 3) (("2" (assert) (("2" (inst - "gg") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "bijective?" +) (("2" (split +) (("1" (expand "injective?" +) (("1" (skolem 1 ("g1" "g2")) (("1" (flatten) (("1" (expand "bij" -1) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (inst - "g1") (("1" (expand "bijective?" -4) (("1" (flatten) (("1" (expand "injective?" -4) (("1" (inst - "g1" "g2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?" 1) (("2" (skeep) (("2" (case "y = 0") (("1" (inst + "g") (("1" (expand "bij" 1) (("1" (assert) nil nil)) nil) ("2" (expand "FunEqSet" 1) (("2" (skosimp*) (("2" (replace -9 +) (("2" (assert) (("2" (skosimp*) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bijective?" -3) (("2" (flatten) (("2" (expand "surjective?") (("2" (inst -4 "y-1") (("1" (skosimp*) (("1" (inst + "x!1") (("1" (expand "bij" +) (("1" (assert) (("1" (replace -9 +) (("1" (assert) (("1" (lift-if) (("1" (ground) (("1" (typepred "x!1") (("1" (expand "FunEqSet") (("1" (flatten) (("1" (assert) (("1" (replace -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x!1") (("2" (expand "FunEqSet" (-1 1)) (("2" (flatten) (("2" (assert) (("2" (skeep) (("2" (inst - "k") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "y") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (typepred "x1!1") (("2" (expand "length" 1) (("2" (expand "bij") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (skeep) (("2" (typepred "gg") (("2" (expand "FunEqSet" (-1 2)) (("2" (flatten) (("2" (assert) (("2" (replace -7) (("2" (replace -2) (("2" (assert) (("2" (decompose-equality 1) (("2" (inst - "x!1") (("2" (assert) (("2" (case "x!1 = 1") (("1" (replaces -1) (("1" (assert) (("1" (replace -9) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace -9) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((listn type-eq-decl nil listn nil)) nil (collect_funs subtype "list_adt[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].cons(count_functions.listrep(count_functions.n, count_functions.m)(count_functions.g), count_functions.collect_funs(count_functions.n, count_functions.m)(count_functions.P, count_functions.f, 1, (number_fields.-)(count_functions.j, 1)))" "{l: list_adt[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].list | EXISTS (bij: [(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)) -> naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))]): booleans.AND(FORALL (g: (count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f))): list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].nth(l, bij(g)) = count_functions.listrep(count_functions.n, count_functions.m)(g), functions[(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)), naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))].bijective?(bij))}"))) (collect_funs_TCC7 0 (collect_funs_TCC7-1 nil 3603122166 ("" (subtype-tcc) nil nil) nil nil (collect_funs subtype "1" "count_functions.I(count_functions.n)"))) (collect_funs_TCC8 0 (collect_funs_TCC8-1 nil 3603122166 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (I type-eq-decl nil count_functions nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (collect_funs subtype "(number_fields.-)(count_functions.j, 1)" "count_functions.I(count_functions.m)"))) (collect_funs_TCC9 0 (collect_funs_TCC9-1 nil 3603122166 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (I type-eq-decl nil count_functions nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil)) nil (collect_funs termination "count_functions.collect_funs(count_functions.n, count_functions.m)(count_functions.P, count_functions.f, 1, (number_fields.-)(count_functions.j, 1))" "nil"))) (collect_funs_TCC10 0 (collect_funs_TCC10-2 "" 3803747060 ("" (skeep) (("" (expand "update") (("" (assert) (("" (hide 3) (("" (typepred "v(n, m)(P, f, 1, j - 1)") (("" (hide -1) (("" (copy -1) (("" (skolem - "bijv") (("" (flatten) (("" (assert) (("" (case "FunEqSet(n, m)(P, 1, j - 1, f) = FunEqSet(n, m)(P, i, j, f)") (("1" (assert) (("1" (inst + "bijv") (("1" (split 3) (("1" (skolem 1 "gg") (("1" (inst - "gg") nil nil)) nil) ("2" (expand "bijective?" (-3 1)) (("2" (flatten) (("2" (split +) (("1" (expand "injective?" 1) (("1" (skolem 1 ("g1" "g2")) (("1" (flatten) (("1" (expand "injective?") (("1" (inst - "g1" "g2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?") (("2" (skeep) (("2" (inst -4 "y") (("2" (skeep -4) (("2" (inst + "x") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (decompose-equality 1) (("2" (expand "FunEqSet") (("2" (assert) (("2" (iff) (("2" (replace -5) (("2" (ground) (("2" (case "x!1 = g") (("1" (assert) nil nil) ("2" (decompose-equality 1) (("2" (inst - "x!2") (("2" (ground) (("1" (replace -7) (("1" (assert) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (replace -6) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (collect_funs subtype "count_functions.collect_funs(count_functions.n, count_functions.m)(count_functions.P, count_functions.f, 1, (number_fields.-)(count_functions.j, 1))" "{l: list_adt[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].list | EXISTS (bij: [(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)) -> naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))]): booleans.AND(FORALL (g: (count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f))): list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].nth(l, bij(g)) = count_functions.listrep(count_functions.n, count_functions.m)(g), functions[(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)), naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))].bijective?(bij))}")) (collect_funs_TCC10-1 nil 3603122166 ("" (skeep) (("" (expand "update") (("" (assert) (("" (hide 3) (("" (typepred "v(n, m)(P, f, 1, j - 1)") (("" (hide -1) (("" (copy -1) (("" (skolem - "bijv") (("" (flatten) (("" (assert) (("" (case "FunEqSet(n, m)(P, 1, j - 1, f) = FunEqSet(n, m)(P, i, j, f)") (("1" (assert) (("1" (inst + "bijv") (("1" (split) (("1" (skolem 1 "gg") (("1" (inst - "gg") nil nil)) nil) ("2" (expand "bijective?" (-3 1)) (("2" (flatten) (("2" (split +) (("1" (expand "injective?" 1) (("1" (skolem 1 ("g1" "g2")) (("1" (flatten) (("1" (expand "injective?") (("1" (inst - "g1" "g2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?") (("2" (skeep) (("2" (inst -4 "y") (("2" (skeep -4) (("2" (inst + "x") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (hide (-1 -2 -3)) (("2" (decompose-equality 1) (("2" (expand "FunEqSet") (("2" (assert) (("2" (iff) (("2" (ground) (("1" (skeep) (("1" (inst - "k") (("1" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (inst - "k") (("2" (assert) nil nil)) nil)) nil) ("3" (case "x!1 = g") (("1" (assert) nil nil) ("2" (decompose-equality 1) (("2" (inst - "x!2") (("2" (ground) (("1" (replace -5) (("1" (assert) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (replace -4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((update const-decl "FinFun(n, m)" count_functions nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (i skolem-const-decl "I(n)" count_functions nil) (f skolem-const-decl "FinFun(n, m)" count_functions nil) (j skolem-const-decl "I(m)" count_functions nil) (P skolem-const-decl "pred[FinFun(n, m)]" count_functions nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (m skolem-const-decl "posnat" count_functions nil) (n skolem-const-decl "posnat" count_functions nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (<= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (I type-eq-decl nil count_functions nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (FinFun type-eq-decl nil count_functions nil) (pred type-eq-decl nil defined_types nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (listn type-eq-decl nil listn nil) (set type-eq-decl nil sets nil) (FunEqSet const-decl "set[FinFun(n, m)]" count_functions nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (listrep const-decl "listn[I(m)](n)" count_functions nil) (bijective? const-decl "bool" functions nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil (collect_funs subtype "count_functions.collect_funs(count_functions.n, count_functions.m)(count_functions.P, count_functions.f, 1, (number_fields.-)(count_functions.j, 1))" "{l: list_adt[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].list | EXISTS (bij: [(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)) -> naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))]): booleans.AND(FORALL (g: (count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f))): list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].nth(l, bij(g)) = count_functions.listrep(count_functions.n, count_functions.m)(g), functions[(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)), naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))].bijective?(bij))}"))) (collect_funs_TCC11 0 (collect_funs_TCC11-1 nil 3603122166 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (I type-eq-decl nil count_functions nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (collect_funs subtype "(number_fields.-)(count_functions.i, 1)" "count_functions.I(count_functions.n)"))) (collect_funs_TCC12 0 (collect_funs_TCC12-1 nil 3603122166 ("" (subtype-tcc) nil nil) nil nil (collect_funs subtype "count_functions.m" "count_functions.I(count_functions.m)"))) (collect_funs_TCC13 0 (collect_funs_TCC13-2 "" 3790088336 ("" (skeep) (("" (assert) nil nil)) nil) ((posint_times_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (collect_funs termination "count_functions.collect_funs(count_functions.n, count_functions.m)(count_functions.P, count_functions.g, (number_fields.-)(count_functions.i, 1), count_functions.m)" "nil")) (collect_funs_TCC13-1 nil 3603122166 ("" (skeep) (("" (assert) (("" (hide (2 3 4)) (("" (postpone) nil nil)) nil)) nil)) nil) nil nil (collect_funs termination "count_functions.collect_funs(count_functions.n, count_functions.m)(count_functions.P, count_functions.g, (number_fields.-)(count_functions.i, 1), count_functions.m)" "nil"))) (collect_funs_TCC14 0 (collect_funs_TCC14-1 nil 3603122166 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (I type-eq-decl nil count_functions nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (collect_funs subtype "(number_fields.-)(count_functions.j, 1)" "count_functions.I(count_functions.m)"))) (collect_funs_TCC15 0 (collect_funs_TCC15-1 nil 3603122166 ("" (subtype-tcc) nil nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil)) nil (collect_funs termination "count_functions.collect_funs(count_functions.n, count_functions.m)(count_functions.P, count_functions.f, count_functions.i, (number_fields.-)(count_functions.j, 1))" "nil"))) (collect_funs_TCC16 0 (collect_funs_TCC16-2 "" 3803747959 ("" (skeep) (("" (expand "update") (("" (assert) (("" (hide (1 2 3)) (("" (name "A" "FunEqSet(n, m)(P, i-1, m, g)") (("" (name "B" "FunEqSet(n,m)(P,i,j-1,f)") (("" (case "NOT disjoint?(A,B)") (("1" (assert) (("1" (hide 3) (("1" (expand "disjoint?") (("1" (expand "empty?") (("1" (expand "member") (("1" (expand "intersection") (("1" (expand "member") (("1" (skolem 1 "gg") (("1" (flatten) (("1" (hide (-3 -4)) (("1" (expand "A") (("1" (expand "B") (("1" (expand "FunEqSet") (("1" (flatten) (("1" (inst - "i") (("1" (assert) (("1" (replace -7) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT FunEqSet(n, m)(P, i, j, f) = union(A,B)") (("1" (hide 3) (("1" (replace -4) (("1" (decompose-equality 1) (("1" (name "gg" "x!1") (("1" (replaces -1) (("1" (assert) (("1" (expand "union") (("1" (expand "member") (("1" (expand "FunEqSet" +) (("1" (hide (-2 -3)) (("1" (iff) (("1" (expand "A") (("1" (expand "B") (("1" (replace -2) (("1" (expand "FunEqSet" +) (("1" (assert) (("1" (assert) (("1" (ground) (("1" (skeep) (("1" (inst - "k_1") (("1" (assert) (("1" (ground) (("1" (case "NOT k_1 = i") (("1" (assert) nil nil) ("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst - "k") (("2" (assert) nil nil)) nil)) nil) ("3" (inst - "i") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "l1" "length(v(n, m)(P, g, i - 1, m))") (("2" (name "l2" "length(v(n, m)(P, f, i, j - 1))") (("2" (assert) (("2" (typepred "v(n, m)(P, g, i - 1, m)") (("2" (hide -1) (("2" (skolem -1 "bijA") (("2" (flatten) (("2" (typepred "v(n, m)(P, f, i, j - 1)") (("2" (hide -1) (("2" (skolem - "bijB") (("2" (flatten) (("2" (assert) (("2" (name "bij" "LAMBDA (gg:(FunEqSet(n, m)(P, i, j, f))): IF A(gg) THEN bijA(gg) ELSE l1+bijB(gg) ENDIF") (("1" (inst + "bij") (("1" (assert) (("1" (split) (("1" (skolem 1 "gg") (("1" (lemma "nth_append[listn[I(m)](n)]") (("1" (inst?) (("1" (assert) (("1" (split -1) (("1" (replaces -1 +) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (replace -13) (("1" (replace -8) (("1" (expand "bij" -1) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (inst -6 "gg") (("1" (assert) (("1" (expand "bij" +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -12) (("2" (replace -7) (("2" (assert) (("2" (inst - "gg") (("1" (expand "bij" 2) (("1" (assert) (("1" (case "A(gg)") (("1" (expand "bij" 1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -9) (("2" (expand "bij" 2) (("2" (lift-if) (("2" (ground) (("2" (typepred "gg") (("2" (replace -8 -1) (("2" (expand "union" -1) (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -6) (("2" (replace -7) (("2" (assert) (("2" (expand "bij" 1) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bijective?") (("2" (flatten) (("2" (split +) (("1" (expand "injective?" +) (("1" (skolem 1 ("g1" "g2")) (("1" (flatten) (("1" (expand "bij" -1) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (copy -9) (("1" (expand "injective?" -1) (("1" (inst - "g1" "g2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (copy -4) (("2" (expand "injective?" -1) (("2" (inst - "g1" "g2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?" +) (("2" (skeep) (("2" (typepred "y") (("2" (rewrite "length_append") (("2" (replace -9 -1) (("2" (replace -10 -1) (("2" (assert) (("2" (case "y < l1") (("1" (copy -9) (("1" (expand "surjective?" -1) (("1" (inst - "y") (("1" (skolem - "gg") (("1" (inst + "gg") (("1" (expand "bij" 1) (("1" (propax) nil nil)) nil) ("2" (copy -13) (("2" (replaces -1) (("2" (expand "union") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -11) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (copy -5) (("2" (expand "surjective?" -1) (("2" (inst - "y-l1") (("2" (skolem - "gg") (("2" (inst + "gg") (("1" (expand "bij" 2) (("1" (lift-if) (("1" (ground) (("1" (typepred "gg") (("1" (replace -16) (("1" (copy -15) (("1" (expand "disjoint?" -1) (("1" (expand "empty?") (("1" (expand "member") (("1" (expand "intersection") (("1" (expand "member") (("1" (inst - "gg") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "gg") (("2" (replace -15) (("2" (replace -13 +) (("2" (expand "union") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "gg") (("2" (rewrite "length_append") (("2" (expand "bij" 1) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (skeep) (("2" (replace -9 +) (("2" (typepred "gg") (("2" (replace -8) (("2" (expand "union" -1) (("2" (expand "member") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (collect_funs subtype "list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].append(count_functions.collect_funs(count_functions.n, count_functions.m)(count_functions.P, count_functions.g, (number_fields.-)(count_functions.i, 1), count_functions.m), count_functions.collect_funs(count_functions.n, count_functions.m)(count_functions.P, count_functions.f, count_functions.i, (number_fields.-)(count_functions.j, 1)))" "{l: list_adt[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].list | EXISTS (bij: [(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)) -> naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))]): booleans.AND(FORALL (g: (count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f))): list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].nth(l, bij(g)) = count_functions.listrep(count_functions.n, count_functions.m)(g), functions[(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)), naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))].bijective?(bij))}")) (collect_funs_TCC16-1 nil 3603122528 ("" (skeep) (("" (expand "update") (("" (assert) (("" (hide (2 3 4)) (("" (name "A" "FunEqSet(n, m)(P, i-1, m, g)") (("" (name "B" "FunEqSet(n,m)(P,i,j-1,f)") (("" (case "NOT disjoint?(A,B)") (("1" (assert) (("1" (hide 3) (("1" (expand "disjoint?") (("1" (expand "empty?") (("1" (expand "member") (("1" (expand "intersection") (("1" (expand "member") (("1" (skolem 1 "gg") (("1" (flatten) (("1" (hide (-3 -4)) (("1" (expand "A") (("1" (expand "B") (("1" (expand "FunEqSet") (("1" (flatten) (("1" (inst - "i") (("1" (assert) (("1" (replace -8) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT FunEqSet(n, m)(P, i, j, f) = union(A,B)") (("1" (hide 3) (("1" (replace -5) (("1" (decompose-equality 1) (("1" (name "gg" "x!1") (("1" (replaces -1) (("1" (assert) (("1" (expand "union") (("1" (expand "member") (("1" (expand "FunEqSet" +) (("1" (hide (-2 -3)) (("1" (iff) (("1" (expand "A") (("1" (expand "B") (("1" (replace -3) (("1" (expand "FunEqSet" +) (("1" (assert) (("1" (assert) (("1" (ground) (("1" (skeep) (("1" (inst - "k_1") (("1" (assert) (("1" (ground) (("1" (case "NOT k_1 = i") (("1" (assert) nil nil) ("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst - "k") (("2" (assert) nil nil)) nil)) nil) ("3" (inst - "i") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "l1" "length(v(n, m)(P, g, i - 1, m))") (("2" (name "l2" "length(v(n, m)(P, f, i, j - 1))") (("2" (assert) (("2" (typepred "v(n, m)(P, g, i - 1, m)") (("2" (hide -1) (("2" (skolem -1 "bijA") (("2" (flatten) (("2" (typepred "v(n, m)(P, f, i, j - 1)") (("2" (hide -1) (("2" (skolem - "bijB") (("2" (flatten) (("2" (assert) (("2" (name "bij" "LAMBDA (gg:(FunEqSet(n, m)(P, i, j, f))): IF A(gg) THEN bijA(gg) ELSE l1+bijB(gg) ENDIF") (("1" (inst + "bij") (("1" (assert) (("1" (split) (("1" (skolem 1 "gg") (("1" (lemma "nth_append[listn[I(m)](n)]") (("1" (inst?) (("1" (assert) (("1" (split -1) (("1" (replaces -1 +) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (replace -14) (("1" (replace -8) (("1" (expand "bij" -1) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (inst -6 "gg") (("1" (assert) (("1" (expand "bij" +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -13) (("2" (replace -7) (("2" (assert) (("2" (inst - "gg") (("1" (expand "bij" 2) (("1" (assert) (("1" (case "A(gg)") (("1" (expand "bij" 1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -9) (("2" (expand "bij" 2) (("2" (lift-if) (("2" (ground) (("2" (typepred "gg") (("2" (replace -8 -1) (("2" (expand "union" -1) (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -6) (("2" (replace -7) (("2" (assert) (("2" (expand "bij" 1) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bijective?") (("2" (flatten) (("2" (split +) (("1" (expand "injective?" +) (("1" (skolem 1 ("g1" "g2")) (("1" (flatten) (("1" (expand "bij" -1) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (copy -9) (("1" (expand "injective?" -1) (("1" (inst - "g1" "g2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (copy -4) (("2" (expand "injective?" -1) (("2" (inst - "g1" "g2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?" +) (("2" (skeep) (("2" (typepred "y") (("2" (rewrite "length_append") (("2" (replace -9 -1) (("2" (replace -10 -1) (("2" (assert) (("2" (case "y < l1") (("1" (copy -9) (("1" (expand "surjective?" -1) (("1" (inst - "y") (("1" (skolem - "gg") (("1" (inst + "gg") (("1" (expand "bij" 1) (("1" (propax) nil nil)) nil) ("2" (copy -13) (("2" (replaces -1) (("2" (expand "union") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -11) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (copy -5) (("2" (expand "surjective?" -1) (("2" (inst - "y-l1") (("2" (skolem - "gg") (("2" (inst + "gg") (("1" (expand "bij" 2) (("1" (lift-if) (("1" (ground) (("1" (typepred "gg") (("1" (replace -16) (("1" (copy -15) (("1" (expand "disjoint?" -1) (("1" (expand "empty?") (("1" (expand "member") (("1" (expand "intersection") (("1" (expand "member") (("1" (inst - "gg") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "gg") (("2" (replace -15) (("2" (replace -13 +) (("2" (expand "union") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "gg") (("2" (rewrite "length_append") (("2" (expand "bij" 1) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (skeep) (("2" (replace -9 +) (("2" (typepred "gg") (("2" (replace -8) (("2" (expand "union" -1) (("2" (expand "member") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((update const-decl "FinFun(n, m)" count_functions nil) (union const-decl "set" sets nil) (TRUE const-decl "bool" booleans nil) (n skolem-const-decl "posnat" count_functions nil) (m skolem-const-decl "posnat" count_functions nil) (P skolem-const-decl "pred[FinFun(n, m)]" count_functions nil) (i skolem-const-decl "I(n)" count_functions nil) (j skolem-const-decl "I(m)" count_functions nil) (f skolem-const-decl "FinFun(n, m)" count_functions nil) (bij skolem-const-decl "[(FunEqSet(n, m)(P, i, j, f)) -> nat]" count_functions nil) (append def-decl "list[T]" list_props nil) (v skolem-const-decl "[d1: [posnat, posnat] ->
   [d2:
      {z:
         [pred[FinFun(d1`1, d1`2)], FinFun(d1`1, d1`2), I(d1`1), I(d1`2)] |
         d1`2 * z`3 + z`3 + z`4 < i * m + i + j} ->
      {l: list[listn[I(d1`2)](d1`1)] |
         EXISTS (bij:
                   [(FunEqSet(d1`1, d1`2)(d2`1, d2`3, d2`4, d2`2)) ->
                      below(length(l))]):
           (FORALL (g: (FunEqSet(d1`1, d1`2)(d2`1, d2`3, d2`4, d2`2))):
              nth(l, bij(g)) = listrep(d1`1, d1`2)(g))
            AND bijective?(bij)}]]" count_functions nil) (g skolem-const-decl "FinFun(n, m)" count_functions nil) (nth_append formula-decl nil more_list_props nil) (gg skolem-const-decl "(FunEqSet(n, m)(P, i, j, f))" count_functions nil) (surjective? const-decl "bool" functions nil) (gg skolem-const-decl "(FunEqSet(n, m)(P, i, j - 1, f))" count_functions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (y skolem-const-decl "below(length(append(v(n, m)(P, g, i - 1, m), v(n, m)(P, f, i, j - 1))))" count_functions nil) (gg skolem-const-decl "(FunEqSet(n, m)(P, i - 1, m, g))" count_functions nil) (length_append formula-decl nil list_props nil) (injective? const-decl "bool" functions nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (length def-decl "nat" list_props nil) (listn type-eq-decl nil listn nil) (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (listrep const-decl "listn[I(m)](n)" count_functions nil) (bijective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (A skolem-const-decl "set[FinFun(n, m)]" count_functions nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (B skolem-const-decl "set[FinFun(n, m)]" count_functions nil) (intersection const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (disjoint? const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (I type-eq-decl nil count_functions nil) (FinFun type-eq-decl nil count_functions nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (pred type-eq-decl nil defined_types nil) (FunEqSet const-decl "set[FinFun(n, m)]" count_functions nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil (collect_funs subtype "list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].append(count_functions.collect_funs(count_functions.n, count_functions.m)(count_functions.P, count_functions.g, (number_fields.-)(count_functions.i, 1), count_functions.m), count_functions.collect_funs(count_functions.n, count_functions.m)(count_functions.P, count_functions.f, count_functions.i, (number_fields.-)(count_functions.j, 1)))" "{l: list_adt[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].list | EXISTS (bij: [(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)) -> naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))]): booleans.AND(FORALL (g: (count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f))): list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].nth(l, bij(g)) = count_functions.listrep(count_functions.n, count_functions.m)(g), functions[(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)), naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))].bijective?(bij))}"))) (collect_funs_TCC17 0 (collect_funs_TCC17-1 nil 3603122528 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (I type-eq-decl nil count_functions nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (collect_funs subtype "(number_fields.-)(count_functions.i, 1)" "count_functions.I(count_functions.n)"))) (collect_funs_TCC18 0 (collect_funs_TCC18-1 nil 3603122528 ("" (subtype-tcc) nil nil) nil nil (collect_funs subtype "count_functions.m" "count_functions.I(count_functions.m)"))) (collect_funs_TCC19 0 (collect_funs_TCC19-1 nil 3603122528 ("" (termination-tcc) nil nil) ((posint_times_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil (collect_funs termination "count_functions.collect_funs(count_functions.n, count_functions.m)(count_functions.P, count_functions.g, (number_fields.-)(count_functions.i, 1), count_functions.m)" "nil"))) (collect_funs_TCC20 0 (collect_funs_TCC20-1 nil 3603122528 ("" (skeep) (("" (assert) (("" (hide (3 4 5)) (("" (case "NOT (j = 1 AND i > 1)") (("1" (ground) nil nil) ("2" (hide (1 2)) (("2" (flatten) (("2" (expand "update") (("2" (replaces -1) (("2" (case "NOT FunEqSet(n, m)(P, i, j, f) = FunEqSet(n, m)(P, i-1, m, g)") (("1" (hide 2) (("1" (decompose-equality +) (("1" (name "gg" "x!1") (("1" (replaces -1) (("1" (iff) (("1" (expand "FunEqSet") (("1" (ground) (("1" (skeep) (("1" (inst - "k") (("1" (assert) (("1" (case "NOT k = i") (("1" (assert) (("1" (replace -7) (("1" (assert) nil nil)) nil)) nil) ("2" (replaces -1) (("2" (replaces -7) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst - "k") (("2" (assert) (("2" (replace -7) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (inst - "i") (("3" (assert) (("3" (replace -5) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "v(n, m)(P, g, i - 1, m)") (("2" (hide -1) (("2" (skeep -) (("2" (inst + "bij") (("1" (assert) (("1" (split) (("1" (skolem 1 "gg") (("1" (inst - "gg") nil nil)) nil) ("2" (hide -1) (("2" (expand "bijective?") (("2" (flatten) (("2" (split) (("1" (expand "injective?") (("1" (skeep) (("1" (inst - "x1" "x2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "surjective?") (("2" (skeep) (("2" (inst - "y") (("2" (skeep) (("2" (inst + "x") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "gg") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (I type-eq-decl nil count_functions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (n skolem-const-decl "posnat" count_functions nil) (m skolem-const-decl "posnat" count_functions nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (P skolem-const-decl "pred[FinFun(n, m)]" count_functions nil) (i skolem-const-decl "I(n)" count_functions nil) (g skolem-const-decl "FinFun(n, m)" count_functions nil) (j skolem-const-decl "I(m)" count_functions nil) (f skolem-const-decl "FinFun(n, m)" count_functions nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (int_times_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (listn type-eq-decl nil listn nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (listrep const-decl "listn[I(m)](n)" count_functions nil) (bijective? const-decl "bool" functions nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (FinFun type-eq-decl nil count_functions nil) (set type-eq-decl nil sets nil) (pred type-eq-decl nil defined_types nil) (FunEqSet const-decl "set[FinFun(n, m)]" count_functions nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (update const-decl "FinFun(n, m)" count_functions nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil (collect_funs subtype "count_functions.collect_funs(count_functions.n, count_functions.m)(count_functions.P, count_functions.g, (number_fields.-)(count_functions.i, 1), count_functions.m)" "{l: list_adt[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].list | EXISTS (bij: [(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)) -> naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))]): booleans.AND(FORALL (g: (count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f))): list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].nth(l, bij(g)) = count_functions.listrep(count_functions.n, count_functions.m)(g), functions[(count_functions.FunEqSet(count_functions.n, count_functions.m)(count_functions.P, count_functions.i, count_functions.j, count_functions.f)), naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))].bijective?(bij))}"))) (funs_sat_TCC1 0 (funs_sat_TCC1-1 nil 3603131098 ("" (subtype-tcc) nil nil) nil nil (funs_sat subtype "1" "count_functions.I(count_functions.m)"))) (funs_sat_TCC2 0 (funs_sat_TCC2-1 nil 3603131098 ("" (subtype-tcc) nil nil) nil nil (funs_sat subtype "count_functions.n" "count_functions.I(count_functions.n)"))) (funs_sat_TCC3 0 (funs_sat_TCC3-1 nil 3603131098 ("" (subtype-tcc) nil nil) nil nil (funs_sat subtype "count_functions.m" "count_functions.I(count_functions.m)"))) (funs_sat_TCC4 0 (funs_sat_TCC4-1 nil 3603131098 ("" (skeep) (("" (name "CF" "collect_funs(n, m)
                                          (P,
                                           LAMBDA (i: I(n)): 1,
                                           n,
                                           m)") (("" (replace -1) (("" (typepred "CF") (("" (hide -1) (("" (case "NOT FunEqSet(n, m)(P, n, m, LAMBDA (i: I(n)): 1) = P") (("1" (hide 2) (("1" (hide -1) (("1" (decompose-equality 1) (("1" (iff) (("1" (expand "FunEqSet") (("1" (ground) (("1" (skosimp*) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep -) (("2" (inst + "bij") (("1" (split) (("1" (skeep) (("1" (inst - "g") nil nil)) nil) ("2" (hide -2) (("2" (expand "bijective?") (("2" (ground) (("1" (expand "injective?") (("1" (skeep) (("1" (inst - "x1" "x2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "surjective?") (("2" (skeep) (("2" (inst - "y") (("2" (skeep) (("2" (inst + "x") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (split) (("1" (skeep) (("1" (replaces -1) (("1" (ground) nil nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((collect_funs def-decl "{l: list[listn[I(m)](n)] |
   EXISTS (bij: [(FunEqSet(n, m)(P, i, j, f)) -> below(length(l))]):
     (FORALL (g: (FunEqSet(n, m)(P, i, j, f))):
        nth(l, bij(g)) = listrep(n, m)(g))
      AND bijective?(bij)}" count_functions nil) (bijective? const-decl "bool" functions nil) (listrep const-decl "listn[I(m)](n)" count_functions nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (FunEqSet const-decl "set[FinFun(n, m)]" count_functions nil) (set type-eq-decl nil sets nil) (listn type-eq-decl nil listn nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (pred type-eq-decl nil defined_types nil) (FinFun type-eq-decl nil count_functions nil) (I type-eq-decl nil count_functions nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bij skolem-const-decl "[(FunEqSet(n, m)(P, n, m, LAMBDA (i: I(n)): 1)) -> below(length(CF))]" count_functions nil) (CF skolem-const-decl "{l: list[listn[I(m)](n)] |
   EXISTS (bij:
             [(FunEqSet(n, m)(P, n, m, LAMBDA (i: I(n)): 1)) ->
                below(length(l))]):
     (FORALL (g: (FunEqSet(n, m)(P, n, m, LAMBDA (i: I(n)): 1))):
        nth(l, bij(g)) = listrep(n, m)(g))
      AND bijective?(bij)}" count_functions nil) (P skolem-const-decl "pred[FinFun(n, m)]" count_functions nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (m skolem-const-decl "posnat" count_functions nil) (n skolem-const-decl "posnat" count_functions nil) (injective? const-decl "bool" functions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (surjective? const-decl "bool" functions nil) (TRUE const-decl "bool" booleans nil)) nil (funs_sat subtype "count_functions.collect_funs(count_functions.n, count_functions.m)(count_functions.P, LAMBDA (i: count_functions.I(count_functions.n)): 1, count_functions.n, count_functions.m)" "{l: list_adt[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].list | EXISTS (bij: [(count_functions.P) -> naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))]): booleans.AND(FORALL (g: (count_functions.P)): list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].nth(l, bij(g)) = count_functions.listrep(count_functions.n, count_functions.m)(g), functions[(count_functions.P), naturalnumbers.below(list_props[listn[count_functions.I(count_functions.m)].listn(count_functions.n)].length(l))].bijective?(bij))}"))) (perm5_test 0 (perm5_test-1 nil 3603715146 ("" (eval-formula) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil)) shostak)) (isasol_test8 0 (isasol_test8-1 nil 3603715317 ("" (eval-formula) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil)) shostak)))
