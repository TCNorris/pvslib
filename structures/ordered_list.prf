(ordered_list
 (ordered_list?_TCC1 0
  (ordered_list?_TCC1-2 "" 3790088190 ("" (tcc) nil nil) nil shostak
   (ordered_list? subtype "ordered_list.l"
    "(list_adt[ordered_list.T].cons?)"))
  (ordered_list?_TCC1-1 nil 3620487638 ("" (tcc)) nil nil
   (ordered_list? subtype "ordered_list.l"
    "(list_adt[ordered_list.T].cons?)")))
 (ordered_list?_TCC2 0
  (ordered_list?_TCC2-2 "" 3790088190 ("" (tcc) nil nil) nil shostak
   (ordered_list? termination "ordered_list.ordered_list?(ordered_list.l)"
    "nil"))
  (ordered_list?_TCC2-1 nil 3620487638 ("" (tcc))
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (length def-decl "nat" list_props nil))
   nil
   (ordered_list? termination "ordered_list.ordered_list?(ordered_list.l)"
    "nil")))
 (ol_suffix 0
  (ol_suffix-1 nil 3620556213 ("" (grind) nil nil)
   ((ordered_list? def-decl "bool" ordered_list nil)) shostak))
 (null_ol_TCC1 0
  (null_ol_TCC1-1 nil 3620647273 ("" (subtype-tcc) (("" (grind) nil nil)) nil)
   ((ordered_list? def-decl "bool" ordered_list nil)) nil
   (null_ol subtype "list_adt[ordered_list.T].null" "ordered_list")))
 (car_ol_TCC1 0
  (car_ol_TCC1-1 nil 3620643049 ("" (subtype-tcc) nil nil)
   ((ol_is_l expr-judgement "list[T]" ordered_list nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil ordered_list nil)
    (list type-decl nil list_adt nil)
    (ordered_list? def-decl "bool" ordered_list nil)
    (ordered_list type-eq-decl nil ordered_list nil)
    (null_ol? const-decl "bool" ordered_list nil))
   nil
   (car_ol subtype "ordered_list.nnol" "(list_adt[ordered_list.T].cons?)")))
 (cdr_ol_TCC1 0
  (cdr_ol_TCC1-1 nil 3620643049
   ("" (skeep)
    (("" (use "ol_suffix")
      (("" (typepred "nnol")
        (("" (inst -2 "car(nnol)") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((ol_suffix formula-decl nil ordered_list nil)
    (null_ol? const-decl "bool" ordered_list nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (ordered_list type-eq-decl nil ordered_list nil)
    (ordered_list? def-decl "bool" ordered_list nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil ordered_list nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (ol_is_l expr-judgement "list[T]" ordered_list nil))
   nil
   (cdr_ol subtype "list_adt[ordered_list.T].cdr(ordered_list.nnol)"
    "ordered_list")))
 (length_cdr_ol 0
  (length_cdr_ol-2 "" 3620754840 ("" (grind) nil nil)
   ((ol_is_l expr-judgement "list[T]" ordered_list nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil ordered_list nil)
    (list type-decl nil list_adt nil)
    (ordered_list? def-decl "bool" ordered_list nil)
    (ordered_list type-eq-decl nil ordered_list nil)
    (null_ol? const-decl "bool" ordered_list nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (length def-decl "nat" list_props nil)
    (cdr_ol const-decl "ordered_list" ordered_list nil))
   shostak)
  (length_cdr_ol-1 nil 3620749834
   ("" (grind)
    (("" (expand "length" 1 1)
      (("" (lift-if)
        (("" (grind)
          (("1" (case "ol!1 = cons(car(ol!1), cdr(ol!1))")
            (("1" (grind) nil nil)
             ("2" (grind)
              (("2" (hide-all-but 1)
                (("2" (use "list_cons_eta[T]") (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (postpone) nil nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (ol_ind_sch_TCC1 0
  (ol_ind_sch_TCC1-2 "" 3790088190 ("" (tcc) nil nil) nil shostak
   (ol_ind_sch subtype
    "list_adt[ordered_list.T].cons(ordered_list.x, ordered_list.ol)"
    "ordered_list"))
  (ol_ind_sch_TCC1-1 nil 3620486374 ("" (tcc)) nil nil
   (ol_ind_sch subtype
    "list_adt[ordered_list.T].cons(ordered_list.x, ordered_list.ol)"
    "ordered_list")))
 (ol_ind_sch 0
  (ol_ind_sch-1 nil 3620487676
   ("" (skeep)
    (("" (induct "ol")
      (("1" (typepred "ol!1") (("1" (propax) nil nil)) nil)
       ("2" (assert) nil nil)
       ("3" (skolem 1 ("x" "ol"))
        (("3" (flatten 1)
          (("3" (inst?)
            (("1" (split -4)
              (("1" (inst?) nil nil)
               ("2" (prop)
                (("2" (hide-all-but (-1 1))
                  (("2" (use "ol_suffix") (("2" (assert) nil nil)) nil)) nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (ordered_list? def-decl "bool" ordered_list nil)
    (ordered_list type-eq-decl nil ordered_list nil)
    (pred type-eq-decl nil defined_types nil)
    (T formal-type-decl nil ordered_list nil)
    (list_induction formula-decl nil list_adt nil)
    (ol_is_l expr-judgement "list[T]" ordered_list nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (x skolem-const-decl "T" ordered_list nil)
    (ol_suffix formula-decl nil ordered_list nil)
    (ol skolem-const-decl "list[T]" ordered_list nil))
   shostak))
 (cons_ol_TCC1 0
  (cons_ol_TCC1-2 "" 3790088190 ("" (tcc) nil nil) nil shostak
   (cons_ol subtype "ordered_list.ol" "(list_adt[ordered_list.T].cons?)"))
  (cons_ol_TCC1-1 nil 3620502735 ("" (tcc))
   ((ol_is_l expr-judgement "list[T]" ordered_list nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil ordered_list nil)
    (list type-decl nil list_adt nil)
    (ordered_list? def-decl "bool" ordered_list nil)
    (ordered_list type-eq-decl nil ordered_list nil))
   nil
   (cons_ol subtype "ordered_list.ol" "(list_adt[ordered_list.T].cons?)")))
 (cons_ol_TCC2 0
  (cons_ol_TCC2-1 nil 3620647273 ("" (grind) nil nil)
   ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (< formal-const-decl "pred[[T, T]]" ordered_list nil)
    (pred type-eq-decl nil defined_types nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ordered_list type-eq-decl nil ordered_list nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil ordered_list nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ol_is_l expr-judgement "list[T]" ordered_list nil)
    (ordered_list? def-decl "bool" ordered_list nil))
   nil
   (cons_ol subtype
    "list_adt[ordered_list.T].cons(ordered_list.x, ordered_list.ol)"
    "ordered_list")))
 (last_ol_TCC1 0
  (last_ol_TCC1-2 "" 3790088190 ("" (tcc) nil nil) nil shostak
   (last_ol subtype "ordered_list.ol" "(list_adt[ordered_list.T].cons?)"))
  (last_ol_TCC1-1 nil 3620502735 ("" (tcc)) nil nil
   (last_ol subtype "ordered_list.ol" "(list_adt[ordered_list.T].cons?)")))
 (last_ol_TCC2 0
  (last_ol_TCC2-1 nil 3620502735
   ("" (skeep)
    (("" (typepred "ol") (("" (use "ol_suffix") (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (ordered_list type-eq-decl nil ordered_list nil)
    (ordered_list? def-decl "bool" ordered_list nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil ordered_list nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ol_suffix formula-decl nil ordered_list nil)
    (ol_is_l expr-judgement "list[T]" ordered_list nil))
   shostak
   (last_ol subtype "list_adt[ordered_list.T].cdr(ordered_list.ol)"
    "{ol | (booleans.NOT)(list_adt[ordered_list.T].null?(ordered_list.ol))}")))
 (last_ol_TCC3 0
  (last_ol_TCC3-1 nil 3620647273 ("" (termination-tcc) nil nil)
   ((length def-decl "nat" list_props nil)) nil
   (last_ol termination
    "ordered_list.last_ol(list_adt[ordered_list.T].cdr(ordered_list.ol))"
    "nil")))
 (appendable_ol?_TCC1 0
  (appendable_ol?_TCC1-1 nil 3620647273 ("" (subtype-tcc) nil nil)
   ((ol_is_l expr-judgement "list[T]" ordered_list nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil ordered_list nil)
    (list type-decl nil list_adt nil)
    (ordered_list? def-decl "bool" ordered_list nil)
    (ordered_list type-eq-decl nil ordered_list nil)
    (null_ol? const-decl "bool" ordered_list nil))
   nil
   (appendable_ol? subtype "ordered_list.ol2"
    "{ol | (booleans.NOT)(ordered_list.null_ol?(ordered_list.ol))}")))
 (append_ol_TCC1 0
  (append_ol_TCC1-1 nil 3620502735
   ("" (induct "ol1")
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skolem 1 ("ol1_h" "ol1_t"))
      (("3" (flatten)
        (("3" (skeep)
          (("3" (use "ol_suffix")
            (("3" (assert)
              (("3" (inst -2 "ol2")
                (("1" (expand "append" 1)
                  (("1" (expand "ordered_list?" 1)
                    (("1" (flatten 1)
                      (("1" (split 2)
                        (("1" (expand "append" 1)
                          (("1" (lift-if)
                            (("1" (typepred "ol2")
                              (("1" (split 1)
                                (("1" (flatten 1)
                                  (("1"
                                    (case "null?(ol1_t) AND NOT null?(append(ol1_t, ol2)) IMPLIES NOT null?(ol2)")
                                    (("1" (assert) (("1" (grind) nil nil))
                                      nil)
                                     ("2" (hide-all-but 1)
                                      (("2" (grind) nil nil)) nil))
                                    nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (typepred "ol2") (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (first_ol const-decl "T" ordered_list nil)
    (last_ol def-decl "T" ordered_list nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ol1_t skolem-const-decl "list[T]" ordered_list nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (ol1_h skolem-const-decl "T" ordered_list nil)
    (ol2 skolem-const-decl "{ol2 | appendable_ol?(cons(ol1_h, ol1_t), ol2)}"
     ordered_list nil)
    (ol_suffix formula-decl nil ordered_list nil)
    (ol_is_l expr-judgement "list[T]" ordered_list nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil ordered_list nil)
    (append def-decl "list[T]" list_props nil)
    (appendable_ol? const-decl "bool" ordered_list nil)
    (ordered_list type-eq-decl nil ordered_list nil)
    (ordered_list? def-decl "bool" ordered_list nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak
   (append_ol subtype
    "list_props[ordered_list.T].append(ordered_list.ol1, ordered_list.ol2)"
    "ordered_list")))
 (ordered_append 0
  (ordered_append-1 nil 3620742534
   ("" (induct "l1")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("h_" "t_"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (expand "ordered_list?" 1 1)
            (("2" (inst -1 "l2")
              (("2" (expand "append" -2)
                (("2" (use "ol_suffix")
                  (("2" (assert) (("2" (prop) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ol_suffix formula-decl nil ordered_list nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil ordered_list nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (append def-decl "list[T]" list_props nil)
    (ordered_list? def-decl "bool" ordered_list nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (carol_lt_nth 0
  (carol_lt_nth-1 nil 3633386082
   ("" (induct "nnol")
    (("1" (skolem 2 ("i_")) (("1" (grind) nil nil)) nil)
     ("2" (skolem 1 ("i_"))
      (("2" (grind) (("2" (typepred "i_") (("2" (grind) nil nil)) nil)) nil))
      nil)
     ("3" (flatten) (("3" (skolem 2 ("i_")) (("3" (grind) nil nil)) nil)) nil)
     ("4" (skolem 1 ("e_" "l_"))
      (("4" (flatten)
        (("4" (skolem 2 ("i_"))
          (("4" (expand "car_ol")
            (("4" (expand "nth" 2)
              (("4" (case "l_=null")
                (("1" (typepred "i_") (("1" (grind) nil nil)) nil)
                 ("2" (split)
                  (("1" (inst -1 "i_-1")
                    (("1" (expand "ordered_list?" -2)
                      (("1" (split)
                        (("1" (grind) nil nil)
                         ("2" (flatten)
                          (("2" (use "order")
                            (("2" (expand "strict_order?")
                              (("2" (flatten)
                                (("2" (expand "transitive?")
                                  (("2" (inst? -2 :where 3)
                                    (("2" (inst? -2 :where -5)
                                      (("2" (assert) nil nil)) nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (typepred "i_") (("2" (grind) nil nil)) nil))
                    nil)
                   ("2" (expand "ordered_list?" -1) (("2" (grind) nil nil))
                    nil)
                   ("3" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strict_order? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (order formula-decl nil ordered_list nil)
    (i_ skolem-const-decl "{i: below(length(cons(e_, l_))) | i > 0}"
     ordered_list nil)
    (l_ skolem-const-decl "list[T]" ordered_list nil)
    (e_ skolem-const-decl "T" ordered_list nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (ol_is_l expr-judgement "list[T]" ordered_list nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil ordered_list nil)
    (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil)
    (car_ol const-decl "T" ordered_list nil)
    (< formal-const-decl "pred[[T, T]]" ordered_list nil)
    (pred type-eq-decl nil defined_types nil) (> const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (null_ol? const-decl "bool" ordered_list nil)
    (ordered_list type-eq-decl nil ordered_list nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (ordered_list? def-decl "bool" ordered_list nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (nth_ol_TCC1 0
  (nth_ol_TCC1-1 nil 3632131374 ("" (subtype-tcc) nil nil) nil nil
   (nth_ol subtype "ordered_list.j" "below[length[T](ol1)]")))
 (nth_ol 0
  (nth_ol-1 nil 3633299397
   ("" (induct "ol1")
    (("1" (skolem 2 ("i_" "j_")) (("1" (grind) nil nil)) nil)
     ("2" (flatten) (("2" (grind) nil nil)) nil)
     ("3" (skolem 1 ("e" "list"))
      (("3" (flatten)
        (("3" (split -1)
          (("1" (skolem 1 ("i_" "j_"))
            (("1" (expand "nth" 1 1)
              (("1" (lift-if)
                (("1" (split)
                  (("1" (flatten)
                    (("1" (expand "nth" 1)
                      (("1" (lemma "carol_lt_nth")
                        (("1" (inst -1 "cons(e,list)" "i_")
                          (("1" (expand "car_ol" -1)
                            (("1" (expand "nth" -1) (("1" (propax) nil nil))
                              nil))
                            nil)
                           ("2" (assert)
                            (("2" (expand "null_ol?") (("2" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (expand "nth" 2 2)
                      (("2" (inst -1 "i_-1" "j_-1") (("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand "ordered_list?" -1) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (e skolem-const-decl "T" ordered_list nil)
    (list skolem-const-decl "list[T]" ordered_list nil)
    (null_ol? const-decl "bool" ordered_list nil)
    (> const-decl "bool" reals nil) (car_ol const-decl "T" ordered_list nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (carol_lt_nth formula-decl nil ordered_list nil)
    (j_ skolem-const-decl "{j: nat | j < i_}" ordered_list nil)
    (i_ skolem-const-decl "below(length(cons(e, list)))" ordered_list nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ordered_list type-eq-decl nil ordered_list nil)
    (ol_is_l expr-judgement "list[T]" ordered_list nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil ordered_list nil)
    (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil)
    (< formal-const-decl "pred[[T, T]]" ordered_list nil)
    (pred type-eq-decl nil defined_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (ordered_list? def-decl "bool" ordered_list nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (take_ol 0
  (take_ol-1 nil 3635156440
   ("" (induct "n")
    (("1" (grind) nil nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand "take" 1)
          (("2" (split 1)
            (("1" (grind) nil nil)
             ("2" (flatten)
              (("2" (expand "ordered_list?" 2)
                (("2" (flatten)
                  (("2" (split 3)
                    (("1" (hide -1)
                      (("1" (expand "take" 1)
                        (("1" (lift-if 1)
                          (("1" (split 1)
                            (("1" (flatten)
                              (("1" (expand "length" 2)
                                (("1" (grind) nil nil)) nil))
                              nil)
                             ("2" (flatten)
                              (("2" (split 2)
                                (("1" (grind) nil nil)
                                 ("2" (flatten)
                                  (("2" (typepred "ol")
                                    (("2" (expand "ordered_list?" -1)
                                      (("2" (grind) nil nil)) nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (inst -1 "cdr(ol)")
                      (("2" (typepred "ol")
                        (("2" (expand "ordered_list?" -1)
                          (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (ol skolem-const-decl "ordered_list" ordered_list nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (length def-decl "nat" list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (take def-decl "list[T]" more_list_props nil)
    (ordered_list type-eq-decl nil ordered_list nil)
    (ordered_list? def-decl "bool" ordered_list nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil ordered_list nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (last_take_nth_TCC1 0
  (last_take_nth_TCC1-1 nil 3632131374
   ("" (skeep :preds? t)
    (("" (use "take_ol")
      (("" (assert) (("" (use "length_take[T]") (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((take_ol formula-decl nil ordered_list nil)
    (below type-eq-decl nil naturalnumbers nil)
    (ordered_list type-eq-decl nil ordered_list nil)
    (ordered_list? def-decl "bool" ordered_list nil)
    (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil)
    (T formal-type-decl nil ordered_list nil) (< const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (length_take formula-decl nil more_list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (take def-decl "list[T]" more_list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (last_take_nth subtype
    "more_list_props[ordered_list.T].take(ordered_list.ol, (number_fields.+)(ordered_list.n, 1))"
    "{ol | (booleans.NOT)(list_adt[ordered_list.T].null?(ordered_list.ol))}")))
 (last_take_nth 0
  (last_take_nth-1 nil 3635156888
   ("" (skeep)
    (("" (typepred "n")
      (("" (generalize "ol" "ol_")
        (("1" (generalize "n" "n_" "nat")
          (("1" (induct "n_")
            (("1" (grind) nil nil)
             ("2" (skeep)
              (("2" (skeep)
                (("2" (expand "take" 1)
                  (("2" (lift-if 1)
                    (("2" (split 1)
                      (("1" (flatten) (("1" (assert) nil nil)) nil)
                       ("2" (flatten)
                        (("2" (expand "last_ol" 2)
                          (("2" (lift-if 2)
                            (("2" (split 2)
                              (("1" (flatten)
                                (("1" (assert)
                                  (("1" (hide -2)
                                    (("1" (use "length_take[T]")
                                      (("1"
                                        (grind)
                                        (("1"
                                          (expand "length" -3)
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (flatten)
                                (("2" (assert)
                                  (("2" (expand "nth" 2)
                                    (("2" (inst? -1 :where 2)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (expand "length" -1)
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (typepred "ol_")
                                        (("2"
                                          (expand "ordered_list?" -1)
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (hide-all-but 1)
              (("3" (skeep)
                (("3" (use "take_ol")
                  (("3" (assert)
                    (("3" (expand "take" -3) (("3" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (hide-all-but 1)
            (("2" (skeep)
              (("2" (use "take_ol")
                (("2" (assert)
                  (("2" (expand "take" -3) (("2" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide-all-but 1)
          (("2" (skeep)
            (("2" (use "take_ol")
              (("2" (assert)
                (("2" (expand "take" -3) (("2" (propax) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (ordered_list type-eq-decl nil ordered_list nil)
    (ordered_list? def-decl "bool" ordered_list nil)
    (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil)
    (T formal-type-decl nil ordered_list nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (take_ol formula-decl nil ordered_list nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (length_take formula-decl nil more_list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs
     nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (ol_ skolem-const-decl "ordered_list" ordered_list nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (last_ol def-decl "T" ordered_list nil)
    (take def-decl "list[T]" more_list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil))
   shostak)))

