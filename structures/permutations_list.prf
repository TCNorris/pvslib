(permutations_list
 (count_TCC1 0
  (count_TCC1-1 nil 3654534782 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (length def-decl "nat" list_props nil))
   nil
   (count termination
          "permutations_list.count(permutations_list.t)(permutations_list.xs)"
     "nil")))
 (count_nth 0
  (count_nth-1 nil 3656092583
   ("" (induct "l")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("n" "ns"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (case "i=0")
            (("1" (replace -1 :hide? t)
              (("1" (expand "nth" 1) (("1" (grind) nil nil)) nil)) nil)
             ("2" (expand "nth" 2)
              (("2" (assert)
                (("2" (inst -1 "i-1") (("2" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil permutations_list nil)
    (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil)
    (count def-decl "nat" permutations_list nil)
    (> const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (count_member 0
  (count_member-2 nil 3656851273
   ("" (induct "l")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("n" "ns"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (case "n=a")
            (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil)
             ("2" (assert) (("2" (inst -1 "a") (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil permutations_list nil)
    (member def-decl "bool" list_props nil)
    (count def-decl "nat" permutations_list nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil)
  (count_member-1 nil 3656092798
   ("" (induct "l")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("n" "ns"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (case "n=a")
            (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil)
             ("2" (expand "count" -2)
              (("2" (assert) (("2" (inst -1 "a") (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (count_append 0
  (count_append-1 nil 3656151822
   ("" (skeep 1 :but ("l1"))
    (("" (induct "l1")
      (("1" (grind) nil nil)
       ("2" (skeep 1 :but (("cons1_var" "x") ("cons2_var" "xs")))
        (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (count def-decl "nat" permutations_list nil)
    (append def-decl "list[T]" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (T formal-type-decl nil permutations_list nil)
    (list_induction formula-decl nil list_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil))
   shostak))
 (no_repetitions_count 0
  (no_repetitions_count-1 nil 3656850972
   ("" (induct "l")
    (("1" (grind) nil nil)
     ("2" (skeep 1 :but (("cons1_var" "x") ("cons2_var" "xs")))
      (("2" (skeep 1)
        (("2" (case "a=x")
          (("1" (replace -1 :hide? t)
            (("1" (expand "count" 1)
              (("1" (use "count_member")
                (("1" (assert)
                  (("1" (hide 1)
                    (("1" (hide -2)
                      (("1" (expand "no_repetitions?")
                        (("1" (use "member_nth[T]")
                          (("1" (assert)
                            (("1" (skeep -1)
                              (("1" (inst -3 "0" "i+1")
                                (("1" (assert) (("1" (grind) nil nil)) nil)
                                 ("2" (typepred "i") (("2" (grind) nil nil))
                                  nil)
                                 ("3" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand "count" 2)
            (("2" (assert)
              (("2" (expand "member" -3)
                (("2" (split -1)
                  (("1" (inst?) (("1" (assert) nil nil)) nil)
                   ("2" (hide-all-but (-1 1))
                    (("2" (lemma "no_repetitions_append[T]")
                      (("2" (inst -1 "(:x:)" "xs")
                        (("2" (expand "append" -1)
                          (("2" (expand "append" -1) (("2" (flatten) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (member_nth formula-decl nil more_list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nth def-decl "T" list_props nil)
    (i skolem-const-decl "below(length(xs))" permutations_list nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (xs skolem-const-decl "list[T]" permutations_list nil)
    (x skolem-const-decl "T" permutations_list nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count_member formula-decl nil permutations_list nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (no_repetitions_append formula-decl nil more_list_props nil)
    (append def-decl "list[T]" list_props nil)
    (/= const-decl "boolean" notequal nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil permutations_list nil)
    (count def-decl "nat" permutations_list nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (member def-decl "bool" list_props nil)
    (no_repetitions? const-decl "bool" more_list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (permutation_grow 0
  (permutation_grow-1 nil 3656151446
   ("" (skeep)
    (("" (expand "permutation_list")
      (("" (expand "permutation?")
        (("" (expand "includes?")
          (("" (flatten)
            (("" (split 1)
              (("1" (skeep)
                (("1" (hide -2)
                  (("1" (inst -1 "t")
                    (("1" (rewrite* "count_append") (("1" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide -1)
                (("2" (skeep)
                  (("2" (inst -1 "t")
                    (("2" (rewrite* "count_append") (("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((permutation_list const-decl "bool" permutations_list nil)
    (includes? const-decl "bool" permutations_list nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (append def-decl "list[T]" list_props nil)
    (list type-decl nil list_adt nil)
    (count_append formula-decl nil permutations_list nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (count def-decl "nat" permutations_list nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (T formal-type-decl nil permutations_list nil)
    (permutation? const-decl "bool" permutations_list nil))
   shostak))
 (permutation_decrease 0
  (permutation_decrease-1 nil 3656150971
   ("" (skeep)
    (("" (case "member(a,l)")
      (("1" (use "expand_list_app[T]")
        (("1" (assert)
          (("1" (skeep -1)
            (("1" (inst 1 "l1" "l2")
              (("1" (assert)
                (("1" (expand "permutation_list")
                  (("1" (expand "permutation?")
                    (("1" (flatten)
                      (("1" (expand "includes?")
                        (("1" (replace -1 :hide? t)
                          (("1" (split 1)
                            (("1" (hide -3 -1)
                              (("1" (skeep)
                                (("1" (inst?)
                                  (("1" (use "count_append[T]")
                                    (("1" (replace -1 :hide? t)
                                      (("1"
                                        (rewrite "count_append")
                                        (("1"
                                          (rewrite "count_append")
                                          (("1"
                                            (expand "count" -1 1)
                                            (("1" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide -1 -2)
                              (("2" (skeep)
                                (("2" (inst?)
                                  (("2" (rewrite* "count_append")
                                    (("2" (grind) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (expand "permutation_list")
          (("2" (expand "permutation?")
            (("2" (expand "includes?")
              (("2" (flatten)
                (("2" (hide -2)
                  (("2" (inst -1 "a")
                    (("2" (expand "count" -1 1)
                      (("2" (lemma "count_member")
                        (("2" (inst -1 "a" "l") (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((member def-decl "bool" list_props nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil permutations_list nil)
    (permutation_list const-decl "bool" permutations_list nil)
    (TRUE const-decl "bool" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (count def-decl "nat" permutations_list nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (append def-decl "list[T]" list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (count_append formula-decl nil permutations_list nil)
    (includes? const-decl "bool" permutations_list nil)
    (permutation? const-decl "bool" permutations_list nil)
    (expand_list_app formula-decl nil more_list_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count_member formula-decl nil permutations_list nil))
   shostak))
 (permutation_reverse 0
  (permutation_reverse-1 nil 3656147983
   ("" (induct "l2")
    (("1" (grind) nil nil)
     ("2" (skeep 1 :but (("cons1_var" "x") ("cons2_var" "xs")))
      (("2" (skeep)
        (("2" (expand "reverse" 1)
          (("2"
            (case "EXISTS(l1_,l1__:list[T]): l1 = append(l1_,append( (:x:), l1__)) AND permutation_list(append(l1_,l1__))(xs)")
            (("1" (skeep -1)
              (("1" (inst -3 "append(l1_, l1__)")
                (("1" (assert)
                  (("1"
                    (case "permutation_list(append(l1_, append((:x:), l1__)))(append(reverse(xs),(:x:)))")
                    (("1" (assert) nil nil)
                     ("2" (hide-all-but (-3 1))
                      (("2" (lemma "permutation_grow")
                        (("2" (inst -1 "x" "l1_" "l1__" "reverse(xs)" "null")
                          (("2" (split -1)
                            (("1" (expand "append" -1 4)
                              (("1" (expand "append" -1 4)
                                (("1" (propax) nil nil)) nil))
                              nil)
                             ("2" (use "append_null[T]")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide-all-but (-2 1))
              (("2" (use "permutation_decrease") (("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((permutation_decrease formula-decl nil permutations_list nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (append_null formula-decl nil list_props nil)
    (permutation_grow formula-decl nil permutations_list nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (append def-decl "list[T]" list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (count def-decl "nat" permutations_list nil)
    (includes? const-decl "bool" permutations_list nil)
    (permutation? const-decl "bool" permutations_list nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil permutations_list nil)
    (reverse def-decl "list[T]" list_props nil)
    (permutation_list const-decl "bool" permutations_list nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (permutation_reflexive 0
  (permutation_reflexive-1 nil 3656152174 ("" (grind) nil nil)
   ((includes? const-decl "bool" permutations_list nil)
    (permutation? const-decl "bool" permutations_list nil)
    (permutation_list const-decl "bool" permutations_list nil))
   shostak)))

