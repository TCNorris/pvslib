(circle_optimum_2D (intersects_circle_fun_scal 0 (intersects_circle_fun_scal-1 nil 3527949260 ("" (case "FORALL (R: posreal, c: Vect2, k: posreal, v: Vect2):
                                    intersects_circle_fun?(v, c, R) IMPLIES
                                     intersects_circle_fun?(k * v, c, R)") (("1" (skeep) (("1" (ground) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (inst - "R" "c" "1/k" "k*v") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "intersects_circle_fun?") (("2" (flatten) (("2" (case "v = zero") (("1" (assert) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil) ("2" (case "k*v /= zero") (("1" (assert) (("1" (flatten) (("1" (lemma "Delta_scal[R]") (("1" (inst - "-c" "k" "v") (("1" (replace -1) (("1" (hide -1) (("1" (mult-by -1 "sq(k)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (mult-by -2 "k") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (flatten) (("2" (expand "zero") (("2" (decompose-equality -1) (("2" (decompose-equality +) (("1" (mult-by 1 "k") (("1" (rewrite "vx_scal") (("1" (assert) nil nil)) nil)) nil) ("2" (mult-by 1 "k") (("2" (rewrite "vy_scal") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (zero const-decl "Vector" vectors_2D vectors) (scal_zero formula-decl nil vectors_2D vectors) (dot_scal_right formula-decl nil vectors_2D vectors) (sqv_neg formula-decl nil vectors_2D vectors) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (sq_nz_pos application-judgement "posreal" sq reals) (vx_scal formula-decl nil vectors_2D vectors) (nonzero_real nonempty-type-eq-decl nil reals nil) (both_sides_times1 formula-decl nil real_props nil) (vy_scal formula-decl nil vectors_2D vectors) (AND const-decl "[bool, bool -> bool]" booleans nil) (Delta_scal formula-decl nil horizontal nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (sq const-decl "nonneg_real" sq reals) (Delta const-decl "real" horizontal nil) (* const-decl "real" vectors_2D vectors) (real_times_real_is_real application-judgement "real" reals nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (- const-decl "Vector" vectors_2D vectors) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (scal_assoc formula-decl nil vectors_2D vectors) (scal_1 formula-decl nil vectors_2D vectors) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (intersects_circle_fun? const-decl "bool" circle_optimum_2D nil) (Vector type-eq-decl nil vectors_2D vectors) (* const-decl "Vector" vectors_2D vectors)) shostak)) (intersects_circle_fun_def 0 (intersects_circle_fun_def-1 nil 3527524122 ("" (skeep) (("" (case "v = zero") (("1" (replace -1) (("1" (expand "intersects_circle_fun?") (("1" (expand "circle?") (("1" (expand "segment?") (("1" (ground) (("1" (inst + "zero") (("1" (assert) (("1" (rewrite "sq_eq" 1 :dir rl) (("1" (rewrite "sq_norm") nil nil)) nil)) nil)) nil) ("2" (skeep -1) (("2" (skeep -2) (("2" (replace -2) (("2" (assert) (("2" (rewrite "sqrt_eq" 1 :dir rl) (("2" (rewrite "sqrt_sqv_norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) (("1" (expand "intersects_circle_fun?") (("1" (flatten) (("1" (inst + "Theta_D[R](-c,v,1)*v") (("1" (split +) (("1" (expand "circle?") (("1" (lemma "Theta_D_unique[R]") (("1" (inst - "v" "-c" "Theta_D[R](-c, v, 1)") (("1" (assert) (("1" (rewrite "sqrt_eq" :dir rl) (("1" (rewrite "sqrt_sqv_norm") (("1" (hide-all-but (-1 1)) (("1" (grind :exclude ("norm" "Theta_D")) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "segment?") (("2" (inst?) (("2" (lemma "Theta_D_ge_0[R]") (("2" (case "NOT sqv(-c) <= sq(R)") (("1" (assert) (("1" (inst?) (("1" (assert) (("1" (split -) (("1" (lemma "Theta_D_le[R]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -4) (("2" (hide -2) (("2" (lemma "horizontal_los_inside_Theta[R]") (("2" (inst?) (("2" (inst - "0") (("2" (assert) (("2" (lemma "Theta_D_unique[R]") (("2" (inst?) (("2" (inst - "0") (("2" (assert) (("2" (lemma "Theta_D_le[R]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep -) (("2" (expand "segment?") (("2" (skeep -2) (("2" (replaces -2) (("2" (expand "intersects_circle_fun?") (("2" (case "NOT Delta[R](-c, v) >= 0") (("1" (hide 2) (("1" (rewrite "Delta_ge_0") (("1" (inst + "t") (("1" (expand "circle?") (("1" (rewrite "sqrt_eq" 1 :dir rl) (("1" (rewrite "sqrt_sqv_norm") (("1" (grind :exclude "norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (case "t = 0") (("1" (replace -1) (("1" (expand "circle?") (("1" (assert) (("1" (rewrite "sqrt_le" 2 :dir rl) (("1" (rewrite "sqrt_sqv_norm") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "circle?") (("2" (lemma "horizontal_conflict[norm(c)]") (("1" (inst - "v" "-c") (("1" (flatten) (("1" (hide -2) (("1" (split -) (("1" (flatten) (("1" (split -) (("1" (hide-all-but -1) (("1" (rewrite "sqrt_lt" :dir rl) (("1" (assert) (("1" (rewrite "sqrt_sqv_norm") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 2)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "horizontal_conflict?") (("2" (inst + "t") (("2" (rewrite "sqrt_lt" 1 :dir rl) (("2" (assert) (("2" (rewrite "sqrt_sqv_norm") (("2" (rewrite "sqrt_le" 4 :dir rl) (("2" (rewrite "sqrt_sqv_norm") (("2" (assert) (("2" (hide -1) (("2" (grind :exclude "norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((zero const-decl "Vector" vectors_2D vectors) (Vector type-eq-decl nil vectors_2D vectors) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (real nonempty-type-from-decl nil reals nil) (intersects_circle_fun? const-decl "bool" circle_optimum_2D nil) (segment? const-decl "bool" circle_optimum_2D nil) (sqrt_eq formula-decl nil sqrt reals) (sqv const-decl "nnreal" vectors_2D vectors) (sq const-decl "nonneg_real" sq reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sqrt_pos application-judgement "posreal" sqrt reals) (sqrt_sq formula-decl nil sqrt reals) (sqrt_sqv_norm formula-decl nil vectors_2D vectors) (sq_eq formula-decl nil sq reals) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nnreal type-eq-decl nil real_types nil) (norm const-decl "nnreal" vectors_2D vectors) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (sq_norm formula-decl nil vectors_2D vectors) (norm_neg formula-decl nil vectors_2D vectors) (sub_zero_left formula-decl nil vectors_2D vectors) (sq_nz_pos application-judgement "posreal" sq reals) (scal_zero formula-decl nil vectors_2D vectors) (circle? const-decl "bool" circle_optimum_2D nil) (sqrt_le formula-decl nil sqrt reals) (horizontal_conflict formula-decl nil horizontal nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sqrt_lt formula-decl nil sqrt reals) (horizontal_conflict? const-decl "bool" horizontal nil) (dot_zero_left formula-decl nil vectors_2D vectors) (sub_zero_right formula-decl nil vectors_2D vectors) (neg_zero formula-decl nil vectors_2D vectors) (norm_zero formula-decl nil vectors_2D vectors) (norm_eq_0 formula-decl nil vectors_2D vectors) (Delta_ge_0 formula-decl nil horizontal nil) (TRUE const-decl "bool" booleans nil) (v skolem-const-decl "Vect2" circle_optimum_2D nil) (c skolem-const-decl "Vect2" circle_optimum_2D nil) (- const-decl "Vector" vectors_2D vectors) (Delta const-decl "real" horizontal nil) (R skolem-const-decl "posreal" circle_optimum_2D nil) (* const-decl "Vector" vectors_2D vectors) (/= const-decl "boolean" notequal nil) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign type-eq-decl nil sign reals) (Theta_D const-decl "real" horizontal nil) (Theta_D_ge_0 formula-decl nil horizontal nil) (scal_0 formula-decl nil vectors_2D vectors) (add_zero_right formula-decl nil vectors_2D vectors) (horizontal_los_inside_Theta formula-decl nil horizontal nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (* const-decl "real" vectors_2D vectors) (Theta_D_le formula-decl nil horizontal nil) (Sp_vect2 type-eq-decl nil horizontal nil) (<= const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (+ const-decl "Vector" vectors_2D vectors) (- const-decl "Vector" vectors_2D vectors) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_real_is_real application-judgement "real" reals nil) (sqv_neg formula-decl nil vectors_2D vectors) (Theta_D_unique formula-decl nil horizontal nil)) nil)) (intersects_circle_fun_inc 0 (intersects_circle_fun_inc-2 "" 3790107934 ("" (case "FORALL (R: posreal, c: Vect2, u, v: Vect2): sqv(u) = 1 AND sqv(v) = 1 AND
                             intersects_circle_fun?(v, c, R) AND ^(v) * c <= ^(u) * c IMPLIES
                              intersects_circle_fun?(u, c, R)") (("1" (skeep) (("1" (inst - "R" "c" "^(u)" "^(v)") (("1" (assert) (("1" (split -) (("1" (lemma "intersects_circle_fun_scal") (("1" (inst - "R" "c" "1/norm(u)" "u") (("1" (assert) (("1" (expand "^") (("1" (propax) nil nil)) nil)) nil) ("2" (split +) (("1" (cross-mult 1) (("1" (ground) (("1" (lemma "norm_eq_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (cross-mult 1) (("2" (ground) (("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (ground) (("3" (lemma "norm_eq_0") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "^") (("2" (rewrite "sqv_scal") (("2" (rewrite "sq_div") (("1" (rewrite "sq_norm") (("1" (assert) nil nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "^") (("3" (rewrite "sqv_scal") (("3" (rewrite "sq_div") (("1" (rewrite "sq_norm") (("1" (assert) nil nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "intersects_circle_fun_scal") (("4" (inst - "R" "c" "1/norm(v)" "v") (("1" (assert) (("1" (expand "^") (("1" (propax) nil nil)) nil)) nil) ("2" (split +) (("1" (cross-mult 1) (("1" (ground) (("1" (lemma "norm_eq_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (cross-mult 1) (("2" (ground) (("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "norm_eq_0") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (case "FORALL (zpt:Nz_vect2): ^(^(zpt)) = ^(zpt)") (("1" (inst-cp - "u") (("1" (inst - "v") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (expand "^" + 1) (("2" (typepred "^(zpt)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (label "sqvuv" (-1 -2)) (("2" (case "^(v) = v AND ^(u) = u") (("1" (flatten) (("1" (replaces -1) (("1" (replaces -1) (("1" (hide "sqvuv") (("1" (expand "intersects_circle_fun?") (("1" (case "NOT (v = zero OR u = zero)") (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (label "uvnz" (1 2)) (("1" (hide "uvnz") (("1" (case "FORALL (bl1,bl2:bool): (bl1 OR bl2) IFF (bl1 OR (bl2 AND not bl1))") (("1" (label "final" 1) (("1" (hide "final") (("1" (rewrite -1) (("1" (hide -1) (("1" (reveal "final") (("1" (split -) (("1" (split +) (("1" (expand "Delta") (("1" (reveal "sqvuv") (("1" (replace -1) (("1" (hide -1) (("1" (replace -1) (("1" (hide -1) (("1" (case "sq(u*perpR(c)) <= sq(v*perpR(c))") (("1" (hide -4) (("1" (grind) nil nil)) nil) ("2" (hide (-2 2)) (("2" (lemma "orthogonal_basis") (("2" (inst - "c" "perpR(c)" _) (("2" (inst-cp - "u") (("2" (inst - "v") (("2" (assert) (("2" (case "c /= zero AND perpR(c) /= zero AND orthogonal?(c, perpR(c))") (("1" (flatten) (("1" (assert) (("1" (lemma "orthogonal_basis_sqv") (("1" (inst?) (("1" (assert) (("1" (label "ddvc1" -3) (("1" (hide "ddvc1") (("1" (label "ddvc2" -1) (("1" (hide "ddvc2") (("1" (lemma "orthogonal_basis_sqv") (("1" (inst?) (("1" (assert) (("1" (reveal "ddvc1") (("1" (reveal "ddvc2") (("1" (delabel "ddvc1") (("1" (delabel "ddvc2") (("1" (case "sqv(perpR(c)) = sqv(c)") (("1" (replace -1) (("1" (hide -1) (("1" (reveal "sqvuv") (("1" (replace -1) (("1" (replace -2) (("1" (case "sq(u*c) >= sq(v*c)") (("1" (rewrite "sq_div") (("1" (rewrite "sq_div") (("1" (rewrite "sq_div") (("1" (rewrite "sq_div") (("1" (mult-by 3 "sqv(c)/sq(sqv(c))") (("1" (mult-by -1 "sqv(c)/sq(sqv(c))") (("1" (ground) nil nil) ("2" (real-props) nil nil)) nil) ("2" (split +) (("1" (cross-mult 1) nil nil) ("2" (cross-mult 1) (("2" (rewrite "sq_ge") (("2" (lemma "sqv_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "sq_ge") (("1" (hide-all-but (-8 1)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (-8 -9 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split +) (("1" (flatten) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (case "c = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "zero") (("2" (expand "perpR") (("2" (flatten) (("2" (decompose-equality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide-all-but (-1 -3 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (assert) (("2" (lemma "Delta_ge_0_2[R]") (("2" (inst?) (("2" (assert) (("2" (inst + "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (reveal "sqvuv") (("2" (split -) (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "norm(u) = 1 and norm(v) = 1") (("1" (expand "^" 1) (("1" (flatten) (("1" (replaces -1) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 1)) (("2" (rewrite "sqrt_eq" -1 :dir rl) (("2" (rewrite "sqrt_eq" -2 :dir rl) (("2" (rewrite "sqrt_sqv_norm") (("2" (rewrite "sqrt_sqv_norm") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (replace -4) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (replace -4) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ((posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (sqrt_eq formula-decl nil sqrt reals) (sqrt_pos application-judgement "posreal" sqrt reals) (sqrt_1 formula-decl nil sqrt reals) (sqrt_sqv_norm formula-decl nil vectors_2D vectors) (sqv_zero formula-decl nil vectors_2D vectors) (sq const-decl "nonneg_real" sq reals) (add_zero_right formula-decl nil vectors_2D vectors) (scal_0 formula-decl nil vectors_2D vectors) (Delta_ge_0_2 formula-decl nil horizontal nil) (orthogonal? const-decl "bool" vectors_2D vectors) (real_div_nzreal_is_real application-judgement "real" reals nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (c skolem-const-decl "Vect2" circle_optimum_2D nil) (pos_div_ge formula-decl nil real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (div_mult_pos_gt1 formula-decl nil extra_real_props nil) (sqv_eq_0 formula-decl nil vectors_2D vectors) (sq_ge formula-decl nil sq reals) (div_mult_pos_ge1 formula-decl nil real_props nil) (orthogonal_basis_sqv formula-decl nil basis_2D vectors) (perpR_eq_zero formula-decl nil perpendicular_2D vectors) (dot_zero_right formula-decl nil vectors_2D vectors) (sq_0 formula-decl nil sq reals) (orthogonal_basis formula-decl nil basis_2D vectors) (minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (det const-decl "real" det_2D vectors) (- const-decl "Vector" vectors_2D vectors) (perpR const-decl "Vect2" perpendicular_2D vectors) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (Delta const-decl "real" horizontal nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (sqv_neg formula-decl nil vectors_2D vectors) (OR const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (nz_sqv_gt_0 application-judgement "posreal" vectors_2D vectors) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (NOT const-decl "[bool -> bool]" booleans nil) (nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors) (nz_nzv application-judgement "Nz_vector" vectors_2D vectors) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (scal_1 formula-decl nil vectors_2D vectors) (norm_normalize formula-decl nil vectors_2D vectors) (v skolem-const-decl "Vect2" circle_optimum_2D nil) (sq_div formula-decl nil sq reals) (sq_1 formula-decl nil sq reals) (real_times_real_is_real application-judgement "real" reals nil) (dot_scal_left formula-decl nil vectors_2D vectors) (sq_norm formula-decl nil vectors_2D vectors) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (sq_nz_pos application-judgement "posreal" sq reals) (sqv_scal formula-decl nil vectors_2D vectors) (intersects_circle_fun_scal formula-decl nil circle_optimum_2D nil) (norm_eq_0 formula-decl nil vectors_2D vectors) (nonzero_real nonempty-type-eq-decl nil reals nil) (div_mult_pos_neg_ge1 formula-decl nil extra_real_props nil) (div_mult_pos_neg_gt1 formula-decl nil extra_real_props nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (u skolem-const-decl "Vect2" circle_optimum_2D nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Vector type-eq-decl nil vectors_2D vectors) (nnreal type-eq-decl nil real_types nil) (sqv const-decl "nnreal" vectors_2D vectors) (intersects_circle_fun? const-decl "bool" circle_optimum_2D nil) (<= const-decl "bool" reals nil) (* const-decl "real" vectors_2D vectors) (/= const-decl "boolean" notequal nil) (zero const-decl "Vector" vectors_2D vectors) (Nz_vector type-eq-decl nil vectors_2D vectors) (norm const-decl "nnreal" vectors_2D vectors) (Normalized type-eq-decl nil vectors_2D vectors) (^ const-decl "Normalized" vectors_2D vectors)) shostak) (intersects_circle_fun_inc-1 nil 3527947389 ("" (case "FORALL (R: posreal, c: Vect2, u, v: Vect2): sqv(u) = 1 AND sqv(v) = 1 AND
                             intersects_circle_fun?(v, c, R) AND ^(v) * c <= ^(u) * c IMPLIES
                              intersects_circle_fun?(u, c, R)") (("1" (skeep) (("1" (inst - "R" "c" "^(u)" "^(v)") (("1" (assert) (("1" (split -) (("1" (lemma "intersects_circle_fun_scal") (("1" (inst - "R" "c" "1/norm(u)" "u") (("1" (assert) (("1" (expand "^") (("1" (propax) nil nil)) nil)) nil) ("2" (split +) (("1" (cross-mult 1) (("1" (ground) (("1" (lemma "norm_eq_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (cross-mult 1) (("2" (ground) (("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (ground) (("3" (lemma "norm_eq_0") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "^") (("2" (rewrite "sqv_scal") (("2" (rewrite "sq_div") (("1" (rewrite "sq_norm") (("1" (assert) nil nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "^") (("3" (rewrite "sqv_scal") (("3" (rewrite "sq_div") (("1" (rewrite "sq_norm") (("1" (assert) nil nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "intersects_circle_fun_scal") (("4" (inst - "R" "c" "1/norm(v)" "v") (("1" (assert) (("1" (expand "^") (("1" (propax) nil nil)) nil)) nil) ("2" (split +) (("1" (cross-mult 1) (("1" (ground) (("1" (lemma "norm_eq_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (cross-mult 1) (("2" (ground) (("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "norm_eq_0") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (case "FORALL (zpt:Nz_vect2): ^(^(zpt)) = ^(zpt)") (("1" (inst-cp - "u") (("1" (inst - "v") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (expand "^" + 1) (("2" (typepred "^(zpt)") (("2" (assert) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (label "sqvuv" (-1 -2)) (("2" (case "^(v) = v AND ^(u) = u") (("1" (flatten) (("1" (replaces -1) (("1" (replaces -1) (("1" (hide "sqvuv") (("1" (expand "intersects_circle_fun?") (("1" (case "NOT (v = zero OR u = zero)") (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (label "uvnz" (1 2)) (("1" (hide "uvnz") (("1" (case "FORALL (bl1,bl2:bool): (bl1 OR bl2) IFF (bl1 OR (bl2 AND not bl1))") (("1" (label "final" 1) (("1" (hide "final") (("1" (rewrite -1) (("1" (hide -1) (("1" (reveal "final") (("1" (split -) (("1" (split +) (("1" (expand "Delta") (("1" (reveal "sqvuv") (("1" (replace -1) (("1" (hide -1) (("1" (replace -1) (("1" (hide -1) (("1" (case "sq(u*perpR(c)) <= sq(v*perpR(c))") (("1" (hide -4) (("1" (grind) nil nil)) nil) ("2" (hide (-2 2)) (("2" (lemma "orthogonal_basis") (("2" (inst - "c" "perpR(c)" _) (("2" (inst-cp - "u") (("2" (inst - "v") (("2" (assert) (("2" (case "c /= zero AND perpR(c) /= zero AND orthogonal?(c, perpR(c))") (("1" (flatten) (("1" (assert) (("1" (lemma "orthogonal_basis_sqv") (("1" (inst?) (("1" (assert) (("1" (label "ddvc1" -3) (("1" (hide "ddvc1") (("1" (label "ddvc2" -1) (("1" (hide "ddvc2") (("1" (lemma "orthogonal_basis_sqv") (("1" (inst?) (("1" (assert) (("1" (reveal "ddvc1") (("1" (reveal "ddvc2") (("1" (delabel "ddvc1") (("1" (delabel "ddvc2") (("1" (case "sqv(perpR(c)) = sqv(c)") (("1" (replace -1) (("1" (hide -1) (("1" (reveal "sqvuv") (("1" (replace -1) (("1" (replace -2) (("1" (case "sq(u*c) >= sq(v*c)") (("1" (rewrite "sq_div") (("1" (rewrite "sq_div") (("1" (rewrite "sq_div") (("1" (rewrite "sq_div") (("1" (mult-by 3 "sqv(c)/sq(sqv(c))") (("1" (mult-by -1 "sqv(c)/sq(sqv(c))") (("1" (ground) nil nil) ("2" (real-props) nil nil)) nil) ("2" (split +) (("1" (cross-mult 1) nil nil) ("2" (cross-mult 1) (("2" (rewrite "sq_ge") (("2" (lemma "sqv_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "sq_ge") (("1" (hide-all-but (-8 1)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (-8 -9 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split +) (("1" (flatten) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (case "c = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "zero") (("2" (expand "perpR") (("2" (flatten) (("2" (decompose-equality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide-all-but (-1 -3 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (assert) (("2" (lemma "Delta_ge_0_2[R]") (("2" (inst?) (("2" (assert) (("2" (inst + "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (reveal "sqvuv") (("2" (split -) (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "norm(u) = 1 and norm(v) = 1") (("1" (expand "^" 1) (("1" (flatten) (("1" (replaces -1) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 1)) (("2" (rewrite "sqrt_eq" -1 :dir rl) (("2" (rewrite "sqrt_eq" -2 :dir rl) (("2" (rewrite "sqrt_sqv_norm") (("2" (rewrite "sqrt_sqv_norm") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (replace -4) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (replace -4) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ((posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (sqrt_eq formula-decl nil sqrt reals) (sqrt_pos application-judgement "posreal" sqrt reals) (sqrt_1 formula-decl nil sqrt reals) (sqrt_sqv_norm formula-decl nil vectors_2D vectors) (sqv_zero formula-decl nil vectors_2D vectors) (sq const-decl "nonneg_real" sq reals) (add_zero_right formula-decl nil vectors_2D vectors) (scal_0 formula-decl nil vectors_2D vectors) (Delta_ge_0_2 formula-decl nil horizontal nil) (orthogonal? const-decl "bool" vectors_2D vectors) (real_div_nzreal_is_real application-judgement "real" reals nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) nil (pos_div_ge formula-decl nil real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (div_mult_pos_gt1 formula-decl nil extra_real_props nil) (sqv_eq_0 formula-decl nil vectors_2D vectors) (sq_ge formula-decl nil sq reals) (div_mult_pos_ge1 formula-decl nil real_props nil) (orthogonal_basis_sqv formula-decl nil basis_2D vectors) (perpR_eq_zero formula-decl nil perpendicular_2D vectors) (dot_zero_right formula-decl nil vectors_2D vectors) (sq_0 formula-decl nil sq reals) (orthogonal_basis formula-decl nil basis_2D vectors) (minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (det const-decl "real" det_2D vectors) nil (perpR const-decl "Vect2" perpendicular_2D vectors) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (Delta const-decl "real" horizontal nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (sqv_neg formula-decl nil vectors_2D vectors) (OR const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (nz_sqv_gt_0 application-judgement "posreal" vectors_2D vectors) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (NOT const-decl "[bool -> bool]" booleans nil) (nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors) (nz_nzv application-judgement "Nz_vector" vectors_2D vectors) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (scal_1 formula-decl nil vectors_2D vectors) (norm_normalize formula-decl nil vectors_2D vectors) nil (sq_div formula-decl nil sq reals) (sq_1 formula-decl nil sq reals) (real_times_real_is_real application-judgement "real" reals nil) (dot_scal_left formula-decl nil vectors_2D vectors) (sq_norm formula-decl nil vectors_2D vectors) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (sq_nz_pos application-judgement "posreal" sq reals) (sqv_scal formula-decl nil vectors_2D vectors) (intersects_circle_fun_scal formula-decl nil circle_optimum_2D nil) (norm_eq_0 formula-decl nil vectors_2D vectors) (nonzero_real nonempty-type-eq-decl nil reals nil) (div_mult_pos_neg_ge1 formula-decl nil extra_real_props nil) (div_mult_pos_neg_gt1 formula-decl nil extra_real_props nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) nil (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Vector type-eq-decl nil vectors_2D vectors) (nnreal type-eq-decl nil real_types nil) (sqv const-decl "nnreal" vectors_2D vectors) (intersects_circle_fun? const-decl "bool" circle_optimum_2D nil) (<= const-decl "bool" reals nil) (* const-decl "real" vectors_2D vectors) (/= const-decl "boolean" notequal nil) (zero const-decl "Vector" vectors_2D vectors) (Nz_vector type-eq-decl nil vectors_2D vectors) (norm const-decl "nnreal" vectors_2D vectors) (Normalized type-eq-decl nil vectors_2D vectors) (^ const-decl "Normalized" vectors_2D vectors)) nil)) (inter_circle_max_time_TCC1 0 (inter_circle_max_time_TCC1-1 nil 3527524768 ("" (subtype-tcc) nil nil) ((posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (/= const-decl "boolean" notequal nil) (- const-decl "Vector" vectors_2D vectors) (sq const-decl "nonneg_real" sq reals) (* const-decl "real" vectors_2D vectors) (sqv const-decl "nnreal" vectors_2D vectors) (det const-decl "real" det_2D vectors) (Delta const-decl "real" horizontal nil) (intersects_circle_fun? const-decl "bool" circle_optimum_2D nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil (inter_circle_max_time subtype "circle_optimum_2D.v" "{nzv | reals.>=(horizontal[circle_optimum_2D.R].Delta((vectors_2D.-)(circle_optimum_2D.c), horizontal.nzv), 0)}"))) (inter_circle_max_time_TCC2 0 (inter_circle_max_time_TCC2-1 nil 3527524768 ("" (skeep) (("" (lemma "intersects_circle_fun_def") (("" (inst?) (("" (assert) (("" (skeep -1) (("" (expand "segment?") (("" (skeep -2) (("" (replace -2) (("" (hide -2) (("" (expand "circle?") (("" (lemma "Theta_D_unique[R]") (("" (inst?) (("" (inst - "-c") (("" (assert) (("" (expand "intersects_circle_fun?") (("" (flatten) (("" (assert) (("" (flatten) (("" (hide -2) (("" (split -) (("1" (lemma "Theta_D_le[R]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "sqrt_eq" 1 :dir rl) (("2" (rewrite "sqrt_sqv_norm") (("2" (assert) (("2" (hide-all-but (-1 1)) (("2" (grind :exclude "norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((intersects_circle_fun_def formula-decl nil circle_optimum_2D nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (segment? const-decl "bool" circle_optimum_2D nil) (circle? const-decl "bool" circle_optimum_2D nil) (nnreal type-eq-decl nil real_types nil) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (zero const-decl "Vector" vectors_2D vectors) (/= const-decl "boolean" notequal nil) (Vector type-eq-decl nil vectors_2D vectors) (minus_odd_is_odd application-judgement "odd_int" integers nil) (Theta_D_le formula-decl nil horizontal nil) (sqrt_sqv_norm formula-decl nil vectors_2D vectors) (- const-decl "Vector" vectors_2D vectors) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_real_is_real application-judgement "real" reals nil) (sqrt_sq formula-decl nil sqrt reals) (sqrt_pos application-judgement "posreal" sqrt reals) (sq_nz_pos application-judgement "posreal" sq reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sqrt_eq formula-decl nil sqrt reals) (sqv const-decl "nnreal" vectors_2D vectors) (+ const-decl "Vector" vectors_2D vectors) (* const-decl "Vector" vectors_2D vectors) (sq const-decl "nonneg_real" sq reals) (sqv_neg formula-decl nil vectors_2D vectors) (intersects_circle_fun? const-decl "bool" circle_optimum_2D nil) (- const-decl "Vector" vectors_2D vectors) (Theta_D_unique formula-decl nil horizontal nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (inter_circle_max_time subtype "horizontal[circle_optimum_2D.R].Theta_D((vectors_2D.-)(circle_optimum_2D.c), circle_optimum_2D.v, 1)" "nnreal"))) (inter_circle_max_time_scal 0 (inter_circle_max_time_scal-1 nil 3529411095 ("" (skeep) (("" (cross-mult 1) (("" (expand "inter_circle_max_time") (("" (lift-if) (("" (lift-if) (("" (lift-if) (("" (assert) (("" (ground) (("1" (lemma "Theta_D_scal[R]") (("1" (inst?) (("1" (assert) (("1" (expand "intersects_circle_fun?") (("1" (flatten) (("1" (assert) (("1" (expand "sign" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (assert) nil nil)) nil) ("3" (expand "intersects_circle_fun?") (("3" (assert) (("3" (flatten) (("3" (assert) (("3" (split +) (("1" (flatten) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "Delta_scal[R]") (("2" (inst?) (("2" (assert) (("2" (mult-by 1 "sq(pt)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (mult-by 1 "pt") (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (case "(1/pt)*(pt*v) = zero") (("1" (assert) nil nil) ("2" (replace -2) (("2" (assert) nil nil)) nil)) nil) ("5" (expand "intersects_circle_fun?") (("5" (flatten) (("5" (split 3) (("1" (flatten) (("1" (case "(1/pt)*(pt*v) = zero") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "Delta_scal[R]") (("2" (inst?) (("2" (assert) (("2" (mult-by -2 "sq(pt)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (assert) (("3" (mult-by -2 "pt") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (inter_circle_max_time const-decl "nnreal" circle_optimum_2D nil) (nnreal type-eq-decl nil real_types nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (times_div2 formula-decl nil real_props nil) (div_cancel4 formula-decl nil real_props nil) (Vector type-eq-decl nil vectors_2D vectors) (* const-decl "Vector" vectors_2D vectors) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_times_real_is_real application-judgement "real" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign type-eq-decl nil sign reals) (nzreal nonempty-type-eq-decl nil reals nil) (zero const-decl "Vector" vectors_2D vectors) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (- const-decl "Vector" vectors_2D vectors) (intersects_circle_fun? const-decl "bool" circle_optimum_2D nil) (sqv_neg formula-decl nil vectors_2D vectors) (dot_scal_right formula-decl nil vectors_2D vectors) (sign const-decl "Sign" sign reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (Theta_D_scal formula-decl nil horizontal nil) (scal_zero formula-decl nil vectors_2D vectors) (sq_nz_pos application-judgement "posreal" sq reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (* const-decl "real" vectors_2D vectors) (Delta_scal formula-decl nil horizontal nil) (Delta const-decl "real" horizontal nil) (sq const-decl "nonneg_real" sq reals) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (scal_1 formula-decl nil vectors_2D vectors) (scal_assoc formula-decl nil vectors_2D vectors) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil)) shostak)) (inter_circle_max_time_def 0 (inter_circle_max_time_def-1 nil 3527525027 ("" (skeep) (("" (name "tcm" "inter_circle_max_time(v, c, R)") (("" (replace -1) (("" (assert) (("" (split +) (("1" (flatten) (("1" (lemma "intersects_circle_fun_def") (("1" (inst?) (("1" (assert) (("1" (case "NOT circle?(c, R)(tcm * v)") (("1" (hide 2) (("1" (expand "circle?") (("1" (expand "inter_circle_max_time") (("1" (lift-if) (("1" (ground) (("1" (lemma "Theta_D_unique[R]") (("1" (inst?) (("1" (inst - "-c") (("1" (assert) (("1" (copy -4) (("1" (expand "intersects_circle_fun?" -1) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (rewrite "sqrt_eq" -3 :dir rl) (("1" (rewrite "sqrt_sqv_norm") (("1" (assert) (("1" (hide-all-but (-3 2)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (assert) (("2" (skeep -3) (("2" (expand "segment?") (("2" (skeep -4) (("2" (assert) (("2" (replace -4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (skeep) (("2" (expand "inter_circle_max_time") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (lemma "Theta_D_unique[R]") (("1" (inst - _ _ "nnt") (("1" (inst?) (("1" (assert) (("1" (expand "intersects_circle_fun?") (("1" (flatten) (("1" (assert) (("1" (copy -5) (("1" (expand "circle?" -1) (("1" (case "sqv(-c+nnt*v) = sq(R)") (("1" (assert) (("1" (case "nnt = tcm") (("1" (assert) nil nil) ("2" (assert) (("2" (case "nnt = 0") (("1" (replace -1) (("1" (assert) (("1" (rewrite "norm_scal") (("1" (expand "abs" +) (("1" (lemma "posreal_times_posreal_is_posreal") (("1" (inst?) (("1" (assert) nil nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "nnt < tcm") (("1" (mult-by -1 "norm(v)") (("1" (case "forall (aannrr:nnreal): aannrr = abs(aannrr)") (("1" (inst-cp - "nnt") (("1" (inst - "tcm") (("1" (replace -1 -3) (("1" (replace -2 -3) (("1" (hide (-1 -2)) (("1" (rewrite "norm_scal" :dir rl) (("1" (rewrite "norm_scal" :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (expand "abs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "Theta_D_le[R]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "norm_eq_sqv_eq" 1) (("2" (hide-all-but (-1 1)) (("2" (grind :exclude "norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (replace -1 :dir rl) (("2" (assert) (("2" (case "NOT intersects_circle_fun?(v, c, R)") (("1" (lemma "intersects_circle_fun_def") (("1" (inst?) (("1" (assert) (("1" (inst + "nnt*v") (("1" (assert) (("1" (expand "segment?") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (replace -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((inter_circle_max_time const-decl "nnreal" circle_optimum_2D nil) (nnreal type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (real nonempty-type-from-decl nil reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (norm_eq_sqv_eq formula-decl nil vectors_2D vectors) (Theta_D_le formula-decl nil horizontal nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (norm_scal formula-decl nil vectors_2D vectors) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (posreal_times_posreal_is_posreal judgement-tcc nil real_types nil) (norm_eq_0 formula-decl nil vectors_2D vectors) (v skolem-const-decl "Vect2" circle_optimum_2D nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (norm_zero formula-decl nil vectors_2D vectors) (add_zero_right formula-decl nil vectors_2D vectors) (scal_0 formula-decl nil vectors_2D vectors) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (* const-decl "Vector" vectors_2D vectors) (Vector type-eq-decl nil vectors_2D vectors) (circle? const-decl "bool" circle_optimum_2D nil) (NOT const-decl "[bool -> bool]" booleans nil) (segment? const-decl "bool" circle_optimum_2D nil) (norm_neg formula-decl nil vectors_2D vectors) (sub_zero_left formula-decl nil vectors_2D vectors) (scal_zero formula-decl nil vectors_2D vectors) (Theta_D_unique formula-decl nil horizontal nil) (- const-decl "Vector" vectors_2D vectors) (sqv_neg formula-decl nil vectors_2D vectors) (sqrt_sqv_norm formula-decl nil vectors_2D vectors) (minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (- const-decl "Vector" vectors_2D vectors) (norm const-decl "nnreal" vectors_2D vectors) (* const-decl "real" vectors_2D vectors) (sqrt_sq formula-decl nil sqrt reals) (sqrt_pos application-judgement "posreal" sqrt reals) (sq_nz_pos application-judgement "posreal" sq reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sqrt_eq formula-decl nil sqrt reals) (sqv const-decl "nnreal" vectors_2D vectors) (+ const-decl "Vector" vectors_2D vectors) (sq const-decl "nonneg_real" sq reals) (intersects_circle_fun? const-decl "bool" circle_optimum_2D nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (zero const-decl "Vector" vectors_2D vectors) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (intersects_circle_fun_def formula-decl nil circle_optimum_2D nil)) shostak)) (inter_circle_max_norm_scal 0 (inter_circle_max_norm_scal-1 nil 3527585618 ("" (skeep) (("" (expand "inter_circle_max_norm") (("" (lift-if) (("" (lift-if) (("" (lift-if) (("" (ground) (("1" (expand "inter_circle_max_time") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (lemma "Theta_D_scal[R]") (("1" (inst?) (("1" (split -) (("1" (assert) (("1" (rewrite "norm_scal") (("1" (expand "abs") (("1" (assert) (("1" (expand "sign" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "intersects_circle_fun?") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (assert) nil nil)) nil) ("3" (case "v = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (rewrite "vx_scal") (("2" (rewrite "vy_scal") (("2" (decompose-equality +) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "intersects_circle_fun?") (("2" (flatten) (("2" (lemma "Delta_scal[R]") (("2" (inst?) (("2" (assert) (("2" (replace -1) (("2" (split -) (("1" (flatten) (("1" (case "NOT Delta[R](-c,v) >=0") (("1" (hide 2) (("1" (mult-by 1 "sq(pt)") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "v/=zero") (("1" (assert) (("1" (hide -1) (("1" (flatten) (("1" (assert) (("1" (mult-by 2 "pt") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "v = zero") (("1" (assert) nil nil) ("2" (hide-all-but (-1 1)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (rewrite "vy_scal") (("2" (rewrite "vx_scal") (("2" (decompose-equality +) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 1) (("3" (expand "intersects_circle_fun?") (("3" (flatten) (("3" (split -) (("1" (flatten) (("1" (assert) (("1" (lemma "Delta_scal[R]") (("1" (inst?) (("1" (assert) (("1" (case "NOT Delta[R](-c,pt*v) >=0") (("1" (mult-by -2 "sq(pt)") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (case "pt*v /= zero") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (mult-by -4 "pt") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (flatten) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (rewrite "vx_scal") (("2" (rewrite "vy_scal") (("2" (decompose-equality +) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((inter_circle_max_norm const-decl "nnreal" circle_optimum_2D nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (nzint nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign type-eq-decl nil sign reals) (nzreal nonempty-type-eq-decl nil reals nil) (Vector type-eq-decl nil vectors_2D vectors) (zero const-decl "Vector" vectors_2D vectors) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (Vect2 type-eq-decl nil vectors_2D_def vectors) (- const-decl "Vector" vectors_2D vectors) (intersects_circle_fun? const-decl "bool" circle_optimum_2D nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (sign const-decl "Sign" sign reals) (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}" real_defs nil) (norm_scal formula-decl nil vectors_2D vectors) (Theta_D_scal formula-decl nil horizontal nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (scal_zero formula-decl nil vectors_2D vectors) (norm_zero formula-decl nil vectors_2D vectors) (AND const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "Vector" vectors_2D vectors) (vy_scal formula-decl nil vectors_2D vectors) (vx_scal formula-decl nil vectors_2D vectors) (inter_circle_max_time const-decl "nnreal" circle_optimum_2D nil) (Delta_scal formula-decl nil horizontal nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (sq_nz_pos application-judgement "posreal" sq reals) (sqv_neg formula-decl nil vectors_2D vectors) (dot_scal_right formula-decl nil vectors_2D vectors) (NOT const-decl "[bool -> bool]" booleans nil) (Delta const-decl "real" horizontal nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (sq const-decl "nonneg_real" sq reals) (* const-decl "real" vectors_2D vectors) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (dot_zero_right formula-decl nil vectors_2D vectors)) shostak)) (max_norm_increasing 0 (max_norm_increasing-1 nil 3527584737 ("" (case "FORALL (R: posreal, c: Vect2, u, v: Vect2): norm(u) = 1 AND norm(v) = 1 IMPLIES
                                                                                                                                             ^(v) * c <= ^(u) * c IMPLIES
                                                                                                                                              inter_circle_max_norm(v, c, R) <= inter_circle_max_norm(u, c, R)") (("1" (skeep) (("1" (split -) (("1" (inst - "R" "c" "^(u)" "^(v)") (("1" (assert) (("1" (flatten) (("1" (split -) (("1" (expand "^") (("1" (lemma "inter_circle_max_norm_scal") (("1" (inst - "R" "c" _ _) (("1" (inst-cp - "v" "1/norm(v)") (("1" (inst - "u" "1/norm(u)") (("1" (assert) nil nil) ("2" (split +) (("1" (cross-mult 1) (("1" (ground) (("1" (lemma "norm_eq_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (cross-mult 1) (("2" (ground) (("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split +) (("1" (cross-mult 1) (("1" (ground) (("1" (lemma "norm_eq_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (cross-mult 1) (("2" (ground) (("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (vvz:Vect2): norm(vvz) = 1 IMPLIES ^(vvz) = vvz") (("1" (inst-cp - "^(v)") (("1" (inst - "^(u)") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (expand "^") (("2" (assert) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (replace -2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -2) (("2" (flatten) (("2" (case "v = zero") (("1" (hide -2) (("1" (replace -1) (("1" (expand "inter_circle_max_norm") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replaces -1) (("2" (assert) (("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (case "FORALL (vvz:Vect2): norm(vvz) = 1 IMPLIES ^(vvz) = vvz") (("1" (inst-cp - "v") (("1" (inst - "u") (("1" (assert) (("1" (replaces -1) (("1" (replaces -1) (("1" (label "normu" -1) (("1" (label "normv" -2) (("1" (case "u/=zero AND v/=zero") (("1" (flatten) (("1" (label "uvnz" (1 2)) (("1" (hide "uvnz") (("1" (case "sqv(u) = 1 AND sqv(v) = 1") (("1" (flatten) (("1" (label "sqvu" -1) (("1" (label "sqvv" -2) (("1" (hide ("sqvu" "sqvv" "normu" "normv")) (("1" (expand "inter_circle_max_norm") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (ground) (("1" (name "pu" "inter_circle_max_time(u, c, R) * u") (("1" (name "pv" "inter_circle_max_time(v, c, R) * v") (("1" (lemma "law_cosines_alt") (("1" (inst - "zero" "c" "pu") (("1" (lemma "law_cosines_alt") (("1" (inst - "zero" "c" "pv") (("1" (assert) (("1" (lemma "law_cosines_alt") (("1" (inst - "c" "pu" "pv") (("1" (assert) (("1" (label "dlem" -1) (("1" (hide "dlem") (("1" (expand "dist") (("1" (rewrite "sq_sqrt") (("1" (rewrite "sq_sqrt") (("1" (rewrite "sq_sqrt") (("1" (rewrite "sq_sqrt") (("1" (rewrite "sq_sqrt") (("1" (rewrite "sq_dist_norm") (("1" (rewrite "sq_dist_norm") (("1" (rewrite "sq_dist_norm") (("1" (rewrite "sq_dist_norm") (("1" (rewrite "sq_dist_norm") (("1" (case "sq(norm(pv)) <= sq(norm(pu))") (("1" (rewrite "sq_le" -1) (("1" (hide-all-but (-1 1)) (("1" (expand "pv") (("1" (expand "pu") (("1" (rewrite "norm_scal") (("1" (rewrite "norm_scal") (("1" (expand "abs") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case "sq(norm(pv-c)) = sq(norm(pu-c))") (("1" (replace -1) (("1" (hide -1) (("1" (replaces -1) (("1" (replaces -1) (("1" (assert) (("1" (case "c*(c-pu) <= c*(c-pv)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (case "c*pv <= c*pu") (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (hide 2) (("2" (expand "intersects_circle_fun?") (("2" (case "FORALL (b1,b2:bool): (b1 OR b2) IFF (b1 OR (b2 AND NOT b1))") (("1" (reveal "uvnz") (("1" (assert) (("1" (hide "uvnz") (("1" (rewrite -1) (("1" (label "hyp1" -4) (("1" (hide "hyp1") (("1" (rewrite -1) (("1" (reveal "hyp1") (("1" (delabel "hyp1") (("1" (hide -2) (("1" (flatten) (("1" (case "NOT (sq(-c * u) + sq(R) - sqv(c) >= 0 AND sq(-c * v) + sq(R) - sqv(c) >= 0)") (("1" (lemma "Delta_discr2b[R]") (("1" (hide-all-but (-1 -2 -6 1)) (("1" (expand "discr2b") (("1" (split +) (("1" (inst?) (("1" (assert) (("1" (reveal "sqvu") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (inst?) (("2" (assert) (("2" (reveal "sqvv") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (ground) (("1" (hide (-6 -7)) (("1" (expand "pv") (("1" (expand "pu") (("1" (case "inter_circle_max_time(v, c, R) <=inter_circle_max_time(u, c, R)") (("1" (mult-ineq -1 -8) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (expand "inter_circle_max_time") (("2" (expand "Theta_D") (("2" (expand "root2b") (("2" (expand "discr2b") (("2" (reveal ("sqvu" "sqvv")) (("2" (replace -1) (("2" (replace -2) (("2" (assert) (("2" (case "FORALL (zzpr:real): zzpr/1 = zzpr") (("1" (rewrite -1) (("1" (rewrite -1) (("1" (hide -1) (("1" (case-replace "-(-c * v) = v*c") (("1" (case-replace "-(-c * u) = u*c") (("1" (hide -1 -2) (("1" (case "sqrt(sq(-c * v) + sq(R) - sqv(c)) <= sqrt(sq(-c * u) + sq(R) - sqv(c))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "sqrt_le") (("2" (lemma "sq_le") (("2" (inst - "v*c" "u*c") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (mult-by -2 "inter_circle_max_time(u, c, R)") (("2" (mult-by 1 "inter_circle_max_time(v, c, R)") (("2" (expand "pv" +) (("2" (expand "pu" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -9 1)) (("3" (grind) nil nil)) nil) ("4" (reveal "dlem") (("4" (case "sq(dist(pv, c)) = sq(R) AND sq(dist(pu, c)) = sq(R)") (("1" (flatten) (("1" (replaces -1) (("1" (replaces -1) (("1" (assert) (("1" (case "sq(dist(pv,pu)) = sqv(pu-pv)") (("1" (replace -1) (("1" (hide -1) (("1" (both-sides "-" "sqv(pu-pv)" -1) (("1" (assert) (("1" (mult-by -1 "-1") (("1" (assert) (("1" (case "(pu*c-sqv(c))^2 + (pu*perpR(c))^2 = (pv*c-sqv(c))^2 + (pv*perpR(c))^2") (("1" (case "(pu * perpR(c)) ^ 2 >= (pv * perpR(c)) ^ 2 AND (pu * c - sqv(c)) ^ 2 >
                                                                                                                                                                                                                                                      (pv * c - sqv(c)) ^ 2") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide -1) (("2" (lemma "orthogonal_basis") (("2" (case "FORALL (e1, e2, w1,w2: Vect2):
                                                                                                                                                                                                                                            e1 /= zero AND e2 /= zero AND orthogonal?(e1, e2) AND norm(e1) = norm(e2) AND sqv(w1) = sqv(w2) IMPLIES
                                                                                                                                                                                                                                             ((sq(w1*e1) >= sq(w2*e1) AND sq(w1*e2) <= sq(w2*e2)) OR (sq(w1*e1) < sq(w2*e1) AND sq(w1*e2) > sq(w2*e2)))") (("1" (hide -2) (("1" (inst - "c" "perpR(c)" _ _) (("1" (inst-cp - "v" "u") (("1" (inst - "pv-c" "pu-c") (("1" (assert) (("1" (case "perpR(c) /= zero AND
                                                                                                                                                                                                                                                         orthogonal?(c, perpR(c))") (("1" (flatten) (("1" (assert) (("1" (case "norm(c) = norm(perpR(c)) AND sqv(v) = sqv(u) AND sqv(pv - c) = sqv(pu - c)") (("1" (flatten) (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (case "c*pv <= 0") (("1" (lemma "sq_gt") (("1" (inst - "-((pu-c)*c)" "-((pv-c)*c)") (("1" (rewrite "sq_neg") (("1" (rewrite "sq_neg") (("1" (assert) (("1" (hide-all-but (1 6)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (typepred "sqv(c)") (("2" (grind) nil nil)) nil)) nil) ("3" (hide-all-but (-1 1 6)) (("3" (typepred "sqv(c)") (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (mult-by 4 "inter_circle_max_time(v, c, R)") (("2" (assert) (("2" (hide-all-but (1 4)) (("2" (expand "pv") (("2" (grind :exclude "inter_circle_max_time") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -) (("1" (flatten) (("1" (name "puc" "inter_circle_max_time(u, c, R)") (("1" (name "pvc" "inter_circle_max_time(v, c, R)") (("1" (replaces -1) (("1" (replaces -1) (("1" (case "pvc <= puc") (("1" (case "sq(pvc) <= sq(puc)") (("1" (mult-ineq -1 -4) (("1" (rewrite "sq_times" :dir rl) (("1" (rewrite "sq_times" :dir rl) (("1" (split +) (("1" (hide-all-but (-1 1)) (("1" (expand "pvc") (("1" (expand "pu") (("1" (expand "puc") (("1" (expand "pv") (("1" (grind :exclude ("inter_circle_max_time" "perpR")) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sq_gt") (("2" (inst - "- (pu * c - sqv(c))" "-(pv * c - sqv(c))") (("1" (rewrite "sq_neg") (("1" (rewrite "sq_neg") (("1" (flatten) (("1" (hide -1) (("1" (split -) (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (case "c*pu <=0") (("1" (hide-all-but (-1 1 6)) (("1" (grind) nil nil)) nil) ("2" (mult-by 6 "puc") (("1" (hide-all-but (1 6)) (("1" (expand "pu") (("1" (expand "puc") (("1" (grind :exclude ("inter_circle_max_time")) nil nil)) nil)) nil)) nil) ("2" (case "puc = 0") (("1" (expand "puc" -1) (("1" (expand "pu" 2) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (mult-by 4 "pvc") (("1" (hide-all-but (1 4)) (("1" (typepred "sqv(c)") (("1" (expand "pvc") (("1" (expand "pv") (("1" (grind :exclude ("inter_circle_max_time")) nil nil)) nil)) nil)) nil)) nil) ("2" (case "pvc = 0") (("1" (replace -1) (("1" (assert) (("1" (replace -19 :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (mult-by 5 "puc") (("1" (hide-all-but (1 5)) (("1" (typepred "sqv(c)") (("1" (expand "pu") (("1" (expand "puc") (("1" (grind :exclude ("inter_circle_max_time")) nil nil)) nil)) nil)) nil)) nil) ("2" (case "puc = 0") (("1" (replace -1) (("1" (assert) (("1" (replace -20 :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sq_le") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (case "FORALL (a1,a2,b1,b2:nnreal): a1<=a2 AND b1<=b2 IMPLIES a1*b1<=a2*b2") (("1" (inst - "puc" "pvc" "-(c*u)" "-(c*v)") (("1" (assert) (("1" (split -) (("1" (hide-all-but (-1 6)) (("1" (expand "pv") (("1" (expand "pu") (("1" (expand "pvc") (("1" (expand "puc") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-18 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (mult-ineq -1 -2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "sq_lt") (("2" (inst - "-(v*c)" "-(u*c)") (("1" (rewrite "sq_neg") (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (1 5)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (1 4)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split +) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil) ("2" (reveal "sqvv") (("2" (reveal "sqvu") (("2" (assert) nil nil)) nil)) nil) ("3" (lemma "inter_circle_max_time_def") (("3" (inst - "R" "c" _) (("3" (inst-cp - "v") (("3" (inst - "u") (("3" (assert) (("3" (flatten) (("3" (hide (-2 -4 -6 -7)) (("3" (expand "circle?") (("3" (case "FORALL (vv1,vv2:Vect2): norm(vv1) = R AND norm(vv2) = R IMPLIES sqv(vv1) = sqv(vv2)") (("1" (rewrite -1) nil nil) ("2" (hide-all-but 1) (("2" (case "FORALL (vvv1:Vect2): norm(vvv1) = R IMPLIES sqv(vvv1) = sq(R)") (("1" (skeep) (("1" (inst-cp - "vv1") (("1" (inst - "vv2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (rewrite "sqrt_eq" 1 :dir rl) (("2" (rewrite "sqrt_sqv_norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide (-1 -2)) (("2" (split +) (("1" (flatten) (("1" (case "c = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "perpR") (("2" (expand "zero") (("2" (flatten) (("2" (decompose-equality +) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (skeep) (("2" (inst - "e1" "e2" _) (("2" (assert) (("2" (case "FORALL (w: Vect2):
                                                                                                                                                                                      sqv(w) = sq((w * e1) / sqv(e1))*sqv(e1) + sq((w * e2) / sqv(e2))*sqv(e2)") (("1" (hide -5) (("1" (inst-cp - "w1") (("1" (inst - "w2") (("1" (case "sqv(w1) = sqv(w2)") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (replace -1) (("1" (hide -1) (("1" (case "sqv(e1) = sqv(e2)") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (rewrite "sq_div") (("1" (rewrite "sq_div") (("1" (rewrite "sq_div") (("1" (rewrite "sq_div") (("1" (mult-by -1 "sqv(e1)") (("1" (expand "sq") (("1" (ground) nil nil)) nil)) nil) ("2" (rewrite "sqv_eq_0" :dir rl) nil nil)) nil) ("2" (rewrite "sqv_eq_0" :dir rl) nil nil)) nil) ("2" (rewrite "sqv_eq_0" :dir rl) nil nil)) nil) ("2" (rewrite "sqrt_eq" :dir rl) (("2" (rewrite "sqv_eq_0" :dir rl) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "sqrt_eq" :dir rl) (("2" (rewrite "sqrt_sqv_norm") (("2" (rewrite "sqrt_sqv_norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst - "w") (("2" (name "cv1" "sq((w * e1) / sqv(e1)) * sqv(e1) + sq((w * e2) / sqv(e2)) * sqv(e2)") (("2" (replace -1) (("2" (replace -5 +) (("2" (case "sqv(e1) = sqv(e2)") (("1" (replace -1 :dir rl) (("1" (rewrite "sqv_add") (("1" (expand "orthogonal?") (("1" (replace -3) (("1" (assert) (("1" (hide-all-but (1 2 3)) (("1" (expand "cv1") (("1" (rewrite "sqv_scal") (("1" (rewrite "sqv_scal") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "sqrt_eq" :dir rl) (("2" (rewrite "sqrt_sqv_norm") (("2" (rewrite "sqrt_sqv_norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "sqv_eq_0" :dir rl) (("3" (assert) (("3" (rewrite "sqv_eq_0" :dir rl) nil nil)) nil)) nil) ("4" (rewrite "sqv_eq_0" :dir rl) (("4" (rewrite "sqv_eq_0" :dir rl) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "sqv(pu-c) = sq(R) AND sqv(pv-c) = sq(R)") (("1" (flatten) (("1" (lemma "orthogonal_basis") (("1" (inst - "c" "perpR(c)" _) (("1" (inst-cp - "pu-c") (("1" (inst - "pv-c") (("1" (assert) (("1" (case "perpR(c) /= zero AND orthogonal?(c, perpR(c))") (("1" (flatten) (("1" (assert) (("1" (hide -1) (("1" (lemma "orthogonal_basis_sqv") (("1" (inst?) (("1" (assert) (("1" (replace -5) (("1" (hide -2) (("1" (lemma "orthogonal_basis_sqv") (("1" (inst?) (("1" (assert) (("1" (replace -4) (("1" (replace -1 -2) (("1" (hide (-1 -3)) (("1" (case "sqv(perpR(c)) = sqv(c)") (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "sq_div") (("1" (rewrite "sq_div") (("1" (rewrite "sq_div") (("1" (rewrite "sq_div") (("1" (rewrite "dot_sub_left") (("1" (rewrite "dot_sub_left") (("1" (rewrite "dot_sub_left") (("1" (rewrite "dot_sub_left") (("1" (case "c*perpR(c) = 0") (("1" (replace -1) (("1" (assert) (("1" (case "c*c = sqv(c)") (("1" (replace -1) (("1" (case "FORALL (zpop:real): zpop^2 = sq(zpop)") (("1" (rewrite -1) (("1" (rewrite -1) (("1" (rewrite -1) (("1" (rewrite -1) (("1" (rewrite -1) (("1" (mult-by 2 "sqv(c)/sq(sqv(c))") (("1" (assert) nil nil) ("2" (flatten) (("2" (cross-mult -1) (("2" (lemma "sqv_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (expand "^") (("2" (expand "expt") (("2" (expand "expt") (("2" (expand "expt") (("2" (expand "sq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "sqv" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "sqv_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (rewrite "sqv_eq_0") nil nil)) nil)) nil) ("2" (flatten) (("2" (rewrite "sqv_eq_0") nil nil)) nil)) nil) ("2" (flatten) (("2" (rewrite "sqv_eq_0") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split +) (("1" (case "c = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1 2)) (("2" (flatten) (("2" (expand "zero") (("2" (expand "perpR") (("2" (flatten) (("2" (decompose-equality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "inter_circle_max_time_def") (("2" (inst - "R" "c" _) (("2" (inst-cp - "v") (("2" (inst - "u") (("2" (assert) (("2" (flatten) (("2" (hide (-2 -4)) (("2" (expand "circle?") (("2" (case "FORALL (rtz:Vect2): norm(rtz) = R IMPLIES sqv(rtz) = sq(R)") (("1" (split +) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (inst?) (("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (rewrite "sqrt_eq" 1 :dir rl) (("2" (rewrite "sqrt_sqv_norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "dist") (("2" (rewrite "sq_sqrt") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "inter_circle_max_time_def") (("2" (inst - "R" "c" _) (("2" (inst-cp - "v") (("2" (inst - "u") (("2" (assert) (("2" (flatten) (("2" (hide (-2 -4)) (("2" (expand "circle?") (("2" (case "FORALL (rtz:Vect2): norm(rtz) = R IMPLIES sqv(rtz) = sq(R)") (("1" (inst-cp - "pv-c") (("1" (inst - "pu-c") (("1" (assert) (("1" (hide-all-but (-1 -2 1)) (("1" (expand "dist") (("1" (rewrite "sq_sqrt") (("1" (rewrite "sq_sqrt") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (rewrite "sqrt_eq" 1 :dir rl) (("2" (rewrite "sqrt_sqv_norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "inter_circle_max_time_def") (("2" (inst - "R" "c" _) (("2" (inst-cp - "v") (("2" (inst - "u") (("2" (assert) (("2" (flatten) (("2" (hide (-2 -4)) (("2" (expand "circle?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "intersects_circle_fun?") (("2" (flatten) (("2" (reveal "uvnz") (("2" (assert) (("2" (hide 4) (("2" (hide "uvnz") (("2" (flatten) (("2" (case "FORALL (bl1,bl2:bool): (bl1 OR bl2) IFF ((bl1 AND NOT bl2) OR bl2)") (("1" (label "final" 1) (("1" (hide "final") (("1" (rewrite -1) (("1" (hide -1) (("1" (reveal "final") (("1" (split -) (("1" (flatten) (("1" (split +) (("1" (expand "Delta") (("1" (reveal "sqvu") (("1" (reveal "sqvv") (("1" (replace -1) (("1" (hide -1) (("1" (replace -1) (("1" (hide -1) (("1" (case "sq(u*perpR(c)) <= sq(v*perpR(c))") (("1" (grind) nil nil) ("2" (hide (-2 2)) (("2" (lemma "orthogonal_basis") (("2" (inst - "c" "perpR(c)" _) (("2" (inst-cp - "u") (("2" (inst - "v") (("2" (assert) (("2" (case "c /= zero AND perpR(c) /= zero AND orthogonal?(c, perpR(c))") (("1" (flatten) (("1" (assert) (("1" (lemma "orthogonal_basis_sqv") (("1" (inst?) (("1" (assert) (("1" (label "ddvc1" -3) (("1" (hide "ddvc1") (("1" (label "ddvc2" -1) (("1" (hide "ddvc2") (("1" (lemma "orthogonal_basis_sqv") (("1" (inst?) (("1" (assert) (("1" (reveal "ddvc1") (("1" (reveal "ddvc2") (("1" (delabel "ddvc1") (("1" (delabel "ddvc2") (("1" (case "sqv(perpR(c)) = sqv(c)") (("1" (replace -1) (("1" (hide -1) (("1" (reveal "sqvv") (("1" (replace -1) (("1" (reveal "sqvu") (("1" (replace -1) (("1" (case "sq(u*c) >= sq(v*c)") (("1" (rewrite "sq_div") (("1" (rewrite "sq_div") (("1" (rewrite "sq_div") (("1" (rewrite "sq_div") (("1" (mult-by 3 "sqv(c)/sq(sqv(c))") (("1" (mult-by -1 "sqv(c)/sq(sqv(c))") (("1" (ground) (("1" (real-props) nil nil)) nil) ("2" (cross-mult 1) nil nil)) nil) ("2" (split +) (("1" (cross-mult 1) nil nil) ("2" (cross-mult 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "sq_ge") (("1" (hide-all-but (-8 1)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (-8 -9 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split +) (("1" (flatten) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (case "c = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "zero") (("2" (expand "perpR") (("2" (flatten) (("2" (decompose-equality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide-all-but (-1 -3 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (split +) (("1" (expand "Delta") (("1" (reveal "sqvu") (("1" (replace -1) (("1" (lemma "schwarz") (("1" (inst - "u" "perpR(c)") (("1" (lemma "sq_le") (("1" (inst?) (("1" (assert) (("1" (hide -2) (("1" (case "sq(norm(u) * norm(perpR(c)))<=sq(R)") (("1" (hide-all-but (-1 -2 1)) (("1" (grind) nil nil)) nil) ("2" (hide (-1 2)) (("2" (reveal "normu") (("2" (assert) (("2" (replace -1) (("2" (lemma "sq_norm") (("2" (inst - "perpR(c)") (("2" (replace -1) (("2" (hide -1) (("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (wwzz:Vect2): norm(wwzz)=1 IMPLIES sqv(wwzz) = 1") (("1" (inst-cp - "u") (("1" (inst - "v") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (rewrite "sqrt_eq" 1 :dir rl) (("2" (rewrite "sqrt_sqv_norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split +) (("1" (flatten) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (expand "^") (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (replace -2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (replace -3) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (replace -3) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ((sqv const-decl "nnreal" vectors_2D vectors) (det const-decl "real" det_2D vectors) (perpR_eq_zero formula-decl nil perpendicular_2D vectors) (sq_ge formula-decl nil sq reals) (both_sides_times_pos_le1 formula-decl nil real_props nil) (div_mult_pos_ge1 formula-decl nil real_props nil) (both_sides_div_pos_le1 formula-decl nil real_props nil) (neg_times_le formula-decl nil real_props nil) (le_times_le_pos formula-decl nil real_props nil) (div_cancel4 formula-decl nil real_props nil) (div_distributes formula-decl nil real_props nil) (times_div2 formula-decl nil real_props nil) (times_div1 formula-decl nil real_props nil) (div_mult_pos_gt1 formula-decl nil extra_real_props nil) (Delta const-decl "real" horizontal nil) (sq_norm formula-decl nil vectors_2D vectors) (sq_abs formula-decl nil sq reals) (schwarz formula-decl nil vectors_2D vectors) (* const-decl "Vector" vectors_2D vectors) (inter_circle_max_time const-decl "nnreal" circle_optimum_2D nil) (law_cosines_alt formula-decl nil law_cos_pos_2D vectors) (real_minus_real_is_real application-judgement "real" reals nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (sub_zero_right formula-decl nil vectors_2D vectors) (dist const-decl "nnreal" distance_2D vectors) (sq_dist_norm formula-decl nil distance_2D vectors) (IFF const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (sq_nz_pos application-judgement "posreal" sq reals) (sqv_neg formula-decl nil vectors_2D vectors) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "Vector" vectors_2D vectors) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (discr2b const-decl "real" quadratic_2b reals) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nz_sqv_gt_0 application-judgement "posreal" vectors_2D vectors) (Delta_discr2b formula-decl nil horizontal nil) (le_times_le_any1 formula-decl nil extra_real_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (root2b const-decl "real" quadratic_2b reals) (u skolem-const-decl "Vect2" circle_optimum_2D nil) (c skolem-const-decl "Vect2" circle_optimum_2D nil) (v skolem-const-decl "Vect2" circle_optimum_2D nil) (sqrt_le formula-decl nil sqrt reals) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (- const-decl "[numfield -> numfield]" number_fields nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_real_is_real application-judgement "real" reals nil) (Theta_D const-decl "real" horizontal nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (dot_scal_right formula-decl nil vectors_2D vectors) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (^ const-decl "real" exponentiation nil) (perpR const-decl "Vect2" perpendicular_2D vectors) (orthogonal? const-decl "bool" vectors_2D vectors) (< const-decl "bool" reals nil) (circle? const-decl "bool" circle_optimum_2D nil) (sqrt_eq formula-decl nil sqrt reals) (sqrt_pos application-judgement "posreal" sqrt reals) (sqrt_sq formula-decl nil sqrt reals) (sqrt_sqv_norm formula-decl nil vectors_2D vectors) (inter_circle_max_time_def formula-decl nil circle_optimum_2D nil) (sq_neg formula-decl nil sq reals) (sq_gt formula-decl nil sq reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (dot_zero_left formula-decl nil vectors_2D vectors) (sq_0 formula-decl nil sq reals) (dot_zero_right formula-decl nil vectors_2D vectors) (scal_0 formula-decl nil vectors_2D vectors) (expt def-decl "real" exponentiation nil) (puc skolem-const-decl "nnreal" circle_optimum_2D nil) (pvc skolem-const-decl "nnreal" circle_optimum_2D nil) (sq_times formula-decl nil sq reals) (sq_lt formula-decl nil sq reals) (cv1 skolem-const-decl "nnreal" circle_optimum_2D nil) (sqv_scal formula-decl nil vectors_2D vectors) (scal_assoc formula-decl nil vectors_2D vectors) (sqv_add formula-decl nil vectors_2D vectors) (sqv_eq_0 formula-decl nil vectors_2D vectors) (sq_div formula-decl nil sq reals) (orthogonal_basis formula-decl nil basis_2D vectors) (orthogonal_basis_sqv formula-decl nil basis_2D vectors) (dot_sub_left formula-decl nil vectors_2D vectors) (div_cancel3 formula-decl nil real_props nil) (both_sides_times1 formula-decl nil real_props nil) (intersects_circle_fun? const-decl "bool" circle_optimum_2D nil) (real_plus_real_is_real application-judgement "real" reals nil) (- const-decl "Vector" vectors_2D vectors) (sq_le formula-decl nil sq reals) (pv skolem-const-decl "Vector" circle_optimum_2D nil) (norm_scal formula-decl nil vectors_2D vectors) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (pu skolem-const-decl "Vector" circle_optimum_2D nil) (sq const-decl "nonneg_real" sq reals) (sq_sqrt formula-decl nil sqrt reals) (sq_dist const-decl "nnreal" distance_2D vectors) (sqrt_1 formula-decl nil sqrt reals) (TRUE const-decl "bool" booleans nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (scal_1 formula-decl nil vectors_2D vectors) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (norm_zero formula-decl nil vectors_2D vectors) (u skolem-const-decl "Vect2" circle_optimum_2D nil) (div_mult_pos_neg_gt1 formula-decl nil extra_real_props nil) (div_mult_pos_neg_ge1 formula-decl nil extra_real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (norm_eq_0 formula-decl nil vectors_2D vectors) (real_times_real_is_real application-judgement "real" reals nil) (dot_scal_left formula-decl nil vectors_2D vectors) (v skolem-const-decl "Vect2" circle_optimum_2D nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (inter_circle_max_norm_scal formula-decl nil circle_optimum_2D nil) (norm_normalize formula-decl nil vectors_2D vectors) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Vector type-eq-decl nil vectors_2D vectors) (nnreal type-eq-decl nil real_types nil) (norm const-decl "nnreal" vectors_2D vectors) (<= const-decl "bool" reals nil) (* const-decl "real" vectors_2D vectors) (/= const-decl "boolean" notequal nil) (zero const-decl "Vector" vectors_2D vectors) (Nz_vector type-eq-decl nil vectors_2D vectors) (Normalized type-eq-decl nil vectors_2D vectors) (^ const-decl "Normalized" vectors_2D vectors) (inter_circle_max_norm const-decl "nnreal" circle_optimum_2D nil)) shostak)) (max_circle_point_in_slice_TCC1 0 (max_circle_point_in_slice_TCC1-2 "" 3804520403 ("" (skeep) (("" (lemma "norm_eq_0") (("" (inst?) (("" (assert) (("" (hide-all-but (-1 2)) (("" (expand "zero") (("" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (max_circle_point_in_slice subtype "vectors_2D.norm((vectors_2D.-)(circle_optimum_2D.c, circle_optimum_2D.p))" "nznum")) (max_circle_point_in_slice_TCC1-1 nil 3527939533 ("" (skeep) (("" (lemma "norm_eq_0") (("" (inst?) (("" (assert) (("" (hide-all-but (-1 1)) (("" (expand "zero") (("" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((norm_eq_0 formula-decl nil vectors_2D vectors) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (zero const-decl "Vector" vectors_2D vectors) (real_minus_real_is_real application-judgement "real" reals nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (- const-decl "Vector" vectors_2D vectors) (Vector type-eq-decl nil vectors_2D vectors) (real nonempty-type-from-decl nil reals nil)) nil (max_circle_point_in_slice subtype "vectors_2D.norm((vectors_2D.-)(circle_optimum_2D.c, circle_optimum_2D.p))" "nznum"))) (lem1 0 (lem1-1 nil 3528642065 ("" (skeep) (("" (ground) (("1" (rewrite "sq_le" :dir rl) (("1" (rewrite "sq_norm") (("1" (rewrite "sq_eq" -2 :dir rl) (("1" (rewrite "sq_eq" -3 :dir rl) (("1" (rewrite "sq_norm") (("1" (rewrite "sq_norm") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "sq_le" :dir rl) (("2" (rewrite "sq_norm") (("2" (rewrite "sq_eq" -2 :dir rl) (("2" (rewrite "sq_eq" -3 :dir rl) (("2" (rewrite "sq_norm") (("2" (rewrite "sq_norm") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "sq_lt" :dir rl) (("3" (rewrite "sq_norm") (("3" (rewrite "sq_eq" -2 :dir rl) (("3" (rewrite "sq_eq" -3 :dir rl) (("3" (rewrite "sq_norm") (("3" (rewrite "sq_norm") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (rewrite "sq_lt" :dir rl) (("4" (rewrite "sq_norm") (("4" (rewrite "sq_eq" -2 :dir rl) (("4" (rewrite "sq_eq" -3 :dir rl) (("4" (rewrite "sq_norm") (("4" (rewrite "sq_norm") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sqrt_pos application-judgement "posreal" sqrt reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sq_norm formula-decl nil vectors_2D vectors) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (sqv const-decl "nnreal" vectors_2D vectors) (* const-decl "real" vectors_2D vectors) (sq_1 formula-decl nil sq reals) (sq_eq formula-decl nil sq reals) (sq_sqrt formula-decl nil sqrt reals) (sq_nz_pos application-judgement "posreal" sq reals) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (- const-decl "Vector" vectors_2D vectors) (norm const-decl "nnreal" vectors_2D vectors) (nnreal type-eq-decl nil real_types nil) (Vector type-eq-decl nil vectors_2D vectors) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (sq_le formula-decl nil sq reals) (sq_lt formula-decl nil sq reals)) shostak)) (lem2 0 (lem2-1 nil 3528642564 ("" (skeep) (("" (ground) (("1" (rewrite "sq_ge" 1 :dir rl) (("1" (rewrite "sq_norm") (("1" (rewrite "sq_norm") (("1" (rewrite "sq_eq" -2 :dir rl) (("1" (rewrite "sq_eq" -3 :dir rl) (("1" (rewrite "sq_eq" -4 :dir rl) (("1" (rewrite "sq_norm") (("1" (rewrite "sq_norm") (("1" (rewrite "sq_norm") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "sq_ge" -1 :dir rl) (("2" (rewrite "sq_norm") (("2" (rewrite "sq_norm") (("2" (rewrite "sq_eq" -2 :dir rl) (("2" (rewrite "sq_eq" -3 :dir rl) (("2" (rewrite "sq_eq" -4 :dir rl) (("2" (rewrite "sq_norm") (("2" (rewrite "sq_norm") (("2" (rewrite "sq_norm") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "sq_gt" 1 :dir rl) (("3" (rewrite "sq_norm") (("3" (rewrite "sq_norm") (("3" (rewrite "sq_eq" -2 :dir rl) (("3" (rewrite "sq_eq" -3 :dir rl) (("3" (rewrite "sq_eq" -4 :dir rl) (("3" (rewrite "sq_norm") (("3" (rewrite "sq_norm") (("3" (rewrite "sq_norm") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (rewrite "sq_gt" -1 :dir rl) (("4" (rewrite "sq_norm") (("4" (rewrite "sq_norm") (("4" (rewrite "sq_eq" -2 :dir rl) (("4" (rewrite "sq_eq" -3 :dir rl) (("4" (rewrite "sq_eq" -4 :dir rl) (("4" (rewrite "sq_norm") (("4" (rewrite "sq_norm") (("4" (rewrite "sq_norm") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (sq_norm formula-decl nil vectors_2D vectors) (sq_eq formula-decl nil sq reals) (sq_nz_pos application-judgement "posreal" sq reals) (sq_1 formula-decl nil sq reals) (* const-decl "real" vectors_2D vectors) (sqv const-decl "nnreal" vectors_2D vectors) (real_minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (- const-decl "Vector" vectors_2D vectors) (norm const-decl "nnreal" vectors_2D vectors) (nnreal type-eq-decl nil real_types nil) (Vector type-eq-decl nil vectors_2D vectors) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (sq_ge formula-decl nil sq reals) (sq_gt formula-decl nil sq reals)) shostak)) (max_circle_point_in_slice_intersection 0 (max_circle_point_in_slice_intersection-1 nil 3528802516 ("" (case "NOT FORALL (a1,a2,b1:Nz_vect2): orthonormal?(a1,a2) AND norm(b1) = 1 AND a2*b1 = 0 IMPLIES b1 = a1 OR b1 = -a1") (("1" (hide-all-but 1) (("1" (skeep) (("1" (lemma "orthonormal_basis") (("1" (inst - "a1" "a2" "b1") (("1" (assert) (("1" (case "b1*a2 = 0") (("1" (replace -1) (("1" (assert) (("1" (case "b1*a1 = 1 OR b1*a1 = -1") (("1" (split -) (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("2" (case "norm(a1) = 1") (("1" (replace -3 -5) (("1" (rewrite "norm_scal") (("1" (replace -1) (("1" (expand "abs") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "orthonormal?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "thislem" -1) (("2" (hide "thislem") (("2" (case "NOT FORALL (a1,a2,a3:Nz_vect2): orthonormal?(a1,a3) and orthonormal?(a2,a3) IMPLIES a1=a2 OR a1=-a2") (("1" (hide-all-but (-4 1)) (("1" (skeep) (("1" (lemma "orthonormal_basis") (("1" (inst - "a1" "a3" "a2") (("1" (assert) (("1" (expand "orthonormal?") (("1" (flatten) (("1" (expand "orthogonal?") (("1" (replace -5) (("1" (assert) (("1" (case "a2*a1 = 1 OR a2*a1 = -1") (("1" (split -) (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (replace -1) (("2" (assert) (("2" (replace -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1 -6) (("2" (rewrite "norm_scal") (("2" (replace -3) (("2" (expand "abs") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "thatlem" -1) (("2" (hide "thatlem") (("2" (skeep) (("2" (name "ff" "LAMBDA (vv:Vect2): min(min(min(vv*aa,vv*bb),vv*cc),vv*dd)") (("2" (name "fk" "LAMBDA (vv:Vect2): min(vv*cc,vv*dd)") (("2" (case "ff(h)>0 AND ff(g)<0 AND fk(h)>0 AND fk(g)>0") (("1" (flatten) (("1" (case "EXISTS (vv:Nz_vect2): ff(vv) = 0 AND fk(vv)>0") (("1" (case "EXISTS (vv:Nz_vect2): norm(vv)=1 AND ff(vv) = 0 AND fk(vv)>0") (("1" (hide -2) (("1" (skeep -1) (("1" (case "(vv*aa =0 AND vv*bb>=0 AND vv*cc>0 AND vv*dd>0) OR (vv*aa >=0 AND vv*bb=0 AND vv*cc>0 AND vv*dd>0)") (("1" (split -) (("1" (flatten) (("1" (case "vv = ap") (("1" (ground) nil nil) ("2" (case "vv = -ap") (("1" (replace -1) (("1" (case "ap*bb = 0") (("1" (case "bb = -aa") (("1" (replace -1) (("1" (hide-all-but (-28 -29)) (("1" (grind) nil nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "aa" "ap" "bb") (("2" (assert) (("2" (expand "orthonormal?") (("2" (split -1) (("1" (replace -1) (("1" (case "ap = -bp") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (hide-all-but (-27 1 -17 -18 -1 -8)) (("2" (lemma "orthonormal_basis") (("2" (inst - "aa" "ap" "bp") (("2" (split -) (("1" (case "bp*aa = 0") (("1" (replace -1) (("1" (assert) (("1" (replace -2) (("1" (flatten) (("1" (rewrite "norm_scal") (("1" (replace -4) (("1" (assert) (("1" (expand "abs") (("1" (lift-if) (("1" (ground) (("1" (case "bp*ap = -1") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -2 :dir rl) (("2" (flatten) (("2" (expand "orthogonal?") (("2" (assert) (("2" (hide-all-but (-6 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "orthonormal?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -22 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (reveal "thatlem") (("2" (inst - "vv" "ap" "aa") (("2" (assert) (("2" (expand "orthonormal?") (("2" (flatten) (("2" (assert) (("2" (expand "orthogonal?") (("2" (hide-all-but (-14 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "vv = bp") (("1" (ground) nil nil) ("2" (case "vv = -bp") (("1" (replace -1) (("1" (case "bp*aa = 0") (("1" (case "aa = -bb") (("1" (replace -1) (("1" (hide-all-but (-28 -29)) (("1" (grind) nil nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "bb" "bp" "aa") (("2" (assert) (("2" (expand "orthonormal?") (("2" (split -1) (("1" (assert) (("1" (case "ap = -bp") (("1" (assert) nil nil) ("2" (hide-all-but (-1 -2 -8 -17 -18 -27 1)) (("2" (lemma "orthonormal_basis") (("2" (inst - "aa" "ap" "bp") (("2" (split -) (("1" (replace -3) (("1" (assert) (("1" (replace -1) (("1" (flatten) (("1" (rewrite "norm_scal") (("1" (replace -7) (("1" (assert) (("1" (expand "abs") (("1" (lift-if) (("1" (ground) (("1" (case "bp*ap = -1") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "orthonormal?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -21 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (reveal "thatlem") (("2" (inst - "vv" "bp" "bb") (("2" (assert) (("2" (expand "orthonormal?") (("2" (flatten) (("2" (assert) (("2" (expand "orthogonal?") (("2" (hide-all-but (-17 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -3 1)) (("2" (expand "fk") (("2" (case "vv*cc > 0 AND vv*dd>0") (("1" (flatten) (("1" (assert) (("1" (hide -4) (("1" (expand "ff") (("1" (expand "min") (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lift-if) (("2" (split -) (("1" (assert) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (lift-if) (("1" (split -) (("1" (assert) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lift-if) (("2" (split -) (("1" (assert) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "min") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (skeep -1) (("2" (inst + "^(vv)") (("2" (assert) (("2" (typepred "^(vv)") (("2" (assert) (("2" (split +) (("1" (hide -3) (("1" (expand "^") (("1" (name "cck" "1/norm(vv)") (("1" (case "cck > 0") (("1" (replace -2) (("1" (hide -2) (("1" (case "FORALL (dzp:Vect2): (cck*vv)*dzp >=0 IFF vv*dzp>=0") (("1" (case "FORALL (dzp:Vect2): (cck*vv)*dzp=0 IFF vv*dzp=0") (("1" (inst-cp - "aa") (("1" (inst-cp - "bb") (("1" (inst-cp - "cc") (("1" (inst - "dd") (("1" (inst-cp - "aa") (("1" (inst-cp - "bb") (("1" (inst-cp - "cc") (("1" (inst - "dd") (("1" (case "(vv*aa =0 AND vv*bb>=0 AND vv*cc>=0 AND vv*dd>=0) OR (vv*aa >=0 AND vv*bb=0 AND vv*cc>=0 AND vv*dd>=0) OR (vv*aa >=0 AND vv*bb>=0 AND vv*cc=0 AND vv*dd>=0) OR (vv*aa >=0 AND vv*bb>=0 AND vv*cc>=0 AND vv*dd=0)") (("1" (case "((cck*vv)*aa =0 AND (cck*vv)*bb>=0 AND (cck*vv)*cc>=0 AND (cck*vv)*dd>=0) OR ((cck*vv)*aa >=0 AND (cck*vv)*bb=0 AND (cck*vv)*cc>=0 AND (cck*vv)*dd>=0) OR ((cck*vv)*aa >=0 AND (cck*vv)*bb>=0 AND (cck*vv)*cc=0 AND (cck*vv)*dd>=0) OR ((cck*vv)*aa >=0 AND (cck*vv)*bb>=0 AND (cck*vv)*cc>=0 AND (cck*vv)*dd=0)") (("1" (hide-all-but (-1 1)) (("1" (expand "ff") (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (replace -1) (("1" (expand "min") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -2) (("2" (expand "min") (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (replace -3) (("3" (assert) (("3" (expand "min") (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (flatten) (("4" (replace -4) (("4" (assert) (("4" (expand "min") (("4" (lift-if) (("4" (lift-if) (("4" (lift-if) (("4" (assert) (("4" (lift-if) (("4" (assert) (("4" (lift-if) (("4" (lift-if) (("4" (assert) (("4" (lift-if) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-11 2)) (("2" (flatten) (("2" (split -) (("1" (flatten) (("1" (mult-by -1 "cck") (("1" (mult-by -2 "cck") (("1" (mult-by -3 "cck") (("1" (mult-by -4 "cck") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (mult-by -1 "cck") (("2" (mult-by -2 "cck") (("2" (mult-by -3 "cck") (("2" (mult-by -4 "cck") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (mult-by -1 "cck") (("3" (mult-by -2 "cck") (("3" (mult-by -3 "cck") (("3" (mult-by -4 "cck") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (flatten) (("4" (mult-by -1 "cck") (("4" (mult-by -2 "cck") (("4" (mult-by -3 "cck") (("4" (mult-by -4 "cck") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-10 1)) (("2" (flatten) (("2" (expand "ff") (("2" (expand "min") (("2" (assert) (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (ground) (("2" (mult-by 1 "cck") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (ground) (("1" (mult-by 1 "cck") (("1" (assert) nil nil)) nil) ("2" (mult-by -1 "cck") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (expand "fk") (("2" (expand "^") (("2" (name "cck" "1/norm(vv)") (("2" (replace -1) (("2" (case "cck > 0") (("1" (expand "min") (("1" (lift-if) (("1" (ground) (("1" (mult-by -2 "cck") (("1" (assert) nil nil)) nil) ("2" (mult-by 1 "cck") (("2" (assert) nil nil)) nil) ("3" (mult-by -1 "cck") (("3" (assert) nil nil)) nil) ("4" (mult-by -1 "cck") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 -3 -4 -5 -6 1 -11 -12)) (("2" (name "linet" "LAMBDA (v1,v2:Nz_vect2): LAMBDA (tr:real): (1-tr)*v1 + tr*v2") (("2" (case "NOT FORALL (tr:real): 0<=tr AND tr<=1 IMPLIES fk(linet(g,h)(tr)) > 0") (("1" (hide (-1 2)) (("1" (skeep) (("1" (case "FORALL (rvk:Vect2): h*rvk > 0 AND g*rvk > 0 IMPLIES linet(g,h)(tr)*rvk > 0") (("1" (inst-cp - "cc") (("1" (inst - "dd") (("1" (hide -4) (("1" (hide-all-but (-1 -2 -6 -7 1)) (("1" (expand "fk") (("1" (expand "min") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 1)) (("2" (skeep) (("2" (case "tr = 0") (("1" (replace -1) (("1" (expand "linet") (("1" (grind) nil nil)) nil)) nil) ("2" (mult-by -1 "tr") (("2" (mult-by -2 "1-tr") (("1" (expand "linet") (("1" (grind) nil nil)) nil) ("2" (case "tr = 1") (("1" (replace -1) (("1" (expand "linet") (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "ffline" "LAMBDA (tr:real): ff(linet(g,h)(tr))") (("2" (lemma "interm_val2") (("2" (inst - "0" "1" "0") (("2" (assert) (("2" (inst - "ffline") (("2" (case "ffline(0) = ff(g) AND ffline(1) = ff(h)") (("1" (flatten) (("1" (assert) (("1" (split -) (("1" (hide (-2 -3)) (("1" (skeep -1) (("1" (case "linet(g,h)(c) /= zero") (("1" (flatten) (("1" (inst + "linet(g,h)(c)") (("1" (expand "ffline" -1) (("1" (assert) (("1" (inst - "c") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (inst - "c") (("2" (assert) (("2" (replace -1) (("2" (hide-all-but -4) (("2" (expand "fk") (("2" (expand "zero") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "continuous?(ffline)") (("1" (hide-all-but (-1 1)) (("1" (expand "continuous?") (("1" (expand "restrict") (("1" (expand "continuous?") (("1" (skeep) (("1" (inst - "x0") (("1" (skeep) (("1" (inst - "epsilon") (("1" (skeep -1) (("1" (inst + "delta") (("1" (skeep) (("1" (inst - "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case "FORALL (rg:Vect2): continuous?(LAMBDA (tr:real): rg*linet(g,h)(tr))") (("1" (hide-all-but (-1 1)) (("1" (expand "ffline") (("1" (expand "ff") (("1" (lemma "min_cont[real]") (("1" (inst - "LAMBDA (tr:real): min(min(linet(g, h)(tr) * aa,
                                                    linet(g, h)(tr) * bb),
                                                linet(g, h)(tr) * cc)" "LAMBDA (tr:real): linet(g, h)(tr) * dd") (("1" (hide 2) (("1" (inst - "dd") (("1" (case "(LAMBDA (tr: real): dd * linet(g, h)(tr)) = (LAMBDA (tr: real): linet(g, h)(tr) * dd)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "min_cont[real]") (("2" (inst - "LAMBDA (tr:real): min(linet(g, h)(tr) * aa, linet(g, h)(tr) * bb)" "LAMBDA (tr:real): linet(g, h)(tr) * cc") (("1" (hide 2) (("1" (inst - "cc") (("1" (case "(LAMBDA (tr: real): cc * linet(g, h)(tr)) = (LAMBDA (tr: real): linet(g, h)(tr) * cc)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "min_cont[real]") (("2" (inst - "LAMBDA (tr:real): linet(g, h)(tr) * aa" "LAMBDA (tr:real): linet(g, h)(tr) * bb") (("1" (hide 2) (("1" (inst - "bb") (("1" (case "(LAMBDA (tr: real): bb * linet(g, h)(tr)) = (LAMBDA (tr: real): linet(g, h)(tr) * bb)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (inst - "aa") (("2" (case "(LAMBDA (tr: real): aa * linet(g, h)(tr)) = (LAMBDA (tr: real): linet(g, h)(tr) * aa)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "linet") (("2" (case "FORALL (ar,br:real): continuous?(LAMBDA (tr:real): br*tr + ar)") (("1" (skeep) (("1" (inst - "rg*g" "rg*h-rg*g") (("1" (grind :exclude "continuous?") nil nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (case "br = 0") (("1" (replace -1) (("1" (assert) (("1" (expand "continuous?") (("1" (expand "continuous?") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "continuous?") (("2" (skeep 2) (("2" (expand "continuous?") (("2" (skeep 2) (("2" (inst + "epsilon/abs(br)") (("1" (skeep 2) (("1" (lemma "abs_mult") (("1" (inst - "br" "x-x0") (("1" (assert) (("1" (replace -1) (("1" (cross-mult -2) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split +) (("1" (cross-mult 1) nil nil) ("2" (cross-mult 1) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "ffline") (("2" (expand "linet") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-14 -15 -16 -17 -18 -19 1 2)) (("2" (expand "ff") (("2" (expand "fk") (("2" (split +) (("1" (expand "min") (("1" (assert) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (assert) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (assert) (("1" (lift-if) (("1" (split +) (("1" (flatten) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lift-if) (("2" (split +) (("1" (flatten) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lift-if) (("2" (split +) (("1" (flatten) (("1" (assert) (("1" (lift-if) (("1" (split +) (("1" (flatten) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lift-if) (("2" (split +) (("1" (flatten) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (expand "min") (("3" (assert) (("3" (lift-if) (("3" (split +) (("1" (flatten) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (split +) (("1" (assert) (("1" (expand "min") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (expand "min") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((orthogonal? const-decl "bool" vectors_2D vectors) (norm_neg formula-decl nil vectors_2D vectors) (neg_neg formula-decl nil vectors_2D vectors) (<= const-decl "bool" reals nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (> const-decl "bool" reals nil) (< const-decl "bool" reals nil) (^ const-decl "Normalized" vectors_2D vectors) (Normalized type-eq-decl nil vectors_2D vectors) (Nz_vector type-eq-decl nil vectors_2D vectors) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (both_sides_times1 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (* const-decl "Vector" vectors_2D vectors) (IFF const-decl "[bool, bool -> bool]" booleans nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (both_sides_times_pos_gt1 formula-decl nil real_props nil) (norm_normalize formula-decl nil vectors_2D vectors) (min_id formula-decl nil min_max reals) (add_zero_left formula-decl nil vectors_2D vectors) (dot_scal_left formula-decl nil vectors_2D vectors) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (fk skolem-const-decl "[vv: Vect2 -> {p: real | p <= vv * cc AND p <= vv * dd}]" circle_optimum_2D nil) (ff skolem-const-decl "[vv: Vect2 ->
   {p: real | p <= min(min(vv * aa, vv * bb), vv * cc) AND p <= vv * dd}]" circle_optimum_2D nil) (real_minus_real_is_real application-judgement "real" reals nil) (+ const-decl "Vector" vectors_2D vectors) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (ffline skolem-const-decl "[tr: real ->
   {p: real |
      p <=
       min(min(linet(g, h)(tr) * aa, linet(g, h)(tr) * bb),
           linet(g, h)(tr) * cc)
       AND p <= linet(g, h)(tr) * dd}]" circle_optimum_2D nil) (c skolem-const-decl "closed_interval[real](0, 1)" circle_optimum_2D nil) (h skolem-const-decl "Nz_vect2" circle_optimum_2D nil) (g skolem-const-decl "Nz_vect2" circle_optimum_2D nil) (closed_interval type-eq-decl nil intervals_real reals) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (br skolem-const-decl "real" circle_optimum_2D nil) (epsilon skolem-const-decl "posreal" circle_optimum_2D nil) (abs_mult formula-decl nil real_props nil) (div_mult_pos_lt2 formula-decl nil real_props nil) (div_mult_pos_gt1 formula-decl nil extra_real_props nil) (div_mult_pos_ge1 formula-decl nil real_props nil) (continuous_fun nonempty-type-eq-decl nil continuous_functions analysis) (aa skolem-const-decl "Nz_vect2" circle_optimum_2D nil) (bb skolem-const-decl "Nz_vect2" circle_optimum_2D nil) (cc skolem-const-decl "Nz_vect2" circle_optimum_2D nil) (dd skolem-const-decl "Nz_vect2" circle_optimum_2D nil) (min_cont formula-decl nil continuous_lambda analysis) (restrict const-decl "R" restrict nil) (continuous? const-decl "bool" continuous_functions analysis) (continuous? const-decl "bool" continuous_functions analysis) (interm_val2 formula-decl nil interm_value_thm analysis) (tr skolem-const-decl "real" circle_optimum_2D nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (linet skolem-const-decl "[[Nz_vect2, Nz_vect2] -> [real -> Vector]]" circle_optimum_2D nil) (orthonormal_basis formula-decl nil basis_2D vectors) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (scal_neg_1 formula-decl nil vectors_2D vectors) (nz_nzv application-judgement "Nz_vector" vectors_2D vectors) (scal_1 formula-decl nil vectors_2D vectors) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (norm_scal formula-decl nil vectors_2D vectors) (add_zero_right formula-decl nil vectors_2D vectors) (scal_0 formula-decl nil vectors_2D vectors) (nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors) (neg_nzv application-judgement "Nz_vector" vectors_2D vectors) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Vector type-eq-decl nil vectors_2D vectors) (/= const-decl "boolean" notequal nil) (zero const-decl "Vector" vectors_2D vectors) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (orthonormal? const-decl "bool" basis_2D vectors) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (norm const-decl "nnreal" vectors_2D vectors) (* const-decl "real" vectors_2D vectors) (OR const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "Vector" vectors_2D vectors)) nil)) (max_circle_point_in_slice_union 0 (max_circle_point_in_slice_union-1 nil 3528802663 ("" (skeep) (("" (lemma "max_circle_point_in_slice_intersection") (("" (label "thyp" -12) (("" (hide "thyp") (("" (split -) (("1" (split -) (("1" (inst - "aa" "bb" "cc" "cc" "ap" "bp" "cp" "cp" "h" "g") (("1" (assert) (("1" (reveal "thyp") (("1" (replace -1) (("1" (hide -1) (("1" (replace 2) (("1" (hide-all-but (-5 1)) (("1" (expand "orthonormal?") (("1" (flatten) (("1" (hide (-2 -3)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT (g*cc <=0 AND h*dd <= 0)") (("1" (split +) (("1" (inst - "aa" "bb" "cc" "cc" "ap" "bp" "cp" "cp" "h" "g") (("1" (assert) (("1" (reveal "thyp") (("1" (replace -1) (("1" (hide -1) (("1" (replace 3) (("1" (hide-all-but (-5 2)) (("1" (expand "orthonormal?") (("1" (flatten) (("1" (hide (-2 -3)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst - "aa" "bb" "dd" "dd" "ap" "bp" "dp" "dp" "h" "g") (("2" (assert) (("2" (reveal "thyp") (("2" (replace -1) (("2" (hide -1) (("2" (replace 3) (("2" (hide-all-but (-6 2)) (("2" (expand "orthonormal?") (("2" (flatten) (("2" (hide (-2 -3)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (split -) (("1" (inst - "aa" "bb" "dd" "dd" "ap" "bp" "dp" "dp" "h" "g") (("1" (assert) (("1" (reveal "thyp") (("1" (replace -1) (("1" (hide -1) (("1" (replace 2) (("1" (hide-all-but (-6 1)) (("1" (expand "orthonormal?") (("1" (flatten) (("1" (hide (-2 -3)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT (g*dd <=0 AND h*cc <= 0)") (("1" (split +) (("1" (inst - "aa" "bb" "dd" "dd" "ap" "bp" "dp" "dp" "h" "g") (("1" (assert) (("1" (reveal "thyp") (("1" (replace -1) (("1" (hide -1) (("1" (replace 3) (("1" (hide-all-but (-6 2)) (("1" (expand "orthonormal?") (("1" (flatten) (("1" (hide (-2 -3)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst - "aa" "bb" "cc" "cc" "ap" "bp" "cp" "cp" "h" "g") (("2" (assert) (("2" (reveal "thyp") (("2" (replace -1) (("2" (hide -1) (("2" (replace 3) (("2" (hide-all-but (-5 2)) (("2" (expand "orthonormal?") (("2" (flatten) (("2" (hide (-2 -3)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((max_circle_point_in_slice_intersection formula-decl nil circle_optimum_2D nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (orthonormal? const-decl "bool" basis_2D vectors) (* const-decl "real" vectors_2D vectors) (orthogonal? const-decl "bool" vectors_2D vectors) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (zero const-decl "Vector" vectors_2D vectors) (/= const-decl "boolean" notequal nil) (boolean nonempty-type-decl nil booleans nil) (Vector type-eq-decl nil vectors_2D vectors) (real nonempty-type-from-decl nil reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (<= const-decl "bool" reals nil)) shostak)) (dot_gt_dot_equals_slice_intersection 0 (dot_gt_dot_equals_slice_intersection-5 "" 3790107981 ("" (case "FORALL (rpt1,rpt2,rpt3:Vect2): orthonormal?(rpt1,rpt2) AND orthogonal?(rpt3,rpt2) AND norm(rpt3)=1 IMPLIES (rpt3 = rpt1 OR rpt3 = -rpt1)") (("1" (label "thislem" -1) (("1" (hide "thislem") (("1" (skeep) (("1" (name "gp" "perpR(g)") (("1" (name "rpz" "(rp*g)*g - (rp*gp)*gp") (("1" (lemma "orthonormal_basis") (("1" (inst - "g" "gp" _) (("1" (case "orthonormal?(g,gp)") (("1" (assert) (("1" (label "orthog" -2) (("1" (copy "orthog") (("1" (hide "orthog") (("1" (inst - "rp") (("1" (case "NOT (perpR(rp) = (rp*g)*gp - (rp*gp)*g AND perpR(rpz) = (rp*g)*gp+(rp*gp)*g)") (("1" (hide 2) (("1" (name "prp" "perpR(rp)") (("1" (replace -1) (("1" (replace -2 -1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (name "prpz" "perpR(rpz)") (("1" (replace -1) (("1" (replace -4 :dir rl) (("1" (replace -1 :dir rl) (("1" (hide -) (("1" (expand "gp") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (name "vv1" "IF perpR(rp)*rpz > 0 THEN perpR(rp) ELSE -perpR(rp) ENDIF") (("2" (name "vv2" "IF perpR(rpz)*rp > 0 THEN perpR(rpz) ELSE -perpR(rpz) ENDIF") (("2" (case "rp*vv1 = 0 AND rpz*vv1 > 0") (("1" (case "rpz*vv2 = 0 AND rp*vv2 > 0") (("1" (flatten) (("1" (inst + "vv1" "vv2") (("1" (case "norm(vv1) = 1 AND norm(vv2) = 1") (("1" (flatten) (("1" (assert) (("1" (case "NOT g*vv1 = g*vv2") (("1" (hide 2) (("1" (hide (-7 -8)) (("1" (label "prrp" -7) (("1" (label "prrpz" -8) (("1" (expand "vv1") (("1" (expand "vv2") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (hide-all-but (-1 -5)) (("1" (grind) nil nil)) nil) ("2" (replace "prrp" 4) (("2" (replace "prrpz" 4) (("2" (expand "orthonormal?") (("2" (flatten) (("2" (expand "orthogonal?") (("2" (case "g*gp = 0") (("1" (mult-by -1 "rp*g") (("1" (hide-all-but (-1 4)) (("1" (grind) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace "prrp" 3) (("3" (replace "prrpz" 3) (("3" (case "g*gp = 0") (("1" (mult-by -1 "rp*g") (("1" (hide-all-but (-1 3)) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "orthonormal?") (("2" (expand "orthogonal?") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-1 -3)) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -1) (("2" (skeep) (("2" (split) (("1" (flatten) (("1" (hide (-8 -9)) (("1" (split +) (("1" (expand "vv1") (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (replace -9 +) (("1" (case "(rp*g)*(ww*gp) > (rp*gp)*(ww*g)") (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (hide 2) (("2" (case "NOT perpR(rp)*rpz = -2*(rp*gp)*(rp*g)") (("1" (hide 2) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "-(rp*gp)" "rp*g" "rp*g" "-(rp*gp)" "g" "gp" "perpR(rp)" "rpz") (("1" (assert) (("1" (hide-all-but (-9 -13 1)) (("1" (replace -1) (("1" (replace -2 :dir rl) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vv2") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (case "NOT rpz*perpR(rp) = 0") (("1" (hide-all-but (-1 -4 1)) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -2) (("2" (case "NOT rp*gp < 0") (("1" (mult-by 1 "rp*g") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (case "NOT ww*gp < 0") (("1" (mult-by 1 "rp*g") (("1" (mult-by -1 "ww*g") (("1" (assert) nil nil)) nil)) nil) ("2" (case "ww*gp > rp*gp") (("1" (case "-(ww*gp) < -(rp*gp)") (("1" (mult-ineq -1 -9) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (case "sq(-(rp*gp)) > sq(-(ww*gp))") (("1" (rewrite "sq_gt") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "rp") (("2" (assert) (("2" (inst? -2) (("2" (inst - _ _ "ww") (("2" (inst - "ww*g" "ww*gp") (("2" (assert) (("2" (replace -23) (("2" (split -) (("1" (lemma "sq_gt") (("1" (inst - "ww*g" "rp*g") (("1" (assert) (("1" (rewrite "sq_neg") (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -8 2) (("2" (case "(rp*g)*(ww*gp) < (rp*gp)*(ww*g)") (("1" (hide-all-but (-1 2)) (("1" (grind) nil nil)) nil) ("2" (hide 3) (("2" (case "NOT perpR(rp)*rpz = -2*(rp*gp)*(rp*g)") (("1" (hide 2) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "-(rp*gp)" "rp*g" "rp*g" "-(rp*gp)" "g" "gp" "perpR(rp)" "rpz") (("1" (assert) (("1" (hide-all-but (-8 -12 1)) (("1" (replace -1) (("1" (replace -2 :dir rl) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vv2") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (replace -3) (("1" (case "NOT rp*gp >= 0") (("1" (mult-by 1 "rp*g") (("1" (assert) nil nil) ("2" (case "rp*g = 0") (("1" (replace -1) (("1" (assert) (("1" (case "rpz =-rp") (("1" (replace -1) (("1" (hide-all-but -11) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (case "NOT ww*gp >= 0") (("1" (mult-by 1 "rp*g") (("1" (mult-by -1 "ww*g") (("1" (assert) nil nil)) nil) ("2" (case "rp*g = 0") (("1" (replace -1) (("1" (assert) (("1" (case "rpz =-rp") (("1" (replace -1) (("1" (hide-all-but -12) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (case "rp*gp > ww*gp") (("1" (mult-ineq -1 -8) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (case "sq((rp*gp)) > sq((ww*gp))") (("1" (rewrite "sq_gt") nil nil) ("2" (hide 2) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "rp") (("2" (assert) (("2" (inst? -2) (("2" (inst - _ _ "ww") (("2" (inst - "ww*g" "ww*gp") (("2" (assert) (("2" (replace -23) (("2" (split -) (("1" (replace -22) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (lemma "sq_gt") (("1" (inst - "ww*g" "rp*g") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (hide-all-but (-6 -8)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vv2") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (replace -10 +) (("1" (case "(rp*g)*(ww*gp) > -(rp*gp)*(ww*g)") (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (hide 2) (("2" (case "NOT perpR(rpz)*rp = 2*(rp*gp)*(rp*g)") (("1" (hide 2) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "rp*gp" "rp*g" "rp*g" "rp*gp" "g" "gp" "perpR(rpz)" "rp") (("1" (assert) (("1" (hide-all-but (-10 1)) (("1" (replace -1) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vv1") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (hide-all-but (-1 -4)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -2) (("2" (case "NOT rp*gp > 0") (("1" (mult-by 1 "rp*g") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (case "NOT ww*gp < 0") (("1" (mult-by 1 "rp*g") (("1" (mult-by -1 "ww*g") (("1" (assert) nil nil)) nil)) nil) ("2" (case "-(ww*gp) < (rp*gp)") (("1" (mult-ineq -1 -8) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (case "sq((rp*gp)) > sq(-(ww*gp))") (("1" (rewrite "sq_gt") nil nil) ("2" (hide 2) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "rp") (("2" (assert) (("2" (inst? -2) (("2" (inst - _ _ "ww") (("2" (inst - "ww*g" "ww*gp") (("2" (assert) (("2" (replace -23) (("2" (split -) (("1" (replace -22) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (rewrite "sq_gt" -9 :dir rl) (("1" (assert) (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -9 +) (("2" (case "(rp*g)*(ww*gp) < -(rp*gp)*(ww*g)") (("1" (hide-all-but (-1 2)) (("1" (grind) nil nil)) nil) ("2" (hide 2) (("2" (case "NOT perpR(rpz)*rp = 2*(rp*gp)*(rp*g)") (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "rp*gp" "rp*g" "rp*g" "rp*gp" "g" "gp" "perpR(rpz)" "rp") (("1" (assert) (("1" (hide-all-but (-9 1)) (("1" (replace -1) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vv1") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (hide 2) (("1" (case "NOT perpR(rpz)*rp < 0") (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (replace -4) (("2" (case "NOT rp*gp < 0") (("1" (mult-by 1 "rp*g") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (case "NOT ww*gp > 0") (("1" (mult-by 1 "rp*g") (("1" (mult-by -1 "ww*g") (("1" (assert) nil nil)) nil)) nil) ("2" (case "-(rp*gp) > ww*gp") (("1" (mult-ineq -1 -9) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (case "sq(-(rp*gp)) > sq((ww*gp))") (("1" (rewrite "sq_gt") nil nil) ("2" (hide 2) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "rp") (("2" (assert) (("2" (inst? -2) (("2" (inst - _ _ "ww") (("2" (inst - "ww*g" "ww*gp") (("2" (assert) (("2" (replace -23) (("2" (replace -24) (("2" (split -) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (rewrite "sq_gt" -10 :dir rl) (("1" (assert) (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (hide-all-but (-6 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (case "vv1*rpz > 0 AND vv1*rp = 0 AND vv2*rp > 0 AND vv2*rpz = 0") (("1" (hide (-10 -11)) (("1" (flatten) (("1" (expand "vv1") (("1" (lift-if) (("1" (split -) (("1" (assert) (("1" (expand "vv2") (("1" (lift-if) (("1" (split -) (("1" (assert) (("1" (hide-all-but (-1 -2)) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -13 -5) (("2" (replace -14 -6) (("2" (case "NOT ((rp*g)*(ww*gp) > (rp*gp)*(ww*g) AND (rp*g)*(ww*gp) < -(rp*gp)*(ww*g))") (("1" (hide-all-but (-5 -6 1)) (("1" (grind) nil nil)) nil) ("2" (hide (-6 -7)) (("2" (flatten) (("2" (assert) (("2" (case "abs(ww*gp) >= abs(rp*gp)") (("1" (case "rp*g >= ww*g") (("1" (mult-ineq -1 -2) (("1" (hide -3) (("1" (expand "abs") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (case "ww*g >= 0") (("1" (assert) (("1" (mult-by -1 "rp*gp") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 4) (("2" (case "ww*g < 0 AND rp*gp >= 0") (("1" (hide (1 2)) (("1" (flatten) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "-(rp*gp)" "rp*g" "rp*g" "-(rp*gp)" "g" "gp" "perpR(rp)" "rpz") (("1" (assert) (("1" (split -) (("1" (case "perpR(rp)*rpz = -2* (rp*g)*(rp*gp)") (("1" (hide -2) (("1" (mult-by -3 "rp*g") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (replaces -16) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("3" (replaces -20 :dir rl) (("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "abs" + 3) (("2" (expand "abs" + 4) (("2" (hide-all-but (1 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "ww") (("2" (inst -2 "ww*g" "ww*gp") (("2" (inst - _ _ "rp") (("2" (inst - "rp*g" "rp*gp") (("2" (assert) (("2" (replace -23) (("2" (replace -24) (("2" (split -) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (rewrite "sq_gt" 3 :dir rl) (("1" (rewrite "sq_ge" 1 :dir rl) (("1" (assert) nil nil)) nil) ("2" (case "NOT -(ww*g) > rp*g") (("1" (rewrite "sq_gt" 1 :dir rl) (("1" (rewrite "sq_ge" 3 :dir rl) (("1" (assert) (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "NOT rp*gp >= 0") (("1" (mult-by 1 "-ww*g") (("1" (assert) (("1" (hide-all-but (-4 -5 1)) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 -22 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (expand "abs" + 2) (("2" (assert) (("2" (lemma "orthonormal_basis_dot") (("2" (inst - "rp*gp" "rp*g" "rp*g" "rp*gp" "g" "gp" "perpR(rpz)" "rp") (("2" (assert) (("2" (split -) (("1" (replace -1 +) (("1" (assert) (("1" (case "(rp*g)*(rp*gp) >  0") (("1" (hide-all-but (-1 3)) (("1" (assert) nil nil)) nil) ("2" (hide 4) (("2" (case "rp*g = 0") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (case "rp*gp = 0") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (lemma "posreal_times_posreal_is_posreal") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-18 1)) (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst - "g" "gp" "ww") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "vv2") (("2" (lift-if) (("2" (split -) (("1" (assert) (("1" (replace -13 -5) (("1" (replace -14 -6) (("1" (case "NOT ((rp*g)*(ww*gp) < (rp*gp)*(ww*g) AND (rp*g)*(ww*gp) > -(rp*gp)*(ww*g))") (("1" (hide-all-but (-5 -6 1)) (("1" (grind) nil nil)) nil) ("2" (hide (-6 -7)) (("2" (flatten) (("2" (assert) (("2" (lemma "orthonormal_basis_dot") (("2" (inst - "rp*g" "-(rp*gp)" "-(rp*gp)" "rp*g" "g" "gp" "rpz" "perpR(rp)") (("2" (assert) (("2" (split -) (("1" (case "(rp*g)*(rp*gp) < 0") (("1" (assert) (("1" (hide-all-but (-1 -2 1)) (("1" (grind) nil nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (assert) (("2" (case "abs(ww*gp) >= abs(rp*gp)") (("1" (case "rp*g >= ww*g") (("1" (mult-ineq -1 -2) (("1" (hide -3) (("1" (expand "abs") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (case "-(rp*gp)>0") (("1" (case "rp*g > 0") (("1" (real-props) nil nil) ("2" (case "rp*g = 0") (("1" (replace -1) (("1" (assert) (("1" (case "rpz = - rp") (("1" (replace -1) (("1" (hide-all-but -9) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (case "NOT abs(rp*g) >= abs(ww*g)") (("1" (assert) (("1" (hide 2) (("1" (expand "abs" +) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "abs" + 1) (("2" (expand "abs" + 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (case "rp*gp > 0") (("1" (case "-(ww*g) > 0") (("1" (mult-ineq -1 -2 :signs (+ +)) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (expand "abs" + 2) (("2" (assert) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - "ww*g" "ww*gp" "ww") (("2" (inst - "rp*g" "rp*gp" "rp") (("2" (assert) (("2" (split -) (("1" (replace -25) (("1" (replace -24) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (rewrite "sq_ge" 2 :dir rl) (("1" (rewrite "sq_gt" 4 :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst - "g" "gp" "ww") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT rp*gp = 0") (("1" (mult-by 2 "rp*g") (("1" (mult-by 2 "rp*g") (("1" (assert) nil nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) (("2" (case "rpz = -rp") (("1" (replace -1) (("1" (hide-all-but (-12)) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -17 1 :dir rl) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("3" (replace -13 1) (("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (hide-all-but (-1 -2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT (perpR(rpz)*rp = 0 OR perpR(rp)*rpz = 0)") (("1" (flatten) (("1" (hide-all-but (1 2 3)) (("1" (expand "vv1") (("1" (expand "vv2") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (split -1) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "rp*gp" "rp*g" "rp*g" "rp*gp" "g" "gp" "perpR(rpz)" "rp") (("1" (assert) (("1" (split -) (("1" (replace -1 -2) (("1" (case "NOT (rp*g)*(rp*gp) = 0") (("1" (assert) nil nil) ("2" (hide-all-but (-8 -9 -10 -11 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (replace -16 + :dir rl) (("2" (hide-all-but 1) (("2" (expand "gp") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 -7 -8 -9 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (iggyzip:Vect2): norm(iggyzip) = 1 IMPLIES norm(perpR(iggyzip)) = 1") (("1" (inst-cp - "rp") (("1" (inst-cp - "rpz") (("1" (assert) (("1" (case "norm(rpz) = 1") (("1" (assert) (("1" (inst-cp - "-rp") (("1" (inst - "-rpz") (("1" (rewrite "norm_neg") (("1" (rewrite "norm_neg") (("1" (rewrite "perpR_neg") (("1" (rewrite "perpR_neg") (("1" (hide 2) (("1" (replace -1) (("1" (replace -20) (("1" (replace -10 :dir rl) (("1" (replace -11 :dir rl) (("1" (lift-if +) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (2 3)) (("2" (lemma "orthonormal_basis_norm") (("2" (inst-cp - "rp*g" "rp*gp" "g" "gp" "rp") (("2" (inst - "rp*g" "-(rp*gp)" "g" "gp" "rpz") (("2" (assert) (("2" (split -1) (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-15 1)) (("2" (replace -1 :dir rl) (("2" (hide -) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "NOT rp*vv2 = 0") (("1" (hide-all-but (1 2)) (("1" (expand "vv2") (("1" (grind) nil nil)) nil)) nil) ("2" (hide 1) (("2" (case "rp*perpR(rpz) = 0") (("1" (hide (-2 -3 -4 -5)) (("1" (case "rp = rpz OR rp = -rpz") (("1" (split -) (("1" (case "rp*gp = 0") (("1" (case "rp = g OR rp = -g") (("1" (split -) (("1" (replace -1) (("1" (inst + "perpR(g)" "-perpR(g)") (("1" (assert) (("1" (case "norm(perpR(g)) = 1") (("1" (assert) (("1" (split +) (("1" (hide -) (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (ground) (("1" (case "sqv(g) = 1") (("1" (expand "sqv") (("1" (replace -1) (("1" (lemma "schwarz") (("1" (inst - "ww" "g") (("1" (expand "abs") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "sqrt_eq" 1 :dir rl) (("2" (rewrite "sqrt_sqv_norm") nil nil)) nil)) nil) ("2" (lemma "schwarz") (("2" (inst - "ww" "g") (("2" (expand "abs") (("2" (ground) (("2" (case "sqv(g) = 1") (("1" (expand "sqv") (("1" (replace -1) (("1" (ground) nil nil)) nil)) nil) ("2" (rewrite "sqrt_eq" 1 :dir rl) (("2" (rewrite "sqrt_sqv_norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -2)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-12 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide -) (("2" (flatten) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-11 1)) (("2" (typepred "sqv(g)") (("2" (lemma "sqv_eq_0") (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "g" "gp" "rp") (("2" (assert) (("2" (replace 1) (("2" (expand "orthogonal?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5 -1) (("2" (replace -7 -1 :dir rl) (("2" (case "(rp*gp)*gp = zero") (("1" (case "gp = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1 2)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (mult-by 1 "rp*gp") (("1" (grind) nil nil)) nil) ("2" (mult-by 1 "rp*gp") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "zero") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "rp*g = 0") (("1" (replace -1) (("1" (inst + "g" "g") (("1" (assert) (("1" (skeep) (("1" (hide -) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "(rp*g)*g = zero") (("1" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1 2)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (mult-by 1 "rp*g") (("1" (grind) nil nil)) nil) ("2" (mult-by 1 "rp*g") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5 -1) (("2" (replace -7 -1 :dir rl) (("2" (hide-all-but (-1 1)) (("2" (expand "zero") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "rpz" "perpR(rpz)" "rp") (("2" (assert) (("2" (replace 1) (("2" (expand "orthogonal?") (("2" (expand "orthonormal?") (("2" (case "norm(rpz) = 1") (("1" (assert) (("1" (split +) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (case "rpz = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1 2)) (("2" (flatten) (("2" (expand "zero") (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil)) nil)) nil) ("2" (hide (2 3 4)) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - "rp*g" "-(rp*gp)" "g" "gp" "rpz") (("2" (lemma "orthonormal_basis_norm") (("2" (inst - "rp*g" "rp*gp" "g" "gp" "rp") (("2" (assert) (("2" (split -) (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil) ("2" (replace -7 1 :dir rl) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "vv2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT rpz*vv1=0") (("1" (hide-all-but (1 2)) (("1" (expand "vv1") (("1" (grind) nil nil)) nil)) nil) ("2" (hide 1) (("2" (case "NOT rpz*perpR(rp) = 0") (("1" (hide-all-but (-1 1)) (("1" (expand "vv1") (("1" (grind) nil nil)) nil)) nil) ("2" (hide (-2 -3 -4)) (("2" (case "rpz = rp OR rpz = -rp") (("1" (split -) (("1" (case "rp*gp = 0") (("1" (case "rp = g OR rp = -g") (("1" (split -) (("1" (replace -1) (("1" (inst + "perpR(g)" "-perpR(g)") (("1" (assert) (("1" (case "norm(perpR(g)) = 1") (("1" (assert) (("1" (split +) (("1" (hide -) (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (case "sqv(g) = 1") (("1" (expand "sqv") (("1" (replace -1) (("1" (case "(NOT ww*g > 1) AND (NOT (ww*perpR(g) > 0 AND ww*-perpR(g) > 0))") (("1" (ground) nil nil) ("2" (hide 2) (("2" (split +) (("1" (lemma "schwarz") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "sqrt_eq" 1 :dir rl) (("2" (rewrite "sqrt_sqv_norm") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-12 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (case "g = zero") (("1" (assert) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide -) (("2" (flatten) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide -) (("2" (flatten) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (case "sqv(g) = 0") (("1" (rewrite "sqv_eq_0") nil nil) ("2" (typepred "sqv(g)") (("2" (hide-all-but (-1 -12 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "g" "gp" "rp") (("2" (assert) (("2" (expand "orthogonal?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "(rp*gp)*gp = zero") (("1" (case "gp = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1 2)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (mult-by 1 "rp*gp") (("1" (grind) nil nil)) nil) ("2" (mult-by 1 "rp*gp") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5 -1) (("2" (replace -7 -1 :dir rl) (("2" (hide-all-but (-1 1)) (("2" (expand "zero") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "rp*g = 0") (("1" (replace -1) (("1" (inst + "g" "g") (("1" (assert) (("1" (skeep) (("1" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "(rp*g)*g = zero") (("1" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1 2)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (mult-by 1 "rp*g") (("1" (grind) nil nil)) nil) ("2" (mult-by 1 "rp*g") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5 -1) (("2" (replace -7 -1 :dir rl) (("2" (hide-all-but (-1 1)) (("2" (expand "zero") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "rp" "perpR(rp)" "rpz") (("2" (assert) (("2" (expand "orthogonal?") (("2" (replace 1) (("2" (case "norm(rpz) = 1") (("1" (assert) (("1" (hide -1) (("1" (hide (2 3)) (("1" (expand "orthonormal?" 1) (("1" (split +) (("1" (hide -) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (case "rp = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide -) (("2" (expand "zero") (("2" (flatten) (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "perpR") (("4" (expand "norm") (("4" (expand "sqv") (("4" (expand "*") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (2 3 4)) (("2" (lemma "orthonormal_basis_norm") (("2" (inst-cp - "rp*g" "rp*gp" "g" "gp" "rp") (("2" (inst - "rp*g" "-(rp*gp)" "g" "gp" "rpz") (("2" (assert) (("2" (split -) (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil) ("2" (replace -7 1 :dir rl) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (expand "orthonormal?") (("2" (assert) (("2" (split +) (("1" (hide -) (("1" (expand "gp") (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide -) (("2" (flatten) (("2" (expand "gp") (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (expand "gp") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (lemma "orthonormal_basis") (("2" (inst - "rpt1" "rpt2" "rpt3") (("2" (assert) (("2" (expand "orthogonal?") (("2" (lemma "orthonormal_basis_norm") (("2" (inst?) (("2" (assert) (("2" (replace -4) (("2" (assert) (("2" (lemma "sq_abs") (("2" (inst - "rpt3*rpt1") (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (rewrite "sqrt_sq") (("2" (replace -5) (("2" (expand "abs") (("2" (lift-if) (("2" (ground) (("1" (case "rpt3*rpt1 = -1") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (replace -1 :dir rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((add_zero_right formula-decl nil vectors_2D vectors) (scal_1 formula-decl nil vectors_2D vectors) (scal_neg_1 formula-decl nil vectors_2D vectors) (minus_odd_is_odd application-judgement "odd_int" integers nil) (- const-decl "Vector" vectors_2D vectors) (* const-decl "Vector" vectors_2D vectors) (* const-decl "real" vectors_2D vectors) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (vv1 skolem-const-decl "Vect2" circle_optimum_2D nil) (zero const-decl "Vector" vectors_2D vectors) (vv2 skolem-const-decl "Vect2" circle_optimum_2D nil) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (perpR_neg formula-decl nil perpendicular_2D vectors) (sqv const-decl "nnreal" vectors_2D vectors) (norm_neg formula-decl nil vectors_2D vectors) (both_sides_times1_imp formula-decl nil extra_real_props nil) (both_sides_times_pos_gt1 formula-decl nil real_props nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (orthonormal_basis_dot formula-decl nil basis_2D vectors) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_even_is_even application-judgement "even_int" integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (lt_times_lt_any1 formula-decl nil extra_real_props nil) (sq_neg formula-decl nil sq reals) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (orthonormal_basis_norm formula-decl nil basis_2D vectors) (sq_gt formula-decl nil sq reals) (sq const-decl "nonneg_real" sq reals) (posreal nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (sqrt_eq formula-decl nil sqrt reals) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (gt_times_gt_any1 formula-decl nil extra_real_props nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (g skolem-const-decl "Vect2" circle_optimum_2D nil) (rp skolem-const-decl "Vect2" circle_optimum_2D nil) (add_zero_left formula-decl nil vectors_2D vectors) (sub_zero_left formula-decl nil vectors_2D vectors) (scal_0 formula-decl nil vectors_2D vectors) (sq_abs formula-decl nil sq reals) (sq_ge formula-decl nil sq reals) (neg_nzv application-judgement "Nz_vector" vectors_2D vectors) (ww skolem-const-decl "Nz_vect2" circle_optimum_2D nil) (posreal_times_posreal_is_posreal judgement-tcc nil real_types nil) (sqrt_sq formula-decl nil sqrt reals) (sq_0 formula-decl nil sq reals) (TRUE const-decl "bool" booleans nil) (ge_times_ge_any1 formula-decl nil extra_real_props nil) (neg_times_lt formula-decl nil real_props nil) (both_sides_times1 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (int_times_even_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (dot_zero_right formula-decl nil vectors_2D vectors) (sqv_eq_0 formula-decl nil vectors_2D vectors) (norm_zero formula-decl nil vectors_2D vectors) (scal_zero formula-decl nil vectors_2D vectors) (dot_zero_left formula-decl nil vectors_2D vectors) (neg_zero formula-decl nil vectors_2D vectors) (perpR_eq_zero formula-decl nil perpendicular_2D vectors) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (schwarz formula-decl nil vectors_2D vectors) (sqrt_sqv_norm formula-decl nil vectors_2D vectors) (sqrt_1 formula-decl nil sqrt reals) (sqrt_pos application-judgement "posreal" sqrt reals) (> const-decl "bool" reals nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (gp skolem-const-decl "Vect2" circle_optimum_2D nil) (+ const-decl "Vector" vectors_2D vectors) (NOT const-decl "[bool -> bool]" booleans nil) (orthonormal_basis formula-decl nil basis_2D vectors) (perpR const-decl "Vect2" perpendicular_2D vectors) (real nonempty-type-from-decl nil reals nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (orthonormal? const-decl "bool" basis_2D vectors) (Vector type-eq-decl nil vectors_2D vectors) (orthogonal? const-decl "bool" vectors_2D vectors) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (norm const-decl "nnreal" vectors_2D vectors) (OR const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "Vector" vectors_2D vectors)) shostak) (dot_gt_dot_equals_slice_intersection-4 nil 3529221572 ("" (case "FORALL (rpt1,rpt2,rpt3:Vect2): orthonormal?(rpt1,rpt2) AND orthogonal?(rpt3,rpt2) AND norm(rpt3)=1 IMPLIES (rpt3 = rpt1 OR rpt3 = -rpt1)") (("1" (label "thislem" -1) (("1" (hide "thislem") (("1" (skeep) (("1" (name "gp" "perpR(g)") (("1" (name "rpz" "(rp*g)*g - (rp*gp)*gp") (("1" (lemma "orthonormal_basis") (("1" (inst - "g" "gp" _) (("1" (case "orthonormal?(g,gp)") (("1" (assert) (("1" (label "orthog" -2) (("1" (copy "orthog") (("1" (hide "orthog") (("1" (inst - "rp") (("1" (case "NOT (perpR(rp) = (rp*g)*gp - (rp*gp)*g AND perpR(rpz) = (rp*g)*gp+(rp*gp)*g)") (("1" (hide 2) (("1" (name "prp" "perpR(rp)") (("1" (replace -1) (("1" (replace -2 -1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (name "prpz" "perpR(rpz)") (("1" (replace -1) (("1" (replace -4 :dir rl) (("1" (replace -1 :dir rl) (("1" (hide -) (("1" (expand "gp") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (name "vv1" "IF perpR(rp)*rpz > 0 THEN perpR(rp) ELSE -perpR(rp) ENDIF") (("2" (name "vv2" "IF perpR(rpz)*rp > 0 THEN perpR(rpz) ELSE -perpR(rpz) ENDIF") (("2" (case "rp*vv1 = 0 AND rpz*vv1 > 0") (("1" (case "rpz*vv2 = 0 AND rp*vv2 > 0") (("1" (flatten) (("1" (inst + "vv1" "vv2") (("1" (case "norm(vv1) = 1 AND norm(vv2) = 1") (("1" (flatten) (("1" (assert) (("1" (case "NOT g*vv1 = g*vv2") (("1" (hide 2) (("1" (hide (-7 -8)) (("1" (label "prrp" -7) (("1" (label "prrpz" -8) (("1" (expand "vv1") (("1" (expand "vv2") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (hide-all-but (-1 -5)) (("1" (grind) nil nil)) nil) ("2" (replace "prrp" 4) (("2" (replace "prrpz" 4) (("2" (expand "orthonormal?") (("2" (flatten) (("2" (expand "orthogonal?") (("2" (case "g*gp = 0") (("1" (mult-by -1 "rp*g") (("1" (hide-all-but (-1 4)) (("1" (grind) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace "prrp" 3) (("3" (replace "prrpz" 3) (("3" (case "g*gp = 0") (("1" (mult-by -1 "rp*g") (("1" (hide-all-but (-1 3)) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "orthonormal?") (("2" (expand "orthogonal?") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-1 -3)) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -1) (("2" (skeep) (("2" (split) (("1" (flatten) (("1" (hide (-8 -9)) (("1" (split +) (("1" (expand "vv1") (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (replace -9 +) (("1" (case "(rp*g)*(ww*gp) > (rp*gp)*(ww*g)") (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (hide 2) (("2" (case "NOT perpR(rp)*rpz = -2*(rp*gp)*(rp*g)") (("1" (hide 2) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "-(rp*gp)" "rp*g" "rp*g" "-(rp*gp)" "g" "gp" "perpR(rp)" "rpz") (("1" (assert) (("1" (hide-all-but (-9 -13 1)) (("1" (replace -1) (("1" (replace -2 :dir rl) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vv2") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (case "NOT rpz*perpR(rp) = 0") (("1" (hide-all-but (-1 -4 1)) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -2) (("2" (case "NOT rp*gp < 0") (("1" (mult-by 1 "rp*g") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (case "NOT ww*gp < 0") (("1" (mult-by 1 "rp*g") (("1" (mult-by -1 "ww*g") (("1" (assert) nil nil)) nil)) nil) ("2" (case "ww*gp > rp*gp") (("1" (case "-(ww*gp) < -(rp*gp)") (("1" (mult-ineq -1 -9) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (case "sq(-(rp*gp)) > sq(-(ww*gp))") (("1" (rewrite "sq_gt") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "rp") (("2" (assert) (("2" (inst? -2) (("2" (inst - _ _ "ww") (("2" (inst - "ww*g" "ww*gp") (("2" (assert) (("2" (replace -23) (("2" (split -) (("1" (lemma "sq_gt") (("1" (inst - "ww*g" "rp*g") (("1" (assert) (("1" (rewrite "sq_neg") (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -8 2) (("2" (case "(rp*g)*(ww*gp) < (rp*gp)*(ww*g)") (("1" (hide-all-but (-1 2)) (("1" (grind) nil nil)) nil) ("2" (hide 3) (("2" (case "NOT perpR(rp)*rpz = -2*(rp*gp)*(rp*g)") (("1" (hide 2) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "-(rp*gp)" "rp*g" "rp*g" "-(rp*gp)" "g" "gp" "perpR(rp)" "rpz") (("1" (assert) (("1" (hide-all-but (-8 -12 1)) (("1" (replace -1) (("1" (replace -2 :dir rl) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vv2") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (replace -3) (("1" (case "NOT rp*gp >= 0") (("1" (mult-by 1 "rp*g") (("1" (assert) nil nil) ("2" (case "rp*g = 0") (("1" (replace -1) (("1" (assert) (("1" (case "rpz =-rp") (("1" (replace -1) (("1" (hide-all-but -11) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (case "NOT ww*gp >= 0") (("1" (mult-by 1 "rp*g") (("1" (mult-by -1 "ww*g") (("1" (assert) nil nil)) nil) ("2" (case "rp*g = 0") (("1" (replace -1) (("1" (assert) (("1" (case "rpz =-rp") (("1" (replace -1) (("1" (hide-all-but -12) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (case "rp*gp > ww*gp") (("1" (mult-ineq -1 -8) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (case "sq((rp*gp)) > sq((ww*gp))") (("1" (rewrite "sq_gt") nil nil) ("2" (hide 2) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "rp") (("2" (assert) (("2" (inst? -2) (("2" (inst - _ _ "ww") (("2" (inst - "ww*g" "ww*gp") (("2" (assert) (("2" (replace -23) (("2" (split -) (("1" (replace -22) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (lemma "sq_gt") (("1" (inst - "ww*g" "rp*g") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (hide-all-but (-6 -8)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vv2") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (replace -10 +) (("1" (case "(rp*g)*(ww*gp) > -(rp*gp)*(ww*g)") (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (hide 2) (("2" (case "NOT perpR(rpz)*rp = 2*(rp*gp)*(rp*g)") (("1" (hide 2) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "rp*gp" "rp*g" "rp*g" "rp*gp" "g" "gp" "perpR(rpz)" "rp") (("1" (assert) (("1" (hide-all-but (-10 1)) (("1" (replace -1) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vv1") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (hide-all-but (-1 -4)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -2) (("2" (case "NOT rp*gp > 0") (("1" (mult-by 1 "rp*g") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (case "NOT ww*gp < 0") (("1" (mult-by 1 "rp*g") (("1" (mult-by -1 "ww*g") (("1" (assert) nil nil)) nil)) nil) ("2" (case "-(ww*gp) < (rp*gp)") (("1" (mult-ineq -1 -8) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (case "sq((rp*gp)) > sq(-(ww*gp))") (("1" (rewrite "sq_gt") nil nil) ("2" (hide 2) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "rp") (("2" (assert) (("2" (inst? -2) (("2" (inst - _ _ "ww") (("2" (inst - "ww*g" "ww*gp") (("2" (assert) (("2" (replace -23) (("2" (split -) (("1" (replace -22) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (rewrite "sq_gt" -9 :dir rl) (("1" (assert) (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -9 +) (("2" (case "(rp*g)*(ww*gp) < -(rp*gp)*(ww*g)") (("1" (hide-all-but (-1 2)) (("1" (grind) nil nil)) nil) ("2" (hide 2) (("2" (case "NOT perpR(rpz)*rp = 2*(rp*gp)*(rp*g)") (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "rp*gp" "rp*g" "rp*g" "rp*gp" "g" "gp" "perpR(rpz)" "rp") (("1" (assert) (("1" (hide-all-but (-9 1)) (("1" (replace -1) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vv1") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (hide 2) (("1" (case "NOT perpR(rpz)*rp < 0") (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (replace -4) (("2" (case "NOT rp*gp < 0") (("1" (mult-by 1 "rp*g") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (case "NOT ww*gp > 0") (("1" (mult-by 1 "rp*g") (("1" (mult-by -1 "ww*g") (("1" (assert) nil nil)) nil)) nil) ("2" (case "-(rp*gp) > ww*gp") (("1" (mult-ineq -1 -9) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (case "sq(-(rp*gp)) > sq((ww*gp))") (("1" (rewrite "sq_gt") nil nil) ("2" (hide 2) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "rp") (("2" (assert) (("2" (inst? -2) (("2" (inst - _ _ "ww") (("2" (inst - "ww*g" "ww*gp") (("2" (assert) (("2" (replace -23) (("2" (replace -24) (("2" (split -) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (rewrite "sq_gt" -10 :dir rl) (("1" (assert) (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (hide-all-but (-6 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (case "vv1*rpz > 0 AND vv1*rp = 0 AND vv2*rp > 0 AND vv2*rpz = 0") (("1" (hide (-10 -11)) (("1" (flatten) (("1" (expand "vv1") (("1" (lift-if) (("1" (split -) (("1" (assert) (("1" (expand "vv2") (("1" (lift-if) (("1" (split -) (("1" (assert) (("1" (hide-all-but (-1 -2)) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -13 -5) (("2" (replace -14 -6) (("2" (case "NOT ((rp*g)*(ww*gp) > (rp*gp)*(ww*g) AND (rp*g)*(ww*gp) < -(rp*gp)*(ww*g))") (("1" (hide-all-but (-5 -6 1)) (("1" (grind) nil nil)) nil) ("2" (hide (-6 -7)) (("2" (flatten) (("2" (assert) (("2" (case "abs(ww*gp) >= abs(rp*gp)") (("1" (case "rp*g >= ww*g") (("1" (mult-ineq -1 -2) (("1" (hide -3) (("1" (expand "abs") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (case "ww*g >= 0") (("1" (assert) (("1" (mult-by -1 "rp*gp") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 4) (("2" (case "ww*g < 0 AND rp*gp >= 0") (("1" (hide (1 2)) (("1" (flatten) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "-(rp*gp)" "rp*g" "rp*g" "-(rp*gp)" "g" "gp" "perpR(rp)" "rpz") (("1" (assert) (("1" (split -) (("1" (case "perpR(rp)*rpz = -2* (rp*g)*(rp*gp)") (("1" (hide -2) (("1" (mult-by -3 "rp*g") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (replaces -16) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("3" (replaces -20 :dir rl) (("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "abs" + 3) (("2" (expand "abs" + 4) (("2" (hide-all-but (1 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "ww") (("2" (inst -2 "ww*g" "ww*gp") (("2" (inst - _ _ "rp") (("2" (inst - "rp*g" "rp*gp") (("2" (assert) (("2" (replace -23) (("2" (replace -24) (("2" (split -) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (rewrite "sq_gt" 3 :dir rl) (("1" (rewrite "sq_ge" 1 :dir rl) (("1" (assert) nil nil)) nil) ("2" (case "NOT -(ww*g) > rp*g") (("1" (rewrite "sq_gt" 1 :dir rl) (("1" (rewrite "sq_ge" 3 :dir rl) (("1" (assert) (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "NOT rp*gp >= 0") (("1" (mult-by 1 "-ww*g") (("1" (assert) (("1" (hide-all-but (-4 -5 1)) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 -22 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (expand "abs" + 2) (("2" (assert) (("2" (lemma "orthonormal_basis_dot") (("2" (inst - "rp*gp" "rp*g" "rp*g" "rp*gp" "g" "gp" "perpR(rpz)" "rp") (("2" (assert) (("2" (split -) (("1" (replace -1 +) (("1" (assert) (("1" (case "(rp*g)*(rp*gp) >  0") (("1" (hide-all-but (-1 3)) (("1" (assert) nil nil)) nil) ("2" (hide 4) (("2" (case "rp*g = 0") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (case "rp*gp = 0") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (lemma "posreal_times_posreal_is_posreal") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-18 1)) (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst - "g" "gp" "ww") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "vv2") (("2" (lift-if) (("2" (split -) (("1" (assert) (("1" (replace -13 -5) (("1" (replace -14 -6) (("1" (case "NOT ((rp*g)*(ww*gp) < (rp*gp)*(ww*g) AND (rp*g)*(ww*gp) > -(rp*gp)*(ww*g))") (("1" (hide-all-but (-5 -6 1)) (("1" (grind) nil nil)) nil) ("2" (hide (-6 -7)) (("2" (flatten) (("2" (assert) (("2" (lemma "orthonormal_basis_dot") (("2" (inst - "rp*g" "-(rp*gp)" "-(rp*gp)" "rp*g" "g" "gp" "rpz" "perpR(rp)") (("2" (assert) (("2" (split -) (("1" (case "(rp*g)*(rp*gp) < 0") (("1" (assert) (("1" (hide-all-but (-1 -2 1)) (("1" (grind) nil nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (assert) (("2" (case "abs(ww*gp) >= abs(rp*gp)") (("1" (case "rp*g >= ww*g") (("1" (mult-ineq -1 -2) (("1" (hide -3) (("1" (expand "abs") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (case "-(rp*gp)>0") (("1" (case "rp*g > 0") (("1" (real-props) nil nil) ("2" (case "rp*g = 0") (("1" (replace -1) (("1" (assert) (("1" (case "rpz = - rp") (("1" (replace -1) (("1" (hide-all-but -9) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (case "NOT abs(rp*g) >= abs(ww*g)") (("1" (assert) (("1" (hide 2) (("1" (expand "abs" +) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "abs" + 1) (("2" (expand "abs" + 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (case "rp*gp > 0") (("1" (case "-(ww*g) > 0") (("1" (mult-ineq -1 -2 :signs (+ +)) (("1" (assert) nil nil) ("2" (real-props) nil nil)) nil) ("2" (assert) (("2" (expand "abs" + 2) (("2" (assert) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - "ww*g" "ww*gp" "ww") (("2" (inst - "rp*g" "rp*gp" "rp") (("2" (assert) (("2" (split -) (("1" (replace -25) (("1" (replace -24) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (rewrite "sq_ge" 2 :dir rl) (("1" (rewrite "sq_gt" 4 :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst - "g" "gp" "ww") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT rp*gp = 0") (("1" (mult-by 2 "rp*g") (("1" (mult-by 2 "rp*g") (("1" (assert) nil nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) (("2" (case "rpz = -rp") (("1" (replace -1) (("1" (hide-all-but (-12)) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -17 1 :dir rl) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("3" (replace -13 1) (("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (hide-all-but (-1 -2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT (perpR(rpz)*rp = 0 OR perpR(rp)*rpz = 0)") (("1" (flatten) (("1" (hide-all-but (1 2 3)) (("1" (expand "vv1") (("1" (expand "vv2") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (split -1) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "rp*gp" "rp*g" "rp*g" "rp*gp" "g" "gp" "perpR(rpz)" "rp") (("1" (assert) (("1" (split -) (("1" (replace -1 -2) (("1" (case "NOT (rp*g)*(rp*gp) = 0") (("1" (assert) nil nil) ("2" (hide-all-but (-8 -9 -10 -11 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (replace -16 + :dir rl) (("2" (hide-all-but 1) (("2" (expand "gp") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 -7 -8 -9 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (iggyzip:Vect2): norm(iggyzip) = 1 IMPLIES norm(perpR(iggyzip)) = 1") (("1" (inst-cp - "rp") (("1" (inst-cp - "rpz") (("1" (assert) (("1" (case "norm(rpz) = 1") (("1" (assert) (("1" (inst-cp - "-rp") (("1" (inst - "-rpz") (("1" (rewrite "norm_neg") (("1" (rewrite "norm_neg") (("1" (rewrite "perpR_neg") (("1" (rewrite "perpR_neg") (("1" (hide 2) (("1" (replace -1) (("1" (replace -20) (("1" (replace -10 :dir rl) (("1" (replace -11 :dir rl) (("1" (lift-if +) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (2 3)) (("2" (lemma "orthonormal_basis_norm") (("2" (inst-cp - "rp*g" "rp*gp" "g" "gp" "rp") (("2" (inst - "rp*g" "-(rp*gp)" "g" "gp" "rpz") (("2" (assert) (("2" (split -1) (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-15 1)) (("2" (replace -1 :dir rl) (("2" (hide -) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "NOT rp*vv2 = 0") (("1" (hide-all-but (1 2)) (("1" (expand "vv2") (("1" (grind) nil nil)) nil)) nil) ("2" (hide 1) (("2" (case "rp*perpR(rpz) = 0") (("1" (hide (-2 -3 -4 -5)) (("1" (case "rp = rpz OR rp = -rpz") (("1" (split -) (("1" (case "rp*gp = 0") (("1" (case "rp = g OR rp = -g") (("1" (split -) (("1" (replace -1) (("1" (inst + "perpR(g)" "-perpR(g)") (("1" (assert) (("1" (case "norm(perpR(g)) = 1") (("1" (assert) (("1" (split +) (("1" (hide -) (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (ground) (("1" (case "sqv(g) = 1") (("1" (expand "sqv") (("1" (replace -1) (("1" (lemma "schwarz") (("1" (inst - "ww" "g") (("1" (expand "abs") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "sqrt_eq" 1 :dir rl) (("2" (rewrite "sqrt_sqv_norm") nil nil)) nil)) nil) ("2" (lemma "schwarz") (("2" (inst - "ww" "g") (("2" (expand "abs") (("2" (ground) (("2" (case "sqv(g) = 1") (("1" (expand "sqv") (("1" (replace -1) (("1" (ground) nil nil)) nil)) nil) ("2" (rewrite "sqrt_eq" 1 :dir rl) (("2" (rewrite "sqrt_sqv_norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -2)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-12 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide -) (("2" (flatten) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-11 1)) (("2" (typepred "sqv(g)") (("2" (lemma "sqv_eq_0") (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "g" "gp" "rp") (("2" (assert) (("2" (replace 1) (("2" (expand "orthogonal?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5 -1) (("2" (replace -7 -1 :dir rl) (("2" (case "(rp*gp)*gp = zero") (("1" (case "gp = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1 2)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (mult-by 1 "rp*gp") (("1" (grind) nil nil)) nil) ("2" (mult-by 1 "rp*gp") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "zero") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "rp*g = 0") (("1" (replace -1) (("1" (inst + "g" "g") (("1" (assert) (("1" (skeep) (("1" (hide -) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "(rp*g)*g = zero") (("1" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1 2)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (mult-by 1 "rp*g") (("1" (grind) nil nil)) nil) ("2" (mult-by 1 "rp*g") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5 -1) (("2" (replace -7 -1 :dir rl) (("2" (hide-all-but (-1 1)) (("2" (expand "zero") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "rpz" "perpR(rpz)" "rp") (("2" (assert) (("2" (replace 1) (("2" (expand "orthogonal?") (("2" (expand "orthonormal?") (("2" (case "norm(rpz) = 1") (("1" (assert) (("1" (split +) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (case "rpz = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1 2)) (("2" (flatten) (("2" (expand "zero") (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil)) nil)) nil) ("2" (hide (2 3 4)) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - "rp*g" "-(rp*gp)" "g" "gp" "rpz") (("2" (lemma "orthonormal_basis_norm") (("2" (inst - "rp*g" "rp*gp" "g" "gp" "rp") (("2" (assert) (("2" (split -) (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil) ("2" (replace -7 1 :dir rl) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "vv2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT rpz*vv1=0") (("1" (hide-all-but (1 2)) (("1" (expand "vv1") (("1" (grind) nil nil)) nil)) nil) ("2" (hide 1) (("2" (case "NOT rpz*perpR(rp) = 0") (("1" (hide-all-but (-1 1)) (("1" (expand "vv1") (("1" (grind) nil nil)) nil)) nil) ("2" (hide (-2 -3 -4)) (("2" (case "rpz = rp OR rpz = -rp") (("1" (split -) (("1" (case "rp*gp = 0") (("1" (case "rp = g OR rp = -g") (("1" (split -) (("1" (replace -1) (("1" (inst + "perpR(g)" "-perpR(g)") (("1" (assert) (("1" (case "norm(perpR(g)) = 1") (("1" (assert) (("1" (split +) (("1" (hide -) (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (case "sqv(g) = 1") (("1" (expand "sqv") (("1" (replace -1) (("1" (case "(NOT ww*g > 1) AND (NOT (ww*perpR(g) > 0 AND ww*-perpR(g) > 0))") (("1" (ground) nil nil) ("2" (hide 2) (("2" (split +) (("1" (lemma "schwarz") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "sqrt_eq" 1 :dir rl) (("2" (rewrite "sqrt_sqv_norm") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-12 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (case "g = zero") (("1" (assert) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide -) (("2" (flatten) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide -) (("2" (flatten) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (case "sqv(g) = 0") (("1" (rewrite "sqv_eq_0") nil nil) ("2" (typepred "sqv(g)") (("2" (hide-all-but (-1 -12 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "g" "gp" "rp") (("2" (assert) (("2" (expand "orthogonal?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "(rp*gp)*gp = zero") (("1" (case "gp = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1 2)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (mult-by 1 "rp*gp") (("1" (grind) nil nil)) nil) ("2" (mult-by 1 "rp*gp") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5 -1) (("2" (replace -7 -1 :dir rl) (("2" (hide-all-but (-1 1)) (("2" (expand "zero") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "rp*g = 0") (("1" (replace -1) (("1" (inst + "g" "g") (("1" (assert) (("1" (skeep) (("1" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "(rp*g)*g = zero") (("1" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1 2)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (mult-by 1 "rp*g") (("1" (grind) nil nil)) nil) ("2" (mult-by 1 "rp*g") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5 -1) (("2" (replace -7 -1 :dir rl) (("2" (hide-all-but (-1 1)) (("2" (expand "zero") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "rp" "perpR(rp)" "rpz") (("2" (assert) (("2" (expand "orthogonal?") (("2" (replace 1) (("2" (case "norm(rpz) = 1") (("1" (assert) (("1" (hide -1) (("1" (hide (2 3)) (("1" (expand "orthonormal?" 1) (("1" (split +) (("1" (hide -) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (case "rp = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide -) (("2" (expand "zero") (("2" (flatten) (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "perpR") (("4" (expand "norm") (("4" (expand "sqv") (("4" (expand "*") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (2 3 4)) (("2" (lemma "orthonormal_basis_norm") (("2" (inst-cp - "rp*g" "rp*gp" "g" "gp" "rp") (("2" (inst - "rp*g" "-(rp*gp)" "g" "gp" "rpz") (("2" (assert) (("2" (split -) (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil) ("2" (replace -7 1 :dir rl) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (expand "orthonormal?") (("2" (assert) (("2" (split +) (("1" (hide -) (("1" (expand "gp") (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide -) (("2" (flatten) (("2" (expand "gp") (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (expand "gp") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (lemma "orthonormal_basis") (("2" (inst - "rpt1" "rpt2" "rpt3") (("2" (assert) (("2" (expand "orthogonal?") (("2" (lemma "orthonormal_basis_norm") (("2" (inst?) (("2" (assert) (("2" (replace -4) (("2" (assert) (("2" (lemma "sq_abs") (("2" (inst - "rpt3*rpt1") (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (rewrite "sqrt_sq") (("2" (replace -5) (("2" (expand "abs") (("2" (lift-if) (("2" (ground) (("1" (case "rpt3*rpt1 = -1") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (replace -1 :dir rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((add_zero_right formula-decl nil vectors_2D vectors) (scal_1 formula-decl nil vectors_2D vectors) (scal_neg_1 formula-decl nil vectors_2D vectors) (minus_odd_is_odd application-judgement "odd_int" integers nil) nil (* const-decl "Vector" vectors_2D vectors) (* const-decl "real" vectors_2D vectors) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) nil (zero const-decl "Vector" vectors_2D vectors) nil (Nz_vect2 type-eq-decl nil vectors_2D vectors) (perpR_neg formula-decl nil perpendicular_2D vectors) (sqv const-decl "nnreal" vectors_2D vectors) (norm_neg formula-decl nil vectors_2D vectors) (both_sides_times1_imp formula-decl nil extra_real_props nil) (both_sides_times_pos_gt1 formula-decl nil real_props nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (orthonormal_basis_dot formula-decl nil basis_2D vectors) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_even_is_even application-judgement "even_int" integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (lt_times_lt_any1 formula-decl nil extra_real_props nil) (sq_neg formula-decl nil sq reals) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (orthonormal_basis_norm formula-decl nil basis_2D vectors) (sq_gt formula-decl nil sq reals) (sq const-decl "nonneg_real" sq reals) (posreal nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (sqrt_eq formula-decl nil sqrt reals) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (gt_times_gt_any1 formula-decl nil extra_real_props nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) nil nil (add_zero_left formula-decl nil vectors_2D vectors) (sub_zero_left formula-decl nil vectors_2D vectors) (scal_0 formula-decl nil vectors_2D vectors) (sq_abs formula-decl nil sq reals) (sq_ge formula-decl nil sq reals) (neg_nzv application-judgement "Nz_vector" vectors_2D vectors) nil (posreal_times_posreal_is_posreal judgement-tcc nil real_types nil) (sqrt_sq formula-decl nil sqrt reals) (sq_0 formula-decl nil sq reals) (TRUE const-decl "bool" booleans nil) (ge_times_ge_any1 formula-decl nil extra_real_props nil) (neg_times_lt formula-decl nil real_props nil) (both_sides_times1 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (int_times_even_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (dot_zero_right formula-decl nil vectors_2D vectors) (sqv_eq_0 formula-decl nil vectors_2D vectors) (norm_zero formula-decl nil vectors_2D vectors) (scal_zero formula-decl nil vectors_2D vectors) (dot_zero_left formula-decl nil vectors_2D vectors) (neg_zero formula-decl nil vectors_2D vectors) (perpR_eq_zero formula-decl nil perpendicular_2D vectors) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (schwarz formula-decl nil vectors_2D vectors) (sqrt_sqv_norm formula-decl nil vectors_2D vectors) (sqrt_1 formula-decl nil sqrt reals) (sqrt_pos application-judgement "posreal" sqrt reals) (> const-decl "bool" reals nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) nil (+ const-decl "Vector" vectors_2D vectors) (NOT const-decl "[bool -> bool]" booleans nil) (orthonormal_basis formula-decl nil basis_2D vectors) (perpR const-decl "Vect2" perpendicular_2D vectors) (real nonempty-type-from-decl nil reals nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (orthonormal? const-decl "bool" basis_2D vectors) (Vector type-eq-decl nil vectors_2D vectors) (orthogonal? const-decl "bool" vectors_2D vectors) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (norm const-decl "nnreal" vectors_2D vectors) (OR const-decl "[bool, bool -> bool]" booleans nil) nil) nil) (dot_gt_dot_equals_slice_intersection-3 nil 3529219837 ("" (case "FORALL (rpt1,rpt2,rpt3:Vect2): orthonormal?(rpt1,rpt2) AND orthogonal?(rpt3,rpt2) IMPLIES (rpt3 = rpt1 OR rpt3 = -rpt1)") (("1" (label "thislem" -1) (("1" (hide "thislem") (("1" (skeep) (("1" (name "gp" "perpR(g)") (("1" (name "rpz" "(rp*g)*g - (rp*gp)*gp") (("1" (lemma "orthonormal_basis") (("1" (inst - "g" "gp" _) (("1" (case "orthonormal?(g,gp)") (("1" (assert) (("1" (label "orthog" -2) (("1" (copy "orthog") (("1" (hide "orthog") (("1" (inst - "rp") (("1" (case "NOT (perpR(rp) = (rp*g)*gp - (rp*gp)*g AND perpR(rpz) = (rp*g)*gp+(rp*gp)*g)") (("1" (hide 2) (("1" (name "prp" "perpR(rp)") (("1" (replace -1) (("1" (replace -2 -1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (name "prpz" "perpR(rpz)") (("1" (replace -1) (("1" (replace -4 :dir rl) (("1" (replace -1 :dir rl) (("1" (hide -) (("1" (expand "gp") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (name "vv1" "IF perpR(rp)*rpz > 0 THEN perpR(rp) ELSE -perpR(rp) ENDIF") (("2" (name "vv2" "IF perpR(rpz)*rp > 0 THEN perpR(rpz) ELSE -perpR(rpz) ENDIF") (("2" (case "rp*vv1 = 0 AND rpz*vv1 > 0") (("1" (case "rpz*vv2 = 0 AND rp*vv2 > 0") (("1" (flatten) (("1" (inst + "vv1" "vv2") (("1" (case "norm(vv1) = 1 AND norm(vv2) = 1") (("1" (flatten) (("1" (assert) (("1" (skeep) (("1" (split) (("1" (flatten) (("1" (hide (-8 -9)) (("1" (split +) (("1" (expand "vv1") (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (replace -9 +) (("1" (case "(rp*g)*(ww*gp) > (rp*gp)*(ww*g)") (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (hide 2) (("2" (case "NOT perpR(rp)*rpz = -2*(rp*gp)*(rp*g)") (("1" (hide 2) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "-(rp*gp)" "rp*g" "rp*g" "-(rp*gp)" "g" "gp" "perpR(rp)" "rpz") (("1" (assert) (("1" (hide-all-but (-9 -13 1)) (("1" (replace -1) (("1" (replace -2 :dir rl) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vv2") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (case "NOT rpz*perpR(rp) = 0") (("1" (hide-all-but (-1 -4 1)) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -2) (("2" (case "NOT rp*gp < 0") (("1" (mult-by 1 "rp*g") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (case "NOT ww*gp < 0") (("1" (mult-by 1 "rp*g") (("1" (mult-by -1 "ww*g") (("1" (assert) nil nil)) nil)) nil) ("2" (case "ww*gp > rp*gp") (("1" (case "-(ww*gp) < -(rp*gp)") (("1" (mult-ineq -1 -9) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (case "sq(-(rp*gp)) > sq(-(ww*gp))") (("1" (rewrite "sq_gt") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "rp") (("2" (assert) (("2" (inst? -2) (("2" (inst - _ _ "ww") (("2" (inst - "ww*g" "ww*gp") (("2" (assert) (("2" (assert) (("2" (replace -23) (("2" (split -) (("1" (lemma "sq_gt") (("1" (inst - "ww*g" "rp*g") (("1" (assert) (("1" (rewrite "sq_neg") (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -8 2) (("2" (case "(rp*g)*(ww*gp) < (rp*gp)*(ww*g)") (("1" (hide-all-but (-1 2)) (("1" (grind) nil nil)) nil) ("2" (hide 3) (("2" (case "NOT perpR(rp)*rpz = -2*(rp*gp)*(rp*g)") (("1" (hide 2) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "-(rp*gp)" "rp*g" "rp*g" "-(rp*gp)" "g" "gp" "perpR(rp)" "rpz") (("1" (assert) (("1" (assert) (("1" (hide-all-but (-8 -12 1)) (("1" (replace -1) (("1" (replace -2 :dir rl) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vv2") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (assert) (("1" (replace -3) (("1" (case "NOT rp*gp >= 0") (("1" (mult-by 1 "rp*g") (("1" (assert) nil nil) ("2" (case "rp*g = 0") (("1" (replace -1) (("1" (assert) (("1" (case "rpz =-rp") (("1" (replace -1) (("1" (hide-all-but -11) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (case "NOT ww*gp >= 0") (("1" (mult-by 1 "rp*g") (("1" (mult-by -1 "ww*g") (("1" (assert) nil nil)) nil) ("2" (case "rp*g = 0") (("1" (replace -1) (("1" (assert) (("1" (case "rpz =-rp") (("1" (replace -1) (("1" (hide-all-but -12) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (case "rp*gp > ww*gp") (("1" (mult-ineq -1 -8) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (case "sq((rp*gp)) > sq((ww*gp))") (("1" (rewrite "sq_gt") nil nil) ("2" (hide 2) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "rp") (("2" (assert) (("2" (inst? -2) (("2" (inst - _ _ "ww") (("2" (inst - "ww*g" "ww*gp") (("2" (assert) (("2" (assert) (("2" (replace -23) (("2" (split -) (("1" (replace -22) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (lemma "sq_gt") (("1" (inst - "ww*g" "rp*g") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (hide-all-but (-6 -8)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vv2") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (replace -10 +) (("1" (case "(rp*g)*(ww*gp) > -(rp*gp)*(ww*g)") (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (hide 2) (("2" (case "NOT perpR(rpz)*rp = 2*(rp*gp)*(rp*g)") (("1" (hide 2) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "rp*gp" "rp*g" "rp*g" "rp*gp" "g" "gp" "perpR(rpz)" "rp") (("1" (assert) (("1" (hide-all-but (-10 1)) (("1" (replace -1) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vv1") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (hide-all-but (-1 -4)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -2) (("2" (case "NOT rp*gp > 0") (("1" (mult-by 1 "rp*g") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (case "NOT ww*gp < 0") (("1" (mult-by 1 "rp*g") (("1" (mult-by -1 "ww*g") (("1" (assert) nil nil)) nil)) nil) ("2" (case "-(ww*gp) < (rp*gp)") (("1" (mult-ineq -1 -8) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (case "sq((rp*gp)) > sq(-(ww*gp))") (("1" (rewrite "sq_gt") nil nil) ("2" (hide 2) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "rp") (("2" (assert) (("2" (inst? -2) (("2" (inst - _ _ "ww") (("2" (inst - "ww*g" "ww*gp") (("2" (assert) (("2" (assert) (("2" (replace -23) (("2" (split -) (("1" (replace -22) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (rewrite "sq_gt" -9 :dir rl) (("1" (assert) (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -9 +) (("2" (case "(rp*g)*(ww*gp) < -(rp*gp)*(ww*g)") (("1" (hide-all-but (-1 2)) (("1" (grind) nil nil)) nil) ("2" (hide 2) (("2" (case "NOT perpR(rpz)*rp = 2*(rp*gp)*(rp*g)") (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "rp*gp" "rp*g" "rp*g" "rp*gp" "g" "gp" "perpR(rpz)" "rp") (("1" (assert) (("1" (hide-all-but (-9 1)) (("1" (replace -1) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vv1") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (hide 2) (("1" (case "NOT perpR(rpz)*rp < 0") (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (replace -4) (("2" (case "NOT rp*gp < 0") (("1" (mult-by 1 "rp*g") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (case "NOT ww*gp > 0") (("1" (mult-by 1 "rp*g") (("1" (mult-by -1 "ww*g") (("1" (assert) nil nil)) nil)) nil) ("2" (case "-(rp*gp) > ww*gp") (("1" (mult-ineq -1 -9) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (case "sq(-(rp*gp)) > sq((ww*gp))") (("1" (rewrite "sq_gt") nil nil) ("2" (hide 2) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "rp") (("2" (assert) (("2" (inst? -2) (("2" (inst - _ _ "ww") (("2" (inst - "ww*g" "ww*gp") (("2" (assert) (("2" (assert) (("2" (replace -23) (("2" (replace -24) (("2" (split -) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (rewrite "sq_gt" -10 :dir rl) (("1" (assert) (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (hide-all-but (-6 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (case "vv1*rpz > 0 AND vv1*rp = 0 AND vv2*rp > 0 AND vv2*rpz = 0") (("1" (hide (-10 -11)) (("1" (flatten) (("1" (expand "vv1") (("1" (lift-if) (("1" (split -) (("1" (assert) (("1" (expand "vv2") (("1" (lift-if) (("1" (split -) (("1" (assert) (("1" (hide-all-but (-1 -2)) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -13 -5) (("2" (replace -14 -6) (("2" (assert) (("2" (case "NOT ((rp*g)*(ww*gp) > (rp*gp)*(ww*g) AND (rp*g)*(ww*gp) < -(rp*gp)*(ww*g))") (("1" (hide-all-but (-5 -6 1)) (("1" (grind) nil nil)) nil) ("2" (hide (-6 -7)) (("2" (flatten) (("2" (assert) (("2" (case "abs(ww*gp) >= abs(rp*gp)") (("1" (case "rp*g >= ww*g") (("1" (mult-ineq -1 -2) (("1" (hide -3) (("1" (expand "abs") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (case "ww*g >= 0") (("1" (assert) (("1" (mult-by -1 "rp*gp") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 4) (("2" (case "ww*g < 0 AND rp*gp >= 0") (("1" (hide (1 2)) (("1" (flatten) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "-(rp*gp)" "rp*g" "rp*g" "-(rp*gp)" "g" "gp" "perpR(rp)" "rpz") (("1" (assert) (("1" (split -) (("1" (case "perpR(rp)*rpz = -2* (rp*g)*(rp*gp)") (("1" (hide -2) (("1" (mult-by -3 "rp*g") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (replaces -16) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("3" (replaces -20 :dir rl) (("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "abs" + 3) (("2" (expand "abs" + 4) (("2" (hide-all-but (1 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "ww") (("2" (inst -2 "ww*g" "ww*gp") (("2" (inst - _ _ "rp") (("2" (inst - "rp*g" "rp*gp") (("2" (assert) (("2" (replace -23) (("2" (replace -24) (("2" (assert) (("2" (split -) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (rewrite "sq_gt" 3 :dir rl) (("1" (rewrite "sq_ge" 1 :dir rl) (("1" (assert) nil nil)) nil) ("2" (case "NOT -(ww*g) > rp*g") (("1" (rewrite "sq_gt" 1 :dir rl) (("1" (rewrite "sq_ge" 3 :dir rl) (("1" (assert) (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "NOT rp*gp >= 0") (("1" (mult-by 1 "-ww*g") (("1" (assert) (("1" (hide-all-but (-4 -5 1)) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 -22 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (expand "abs" + 2) (("2" (assert) (("2" (lemma "orthonormal_basis_dot") (("2" (inst - "rp*gp" "rp*g" "rp*g" "rp*gp" "g" "gp" "perpR(rpz)" "rp") (("2" (assert) (("2" (split -) (("1" (replace -1 +) (("1" (assert) (("1" (case "(rp*g)*(rp*gp) >  0") (("1" (hide-all-but (-1 3)) (("1" (assert) nil nil)) nil) ("2" (hide 4) (("2" (case "rp*g = 0") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (case "rp*gp = 0") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (lemma "posreal_times_posreal_is_posreal") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-18 1)) (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst - "g" "gp" "ww") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "vv2") (("2" (lift-if) (("2" (split -) (("1" (assert) (("1" (replace -13 -5) (("1" (replace -14 -6) (("1" (assert) (("1" (case "NOT ((rp*g)*(ww*gp) < (rp*gp)*(ww*g) AND (rp*g)*(ww*gp) > -(rp*gp)*(ww*g))") (("1" (hide-all-but (-5 -6 1)) (("1" (grind) nil nil)) nil) ("2" (hide (-6 -7)) (("2" (flatten) (("2" (assert) (("2" (lemma "orthonormal_basis_dot") (("2" (inst - "rp*g" "-(rp*gp)" "-(rp*gp)" "rp*g" "g" "gp" "rpz" "perpR(rp)") (("2" (assert) (("2" (split -) (("1" (case "(rp*g)*(rp*gp) < 0") (("1" (assert) (("1" (hide-all-but (-1 -2 1)) (("1" (grind) nil nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (assert) (("2" (case "abs(ww*gp) >= abs(rp*gp)") (("1" (case "rp*g >= ww*g") (("1" (mult-ineq -1 -2) (("1" (hide -3) (("1" (expand "abs") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (case "-(rp*gp)>0") (("1" (case "rp*g > 0") (("1" (mult-ineq -1 -2) (("1" (assert) nil nil)) nil) ("2" (case "rp*g = 0") (("1" (replace -1) (("1" (assert) (("1" (case "rpz = - rp") (("1" (replace -1) (("1" (hide-all-but -9) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (case "NOT abs(rp*g) >= abs(ww*g)") (("1" (assert) (("1" (hide 2) (("1" (expand "abs" +) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "abs" + 1) (("2" (expand "abs" + 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (case "rp*gp > 0") (("1" (case "-(ww*g) > 0") (("1" (mult-ineq -1 -2) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (expand "abs" + 2) (("2" (assert) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - "ww*g" "ww*gp" "ww") (("2" (inst - "rp*g" "rp*gp" "rp") (("2" (assert) (("2" (split -) (("1" (replace -25) (("1" (replace -24) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (rewrite "sq_ge" 2 :dir rl) (("1" (rewrite "sq_gt" 4 :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst - "g" "gp" "ww") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT rp*gp = 0") (("1" (mult-by 2 "rp*g") (("1" (mult-by 2 "rp*g") (("1" (assert) nil nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) (("2" (case "rpz = -rp") (("1" (replace -1) (("1" (hide-all-but (-12)) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -17 1 :dir rl) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("3" (replace -13 1) (("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (hide-all-but (-1 -2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT (perpR(rpz)*rp = 0 OR perpR(rp)*rpz = 0)") (("1" (flatten) (("1" (hide-all-but (1 2 3)) (("1" (expand "vv1") (("1" (expand "vv2") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (split -1) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "rp*gp" "rp*g" "rp*g" "rp*gp" "g" "gp" "perpR(rpz)" "rp") (("1" (assert) (("1" (split -) (("1" (replace -1 -2) (("1" (case "NOT (rp*g)*(rp*gp) = 0") (("1" (assert) nil nil) ("2" (hide-all-but (-8 -9 -10 -11 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (replace -16 + :dir rl) (("2" (hide-all-but 1) (("2" (expand "gp") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 -7 -8 -9 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (iggyzip:Vect2): norm(iggyzip) = 1 IMPLIES norm(perpR(iggyzip)) = 1") (("1" (inst-cp - "rp") (("1" (inst-cp - "rpz") (("1" (assert) (("1" (case "norm(rpz) = 1") (("1" (assert) (("1" (inst-cp - "-rp") (("1" (inst - "-rpz") (("1" (rewrite "norm_neg") (("1" (rewrite "norm_neg") (("1" (rewrite "perpR_neg") (("1" (rewrite "perpR_neg") (("1" (hide 2) (("1" (replace -1) (("1" (replace -20) (("1" (replace -10 :dir rl) (("1" (replace -11 :dir rl) (("1" (lift-if +) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (2 3)) (("2" (lemma "orthonormal_basis_norm") (("2" (inst-cp - "rp*g" "rp*gp" "g" "gp" "rp") (("2" (inst - "rp*g" "-(rp*gp)" "g" "gp" "rpz") (("2" (assert) (("2" (split -1) (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-15 1)) (("2" (replace -1 :dir rl) (("2" (hide -) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "NOT rp*vv2 = 0") (("1" (hide-all-but (1 2)) (("1" (expand "vv2") (("1" (grind) nil nil)) nil)) nil) ("2" (hide 1) (("2" (case "rp*perpR(rpz) = 0") (("1" (hide (-2 -3 -4 -5)) (("1" (case "rp = rpz OR rp = -rpz") (("1" (split -) (("1" (case "rp*gp = 0") (("1" (case "rp = g OR rp = -g") (("1" (split -) (("1" (replace -1) (("1" (inst + "g" "-g") (("1" (assert) (("1" (skeep) (("1" (ground) (("1" (case "sqv(g) = 1") (("1" (expand "sqv") (("1" (replace -1) (("1" (lemma "schwarz") (("1" (inst - "ww" "g") (("1" (expand "abs") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "sqrt_eq" 1 :dir rl) (("2" (rewrite "sqrt_sqv_norm") nil nil)) nil)) nil) ("2" (hide-all-but (-1 -2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (case "-(-g) = zero") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-11 1)) (("2" (typepred "sqv(g)") (("2" (lemma "sqv_eq_0") (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "g" "gp" "rp") (("2" (assert) (("2" (replace 1) (("2" (expand "orthogonal?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5 -1) (("2" (replace -7 -1 :dir rl) (("2" (case "(rp*gp)*gp = zero") (("1" (case "gp = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1 2)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (mult-by 1 "rp*gp") (("1" (grind) nil nil)) nil) ("2" (mult-by 1 "rp*gp") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "zero") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "rp*g = 0") (("1" (replace -1) (("1" (inst + "g" "g") (("1" (assert) (("1" (skeep) (("1" (hide -) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "(rp*g)*g = zero") (("1" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1 2)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (mult-by 1 "rp*g") (("1" (grind) nil nil)) nil) ("2" (mult-by 1 "rp*g") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5 -1) (("2" (replace -7 -1 :dir rl) (("2" (hide-all-but (-1 1)) (("2" (expand "zero") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "rpz" "perpR(rpz)" "rp") (("2" (assert) (("2" (replace 1) (("2" (expand "orthogonal?") (("2" (expand "orthonormal?") (("2" (case "norm(rpz) = 1") (("1" (assert) (("1" (split +) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (case "rpz = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1 2)) (("2" (flatten) (("2" (expand "zero") (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil)) nil)) nil) ("2" (hide (2 3 4)) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - "rp*g" "-(rp*gp)" "g" "gp" "rpz") (("2" (lemma "orthonormal_basis_norm") (("2" (inst - "rp*g" "rp*gp" "g" "gp" "rp") (("2" (assert) (("2" (split -) (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil) ("2" (replace -7 1 :dir rl) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "vv2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT rpz*vv1=0") (("1" (hide-all-but (1 2)) (("1" (expand "vv1") (("1" (grind) nil nil)) nil)) nil) ("2" (hide 1) (("2" (case "NOT rpz*perpR(rp) = 0") (("1" (hide-all-but (-1 1)) (("1" (expand "vv1") (("1" (grind) nil nil)) nil)) nil) ("2" (hide (-2 -3 -4)) (("2" (case "rpz = rp OR rpz = -rp") (("1" (split -) (("1" (case "rp*gp = 0") (("1" (case "rp = g OR rp = -g") (("1" (split -) (("1" (inst + "g" "-g") (("1" (assert) (("1" (skeep) (("1" (replace -1) (("1" (case "sqv(g) = 1") (("1" (expand "sqv") (("1" (replace -1) (("1" (case "(NOT ww*g > 1) AND (NOT (ww*g > 0 AND ww*-g > 0))") (("1" (ground) nil nil) ("2" (hide 2) (("2" (split +) (("1" (lemma "schwarz") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "sqrt_eq" 1 :dir rl) (("2" (rewrite "sqrt_sqv_norm") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide -) (("2" (flatten) (("2" (case "g = -(-g)") (("1" (replace -2) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (case "sqv(g) = 0") (("1" (rewrite "sqv_eq_0") nil nil) ("2" (typepred "sqv(g)") (("2" (hide-all-but (-1 -12 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "g" "gp" "rp") (("2" (assert) (("2" (expand "orthogonal?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "(rp*gp)*gp = zero") (("1" (case "gp = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1 2)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (mult-by 1 "rp*gp") (("1" (grind) nil nil)) nil) ("2" (mult-by 1 "rp*gp") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5 -1) (("2" (replace -7 -1 :dir rl) (("2" (hide-all-but (-1 1)) (("2" (expand "zero") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "rp*g = 0") (("1" (replace -1) (("1" (inst + "g" "g") (("1" (assert) (("1" (skeep) (("1" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "(rp*g)*g = zero") (("1" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1 2)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (mult-by 1 "rp*g") (("1" (grind) nil nil)) nil) ("2" (mult-by 1 "rp*g") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5 -1) (("2" (replace -7 -1 :dir rl) (("2" (hide-all-but (-1 1)) (("2" (expand "zero") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "rp" "perpR(rp)" "rpz") (("2" (assert) (("2" (expand "orthogonal?") (("2" (replace 1) (("2" (hide (2 3)) (("2" (expand "orthonormal?" 1) (("2" (split +) (("1" (hide -) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (case "rp = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide -) (("2" (expand "zero") (("2" (flatten) (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "perpR") (("4" (expand "norm") (("4" (expand "sqv") (("4" (expand "*") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (expand "orthonormal?") (("2" (assert) (("2" (split +) (("1" (hide -) (("1" (expand "gp") (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide -) (("2" (flatten) (("2" (expand "gp") (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (expand "gp") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (lemma "orthonormal_basis") (("2" (inst - "rpt1" "rpt2" "rpt3") (("2" (assert) (("2" (expand "orthogonal?") (("2" (replace -3) (("2" (assert) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (dot_gt_dot_equals_slice_intersection-2 nil 3529219743 ("" (case "FORALL (rpt1,rpt2,rpt3:Vect2): orthonormal?(rpt1,rpt2) AND orthogonal?(rpt3,rpt2) IMPLIES (rpt3 = rpt1 OR rpt3 = -rpt1)") (("" (skeep) (("" (name "gp" "perpR(g)") (("" (name "rpz" "(rp*g)*g - (rp*gp)*gp") (("" (lemma "orthonormal_basis") (("" (inst - "g" "gp" _) (("" (case "orthonormal?(g,gp)") (("1" (assert) (("1" (label "orthog" -2) (("1" (copy "orthog") (("1" (hide "orthog") (("1" (inst - "rp") (("1" (case "NOT (perpR(rp) = (rp*g)*gp - (rp*gp)*g AND perpR(rpz) = (rp*g)*gp+(rp*gp)*g)") (("1" (hide 2) (("1" (name "prp" "perpR(rp)") (("1" (replace -1) (("1" (replace -2 -1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (name "prpz" "perpR(rpz)") (("1" (replace -1) (("1" (replace -4 :dir rl) (("1" (replace -1 :dir rl) (("1" (hide -) (("1" (expand "gp") (("1" (grind) nil))))))))))))))))))))))))) ("2" (flatten) (("2" (name "vv1" "IF perpR(rp)*rpz > 0 THEN perpR(rp) ELSE -perpR(rp) ENDIF") (("2" (name "vv2" "IF perpR(rpz)*rp > 0 THEN perpR(rpz) ELSE -perpR(rpz) ENDIF") (("2" (case "rp*vv1 = 0 AND rpz*vv1 > 0") (("1" (case "rpz*vv2 = 0 AND rp*vv2 > 0") (("1" (flatten) (("1" (inst + "vv1" "vv2") (("1" (case "norm(vv1) = 1 AND norm(vv2) = 1") (("1" (flatten) (("1" (assert) (("1" (skeep) (("1" (split) (("1" (flatten) (("1" (hide (-8 -9)) (("1" (split +) (("1" (expand "vv1") (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (replace -9 +) (("1" (case "(rp*g)*(ww*gp) > (rp*gp)*(ww*g)") (("1" (hide-all-but (-1 1)) (("1" (grind) nil))) ("2" (hide 2) (("2" (case "NOT perpR(rp)*rpz = -2*(rp*gp)*(rp*g)") (("1" (hide 2) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "-(rp*gp)" "rp*g" "rp*g" "-(rp*gp)" "g" "gp" "perpR(rp)" "rpz") (("1" (assert) (("1" (hide-all-but (-9 -13 1)) (("1" (replace -1) (("1" (replace -2 :dir rl) (("1" (hide -) (("1" (grind) nil))))))))))))))))) ("2" (expand "vv2") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (case "NOT rpz*perpR(rp) = 0") (("1" (hide-all-but (-1 -4 1)) (("1" (grind) nil))) ("2" (assert) nil))))))) ("2" (flatten) (("2" (assert) (("2" (replace -2) (("2" (case "NOT rp*gp < 0") (("1" (mult-by 1 "rp*g") (("1" (assert) nil))) ("2" (assert) (("2" (case "NOT ww*gp < 0") (("1" (mult-by 1 "rp*g") (("1" (mult-by -1 "ww*g") (("1" (assert) nil))))) ("2" (case "ww*gp > rp*gp") (("1" (case "-(ww*gp) < -(rp*gp)") (("1" (mult-ineq -1 -9) (("1" (assert) nil))) ("2" (assert) nil))) ("2" (case "sq(-(rp*gp)) > sq(-(ww*gp))") (("1" (rewrite "sq_gt") (("1" (assert) nil))) ("2" (hide 2) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "rp") (("2" (assert) (("2" (inst? -2) (("2" (inst - _ _ "ww") (("2" (inst - "ww*g" "ww*gp") (("2" (assert) (("2" (assert) (("2" (replace -23) (("2" (split -) (("1" (lemma "sq_gt") (("1" (inst - "ww*g" "rp*g") (("1" (assert) (("1" (rewrite "sq_neg") (("1" (rewrite "sq_neg") (("1" (assert) nil))))))))))) ("2" (lemma "orthonormal_basis") (("2" (inst?) (("2" (assert) nil))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) ("2" (flatten) (("2" (assert) (("2" (replace -8 2) (("2" (case "(rp*g)*(ww*gp) < (rp*gp)*(ww*g)") (("1" (hide-all-but (-1 2)) (("1" (grind) nil))) ("2" (hide 3) (("2" (case "NOT perpR(rp)*rpz = -2*(rp*gp)*(rp*g)") (("1" (hide 2) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "-(rp*gp)" "rp*g" "rp*g" "-(rp*gp)" "g" "gp" "perpR(rp)" "rpz") (("1" (assert) (("1" (assert) (("1" (hide-all-but (-8 -12 1)) (("1" (replace -1) (("1" (replace -2 :dir rl) (("1" (hide -) (("1" (grind) nil))))))))))))))))))) ("2" (expand "vv2") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (assert) (("1" (replace -3) (("1" (case "NOT rp*gp >= 0") (("1" (mult-by 1 "rp*g") (("1" (assert) nil) ("2" (case "rp*g = 0") (("1" (replace -1) (("1" (assert) (("1" (case "rpz =-rp") (("1" (replace -1) (("1" (hide-all-but -11) (("1" (grind) nil))))) ("2" (assert) nil))))))) ("2" (assert) nil))))) ("2" (case "NOT ww*gp >= 0") (("1" (mult-by 1 "rp*g") (("1" (mult-by -1 "ww*g") (("1" (assert) nil))) ("2" (case "rp*g = 0") (("1" (replace -1) (("1" (assert) (("1" (case "rpz =-rp") (("1" (replace -1) (("1" (hide-all-but -12) (("1" (grind) nil))))) ("2" (assert) nil))))))) ("2" (assert) nil))))) ("2" (case "rp*gp > ww*gp") (("1" (mult-ineq -1 -8) (("1" (assert) nil))) ("2" (assert) (("2" (case "sq((rp*gp)) > sq((ww*gp))") (("1" (rewrite "sq_gt") nil) ("2" (hide 2) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "rp") (("2" (assert) (("2" (inst? -2) (("2" (inst - _ _ "ww") (("2" (inst - "ww*g" "ww*gp") (("2" (assert) (("2" (assert) (("2" (replace -23) (("2" (split -) (("1" (replace -22) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (lemma "sq_gt") (("1" (inst - "ww*g" "rp*g") (("1" (assert) nil))))))))))) ("2" (lemma "orthonormal_basis") (("2" (inst?) (("2" (assert) nil))))))))))))))))))))))))))))))))))))))))))))))) ("2" (flatten) (("2" (assert) (("2" (hide-all-but (-6 -8)) (("2" (grind) nil))))))))))))))))))))))))))))))) ("2" (expand "vv2") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (replace -10 +) (("1" (case "(rp*g)*(ww*gp) > -(rp*gp)*(ww*g)") (("1" (hide-all-but (-1 1)) (("1" (grind) nil))) ("2" (hide 2) (("2" (case "NOT perpR(rpz)*rp = 2*(rp*gp)*(rp*g)") (("1" (hide 2) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "rp*gp" "rp*g" "rp*g" "rp*gp" "g" "gp" "perpR(rpz)" "rp") (("1" (assert) (("1" (hide-all-but (-10 1)) (("1" (replace -1) (("1" (hide -) (("1" (grind) nil))))))))))))))) ("2" (expand "vv1") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (hide-all-but (-1 -4)) (("1" (grind) nil))))))) ("2" (flatten) (("2" (assert) (("2" (replace -2) (("2" (case "NOT rp*gp > 0") (("1" (mult-by 1 "rp*g") (("1" (assert) nil))) ("2" (assert) (("2" (case "NOT ww*gp < 0") (("1" (mult-by 1 "rp*g") (("1" (mult-by -1 "ww*g") (("1" (assert) nil))))) ("2" (case "-(ww*gp) < (rp*gp)") (("1" (mult-ineq -1 -8) (("1" (assert) nil))) ("2" (assert) (("2" (case "sq((rp*gp)) > sq(-(ww*gp))") (("1" (rewrite "sq_gt") nil) ("2" (hide 2) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "rp") (("2" (assert) (("2" (inst? -2) (("2" (inst - _ _ "ww") (("2" (inst - "ww*g" "ww*gp") (("2" (assert) (("2" (assert) (("2" (replace -23) (("2" (split -) (("1" (replace -22) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (rewrite "sq_gt" -9 :dir rl) (("1" (assert) (("1" (rewrite "sq_neg") (("1" (assert) nil))))))))))))) ("2" (lemma "orthonormal_basis") (("2" (inst?) (("2" (assert) nil))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) ("2" (flatten) (("2" (assert) (("2" (replace -9 +) (("2" (case "(rp*g)*(ww*gp) < -(rp*gp)*(ww*g)") (("1" (hide-all-but (-1 2)) (("1" (grind) nil))) ("2" (hide 2) (("2" (case "NOT perpR(rpz)*rp = 2*(rp*gp)*(rp*g)") (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "rp*gp" "rp*g" "rp*g" "rp*gp" "g" "gp" "perpR(rpz)" "rp") (("1" (assert) (("1" (hide-all-but (-9 1)) (("1" (replace -1) (("1" (hide -) (("1" (grind) nil))))))))))))) ("2" (expand "vv1") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (hide 2) (("1" (case "NOT perpR(rpz)*rp < 0") (("1" (hide-all-but (-1 1)) (("1" (grind) nil))) ("2" (replace -4) (("2" (case "NOT rp*gp < 0") (("1" (mult-by 1 "rp*g") (("1" (assert) nil))) ("2" (assert) (("2" (case "NOT ww*gp > 0") (("1" (mult-by 1 "rp*g") (("1" (mult-by -1 "ww*g") (("1" (assert) nil))))) ("2" (case "-(rp*gp) > ww*gp") (("1" (mult-ineq -1 -9) (("1" (assert) nil))) ("2" (hide 2) (("2" (case "sq(-(rp*gp)) > sq((ww*gp))") (("1" (rewrite "sq_gt") nil) ("2" (hide 2) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "rp") (("2" (assert) (("2" (inst? -2) (("2" (inst - _ _ "ww") (("2" (inst - "ww*g" "ww*gp") (("2" (assert) (("2" (assert) (("2" (replace -23) (("2" (replace -24) (("2" (split -) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (rewrite "sq_gt" -10 :dir rl) (("1" (assert) (("1" (rewrite "sq_neg") (("1" (assert) nil))))))))))) ("2" (lemma "orthonormal_basis") (("2" (inst?) (("2" (assert) nil))))))))))))))))))))))))))))))))))))))))))))))))))))) ("2" (flatten) (("2" (assert) (("2" (hide-all-but (-6 1)) (("2" (grind) nil))))))))))))))))))))))))))))))))))))) ("2" (flatten) (("2" (assert) (("2" (case "vv1*rpz > 0 AND vv1*rp = 0 AND vv2*rp > 0 AND vv2*rpz = 0") (("1" (hide (-10 -11)) (("1" (flatten) (("1" (expand "vv1") (("1" (lift-if) (("1" (split -) (("1" (assert) (("1" (expand "vv2") (("1" (lift-if) (("1" (split -) (("1" (assert) (("1" (hide-all-but (-1 -2)) (("1" (grind) nil))))) ("2" (flatten) (("2" (assert) (("2" (replace -13 -5) (("2" (replace -14 -6) (("2" (assert) (("2" (case "NOT ((rp*g)*(ww*gp) > (rp*gp)*(ww*g) AND (rp*g)*(ww*gp) < -(rp*gp)*(ww*g))") (("1" (hide-all-but (-5 -6 1)) (("1" (grind) nil))) ("2" (hide (-6 -7)) (("2" (flatten) (("2" (assert) (("2" (case "abs(ww*gp) >= abs(rp*gp)") (("1" (case "rp*g >= ww*g") (("1" (mult-ineq -1 -2) (("1" (hide -3) (("1" (expand "abs") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (case "ww*g >= 0") (("1" (assert) (("1" (mult-by -1 "rp*gp") (("1" (assert) nil))))) ("2" (hide 4) (("2" (case "ww*g < 0 AND rp*gp >= 0") (("1" (hide (1 2)) (("1" (flatten) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "-(rp*gp)" "rp*g" "rp*g" "-(rp*gp)" "g" "gp" "perpR(rp)" "rpz") (("1" (assert) (("1" (split -) (("1" (case "perpR(rp)*rpz = -2* (rp*g)*(rp*gp)") (("1" (hide -2) (("1" (mult-by -3 "rp*g") (("1" (assert) nil))))) ("2" (hide-all-but (-1 1)) (("2" (replaces -1) (("2" (grind) nil))))))) ("2" (replaces -16) (("2" (hide-all-but 1) (("2" (grind) nil))))) ("3" (replaces -20 :dir rl) (("3" (hide-all-but 1) (("3" (grind) nil))))))))))))))))) ("2" (assert) nil))))))))))))))))))))) ("2" (expand "abs" + 3) (("2" (expand "abs" + 4) (("2" (hide-all-but (1 4)) (("2" (grind) nil))))))))) ("2" (assert) nil))) ("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "ww") (("2" (inst -2 "ww*g" "ww*gp") (("2" (inst - _ _ "rp") (("2" (inst - "rp*g" "rp*gp") (("2" (assert) (("2" (replace -23) (("2" (replace -24) (("2" (assert) (("2" (split -) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (rewrite "sq_gt" 3 :dir rl) (("1" (rewrite "sq_ge" 1 :dir rl) (("1" (assert) nil))) ("2" (case "NOT -(ww*g) > rp*g") (("1" (rewrite "sq_gt" 1 :dir rl) (("1" (rewrite "sq_ge" 3 :dir rl) (("1" (assert) (("1" (rewrite "sq_neg") (("1" (assert) nil))))))))) ("2" (case "NOT rp*gp >= 0") (("1" (mult-by 1 "-ww*g") (("1" (assert) (("1" (hide-all-but (-4 -5 1)) (("1" (grind) nil))))) ("2" (hide-all-but (-1 -22 1)) (("2" (grind) nil))))) ("2" (expand "abs" + 2) (("2" (assert) (("2" (lemma "orthonormal_basis_dot") (("2" (inst - "rp*gp" "rp*g" "rp*g" "rp*gp" "g" "gp" "perpR(rpz)" "rp") (("2" (assert) (("2" (split -) (("1" (replace -1 +) (("1" (assert) (("1" (case "(rp*g)*(rp*gp) >  0") (("1" (hide-all-but (-1 3)) (("1" (assert) nil))) ("2" (hide 4) (("2" (case "rp*g = 0") (("1" (replace -1) (("1" (assert) nil))) ("2" (case "rp*gp = 0") (("1" (replace -1) (("1" (assert) nil))) ("2" (lemma "posreal_times_posreal_is_posreal") (("2" (inst?) (("2" (assert) nil))))))))))))))))) ("2" (hide-all-but (-18 1)) (("2" (replaces -1) (("2" (grind) nil))))))))))))))))))))))))))) ("2" (lemma "orthonormal_basis") (("2" (inst - "g" "gp" "ww") (("2" (assert) nil))))))))))))))))))))))))))))))))))))))))))))))))))))))) ("2" (flatten) (("2" (assert) (("2" (expand "vv2") (("2" (lift-if) (("2" (split -) (("1" (assert) (("1" (replace -13 -5) (("1" (replace -14 -6) (("1" (assert) (("1" (case "NOT ((rp*g)*(ww*gp) < (rp*gp)*(ww*g) AND (rp*g)*(ww*gp) > -(rp*gp)*(ww*g))") (("1" (hide-all-but (-5 -6 1)) (("1" (grind) nil))) ("2" (hide (-6 -7)) (("2" (flatten) (("2" (assert) (("2" (lemma "orthonormal_basis_dot") (("2" (inst - "rp*g" "-(rp*gp)" "-(rp*gp)" "rp*g" "g" "gp" "rpz" "perpR(rp)") (("2" (assert) (("2" (split -) (("1" (case "(rp*g)*(rp*gp) < 0") (("1" (assert) (("1" (hide-all-but (-1 -2 1)) (("1" (grind) nil))))) ("2" (hide (-1 2)) (("2" (assert) (("2" (case "abs(ww*gp) >= abs(rp*gp)") (("1" (case "rp*g >= ww*g") (("1" (mult-ineq -1 -2) (("1" (hide -3) (("1" (expand "abs") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (case "-(rp*gp)>0") (("1" (case "rp*g > 0") (("1" (mult-ineq -1 -2) (("1" (assert) nil))) ("2" (case "rp*g = 0") (("1" (replace -1) (("1" (assert) (("1" (case "rpz = - rp") (("1" (replace -1) (("1" (hide-all-but -9) (("1" (grind) nil))))) ("2" (assert) nil))))))) ("2" (assert) nil))))) ("2" (assert) nil))))))))))))))))) ("2" (flatten) (("2" (assert) (("2" (case "NOT abs(rp*g) >= abs(ww*g)") (("1" (assert) (("1" (hide 2) (("1" (expand "abs" +) (("1" (propax) nil))))))) ("2" (assert) (("2" (expand "abs" + 1) (("2" (expand "abs" + 2) (("2" (propax) nil))))))))))))))) ("2" (assert) nil))) ("2" (case "rp*gp > 0") (("1" (case "-(ww*g) > 0") (("1" (mult-ineq -1 -2) (("1" (assert) nil))) ("2" (assert) (("2" (expand "abs" + 2) (("2" (assert) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - "ww*g" "ww*gp" "ww") (("2" (inst - "rp*g" "rp*gp" "rp") (("2" (assert) (("2" (split -) (("1" (replace -25) (("1" (replace -24) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (rewrite "sq_ge" 2 :dir rl) (("1" (rewrite "sq_gt" 4 :dir rl) (("1" (assert) nil))))))))))))) ("2" (lemma "orthonormal_basis") (("2" (inst - "g" "gp" "ww") (("2" (assert) nil))))))))))))))))))))))))) ("2" (case "NOT rp*gp = 0") (("1" (mult-by 2 "rp*g") (("1" (mult-by 2 "rp*g") (("1" (assert) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) (("2" (case "rpz = -rp") (("1" (replace -1) (("1" (hide-all-but (-12)) (("1" (grind) nil))))) ("2" (assert) nil))))))))))))) ("2" (replace -1) (("2" (assert) nil))))))))))))))) ("2" (replace -17 1 :dir rl) (("2" (hide-all-but 1) (("2" (grind) nil))))) ("3" (replace -13 1) (("3" (hide-all-but 1) (("3" (grind) nil))))))))))))))))))))))))))))) ("2" (flatten) (("2" (assert) (("2" (hide-all-but (-1 -2)) (("2" (grind) nil))))))))))))))))))))))))))) ("2" (case "NOT (perpR(rpz)*rp = 0 OR perpR(rp)*rpz = 0)") (("1" (flatten) (("1" (hide-all-but (1 2 3)) (("1" (expand "vv1") (("1" (expand "vv2") (("1" (grind) nil))))))))) ("2" (split -1) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "rp*gp" "rp*g" "rp*g" "rp*gp" "g" "gp" "perpR(rpz)" "rp") (("1" (assert) (("1" (split -) (("1" (replace -1 -2) (("1" (case "NOT (rp*g)*(rp*gp) = 0") (("1" (assert) nil) ("2" (hide-all-but (-8 -9 -10 -11 1)) (("2" (grind) nil))))))) ("2" (replace -16 + :dir rl) (("2" (hide-all-but 1) (("2" (expand "gp") (("2" (grind) nil))))))))))))))) ("2" (hide-all-but (-6 -7 -8 -9 1)) (("2" (grind) nil))))))))))))))))))))) ("2" (case "FORALL (iggyzip:Vect2): norm(iggyzip) = 1 IMPLIES norm(perpR(iggyzip)) = 1") (("1" (inst-cp - "rp") (("1" (inst-cp - "rpz") (("1" (assert) (("1" (case "norm(rpz) = 1") (("1" (assert) (("1" (inst-cp - "-rp") (("1" (inst - "-rpz") (("1" (rewrite "norm_neg") (("1" (rewrite "norm_neg") (("1" (rewrite "perpR_neg") (("1" (rewrite "perpR_neg") (("1" (hide 2) (("1" (replace -1) (("1" (replace -20) (("1" (replace -10 :dir rl) (("1" (replace -11 :dir rl) (("1" (lift-if +) (("1" (lift-if) (("1" (ground) nil))))))))))))))))))))))))))))) ("2" (hide (2 3)) (("2" (lemma "orthonormal_basis_norm") (("2" (inst-cp - "rp*g" "rp*gp" "g" "gp" "rp") (("2" (inst - "rp*g" "-(rp*gp)" "g" "gp" "rpz") (("2" (assert) (("2" (split -1) (("1" (rewrite "sq_neg") (("1" (assert) nil))) ("2" (hide-all-but (-15 1)) (("2" (replace -1 :dir rl) (("2" (hide -) (("2" (grind) nil))))))))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (grind) nil))))))) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil))))) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil))))))))) ("2" (case "NOT rp*vv2 = 0") (("1" (hide-all-but (1 2)) (("1" (expand "vv2") (("1" (grind) nil))))) ("2" (hide 1) (("2" (case "rp*perpR(rpz) = 0") (("1" (hide (-2 -3 -4 -5)) (("1" (case "rp = rpz OR rp = -rpz") (("1" (split -) (("1" (case "rp*gp = 0") (("1" (case "rp = g OR rp = -g") (("1" (split -) (("1" (replace -1) (("1" (inst + "g" "-g") (("1" (assert) (("1" (skeep) (("1" (ground) (("1" (case "sqv(g) = 1") (("1" (expand "sqv") (("1" (replace -1) (("1" (lemma "schwarz") (("1" (inst - "ww" "g") (("1" (expand "abs") (("1" (ground) nil))))))))))) ("2" (rewrite "sqrt_eq" 1 :dir rl) (("2" (rewrite "sqrt_sqv_norm") nil))))) ("2" (hide-all-but (-1 -2)) (("2" (grind) nil))))))))) ("2" (flatten) (("2" (case "g = zero") (("1" (replace -1) (("1" (assert) nil))) ("2" (hide-all-but (-1 1)) (("2" (case "-(-g) = zero") (("1" (assert) nil) ("2" (replace -1) (("2" (assert) nil))))))))))) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil))))))))) ("2" (replace -1) (("2" (case "g = zero") (("1" (replace -1) (("1" (assert) nil))) ("2" (hide-all-but (-11 1)) (("2" (typepred "sqv(g)") (("2" (lemma "sqv_eq_0") (("2" (inst?) (("2" (grind) nil))))))))))))))) ("2" (postpone) nil))) ("2" (postpone) nil))) ("2" (postpone) nil))) ("2" (postpone) nil))))) ("2" (postpone) nil))))))))) ("2" (postpone) nil))))))))))))))))))))) ("2" (postpone) nil)))))))))))))) nil) nil nil) (dot_gt_dot_equals_slice_intersection-1 nil 3529149190 ("" (skeep) (("" (name "gp" "perpR(g)") (("" (name "rpz" "(rp*g)*g - (rp*gp)*gp") (("" (lemma "orthonormal_basis") (("" (inst - "g" "gp" _) (("" (case "orthonormal?(g,gp)") (("1" (assert) (("1" (label "orthog" -2) (("1" (copy "orthog") (("1" (hide "orthog") (("1" (inst - "rp") (("1" (case "NOT (perpR(rp) = (rp*g)*gp - (rp*gp)*g AND perpR(rpz) = (rp*g)*gp+(rp*gp)*g)") (("1" (hide 2) (("1" (name "prp" "perpR(rp)") (("1" (replace -1) (("1" (replace -2 -1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (name "prpz" "perpR(rpz)") (("1" (replace -1) (("1" (replace -4 :dir rl) (("1" (replace -1 :dir rl) (("1" (hide -) (("1" (expand "gp") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (name "vv1" "IF perpR(rp)*rpz > 0 THEN perpR(rp) ELSE -perpR(rp) ENDIF") (("2" (name "vv2" "IF perpR(rpz)*rp > 0 THEN perpR(rpz) ELSE -perpR(rpz) ENDIF") (("2" (case "rp*vv1 = 0 AND rpz*vv1 > 0") (("1" (case "rpz*vv2 = 0 AND rp*vv2 > 0") (("1" (flatten) (("1" (inst + "vv1" "vv2") (("1" (case "norm(vv1) = 1 AND norm(vv2) = 1") (("1" (flatten) (("1" (assert) (("1" (skeep) (("1" (split) (("1" (flatten) (("1" (hide (-8 -9)) (("1" (split +) (("1" (expand "vv1") (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (replace -9 +) (("1" (case "(rp*g)*(ww*gp) > (rp*gp)*(ww*g)") (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (hide 2) (("2" (case "NOT perpR(rp)*rpz = -2*(rp*gp)*(rp*g)") (("1" (hide 2) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "-(rp*gp)" "rp*g" "rp*g" "-(rp*gp)" "g" "gp" "perpR(rp)" "rpz") (("1" (assert) (("1" (hide-all-but (-9 -13 1)) (("1" (replace -1) (("1" (replace -2 :dir rl) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vv2") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (case "NOT rpz*perpR(rp) = 0") (("1" (hide-all-but (-1 -4 1)) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -2) (("2" (case "NOT rp*gp < 0") (("1" (mult-by 1 "rp*g") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (case "NOT ww*gp < 0") (("1" (mult-by 1 "rp*g") (("1" (mult-by -1 "ww*g") (("1" (assert) nil nil)) nil)) nil) ("2" (case "ww*gp > rp*gp") (("1" (case "-(ww*gp) < -(rp*gp)") (("1" (mult-ineq -1 -9) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (case "sq(-(rp*gp)) > sq(-(ww*gp))") (("1" (rewrite "sq_gt") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "rp") (("2" (assert) (("2" (inst? -2) (("2" (inst - _ _ "ww") (("2" (inst - "ww*g" "ww*gp") (("2" (assert) (("2" (assert) (("2" (replace -23) (("2" (split -) (("1" (lemma "sq_gt") (("1" (inst - "ww*g" "rp*g") (("1" (assert) (("1" (rewrite "sq_neg") (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -8 2) (("2" (case "(rp*g)*(ww*gp) < (rp*gp)*(ww*g)") (("1" (hide-all-but (-1 2)) (("1" (grind) nil nil)) nil) ("2" (hide 3) (("2" (case "NOT perpR(rp)*rpz = -2*(rp*gp)*(rp*g)") (("1" (hide 2) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "-(rp*gp)" "rp*g" "rp*g" "-(rp*gp)" "g" "gp" "perpR(rp)" "rpz") (("1" (assert) (("1" (assert) (("1" (hide-all-but (-8 -12 1)) (("1" (replace -1) (("1" (replace -2 :dir rl) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vv2") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (assert) (("1" (replace -3) (("1" (case "NOT rp*gp >= 0") (("1" (mult-by 1 "rp*g") (("1" (assert) nil nil) ("2" (case "rp*g = 0") (("1" (replace -1) (("1" (assert) (("1" (case "rpz =-rp") (("1" (replace -1) (("1" (hide-all-but -11) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (case "NOT ww*gp >= 0") (("1" (mult-by 1 "rp*g") (("1" (mult-by -1 "ww*g") (("1" (assert) nil nil)) nil) ("2" (case "rp*g = 0") (("1" (replace -1) (("1" (assert) (("1" (case "rpz =-rp") (("1" (replace -1) (("1" (hide-all-but -12) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (case "rp*gp > ww*gp") (("1" (mult-ineq -1 -8) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (case "sq((rp*gp)) > sq((ww*gp))") (("1" (rewrite "sq_gt") nil nil) ("2" (hide 2) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "rp") (("2" (assert) (("2" (inst? -2) (("2" (inst - _ _ "ww") (("2" (inst - "ww*g" "ww*gp") (("2" (assert) (("2" (assert) (("2" (replace -23) (("2" (split -) (("1" (replace -22) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (lemma "sq_gt") (("1" (inst - "ww*g" "rp*g") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (hide-all-but (-6 -8)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vv2") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (replace -10 +) (("1" (case "(rp*g)*(ww*gp) > -(rp*gp)*(ww*g)") (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (hide 2) (("2" (case "NOT perpR(rpz)*rp = 2*(rp*gp)*(rp*g)") (("1" (hide 2) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "rp*gp" "rp*g" "rp*g" "rp*gp" "g" "gp" "perpR(rpz)" "rp") (("1" (assert) (("1" (hide-all-but (-10 1)) (("1" (replace -1) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vv1") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (hide-all-but (-1 -4)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -2) (("2" (case "NOT rp*gp > 0") (("1" (mult-by 1 "rp*g") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (case "NOT ww*gp < 0") (("1" (mult-by 1 "rp*g") (("1" (mult-by -1 "ww*g") (("1" (assert) nil nil)) nil)) nil) ("2" (case "-(ww*gp) < (rp*gp)") (("1" (mult-ineq -1 -8) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (case "sq((rp*gp)) > sq(-(ww*gp))") (("1" (rewrite "sq_gt") nil nil) ("2" (hide 2) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "rp") (("2" (assert) (("2" (inst? -2) (("2" (inst - _ _ "ww") (("2" (inst - "ww*g" "ww*gp") (("2" (assert) (("2" (assert) (("2" (replace -23) (("2" (split -) (("1" (replace -22) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (rewrite "sq_gt" -9 :dir rl) (("1" (assert) (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -9 +) (("2" (case "(rp*g)*(ww*gp) < -(rp*gp)*(ww*g)") (("1" (hide-all-but (-1 2)) (("1" (grind) nil nil)) nil) ("2" (hide 2) (("2" (case "NOT perpR(rpz)*rp = 2*(rp*gp)*(rp*g)") (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "rp*gp" "rp*g" "rp*g" "rp*gp" "g" "gp" "perpR(rpz)" "rp") (("1" (assert) (("1" (hide-all-but (-9 1)) (("1" (replace -1) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vv1") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (hide 2) (("1" (case "NOT perpR(rpz)*rp < 0") (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (replace -4) (("2" (case "NOT rp*gp < 0") (("1" (mult-by 1 "rp*g") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (case "NOT ww*gp > 0") (("1" (mult-by 1 "rp*g") (("1" (mult-by -1 "ww*g") (("1" (assert) nil nil)) nil)) nil) ("2" (case "-(rp*gp) > ww*gp") (("1" (mult-ineq -1 -9) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (case "sq(-(rp*gp)) > sq((ww*gp))") (("1" (rewrite "sq_gt") nil nil) ("2" (hide 2) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "rp") (("2" (assert) (("2" (inst? -2) (("2" (inst - _ _ "ww") (("2" (inst - "ww*g" "ww*gp") (("2" (assert) (("2" (assert) (("2" (replace -23) (("2" (replace -24) (("2" (split -) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (rewrite "sq_gt" -10 :dir rl) (("1" (assert) (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (hide-all-but (-6 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (case "vv1*rpz > 0 AND vv1*rp = 0 AND vv2*rp > 0 AND vv2*rpz = 0") (("1" (hide (-10 -11)) (("1" (flatten) (("1" (expand "vv1") (("1" (lift-if) (("1" (split -) (("1" (assert) (("1" (expand "vv2") (("1" (lift-if) (("1" (split -) (("1" (assert) (("1" (hide-all-but (-1 -2)) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -13 -5) (("2" (replace -14 -6) (("2" (assert) (("2" (case "NOT ((rp*g)*(ww*gp) > (rp*gp)*(ww*g) AND (rp*g)*(ww*gp) < -(rp*gp)*(ww*g))") (("1" (hide-all-but (-5 -6 1)) (("1" (grind) nil nil)) nil) ("2" (hide (-6 -7)) (("2" (flatten) (("2" (assert) (("2" (case "abs(ww*gp) >= abs(rp*gp)") (("1" (case "rp*g >= ww*g") (("1" (mult-ineq -1 -2) (("1" (hide -3) (("1" (expand "abs") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (case "ww*g >= 0") (("1" (assert) (("1" (mult-by -1 "rp*gp") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 4) (("2" (case "ww*g < 0 AND rp*gp >= 0") (("1" (hide (1 2)) (("1" (flatten) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "-(rp*gp)" "rp*g" "rp*g" "-(rp*gp)" "g" "gp" "perpR(rp)" "rpz") (("1" (assert) (("1" (split -) (("1" (case "perpR(rp)*rpz = -2* (rp*g)*(rp*gp)") (("1" (hide -2) (("1" (mult-by -3 "rp*g") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (replaces -16) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("3" (replaces -20 :dir rl) (("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "abs" + 3) (("2" (expand "abs" + 4) (("2" (hide-all-but (1 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - _ _ "ww") (("2" (inst -2 "ww*g" "ww*gp") (("2" (inst - _ _ "rp") (("2" (inst - "rp*g" "rp*gp") (("2" (assert) (("2" (replace -23) (("2" (replace -24) (("2" (assert) (("2" (split -) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (rewrite "sq_gt" 3 :dir rl) (("1" (rewrite "sq_ge" 1 :dir rl) (("1" (assert) nil nil)) nil) ("2" (case "NOT -(ww*g) > rp*g") (("1" (rewrite "sq_gt" 1 :dir rl) (("1" (rewrite "sq_ge" 3 :dir rl) (("1" (assert) (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "NOT rp*gp >= 0") (("1" (mult-by 1 "-ww*g") (("1" (assert) (("1" (hide-all-but (-4 -5 1)) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 -22 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (expand "abs" + 2) (("2" (assert) (("2" (lemma "orthonormal_basis_dot") (("2" (inst - "rp*gp" "rp*g" "rp*g" "rp*gp" "g" "gp" "perpR(rpz)" "rp") (("2" (assert) (("2" (split -) (("1" (replace -1 +) (("1" (assert) (("1" (case "(rp*g)*(rp*gp) >  0") (("1" (hide-all-but (-1 3)) (("1" (assert) nil nil)) nil) ("2" (hide 4) (("2" (case "rp*g = 0") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (case "rp*gp = 0") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (lemma "posreal_times_posreal_is_posreal") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-18 1)) (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst - "g" "gp" "ww") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "vv2") (("2" (lift-if) (("2" (split -) (("1" (assert) (("1" (replace -13 -5) (("1" (replace -14 -6) (("1" (assert) (("1" (case "NOT ((rp*g)*(ww*gp) < (rp*gp)*(ww*g) AND (rp*g)*(ww*gp) > -(rp*gp)*(ww*g))") (("1" (hide-all-but (-5 -6 1)) (("1" (grind) nil nil)) nil) ("2" (hide (-6 -7)) (("2" (flatten) (("2" (assert) (("2" (lemma "orthonormal_basis_dot") (("2" (inst - "rp*g" "-(rp*gp)" "-(rp*gp)" "rp*g" "g" "gp" "rpz" "perpR(rp)") (("2" (assert) (("2" (split -) (("1" (case "(rp*g)*(rp*gp) < 0") (("1" (assert) (("1" (hide-all-but (-1 -2 1)) (("1" (grind) nil nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (assert) (("2" (case "abs(ww*gp) >= abs(rp*gp)") (("1" (case "rp*g >= ww*g") (("1" (mult-ineq -1 -2) (("1" (hide -3) (("1" (expand "abs") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (case "-(rp*gp)>0") (("1" (case "rp*g > 0") (("1" (mult-ineq -1 -2) (("1" (assert) nil nil)) nil) ("2" (case "rp*g = 0") (("1" (replace -1) (("1" (assert) (("1" (case "rpz = - rp") (("1" (replace -1) (("1" (hide-all-but -9) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (case "NOT abs(rp*g) >= abs(ww*g)") (("1" (assert) (("1" (hide 2) (("1" (expand "abs" +) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "abs" + 1) (("2" (expand "abs" + 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (case "rp*gp > 0") (("1" (case "-(ww*g) > 0") (("1" (mult-ineq -1 -2) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (expand "abs" + 2) (("2" (assert) (("2" (lemma "orthonormal_basis_norm") (("2" (inst - _ _ "g" "gp" _) (("2" (inst-cp - "ww*g" "ww*gp" "ww") (("2" (inst - "rp*g" "rp*gp" "rp") (("2" (assert) (("2" (split -) (("1" (replace -25) (("1" (replace -24) (("1" (replace -2 -1) (("1" (rewrite "sqrt_eq") (("1" (rewrite "sq_ge" 2 :dir rl) (("1" (rewrite "sq_gt" 4 :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst - "g" "gp" "ww") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT rp*gp = 0") (("1" (mult-by 2 "rp*g") (("1" (mult-by 2 "rp*g") (("1" (assert) nil nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) (("2" (case "rpz = -rp") (("1" (replace -1) (("1" (hide-all-but (-12)) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -17 1 :dir rl) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("3" (replace -13 1) (("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (hide-all-but (-1 -2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT (perpR(rpz)*rp = 0 OR perpR(rp)*rpz = 0)") (("1" (flatten) (("1" (hide-all-but (1 2 3)) (("1" (expand "vv1") (("1" (expand "vv2") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (split -1) (("1" (lemma "orthonormal_basis_dot") (("1" (inst - "rp*gp" "rp*g" "rp*g" "rp*gp" "g" "gp" "perpR(rpz)" "rp") (("1" (assert) (("1" (split -) (("1" (replace -1 -2) (("1" (case "NOT (rp*g)*(rp*gp) = 0") (("1" (assert) nil nil) ("2" (hide-all-but (-8 -9 -10 -11 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (replace -16 + :dir rl) (("2" (hide-all-but 1) (("2" (expand "gp") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 -7 -8 -9 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (iggyzip:Vect2): norm(iggyzip) = 1 IMPLIES norm(perpR(iggyzip)) = 1") (("1" (inst-cp - "rp") (("1" (inst-cp - "rpz") (("1" (assert) (("1" (case "norm(rpz) = 1") (("1" (assert) (("1" (inst-cp - "-rp") (("1" (inst - "-rpz") (("1" (rewrite "norm_neg") (("1" (rewrite "norm_neg") (("1" (rewrite "perpR_neg") (("1" (rewrite "perpR_neg") (("1" (hide 2) (("1" (replace -1) (("1" (replace -20) (("1" (replace -10 :dir rl) (("1" (replace -11 :dir rl) (("1" (lift-if +) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (2 3)) (("2" (lemma "orthonormal_basis_norm") (("2" (inst-cp - "rp*g" "rp*gp" "g" "gp" "rp") (("2" (inst - "rp*g" "-(rp*gp)" "g" "gp" "rpz") (("2" (assert) (("2" (split -1) (("1" (rewrite "sq_neg") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-15 1)) (("2" (replace -1 :dir rl) (("2" (hide -) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "NOT rp*vv2 = 0") (("1" (hide-all-but (1 2)) (("1" (expand "vv2") (("1" (grind) nil nil)) nil)) nil) ("2" (hide 1) (("2" (case "rp*perpR(rpz) = 0") (("1" (hide (-2 -3 -4 -5)) (("1" (case "rp = rpz OR rp = -rpz") (("1" (split -) (("1" (case "rp*gp = 0") (("1" (case "rp = g OR rp = -g") (("1" (split -) (("1" (replace -1) (("1" (inst + "g" "-g") (("1" (assert) (("1" (skeep) (("1" (ground) (("1" (case "sqv(g) = 1") (("1" (expand "sqv") (("1" (replace -1) (("1" (lemma "schwarz") (("1" (inst - "ww" "g") (("1" (expand "abs") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "sqrt_eq" 1 :dir rl) (("2" (rewrite "sqrt_sqv_norm") nil nil)) nil)) nil) ("2" (hide-all-but (-1 -2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (case "-(-g) = zero") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-11 1)) (("2" (typepred "sqv(g)") (("2" (lemma "sqv_eq_0") (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil)) (dot_gt_dot_equals_slice_union 0 (dot_gt_dot_equals_slice_union-5 nil 3529331774 ("" (case "FORALL (g, rp: Vect2):
                                                                                                                                             rp * g >= 0 AND norm(g) = 1 AND norm(rp) = 1 AND rp/=g IMPLIES
                                                                                                                                              (EXISTS (vv1, vv2: Nz_vect2):
                                                                                                                                                 norm(vv1) = 1 AND
                                                                                                                                                  norm(vv2) = 1 AND
                                                                                                                                                   g * vv1 = g * vv2 AND
                                                                                                                                                    (FORALL (ww: Nz_vect2):
                                                                                                                                                       norm(ww) = 1 IMPLIES
                                                                                                                                                        (ww * g >= rp * g IFF (ww * vv1 >= 0 AND ww * vv2 >= 0))))") (("1" (skeep) (("1" (inst - "-g" "rp") (("1" (assert) (("1" (case "NOT rp*-g >= 0") (("1" (hide-all-but (-2 1)) (("1" (grind) nil nil)) nil) ("2" (assert) (("2" (skeep -2) (("2" (inst + "-vv1" "-vv2") (("2" (assert) (("2" (split +) (("1" (hide-all-but (-4 1)) (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (inst - "ww") (("2" (assert) (("2" (case "(ww*g > rp*g IFF (NOT ww*-g >= rp*-g)) AND ((ww * -vv1 > 0 OR ww * -vv2 > 0) IFF (NOT (ww * vv1 >= 0 AND ww * vv2 >= 0)))") (("1" (ground) nil nil) ("2" (hide (-6 2)) (("2" (hide -) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "dot_gt_dot_equals_slice_intersection") (("2" (skeep) (("2" (label "normrp" -4) (("2" (label "normg" -3) (("2" (label "rpgpos" -2) (("2" (inst - "g" "rp") (("2" (assert) (("2" (label "rpg" 1) (("2" (hide "rpg") (("2" (skeep -1) (("2" (inst + "vv1" "vv2") (("2" (assert) (("2" (label "vv12def" -4) (("2" (skeep) (("2" (split) (("1" (flatten) (("1" (case "NOT ww*g = rp*g") (("1" (inst - "ww") (("1" (assert) (("1" (ground) nil nil)) nil)) nil) ("2" (hide -2) (("2" (case "FORALL (n:posnat): EXISTS (wwn:Nz_vect2): norm(wwn) = 1 AND norm(ww-wwn)<1/n AND wwn*g > rp*g") (("1" (split +) (("1" (case "FORALL (n:posnat): ww*vv1 >= (-1/n)*norm(vv1)") (("1" (hide-all-but (-1 1)) (("1" (lemma "archimedean") (("1" (inst - "(-(ww*vv1))/norm(vv1)") (("1" (skeep -1) (("1" (inst - "n") (("1" (cross-mult -1) (("1" (cross-mult -2) nil nil)) nil)) nil)) nil) ("2" (case "FORALL (rx:real): rx > 0 IMPLIES (rx>=0 AND rx>0)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst - "n") (("2" (skeep -1) (("2" (inst - "wwn") (("2" (assert) (("2" (case "abs(wwn*vv1) <= ww*vv1 + norm(vv1)/n") (("1" (flatten) (("1" (hide-all-but (-1 -9 +)) (("1" (grind :exclude ("norm" "*")) nil nil)) nil)) nil) ("2" (lemma "schwarz") (("2" (inst - "wwn-ww" "vv1") (("2" (case "norm(wwn-ww) < 1/n") (("1" (mult-by -1 "norm(vv1)") (("1" (rewrite "dot_sub_left" -2) (("1" (expand "abs" +) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (n:posnat): ww*vv2 >= (-1/n)*norm(vv2)") (("1" (hide-all-but (-1 1)) (("1" (lemma "archimedean") (("1" (inst - "(-(ww*vv2))/norm(vv2)") (("1" (skeep -1) (("1" (inst - "n") (("1" (cross-mult -1) (("1" (cross-mult -2) nil nil)) nil)) nil)) nil) ("2" (case "FORALL (rx:real): rx > 0 IMPLIES (rx>=0 AND rx>0)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst - "n") (("2" (skeep -1) (("2" (inst - "wwn") (("2" (assert) (("2" (case "abs(wwn*vv2) <= ww*vv2 + norm(vv2)/n") (("1" (flatten) (("1" (hide-all-but (-1 -10 +)) (("1" (grind :exclude ("norm" "*")) nil nil)) nil)) nil) ("2" (lemma "schwarz") (("2" (inst - "wwn-ww" "vv2") (("2" (case "norm(wwn-ww) < 1/n") (("1" (mult-by -1 "norm(vv2)") (("1" (rewrite "dot_sub_left" -2) (("1" (expand "abs" +) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide-all-but (-1 -7 -8 -9 1)) (("2" (lemma "orthonormal_basis") (("2" (inst - "g" "perpR(g)" _) (("2" (inst-cp - "ww") (("2" (inst-cp - "rp") (("2" (assert) (("2" (case "orthonormal?(g,perpR(g))") (("1" (assert) (("1" (name "zp" "(ww*g + 1/(100*n+1))*g + (ww*perpR(g))*perpR(g)") (("1" (case "norm(ww-zp) = 1/(100*n+1)") (("1" (case "norm(zp) <= 1 + 1/(100*n+1)") (("1" (case "norm(zp) >= 1-1/(100*n+1)") (("1" (inst + "(1/norm(zp))*zp") (("1" (split +) (("1" (rewrite "norm_scal") (("1" (expand "abs") (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (cross-mult -1) (("1" (assert) (("1" (ground) (("1" (lemma "norm_eq_0") (("1" (inst?) (("1" (assert) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_triangle") (("2" (inst - "ww" "zp" "(1/norm(zp))*zp") (("2" (case "norm(zp-(1/norm(zp))*zp) < 1/n - 1/(100*n+1)") (("1" (assert) (("1" (replace -5 -1 :dir rl) (("1" (assert) nil nil)) nil)) nil) ("2" (case "NOT norm(zp-(1/norm(zp))*zp) = abs(norm(zp)-1)") (("1" (hide-all-but (-2 -3 1)) (("1" (case "zp - (1/norm(zp))*zp = ((norm(zp)-1)/norm(zp))*zp") (("1" (replace -1) (("1" (rewrite "norm_scal") (("1" (rewrite "abs_div") (("1" (expand "abs" + 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind :exclude "norm") nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide-all-but (-3 -4 1)) (("2" (case "1/(100*n+1) < 1/n - 1/(100*n+1)") (("1" (grind :exclude "norm") nil nil) ("2" (assert) (("2" (hide 2) (("2" (real-props) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case "(1/norm(zp))*zp*g = (1/norm(zp))*(ww*g + 1/(100*n+1))") (("1" (replace -1) (("1" (cross-mult 1) (("1" (assert) (("1" (ground) (("1" (replace -11) (("1" (mult-by -4 "rp*g") (("1" (case "rp*g <1 ") (("1" (mult-by -1 "1/(100*n+1)") (("1" (assert) nil nil)) nil) ("2" (lemma "schwarz") (("2" (inst?) (("2" (expand "abs") (("2" (assert) (("2" (case "NOT rp*g = 1") (("1" (assert) nil nil) ("2" (lemma "schwarz_converse") (("2" (inst?) (("1" (split -1) (("1" (skeep -1) (("1" (replace -1 -16 :dir rl) (("1" (rewrite "norm_scal") (("1" (replace -15) (("1" (assert) (("1" (case "cr = 1") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (reveal "rpg") (("2" (assert) (("2" (expand "abs") (("2" (lift-if) (("2" (assert) (("2" (ground) (("2" (case "cr = -1") (("1" (replace -1) (("1" (assert) (("1" (replace -4 :dir rl) (("1" (hide-all-but -5) (("1" (typepred "sqv(g)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -14 -15 1)) (("2" (replaces -) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "zp" + 2) (("2" (case "sqv(g) = 1") (("1" (hide-all-but (-1 1)) (("1" (mult-by -1 "(ww * g + 1 / (1 + 100 * n))") (("1" (grind :exclude "norm") nil nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "sqrt_eq" 1 :dir rl) (("2" (rewrite "sqrt_sqv_norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst - "1/(norm(zp))*zp") (("2" (assert) (("2" (rewrite "norm_scal") (("2" (rewrite "abs_div") (("2" (expand "abs" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (lemma "norm_eq_0") (("3" (inst?) (("3" (assert) (("3" (replace -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "ww-zp = -(1/(100*n+1))*g") (("1" (lemma "norm_add_le") (("1" (inst - "ww-zp" "zp") (("1" (assert) (("1" (replace -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -7 1) (("2" (expand "zp" +) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_add_le") (("2" (inst - "ww" "zp-ww") (("2" (assert) (("2" (case "ww + (zp-ww) = zp") (("1" (replace -1) (("1" (case "zp-ww = -(ww-zp)") (("1" (replace -1) (("1" (rewrite "norm_neg") (("1" (assert) (("1" (replace -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "ww-zp = -(1/(100*n+1))*g") (("1" (replace -1) (("1" (rewrite "norm_scal") (("1" (expand "abs") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -5) (("2" (expand "zp" +) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (expand "orthonormal?") (("2" (split +) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide -2) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "FORALL (n:posnat): EXISTS (wwn:Nz_vect2): norm(wwn) = 1 AND norm(wwn-ww)<1/n AND wwn*vv1 > 0 AND wwn*vv2 > 0") (("1" (case "FORALL (n:posnat): ww*g >= rp*g - norm(g)/n") (("1" (hide-all-but (-1 1)) (("1" (lemma "archimedean") (("1" (inst - "(rp*g - ww*g)/norm(g)") (("1" (skeep -1) (("1" (inst - "n") (("1" (cross-mult -1) (("1" (cross-mult 1) (("1" (mult-by -2 "n") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (a:real): a> 0 IMPLIES (a>=0 AND a>0)") (("1" (rewrite -1) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (inst - "n") (("2" (skeep -1) (("2" (inst - "wwn") (("2" (assert) (("2" (case "ww*g >= wwn*g - norm(g)/n") (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "schwarz") (("2" (inst - "wwn-ww" "g") (("2" (mult-by -3 "norm(g)") (("2" (rewrite "dot_sub_left") (("2" (expand "abs") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-6 -7 -8 -9 2)) (("2" (case "EXISTS (zpn:Nz_vect2): zpn*vv1 > 0 AND zpn*vv2 > 0") (("1" (case "EXISTS (zpn:Nz_vect2): norm(zpn) = 1 AND zpn*vv1 > 0 AND zpn*vv2 > 0") (("1" (hide -2) (("1" (skeep -1) (("1" (skeep) (("1" (name "rgn" "ww + (1/(100*n+1))*zpn") (("1" (case "rgn /= zero") (("1" (case "norm(rgn)>0") (("1" (flatten) (("1" (name "ZZtop" "(1/norm(rgn))*rgn") (("1" (inst + "ZZtop") (("1" (case "NOT norm(ZZtop) = 1") (("1" (hide 3) (("1" (typepred "^(rgn)") (("1" (expand "^" -1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "NOT (ZZtop*vv1 > 0 AND ZZtop*vv2>0)") (("1" (hide 3) (("1" (expand "ZZtop" 1) (("1" (assert) (("1" (case "rgn*vv1 > 0 AND rgn*vv2>0") (("1" (flatten) (("1" (mult-by -1 "1/norm(rgn)") (("1" (mult-by -2 "1/norm(rgn)") (("1" (assert) nil nil) ("2" (split +) (("1" (cross-mult 1) nil nil) ("2" (cross-mult 1) nil nil)) nil)) nil) ("2" (split) (("1" (cross-mult 1) nil nil) ("2" (cross-mult 1) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "rgn" 1) (("2" (rewrite "dot_add_left") (("2" (rewrite "dot_add_left") (("2" (mult-by -6 "1/(100*n+1)") (("2" (mult-by -7 "1/(100*n+1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (case "NOT ZZtop - ww = (1/norm(rgn))*((1-norm(rgn))*ww + (1/(100*n+1))*zpn)") (("1" (hide-all-but (-5 1)) (("1" (expand "ZZtop") (("1" (expand "rgn " + 2) (("1" (grind :exclude "norm") nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (rewrite "norm_scal") (("2" (rewrite "abs_div") (("2" (expand "abs") (("2" (case "FORALL (rz:real): rz < norm(rgn)/n IMPLIES (1/norm(rgn))*rz < 1/n") (("1" (rewrite -1) (("1" (hide 3) (("1" (hide -1) (("1" (lemma "norm_add_le") (("1" (inst?) (("1" (case "norm((1 - norm(rgn)) * ww) + norm((1 / (1 + 100 * n)) * zpn) < norm(rgn)/n") (("1" (assert) nil nil) ("2" (hide (-1 2)) (("2" (rewrite "norm_scal") (("2" (case "abs(1-norm(rgn))<=1/(100*n+1)") (("1" (replace -16) (("1" (rewrite "norm_scal") (("1" (expand "abs" + 2) (("1" (assert) (("1" (replace -8) (("1" (case "2/(100*n+1) < norm(rgn)/n") (("1" (assert) nil nil) ("2" (hide (-1 2)) (("2" (case "norm(rgn) >= 1 - (1/(100*n+1))") (("1" (mult-by -1 "1/n") (("1" (case "(1 - (1 / (100 * n + 1))) * (1 / n) > 2/(100*n+1)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (field) nil nil)) nil)) nil)) nil) ("2" (lemma "norm_add_le") (("2" (inst - "rgn" "-ww") (("2" (case "norm(rgn+-ww) = 1/(100*n+1)") (("1" (rewrite "norm_neg") (("1" (assert) nil nil)) nil) ("2" (case "rgn+-ww = (1/(100*n+1))*zpn") (("1" (replace -1) (("1" (rewrite "norm_scal") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "rgn") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide (-1 -2 -3 -4)) (("2" (case "norm(rgn) <= 1 + 1/(100*n+1) AND norm(rgn) >= 1 - 1/(100*n+1)") (("1" (hide-all-but (-1 1)) (("1" (grind :exclude "norm") nil nil)) nil) ("2" (hide 2) (("2" (lemma "norm_add_le") (("2" (inst - "rgn" "ww-rgn") (("2" (assert) (("2" (case "rgn + (ww-rgn) = ww") (("1" (replace -1) (("1" (hide -1) (("1" (case "norm(ww-rgn) = 1/(100*n+1)") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (lemma "norm_add_le") (("1" (inst - "ww" "rgn-ww") (("1" (case "ww + (rgn-ww) = rgn") (("1" (replace -1) (("1" (hide -1) (("1" (case "norm(rgn-ww) = 1/(100*n+1)") (("1" (assert) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil) ("2" (case "rgn-ww = (1/(100*n+1))*zpn") (("1" (replace -1) (("1" (rewrite "norm_scal") (("1" (assert) (("1" (expand "abs") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "rgn") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "ww-rgn = (-1/(100*n+1))*zpn") (("1" (replace -1) (("1" (rewrite "norm_scal") (("1" (expand "abs") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "rgn") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (cross-mult 1) (("2" (cross-mult -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (hide-all-but (-2 -3 +)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (mult-by 1 "1/norm(rgn)") (("1" (grind :exclude "norm") nil nil)) nil) ("2" (mult-by 1 "1/norm(rgn)") (("2" (grind :exclude "norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) (("2" (case "rgn*vv1 > 0") (("1" (replace -2) (("1" (assert) nil nil)) nil) ("2" (mult-by -4 "1/(100*n+1)") (("2" (expand "rgn" 1) (("2" (hide-all-but (-6 -4 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (skeep -1) (("2" (inst + "^(zpn)") (("2" (assert) (("2" (typepred "^(zpn)") (("2" (assert) (("2" (mult-by -2 "1/norm(zpn)") (("2" (mult-by -3 "1/norm(zpn)") (("2" (expand "^") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "vv12def") (("2" (inst - "g") (("1" (assert) (("1" (case "sqv(g) = 1") (("1" (expand "sqv") (("1" (replace -1) (("1" (case "rp/=g") (("1" (case "rp*g < 1") (("1" (assert) (("1" (inst?) (("1" (flatten) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "schwarz_converse") (("2" (inst - "rp" "g") (("1" (reveal "normg") (("1" (replace -1) (("1" (reveal "normrp") (("1" (replace -1) (("1" (lemma "schwarz") (("1" (inst?) (("1" (replace -2) (("1" (replace -3) (("1" (reveal "rpgpos") (("1" (expand "abs") (("1" (assert) (("1" (case "g*rp = rp*g") (("1" (assert) (("1" (skeep -6) (("1" (case "cr = 1 OR cr = -1") (("1" (split -) (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (replace -1) (("2" (replace -7 :dir rl) (("2" (hide-all-but 1) (("2" (typepred "sqv(rp)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -6 :dir rl) (("2" (rewrite "norm_scal") (("2" (replace -4) (("2" (expand "abs") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "rpg") (("2" (assert) (("2" (flatten) (("2" (reveal "normg") (("2" (rewrite "sqrt_eq" 2 :dir rl) (("2" (rewrite "sqrt_sqv_norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (replace -1) (("2" (assert) (("2" (reveal "normg") (("2" (replace -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((both_sides_times1 formula-decl nil real_props nil) (Normalized type-eq-decl nil vectors_2D vectors) (^ const-decl "Normalized" vectors_2D vectors) (both_sides_times_pos_gt1 formula-decl nil real_props nil) (rgn skolem-const-decl "Vector" circle_optimum_2D nil) (div_mult_pos_ge1 formula-decl nil real_props nil) (div_mult_pos_gt1 formula-decl nil extra_real_props nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (dot_add_left formula-decl nil vectors_2D vectors) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (odd? const-decl "bool" integers nil) (odd_int nonempty-type-eq-decl nil integers nil) (rat nonempty-type-eq-decl nil rationals nil) (nz_nzv application-judgement "Nz_vector" vectors_2D vectors) (ZZtop skolem-const-decl "Vector" circle_optimum_2D nil) (norm_normalize formula-decl nil vectors_2D vectors) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (rp skolem-const-decl "Vect2" circle_optimum_2D nil) (orthonormal_basis formula-decl nil basis_2D vectors) (orthogonal? const-decl "bool" vectors_2D vectors) (perpR_eq_zero formula-decl nil perpendicular_2D vectors) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (add_neg_sub formula-decl nil vectors_2D vectors) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (div_mult_pos_neg_lt1 formula-decl nil extra_real_props nil) (sub_zero_right formula-decl nil vectors_2D vectors) (norm_zero formula-decl nil vectors_2D vectors) (norm_eq_0 formula-decl nil vectors_2D vectors) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}" real_defs nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (norm_scal formula-decl nil vectors_2D vectors) (abs_div formula-decl nil real_props nil) (minus_div1 formula-decl nil real_props nil) (times_div1 formula-decl nil real_props nil) (div_mult_pos_le1 formula-decl nil real_props nil) (lt_plus_lt2 formula-decl nil real_props nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (odd_times_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (norm_triangle formula-decl nil vectors_2D vectors) (sqrt_sqv_norm formula-decl nil vectors_2D vectors) (sqrt_1 formula-decl nil sqrt reals) (sqrt_pos application-judgement "posreal" sqrt reals) (sqrt_eq formula-decl nil sqrt reals) (both_sides_times1_imp formula-decl nil extra_real_props nil) (dot_scal_left formula-decl nil vectors_2D vectors) (dot_zero_left formula-decl nil vectors_2D vectors) (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (schwarz_converse formula-decl nil vectors_2D vectors) (dot_zero_right formula-decl nil vectors_2D vectors) (scal_1 formula-decl nil vectors_2D vectors) (scal_neg_1 formula-decl nil vectors_2D vectors) (TRUE const-decl "bool" booleans nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (nzrat_abs_is_pos application-judgement "{r: posrat | r >= q}" real_defs nil) (Nz_vector type-eq-decl nil vectors_2D vectors) (g skolem-const-decl "Vect2" circle_optimum_2D nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (div_mult_pos_neg_gt1 formula-decl nil extra_real_props nil) (zp skolem-const-decl "Vector" circle_optimum_2D nil) (norm_add_le formula-decl nil vectors_2D vectors) (add_cancel2 formula-decl nil vectors_2D vectors) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nnrat_plus_posrat_is_posrat application-judgement "posrat" rationals nil) (* const-decl "Vector" vectors_2D vectors) (+ const-decl "Vector" vectors_2D vectors) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (orthonormal? const-decl "bool" basis_2D vectors) (perpR const-decl "Vect2" perpendicular_2D vectors) (schwarz formula-decl nil vectors_2D vectors) (dot_sub_left formula-decl nil vectors_2D vectors) (real_minus_real_is_real application-judgement "real" reals nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil) (sqv const-decl "nnreal" vectors_2D vectors) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (<= const-decl "bool" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (ww skolem-const-decl "Nz_vect2" circle_optimum_2D nil) (vv1 skolem-const-decl "Nz_vect2" circle_optimum_2D nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (div_mult_pos_ge2 formula-decl nil real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (div_mult_pos_lt2 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (times_div2 formula-decl nil real_props nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (archimedean formula-decl nil real_props nil) (- const-decl "[numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (vv2 skolem-const-decl "Nz_vect2" circle_optimum_2D nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (- const-decl "Vector" vectors_2D vectors) (numfield nonempty-type-eq-decl nil number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (dot_gt_dot_equals_slice_intersection formula-decl nil circle_optimum_2D nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (norm_neg formula-decl nil vectors_2D vectors) (neg_nzv application-judgement "Nz_vector" vectors_2D vectors) (> const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (- const-decl "Vector" vectors_2D vectors) (nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors) (real nonempty-type-from-decl nil reals nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (>= const-decl "bool" reals nil) (Vector type-eq-decl nil vectors_2D vectors) (* const-decl "real" vectors_2D vectors) (= const-decl "[T, T -> boolean]" equalities nil) (nnreal type-eq-decl nil real_types nil) (norm const-decl "nnreal" vectors_2D vectors) (/= const-decl "boolean" notequal nil) (zero const-decl "Vector" vectors_2D vectors) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (IFF const-decl "[bool, bool -> bool]" booleans nil)) nil) (dot_gt_dot_equals_slice_union-4 nil 3529331582 ("" (case "FORALL (g, rp: Vect2):
                                                                                                          rp * g >= 0 AND norm(g) = 1 AND norm(rp) = 1 IMPLIES
                                                                                                           (EXISTS (vv1, vv2: Nz_vect2):
                                                                                                              norm(vv1) = 1 AND
                                                                                                               norm(vv2) = 1 AND
                                                                                                                g * vv1 = g * vv2 AND
                                                                                                                 (FORALL (ww: Nz_vect2):
                                                                                                                    norm(ww) = 1 IMPLIES
                                                                                                                     (ww * g >= rp * g IFF (ww * vv1 >= 0 AND ww * vv2 >= 0))))") (("1" (skeep) (("1" (inst - "-g" "rp") (("1" (assert) (("1" (case "NOT rp*-g >= 0") (("1" (hide-all-but (-2 1)) (("1" (grind) nil nil)) nil) ("2" (assert) (("2" (skeep -2) (("2" (inst + "-vv1" "-vv2") (("2" (assert) (("2" (split +) (("1" (hide-all-but (-4 1)) (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (inst - "ww") (("2" (assert) (("2" (case "(ww*g > rp*g IFF (NOT ww*-g >= rp*-g)) AND ((ww * -vv1 > 0 OR ww * -vv2 > 0) IFF (NOT (ww * vv1 >= 0 AND ww * vv2 >= 0)))") (("1" (ground) nil nil) ("2" (hide (-6 2)) (("2" (hide -) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "dot_gt_dot_equals_slice_intersection") (("2" (skeep) (("2" (label "normg" -3) (("2" (label "rpgpos" -2) (("2" (inst - "g" "rp") (("2" (assert) (("2" (case "NOT rp = g") (("1" (label "rpg" 1) (("1" (hide "rpg") (("1" (skeep -1) (("1" (inst + "vv1" "vv2") (("1" (assert) (("1" (label "vv12def" -4) (("1" (skeep) (("1" (split) (("1" (flatten) (("1" (case "NOT ww*g = rp*g") (("1" (inst - "ww") (("1" (assert) (("1" (ground) nil nil)) nil)) nil) ("2" (hide -2) (("2" (case "FORALL (n:posnat): EXISTS (wwn:Nz_vect2): norm(wwn) = 1 AND norm(ww-wwn)<1/n AND wwn*g > rp*g") (("1" (split +) (("1" (case "FORALL (n:posnat): ww*vv1 >= (-1/n)*norm(vv1)") (("1" (hide-all-but (-1 1)) (("1" (lemma "archimedean") (("1" (inst - "(-(ww*vv1))/norm(vv1)") (("1" (skeep -1) (("1" (inst - "n") (("1" (cross-mult -1) (("1" (cross-mult -2) nil nil)) nil)) nil)) nil) ("2" (case "FORALL (rx:real): rx > 0 IMPLIES (rx>=0 AND rx>0)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst - "n") (("2" (skeep -1) (("2" (inst - "wwn") (("2" (assert) (("2" (case "abs(wwn*vv1) <= ww*vv1 + norm(vv1)/n") (("1" (flatten) (("1" (hide-all-but (-1 -9 +)) (("1" (grind :exclude ("norm" "*")) nil nil)) nil)) nil) ("2" (lemma "schwarz") (("2" (inst - "wwn-ww" "vv1") (("2" (case "norm(wwn-ww) < 1/n") (("1" (mult-by -1 "norm(vv1)") (("1" (rewrite "dot_sub_left" -2) (("1" (expand "abs" +) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (n:posnat): ww*vv2 >= (-1/n)*norm(vv2)") (("1" (hide-all-but (-1 1)) (("1" (lemma "archimedean") (("1" (inst - "(-(ww*vv2))/norm(vv2)") (("1" (skeep -1) (("1" (inst - "n") (("1" (cross-mult -1) (("1" (cross-mult -2) nil nil)) nil)) nil)) nil) ("2" (case "FORALL (rx:real): rx > 0 IMPLIES (rx>=0 AND rx>0)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst - "n") (("2" (skeep -1) (("2" (inst - "wwn") (("2" (assert) (("2" (case "abs(wwn*vv2) <= ww*vv2 + norm(vv2)/n") (("1" (flatten) (("1" (hide-all-but (-1 -10 +)) (("1" (grind :exclude ("norm" "*")) nil nil)) nil)) nil) ("2" (lemma "schwarz") (("2" (inst - "wwn-ww" "vv2") (("2" (case "norm(wwn-ww) < 1/n") (("1" (mult-by -1 "norm(vv2)") (("1" (rewrite "dot_sub_left" -2) (("1" (expand "abs" +) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide-all-but (-1 -7 -8 -9 1)) (("2" (lemma "orthonormal_basis") (("2" (inst - "g" "perpR(g)" _) (("2" (inst-cp - "ww") (("2" (inst-cp - "rp") (("2" (assert) (("2" (case "orthonormal?(g,perpR(g))") (("1" (assert) (("1" (name "zp" "(ww*g + 1/(100*n+1))*g + (ww*perpR(g))*perpR(g)") (("1" (case "norm(ww-zp) = 1/(100*n+1)") (("1" (case "norm(zp) <= 1 + 1/(100*n+1)") (("1" (case "norm(zp) >= 1-1/(100*n+1)") (("1" (inst + "(1/norm(zp))*zp") (("1" (split +) (("1" (rewrite "norm_scal") (("1" (expand "abs") (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (cross-mult -1) (("1" (assert) (("1" (ground) (("1" (lemma "norm_eq_0") (("1" (inst?) (("1" (assert) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_triangle") (("2" (inst - "ww" "zp" "(1/norm(zp))*zp") (("2" (case "norm(zp-(1/norm(zp))*zp) < 1/n - 1/(100*n+1)") (("1" (assert) (("1" (replace -5 -1 :dir rl) (("1" (assert) nil nil)) nil)) nil) ("2" (case "NOT norm(zp-(1/norm(zp))*zp) = abs(norm(zp)-1)") (("1" (hide-all-but (-2 -3 1)) (("1" (case "zp - (1/norm(zp))*zp = ((norm(zp)-1)/norm(zp))*zp") (("1" (replace -1) (("1" (rewrite "norm_scal") (("1" (rewrite "abs_div") (("1" (expand "abs" + 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind :exclude "norm") nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide-all-but (-3 -4 1)) (("2" (case "1/(100*n+1) < 1/n - 1/(100*n+1)") (("1" (grind :exclude "norm") nil nil) ("2" (assert) (("2" (hide 2) (("2" (real-props) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case "(1/norm(zp))*zp*g = (1/norm(zp))*(ww*g + 1/(100*n+1))") (("1" (replace -1) (("1" (cross-mult 1) (("1" (assert) (("1" (ground) (("1" (replace -11) (("1" (mult-by -4 "rp*g") (("1" (case "rp*g <1 ") (("1" (mult-by -1 "1/(100*n+1)") (("1" (assert) nil nil)) nil) ("2" (lemma "schwarz") (("2" (inst?) (("2" (expand "abs") (("2" (assert) (("2" (case "NOT rp*g = 1") (("1" (assert) nil nil) ("2" (lemma "schwarz_converse") (("2" (inst?) (("1" (assert) (("1" (skeep -1) (("1" (replace -1 -16 :dir rl) (("1" (rewrite "norm_scal") (("1" (replace -15) (("1" (assert) (("1" (case "cr = 1") (("1" (replace -1) (("1" (assert) (("1" (reveal "rpg") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "abs") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (ground) (("2" (case "cr = -1") (("1" (replace -1) (("1" (assert) (("1" (replace -4 :dir rl) (("1" (hide-all-but -5) (("1" (typepred "sqv(g)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "zp" + 2) (("2" (case "sqv(g) = 1") (("1" (hide-all-but (-1 1)) (("1" (mult-by -1 "(ww * g + 1 / (1 + 100 * n))") (("1" (grind :exclude "norm") nil nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "sqrt_eq" 1 :dir rl) (("2" (rewrite "sqrt_sqv_norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst - "1/(norm(zp))*zp") (("2" (assert) (("2" (rewrite "norm_scal") (("2" (rewrite "abs_div") (("2" (expand "abs" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (lemma "norm_eq_0") (("3" (inst?) (("3" (assert) (("3" (replace -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "ww-zp = -(1/(100*n+1))*g") (("1" (lemma "norm_add_le") (("1" (inst - "ww-zp" "zp") (("1" (assert) (("1" (replace -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -7 1) (("2" (expand "zp" +) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_add_le") (("2" (inst - "ww" "zp-ww") (("2" (assert) (("2" (case "ww + (zp-ww) = zp") (("1" (replace -1) (("1" (case "zp-ww = -(ww-zp)") (("1" (replace -1) (("1" (rewrite "norm_neg") (("1" (assert) (("1" (replace -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "ww-zp = -(1/(100*n+1))*g") (("1" (replace -1) (("1" (rewrite "norm_scal") (("1" (expand "abs") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -5) (("2" (expand "zp" +) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (expand "orthonormal?") (("2" (split +) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide -2) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "FORALL (n:posnat): EXISTS (wwn:Nz_vect2): norm(wwn) = 1 AND norm(wwn-ww)<1/n AND wwn*vv1 > 0 AND wwn*vv2 > 0") (("1" (case "FORALL (n:posnat): ww*g >= rp*g - norm(g)/n") (("1" (hide-all-but (-1 1)) (("1" (lemma "archimedean") (("1" (inst - "(rp*g - ww*g)/norm(g)") (("1" (skeep -1) (("1" (inst - "n") (("1" (cross-mult -1) (("1" (cross-mult 1) (("1" (mult-by -2 "n") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (a:real): a> 0 IMPLIES (a>=0 AND a>0)") (("1" (rewrite -1) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (inst - "n") (("2" (skeep -1) (("2" (inst - "wwn") (("2" (assert) (("2" (case "ww*g >= wwn*g - norm(g)/n") (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "schwarz") (("2" (inst - "wwn-ww" "g") (("2" (mult-by -3 "norm(g)") (("2" (rewrite "dot_sub_left") (("2" (expand "abs") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-6 -7 -8 -9 2)) (("2" (case "EXISTS (zpn:Nz_vect2): zpn*vv1 > 0 AND zpn*vv2 > 0") (("1" (case "EXISTS (zpn:Nz_vect2): norm(zpn) = 1 AND zpn*vv1 > 0 AND zpn*vv2 > 0") (("1" (hide -2) (("1" (skeep -1) (("1" (skeep) (("1" (name "rgn" "ww + (1/(100*n+1))*zpn") (("1" (case "rgn /= zero") (("1" (case "norm(rgn)>0") (("1" (flatten) (("1" (name "ZZtop" "(1/norm(rgn))*rgn") (("1" (inst + "ZZtop") (("1" (case "NOT norm(ZZtop) = 1") (("1" (hide 3) (("1" (typepred "^(rgn)") (("1" (expand "^" -1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "NOT (ZZtop*vv1 > 0 AND ZZtop*vv2>0)") (("1" (hide 3) (("1" (expand "ZZtop" 1) (("1" (assert) (("1" (case "rgn*vv1 > 0 AND rgn*vv2>0") (("1" (flatten) (("1" (mult-by -1 "1/norm(rgn)") (("1" (mult-by -2 "1/norm(rgn)") (("1" (assert) nil nil) ("2" (assert) (("2" (split +) (("1" (cross-mult 1) nil nil) ("2" (cross-mult 1) nil nil)) nil)) nil)) nil) ("2" (split) (("1" (cross-mult 1) nil nil) ("2" (cross-mult 1) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "rgn" 1) (("2" (rewrite "dot_add_left") (("2" (rewrite "dot_add_left") (("2" (mult-by -6 "1/(100*n+1)") (("2" (mult-by -7 "1/(100*n+1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (assert) (("2" (case "NOT ZZtop - ww = (1/norm(rgn))*((1-norm(rgn))*ww + (1/(100*n+1))*zpn)") (("1" (hide-all-but (-5 1)) (("1" (expand "ZZtop") (("1" (expand "rgn " + 2) (("1" (grind :exclude "norm") nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (rewrite "norm_scal") (("2" (rewrite "abs_div") (("2" (expand "abs") (("2" (case "FORALL (rz:real): rz < norm(rgn)/n IMPLIES (1/norm(rgn))*rz < 1/n") (("1" (rewrite -1) (("1" (hide 3) (("1" (hide -1) (("1" (lemma "norm_add_le") (("1" (inst?) (("1" (case "norm((1 - norm(rgn)) * ww) + norm((1 / (1 + 100 * n)) * zpn) < norm(rgn)/n") (("1" (assert) nil nil) ("2" (hide (-1 2)) (("2" (rewrite "norm_scal") (("2" (case "abs(1-norm(rgn))<=1/(100*n+1)") (("1" (replace -16) (("1" (rewrite "norm_scal") (("1" (expand "abs" + 2) (("1" (assert) (("1" (replace -8) (("1" (case "2/(100*n+1) < norm(rgn)/n") (("1" (assert) nil nil) ("2" (hide (-1 2)) (("2" (case "norm(rgn) >= 1 - (1/(100*n+1))") (("1" (mult-by -1 "1/n") (("1" (case "(1 - (1 / (100 * n + 1))) * (1 / n) > 2/(100*n+1)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (field) nil nil)) nil)) nil)) nil) ("2" (lemma "norm_add_le") (("2" (inst - "rgn" "-ww") (("2" (case "norm(rgn+-ww) = 1/(100*n+1)") (("1" (rewrite "norm_neg") (("1" (assert) nil nil)) nil) ("2" (case "rgn+-ww = (1/(100*n+1))*zpn") (("1" (replace -1) (("1" (rewrite "norm_scal") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "rgn") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide (-1 -2 -3 -4)) (("2" (case "norm(rgn) <= 1 + 1/(100*n+1) AND norm(rgn) >= 1 - 1/(100*n+1)") (("1" (hide-all-but (-1 1)) (("1" (grind :exclude "norm") nil nil)) nil) ("2" (hide 2) (("2" (lemma "norm_add_le") (("2" (inst - "rgn" "ww-rgn") (("2" (assert) (("2" (case "rgn + (ww-rgn) = ww") (("1" (replace -1) (("1" (hide -1) (("1" (case "norm(ww-rgn) = 1/(100*n+1)") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (lemma "norm_add_le") (("1" (inst - "ww" "rgn-ww") (("1" (case "ww + (rgn-ww) = rgn") (("1" (replace -1) (("1" (hide -1) (("1" (case "norm(rgn-ww) = 1/(100*n+1)") (("1" (assert) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil) ("2" (case "rgn-ww = (1/(100*n+1))*zpn") (("1" (replace -1) (("1" (rewrite "norm_scal") (("1" (assert) (("1" (expand "abs") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "rgn") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "ww-rgn = (-1/(100*n+1))*zpn") (("1" (replace -1) (("1" (rewrite "norm_scal") (("1" (expand "abs") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "rgn") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (cross-mult 1) (("2" (cross-mult -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (hide-all-but (-2 -3 +)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (mult-by 1 "1/norm(rgn)") (("1" (grind :exclude "norm") nil nil)) nil) ("2" (mult-by 1 "1/norm(rgn)") (("2" (grind :exclude "norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) (("2" (case "rgn*vv1 > 0") (("1" (replace -2) (("1" (assert) nil nil)) nil) ("2" (mult-by -4 "1/(100*n+1)") (("2" (expand "rgn" 1) (("2" (hide-all-but (-6 -4 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (skeep -1) (("2" (inst + "^(zpn)") (("2" (assert) (("2" (typepred "^(zpn)") (("2" (assert) (("2" (mult-by -2 "1/norm(zpn)") (("2" (mult-by -3 "1/norm(zpn)") (("2" (expand "^") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "vv12def") (("2" (inst - "g") (("1" (assert) (("1" (case "sqv(g) = 1") (("1" (expand "sqv") (("1" (replace -1) (("1" (case "rp/=g") (("1" (case "rp*g < 1") (("1" (assert) (("1" (inst?) (("1" (flatten) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "schwarz_converse") (("2" (inst - "rp" "g") (("1" (reveal "normg") (("1" (replace -1) (("1" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (dot_gt_dot_equals_slice_union-3 nil 3529330582 ("" (case "FORALL (g, rp: Vect2):
                                                                                                   rp * g >= 0 AND norm(g) = 1 AND norm(rp) = 1 IMPLIES
                                                                                                    (EXISTS (vv1, vv2: Nz_vect2):
                                                                                                       norm(vv1) = 1 AND
                                                                                                        norm(vv2) = 1 AND
                                                                                                         g * vv1 = g * vv2 AND
                                                                                                          (FORALL (ww: Nz_vect2):
                                                                                                             norm(ww) = 1 IMPLIES
                                                                                                              (ww * g >= rp * g IFF (ww * vv1 >= 0 AND ww * vv2 >= 0))))") (("1" (skeep) (("1" (inst - "-g" "rp") (("1" (assert) (("1" (case "NOT rp*-g >= 0") (("1" (hide-all-but (-2 1)) (("1" (grind) nil nil)) nil) ("2" (assert) (("2" (skeep -2) (("2" (inst + "-vv1" "-vv2") (("2" (assert) (("2" (split +) (("1" (hide-all-but (-4 1)) (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (inst - "ww") (("2" (assert) (("2" (case "(ww*g > rp*g IFF (NOT ww*-g >= rp*-g)) AND ((ww * -vv1 > 0 OR ww * -vv2 > 0) IFF (NOT (ww * vv1 >= 0 AND ww * vv2 >= 0)))") (("1" (ground) nil nil) ("2" (hide (-6 2)) (("2" (hide -) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "dot_gt_dot_equals_slice_intersection") (("2" (skeep) (("2" (label "rpgpos" -2) (("2" (inst - "g" "rp") (("2" (assert) (("2" (case "NOT rp = g") (("1" (label "rpg" 1) (("1" (hide "rpg") (("1" (skeep -1) (("1" (inst + "vv1" "vv2") (("1" (assert) (("1" (label "vv12def" -4) (("1" (skeep) (("1" (split) (("1" (flatten) (("1" (case "NOT ww*g = rp*g") (("1" (inst - "ww") (("1" (assert) (("1" (ground) nil nil)) nil)) nil) ("2" (hide -2) (("2" (case "FORALL (n:posnat): EXISTS (wwn:Nz_vect2): norm(wwn) = 1 AND norm(ww-wwn)<1/n AND wwn*g > rp*g") (("1" (split +) (("1" (case "FORALL (n:posnat): ww*vv1 >= (-1/n)*norm(vv1)") (("1" (hide-all-but (-1 1)) (("1" (lemma "archimedean") (("1" (inst - "(-(ww*vv1))/norm(vv1)") (("1" (skeep -1) (("1" (inst - "n") (("1" (cross-mult -1) (("1" (cross-mult -2) nil nil)) nil)) nil)) nil) ("2" (case "FORALL (rx:real): rx > 0 IMPLIES (rx>=0 AND rx>0)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst - "n") (("2" (skeep -1) (("2" (inst - "wwn") (("2" (assert) (("2" (case "abs(wwn*vv1) <= ww*vv1 + norm(vv1)/n") (("1" (flatten) (("1" (hide-all-but (-1 -9 +)) (("1" (grind :exclude ("norm" "*")) nil nil)) nil)) nil) ("2" (lemma "schwarz") (("2" (inst - "wwn-ww" "vv1") (("2" (case "norm(wwn-ww) < 1/n") (("1" (mult-by -1 "norm(vv1)") (("1" (rewrite "dot_sub_left" -2) (("1" (expand "abs" +) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (n:posnat): ww*vv2 >= (-1/n)*norm(vv2)") (("1" (hide-all-but (-1 1)) (("1" (lemma "archimedean") (("1" (inst - "(-(ww*vv2))/norm(vv2)") (("1" (skeep -1) (("1" (inst - "n") (("1" (cross-mult -1) (("1" (cross-mult -2) nil nil)) nil)) nil)) nil) ("2" (case "FORALL (rx:real): rx > 0 IMPLIES (rx>=0 AND rx>0)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst - "n") (("2" (skeep -1) (("2" (inst - "wwn") (("2" (assert) (("2" (case "abs(wwn*vv2) <= ww*vv2 + norm(vv2)/n") (("1" (flatten) (("1" (hide-all-but (-1 -10 +)) (("1" (grind :exclude ("norm" "*")) nil nil)) nil)) nil) ("2" (lemma "schwarz") (("2" (inst - "wwn-ww" "vv2") (("2" (case "norm(wwn-ww) < 1/n") (("1" (mult-by -1 "norm(vv2)") (("1" (rewrite "dot_sub_left" -2) (("1" (expand "abs" +) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide-all-but (-1 -7 -8 -9 1)) (("2" (lemma "orthonormal_basis") (("2" (inst - "g" "perpR(g)" _) (("2" (inst-cp - "ww") (("2" (inst-cp - "rp") (("2" (assert) (("2" (case "orthonormal?(g,perpR(g))") (("1" (assert) (("1" (name "zp" "(ww*g + 1/(100*n+1))*g + (ww*perpR(g))*perpR(g)") (("1" (case "norm(ww-zp) = 1/(100*n+1)") (("1" (case "norm(zp) <= 1 + 1/(100*n+1)") (("1" (case "norm(zp) >= 1-1/(100*n+1)") (("1" (inst + "(1/norm(zp))*zp") (("1" (split +) (("1" (rewrite "norm_scal") (("1" (expand "abs") (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (cross-mult -1) (("1" (assert) (("1" (ground) (("1" (lemma "norm_eq_0") (("1" (inst?) (("1" (assert) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_triangle") (("2" (inst - "ww" "zp" "(1/norm(zp))*zp") (("2" (case "norm(zp-(1/norm(zp))*zp) < 1/n - 1/(100*n+1)") (("1" (assert) (("1" (replace -5 -1 :dir rl) (("1" (assert) nil nil)) nil)) nil) ("2" (case "NOT norm(zp-(1/norm(zp))*zp) = abs(norm(zp)-1)") (("1" (hide-all-but (-2 -3 1)) (("1" (case "zp - (1/norm(zp))*zp = ((norm(zp)-1)/norm(zp))*zp") (("1" (replace -1) (("1" (rewrite "norm_scal") (("1" (rewrite "abs_div") (("1" (expand "abs" + 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind :exclude "norm") nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide-all-but (-3 -4 1)) (("2" (case "1/(100*n+1) < 1/n - 1/(100*n+1)") (("1" (grind :exclude "norm") nil nil) ("2" (assert) (("2" (hide 2) (("2" (real-props) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case "(1/norm(zp))*zp*g = (1/norm(zp))*(ww*g + 1/(100*n+1))") (("1" (replace -1) (("1" (cross-mult 1) (("1" (assert) (("1" (ground) (("1" (replace -11) (("1" (mult-by -4 "rp*g") (("1" (case "rp*g <1 ") (("1" (mult-by -1 "1/(100*n+1)") (("1" (assert) nil nil)) nil) ("2" (lemma "schwarz") (("2" (inst?) (("2" (expand "abs") (("2" (assert) (("2" (case "NOT rp*g = 1") (("1" (assert) nil nil) ("2" (lemma "schwarz_converse") (("2" (inst?) (("1" (assert) (("1" (skeep -1) (("1" (replace -1 -16 :dir rl) (("1" (rewrite "norm_scal") (("1" (replace -15) (("1" (assert) (("1" (case "cr = 1") (("1" (replace -1) (("1" (assert) (("1" (reveal "rpg") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "abs") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (ground) (("2" (case "cr = -1") (("1" (replace -1) (("1" (assert) (("1" (replace -4 :dir rl) (("1" (hide-all-but -5) (("1" (typepred "sqv(g)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "zp" + 2) (("2" (case "sqv(g) = 1") (("1" (hide-all-but (-1 1)) (("1" (mult-by -1 "(ww * g + 1 / (1 + 100 * n))") (("1" (grind :exclude "norm") nil nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "sqrt_eq" 1 :dir rl) (("2" (rewrite "sqrt_sqv_norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst - "1/(norm(zp))*zp") (("2" (assert) (("2" (rewrite "norm_scal") (("2" (rewrite "abs_div") (("2" (expand "abs" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (lemma "norm_eq_0") (("3" (inst?) (("3" (assert) (("3" (replace -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "ww-zp = -(1/(100*n+1))*g") (("1" (lemma "norm_add_le") (("1" (inst - "ww-zp" "zp") (("1" (assert) (("1" (replace -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -7 1) (("2" (expand "zp" +) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_add_le") (("2" (inst - "ww" "zp-ww") (("2" (assert) (("2" (case "ww + (zp-ww) = zp") (("1" (replace -1) (("1" (case "zp-ww = -(ww-zp)") (("1" (replace -1) (("1" (rewrite "norm_neg") (("1" (assert) (("1" (replace -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "ww-zp = -(1/(100*n+1))*g") (("1" (replace -1) (("1" (rewrite "norm_scal") (("1" (expand "abs") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -5) (("2" (expand "zp" +) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (expand "orthonormal?") (("2" (split +) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide -2) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "FORALL (n:posnat): EXISTS (wwn:Nz_vect2): norm(wwn) = 1 AND norm(wwn-ww)<1/n AND wwn*vv1 > 0 AND wwn*vv2 > 0") (("1" (case "FORALL (n:posnat): ww*g >= rp*g - norm(g)/n") (("1" (hide-all-but (-1 1)) (("1" (lemma "archimedean") (("1" (inst - "(rp*g - ww*g)/norm(g)") (("1" (skeep -1) (("1" (inst - "n") (("1" (cross-mult -1) (("1" (cross-mult 1) (("1" (mult-by -2 "n") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (a:real): a> 0 IMPLIES (a>=0 AND a>0)") (("1" (rewrite -1) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (inst - "n") (("2" (skeep -1) (("2" (inst - "wwn") (("2" (assert) (("2" (case "ww*g >= wwn*g - norm(g)/n") (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "schwarz") (("2" (inst - "wwn-ww" "g") (("2" (mult-by -3 "norm(g)") (("2" (rewrite "dot_sub_left") (("2" (expand "abs") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-6 -7 -8 -9 2)) (("2" (case "EXISTS (zpn:Nz_vect2): zpn*vv1 > 0 AND zpn*vv2 > 0") (("1" (case "EXISTS (zpn:Nz_vect2): norm(zpn) = 1 AND zpn*vv1 > 0 AND zpn*vv2 > 0") (("1" (hide -2) (("1" (skeep -1) (("1" (skeep) (("1" (name "rgn" "ww + (1/(100*n+1))*zpn") (("1" (case "rgn /= zero") (("1" (case "norm(rgn)>0") (("1" (flatten) (("1" (name "ZZtop" "(1/norm(rgn))*rgn") (("1" (inst + "ZZtop") (("1" (case "NOT norm(ZZtop) = 1") (("1" (hide 3) (("1" (typepred "^(rgn)") (("1" (expand "^" -1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "NOT (ZZtop*vv1 > 0 AND ZZtop*vv2>0)") (("1" (hide 3) (("1" (expand "ZZtop" 1) (("1" (assert) (("1" (case "rgn*vv1 > 0 AND rgn*vv2>0") (("1" (flatten) (("1" (mult-by -1 "1/norm(rgn)") (("1" (mult-by -2 "1/norm(rgn)") (("1" (assert) nil nil) ("2" (assert) (("2" (split +) (("1" (cross-mult 1) nil nil) ("2" (cross-mult 1) nil nil)) nil)) nil)) nil) ("2" (split) (("1" (cross-mult 1) nil nil) ("2" (cross-mult 1) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "rgn" 1) (("2" (rewrite "dot_add_left") (("2" (rewrite "dot_add_left") (("2" (mult-by -6 "1/(100*n+1)") (("2" (mult-by -7 "1/(100*n+1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (assert) (("2" (case "NOT ZZtop - ww = (1/norm(rgn))*((1-norm(rgn))*ww + (1/(100*n+1))*zpn)") (("1" (hide-all-but (-5 1)) (("1" (expand "ZZtop") (("1" (expand "rgn " + 2) (("1" (grind :exclude "norm") nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (rewrite "norm_scal") (("2" (rewrite "abs_div") (("2" (expand "abs") (("2" (case "FORALL (rz:real): rz < norm(rgn)/n IMPLIES (1/norm(rgn))*rz < 1/n") (("1" (rewrite -1) (("1" (hide 3) (("1" (hide -1) (("1" (lemma "norm_add_le") (("1" (inst?) (("1" (case "norm((1 - norm(rgn)) * ww) + norm((1 / (1 + 100 * n)) * zpn) < norm(rgn)/n") (("1" (assert) nil nil) ("2" (hide (-1 2)) (("2" (rewrite "norm_scal") (("2" (case "abs(1-norm(rgn))<=1/(100*n+1)") (("1" (replace -16) (("1" (rewrite "norm_scal") (("1" (expand "abs" + 2) (("1" (assert) (("1" (replace -8) (("1" (case "2/(100*n+1) < norm(rgn)/n") (("1" (assert) nil nil) ("2" (hide (-1 2)) (("2" (case "norm(rgn) >= 1 - (1/(100*n+1))") (("1" (mult-by -1 "1/n") (("1" (case "(1 - (1 / (100 * n + 1))) * (1 / n) > 2/(100*n+1)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (field) nil nil)) nil)) nil)) nil) ("2" (lemma "norm_add_le") (("2" (inst - "rgn" "-ww") (("2" (case "norm(rgn+-ww) = 1/(100*n+1)") (("1" (rewrite "norm_neg") (("1" (assert) nil nil)) nil) ("2" (case "rgn+-ww = (1/(100*n+1))*zpn") (("1" (replace -1) (("1" (rewrite "norm_scal") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "rgn") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide (-1 -2 -3 -4)) (("2" (case "norm(rgn) <= 1 + 1/(100*n+1) AND norm(rgn) >= 1 - 1/(100*n+1)") (("1" (hide-all-but (-1 1)) (("1" (grind :exclude "norm") nil nil)) nil) ("2" (hide 2) (("2" (lemma "norm_add_le") (("2" (inst - "rgn" "ww-rgn") (("2" (assert) (("2" (case "rgn + (ww-rgn) = ww") (("1" (replace -1) (("1" (hide -1) (("1" (case "norm(ww-rgn) = 1/(100*n+1)") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (lemma "norm_add_le") (("1" (inst - "ww" "rgn-ww") (("1" (case "ww + (rgn-ww) = rgn") (("1" (replace -1) (("1" (hide -1) (("1" (case "norm(rgn-ww) = 1/(100*n+1)") (("1" (assert) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil) ("2" (case "rgn-ww = (1/(100*n+1))*zpn") (("1" (replace -1) (("1" (rewrite "norm_scal") (("1" (assert) (("1" (expand "abs") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "rgn") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "ww-rgn = (-1/(100*n+1))*zpn") (("1" (replace -1) (("1" (rewrite "norm_scal") (("1" (expand "abs") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "rgn") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (cross-mult 1) (("2" (cross-mult -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (hide-all-but (-2 -3 +)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (mult-by 1 "1/norm(rgn)") (("1" (grind :exclude "norm") nil nil)) nil) ("2" (mult-by 1 "1/norm(rgn)") (("2" (grind :exclude "norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) (("2" (case "rgn*vv1 > 0") (("1" (replace -2) (("1" (assert) nil nil)) nil) ("2" (mult-by -4 "1/(100*n+1)") (("2" (expand "rgn" 1) (("2" (hide-all-but (-6 -4 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (skeep -1) (("2" (inst + "^(zpn)") (("2" (assert) (("2" (typepred "^(zpn)") (("2" (assert) (("2" (mult-by -2 "1/norm(zpn)") (("2" (mult-by -3 "1/norm(zpn)") (("2" (expand "^") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "vv12def") (("2" (inst - "g") (("1" (assert) (("1" (case "sqv(g) = 1") (("1" (expand "sqv") (("1" (replace -1) (("1" (case "rp/=g") (("1" (case "rp*g < 1") (("1" (assert) (("1" (inst?) (("1" (flatten) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "schwarz_converse") (("2" (inst - "rp" "g") (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (dot_gt_dot_equals_slice_union-2 nil 3529231112 ("" (case "FORALL (g, rp: Vect2):
                                                                                            rp * g >= 0 AND norm(g) = 1 AND norm(rp) = 1 IMPLIES
                                                                                             (EXISTS (vv1, vv2: Nz_vect2):
                                                                                                norm(vv1) = 1 AND
                                                                                                 norm(vv2) = 1 AND
                                                                                                  g * vv1 = g * vv2 AND
                                                                                                   (FORALL (ww: Nz_vect2):
                                                                                                      norm(ww) = 1 IMPLIES
                                                                                                       (ww * g >= rp * g IFF (ww * vv1 >= 0 AND ww * vv2 >= 0))))") (("1" (skeep) (("1" (inst - "-g" "rp") (("1" (assert) (("1" (case "NOT rp*-g >= 0") (("1" (hide-all-but (-2 1)) (("1" (grind) nil nil)) nil) ("2" (assert) (("2" (skeep -2) (("2" (inst + "-vv1" "-vv2") (("2" (assert) (("2" (split +) (("1" (hide-all-but (-4 1)) (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (inst - "ww") (("2" (assert) (("2" (case "(ww*g > rp*g IFF (NOT ww*-g >= rp*-g)) AND ((ww * -vv1 > 0 OR ww * -vv2 > 0) IFF (NOT (ww * vv1 >= 0 AND ww * vv2 >= 0)))") (("1" (ground) nil nil) ("2" (hide (-6 2)) (("2" (hide -) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "dot_gt_dot_equals_slice_intersection") (("2" (skeep) (("2" (label "rpgpos" -2) (("2" (inst - "g" "rp") (("2" (assert) (("2" (case "NOT rp = g") (("1" (label "rpg" 1) (("1" (hide "rpg") (("1" (skeep -1) (("1" (inst + "vv1" "vv2") (("1" (assert) (("1" (skeep) (("1" (split) (("1" (flatten) (("1" (case "NOT ww*g = rp*g") (("1" (inst - "ww") (("1" (assert) (("1" (ground) nil nil)) nil)) nil) ("2" (hide -2) (("2" (case "FORALL (n:posnat): EXISTS (wwn:Nz_vect2): norm(wwn) = 1 AND norm(ww-wwn)<1/n AND wwn*g > rp*g") (("1" (split +) (("1" (case "FORALL (n:posnat): ww*vv1 >= (-1/n)*norm(vv1)") (("1" (hide-all-but (-1 1)) (("1" (lemma "archimedean") (("1" (inst - "(-(ww*vv1))/norm(vv1)") (("1" (skeep -1) (("1" (inst - "n") (("1" (cross-mult -1) (("1" (cross-mult -2) nil nil)) nil)) nil)) nil) ("2" (case "FORALL (rx:real): rx > 0 IMPLIES (rx>=0 AND rx>0)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst - "n") (("2" (skeep -1) (("2" (inst - "wwn") (("2" (assert) (("2" (case "abs(wwn*vv1) <= ww*vv1 + norm(vv1)/n") (("1" (flatten) (("1" (hide-all-but (-1 -9 +)) (("1" (grind :exclude ("norm" "*")) nil nil)) nil)) nil) ("2" (lemma "schwarz") (("2" (inst - "wwn-ww" "vv1") (("2" (case "norm(wwn-ww) < 1/n") (("1" (mult-by -1 "norm(vv1)") (("1" (rewrite "dot_sub_left" -2) (("1" (expand "abs" +) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (n:posnat): ww*vv2 >= (-1/n)*norm(vv2)") (("1" (hide-all-but (-1 1)) (("1" (lemma "archimedean") (("1" (inst - "(-(ww*vv2))/norm(vv2)") (("1" (skeep -1) (("1" (inst - "n") (("1" (cross-mult -1) (("1" (cross-mult -2) nil nil)) nil)) nil)) nil) ("2" (case "FORALL (rx:real): rx > 0 IMPLIES (rx>=0 AND rx>0)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst - "n") (("2" (skeep -1) (("2" (inst - "wwn") (("2" (assert) (("2" (case "abs(wwn*vv2) <= ww*vv2 + norm(vv2)/n") (("1" (flatten) (("1" (hide-all-but (-1 -10 +)) (("1" (grind :exclude ("norm" "*")) nil nil)) nil)) nil) ("2" (lemma "schwarz") (("2" (inst - "wwn-ww" "vv2") (("2" (case "norm(wwn-ww) < 1/n") (("1" (mult-by -1 "norm(vv2)") (("1" (rewrite "dot_sub_left" -2) (("1" (expand "abs" +) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide-all-but (-1 -7 -8 -9 1)) (("2" (lemma "orthonormal_basis") (("2" (inst - "g" "perpR(g)" _) (("2" (inst-cp - "ww") (("2" (inst-cp - "rp") (("2" (assert) (("2" (case "orthonormal?(g,perpR(g))") (("1" (assert) (("1" (name "zp" "(ww*g + 1/(100*n+1))*g + (ww*perpR(g))*perpR(g)") (("1" (case "norm(ww-zp) = 1/(100*n+1)") (("1" (case "norm(zp) <= 1 + 1/(100*n+1)") (("1" (case "norm(zp) >= 1-1/(100*n+1)") (("1" (inst + "(1/norm(zp))*zp") (("1" (split +) (("1" (rewrite "norm_scal") (("1" (expand "abs") (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (cross-mult -1) (("1" (assert) (("1" (ground) (("1" (lemma "norm_eq_0") (("1" (inst?) (("1" (assert) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_triangle") (("2" (inst - "ww" "zp" "(1/norm(zp))*zp") (("2" (case "norm(zp-(1/norm(zp))*zp) < 1/n - 1/(100*n+1)") (("1" (assert) (("1" (replace -5 -1 :dir rl) (("1" (assert) nil nil)) nil)) nil) ("2" (case "NOT norm(zp-(1/norm(zp))*zp) = abs(norm(zp)-1)") (("1" (hide-all-but (-2 -3 1)) (("1" (case "zp - (1/norm(zp))*zp = ((norm(zp)-1)/norm(zp))*zp") (("1" (replace -1) (("1" (rewrite "norm_scal") (("1" (rewrite "abs_div") (("1" (expand "abs" + 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind :exclude "norm") nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide-all-but (-3 -4 1)) (("2" (case "1/(100*n+1) < 1/n - 1/(100*n+1)") (("1" (grind :exclude "norm") nil nil) ("2" (assert) (("2" (hide 2) (("2" (real-props) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case "(1/norm(zp))*zp*g = (1/norm(zp))*(ww*g + 1/(100*n+1))") (("1" (replace -1) (("1" (cross-mult 1) (("1" (assert) (("1" (ground) (("1" (replace -11) (("1" (mult-by -4 "rp*g") (("1" (case "rp*g <1 ") (("1" (mult-by -1 "1/(100*n+1)") (("1" (assert) nil nil)) nil) ("2" (lemma "schwarz") (("2" (inst?) (("2" (expand "abs") (("2" (assert) (("2" (case "NOT rp*g = 1") (("1" (assert) nil nil) ("2" (lemma "schwarz_converse") (("2" (inst?) (("1" (assert) (("1" (skeep -1) (("1" (replace -1 -16 :dir rl) (("1" (rewrite "norm_scal") (("1" (replace -15) (("1" (assert) (("1" (case "cr = 1") (("1" (replace -1) (("1" (assert) (("1" (reveal "rpg") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "abs") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (ground) (("2" (case "cr = -1") (("1" (replace -1) (("1" (assert) (("1" (replace -4 :dir rl) (("1" (hide-all-but -5) (("1" (typepred "sqv(g)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "zp" + 2) (("2" (case "sqv(g) = 1") (("1" (hide-all-but (-1 1)) (("1" (mult-by -1 "(ww * g + 1 / (1 + 100 * n))") (("1" (grind :exclude "norm") nil nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "sqrt_eq" 1 :dir rl) (("2" (rewrite "sqrt_sqv_norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst - "1/(norm(zp))*zp") (("2" (assert) (("2" (rewrite "norm_scal") (("2" (rewrite "abs_div") (("2" (expand "abs" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (lemma "norm_eq_0") (("3" (inst?) (("3" (assert) (("3" (replace -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "ww-zp = -(1/(100*n+1))*g") (("1" (lemma "norm_add_le") (("1" (inst - "ww-zp" "zp") (("1" (assert) (("1" (replace -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -7 1) (("2" (expand "zp" +) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_add_le") (("2" (inst - "ww" "zp-ww") (("2" (assert) (("2" (case "ww + (zp-ww) = zp") (("1" (replace -1) (("1" (case "zp-ww = -(ww-zp)") (("1" (replace -1) (("1" (rewrite "norm_neg") (("1" (assert) (("1" (replace -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "ww-zp = -(1/(100*n+1))*g") (("1" (replace -1) (("1" (rewrite "norm_scal") (("1" (expand "abs") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -5) (("2" (expand "zp" +) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (expand "orthonormal?") (("2" (split +) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide -2) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "FORALL (n:posnat): EXISTS (wwn:Nz_vect2): norm(wwn) = 1 AND norm(wwn-ww)<1/n AND wwn*vv1 > 0 AND wwn*vv2 > 0") (("1" (case "FORALL (n:posnat): ww*g >= rp*g - norm(g)/n") (("1" (hide-all-but (-1 1)) (("1" (lemma "archimedean") (("1" (inst - "(rp*g - ww*g)/norm(g)") (("1" (skeep -1) (("1" (inst - "n") (("1" (cross-mult -1) (("1" (cross-mult 1) (("1" (mult-by -2 "n") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (a:real): a> 0 IMPLIES (a>=0 AND a>0)") (("1" (rewrite -1) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (inst - "n") (("2" (skeep -1) (("2" (inst - "wwn") (("2" (assert) (("2" (case "ww*g >= wwn*g - norm(g)/n") (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "schwarz") (("2" (inst - "wwn-ww" "g") (("2" (mult-by -3 "norm(g)") (("2" (rewrite "dot_sub_left") (("2" (expand "abs") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-6 -7 -8 -9 2)) (("2" (case "EXISTS (zpn:Nz_vect2): zpn*vv1 > 0 AND zpn*vv2 > 0") (("1" (case "EXISTS (zpn:Nz_vect2): norm(zpn) = 1 AND zpn*vv1 > 0 AND zpn*vv2 > 0") (("1" (hide -2) (("1" (skeep -1) (("1" (skeep) (("1" (name "rgn" "ww + (1/(100*n+1))*zpn") (("1" (case "rgn /= zero") (("1" (case "norm(rgn)>0") (("1" (flatten) (("1" (name "ZZtop" "(1/norm(rgn))*rgn") (("1" (inst + "ZZtop") (("1" (case "NOT norm(ZZtop) = 1") (("1" (hide 3) (("1" (typepred "^(rgn)") (("1" (expand "^" -1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "NOT (ZZtop*vv1 > 0 AND ZZtop*vv2>0)") (("1" (hide 3) (("1" (expand "ZZtop" 1) (("1" (assert) (("1" (case "rgn*vv1 > 0 AND rgn*vv2>0") (("1" (flatten) (("1" (mult-by -1 "1/norm(rgn)") (("1" (mult-by -2 "1/norm(rgn)") (("1" (assert) nil nil) ("2" (assert) (("2" (split +) (("1" (cross-mult 1) nil nil) ("2" (cross-mult 1) nil nil)) nil)) nil)) nil) ("2" (split) (("1" (cross-mult 1) nil nil) ("2" (cross-mult 1) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "rgn" 1) (("2" (rewrite "dot_add_left") (("2" (rewrite "dot_add_left") (("2" (mult-by -6 "1/(100*n+1)") (("2" (mult-by -7 "1/(100*n+1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (assert) (("2" (case "NOT ZZtop - ww = (1/norm(rgn))*((1-norm(rgn))*ww + (1/(100*n+1))*zpn)") (("1" (hide-all-but (-5 1)) (("1" (expand "ZZtop") (("1" (expand "rgn " + 2) (("1" (grind :exclude "norm") nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (rewrite "norm_scal") (("2" (rewrite "abs_div") (("2" (expand "abs") (("2" (case "FORALL (rz:real): rz < norm(rgn)/n IMPLIES (1/norm(rgn))*rz < 1/n") (("1" (rewrite -1) (("1" (hide 3) (("1" (hide -1) (("1" (lemma "norm_add_le") (("1" (inst?) (("1" (case "norm((1 - norm(rgn)) * ww) + norm((1 / (1 + 100 * n)) * zpn) < norm(rgn)/n") (("1" (assert) nil nil) ("2" (hide (-1 2)) (("2" (rewrite "norm_scal") (("2" (case "abs(1-norm(rgn))<=1/(100*n+1)") (("1" (replace -16) (("1" (rewrite "norm_scal") (("1" (expand "abs" + 2) (("1" (assert) (("1" (replace -8) (("1" (case "2/(100*n+1) < norm(rgn)/n") (("1" (assert) nil nil) ("2" (hide (-1 2)) (("2" (case "norm(rgn) >= 1 - (1/(100*n+1))") (("1" (mult-by -1 "1/n") (("1" (case "(1 - (1 / (100 * n + 1))) * (1 / n) > 2/(100*n+1)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (field) nil nil)) nil)) nil)) nil) ("2" (lemma "norm_add_le") (("2" (inst - "rgn" "-ww") (("2" (case "norm(rgn+-ww) = 1/(100*n+1)") (("1" (rewrite "norm_neg") (("1" (assert) nil nil)) nil) ("2" (case "rgn+-ww = (1/(100*n+1))*zpn") (("1" (replace -1) (("1" (rewrite "norm_scal") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "rgn") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide (-1 -2 -3 -4)) (("2" (case "norm(rgn) <= 1 + 1/(100*n+1) AND norm(rgn) >= 1 - 1/(100*n+1)") (("1" (hide-all-but (-1 1)) (("1" (grind :exclude "norm") nil nil)) nil) ("2" (hide 2) (("2" (lemma "norm_add_le") (("2" (inst - "rgn" "ww-rgn") (("2" (assert) (("2" (case "rgn + (ww-rgn) = ww") (("1" (replace -1) (("1" (hide -1) (("1" (case "norm(ww-rgn) = 1/(100*n+1)") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (lemma "norm_add_le") (("1" (inst - "ww" "rgn-ww") (("1" (case "ww + (rgn-ww) = rgn") (("1" (replace -1) (("1" (hide -1) (("1" (case "norm(rgn-ww) = 1/(100*n+1)") (("1" (assert) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil) ("2" (case "rgn-ww = (1/(100*n+1))*zpn") (("1" (replace -1) (("1" (rewrite "norm_scal") (("1" (assert) (("1" (expand "abs") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "rgn") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "ww-rgn = (-1/(100*n+1))*zpn") (("1" (replace -1) (("1" (rewrite "norm_scal") (("1" (expand "abs") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "rgn") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (cross-mult 1) (("2" (cross-mult -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (hide-all-but (-2 -3 +)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (mult-by 1 "1/norm(rgn)") (("1" (grind :exclude "norm") nil nil)) nil) ("2" (mult-by 1 "1/norm(rgn)") (("2" (grind :exclude "norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) (("2" (case "rgn*vv1 > 0") (("1" (replace -2) (("1" (assert) nil nil)) nil) ("2" (mult-by -4 "1/(100*n+1)") (("2" (expand "rgn" 1) (("2" (hide-all-but (-6 -4 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (skeep -1) (("2" (inst + "^(zpn)") (("2" (assert) (("2" (typepred "^(zpn)") (("2" (assert) (("2" (mult-by -2 "1/norm(zpn)") (("2" (mult-by -3 "1/norm(zpn)") (("2" (expand "^") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (dot_gt_dot_equals_slice_union-1 nil 3529222317 ("" (case "FORALL (g, rp: Vect2):
                                    rp * g >= 0 AND norm(g) = 1 AND norm(rp) = 1 IMPLIES
                                     (EXISTS (vv1, vv2: Nz_vect2):
                                        norm(vv1) = 1 AND
                                         norm(vv2) = 1 AND
                                          g * vv1 = g * vv2 AND
                                           (FORALL (ww: Nz_vect2):
                                              norm(ww) = 1 IMPLIES
                                               (ww * g >= rp * g IFF (ww * vv1 >= 0 AND ww * vv2 >= 0))))") (("1" (skeep) (("1" (inst - "-g" "rp") (("1" (assert) (("1" (case "NOT rp*-g >= 0") (("1" (hide-all-but (-2 1)) (("1" (grind) nil nil)) nil) ("2" (assert) (("2" (skeep -2) (("2" (inst + "-vv1" "-vv2") (("2" (assert) (("2" (split +) (("1" (hide-all-but (-4 1)) (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (inst - "ww") (("2" (assert) (("2" (case "(ww*g > rp*g IFF (NOT ww*-g >= rp*-g)) AND ((ww * -vv1 > 0 OR ww * -vv2 > 0) IFF (NOT (ww * vv1 >= 0 AND ww * vv2 >= 0)))") (("1" (ground) nil nil) ("2" (hide (-6 2)) (("2" (hide -) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "dot_gt_dot_equals_slice_intersection") (("2" (skeep) (("2" (inst - "g" "rp") (("2" (assert) (("2" (case "NOT rp = g") (("1" (label "rpg" 1) (("1" (hide "rpg") (("1" (skeep -1) (("1" (inst + "vv1" "vv2") (("1" (assert) (("1" (comment "begin continuity argument") (("1" (skeep) (("1" (split) (("1" (flatten) (("1" (case "NOT ww*g = rp*g") (("1" (inst - "ww") (("1" (assert) (("1" (ground) nil nil)) nil)) nil) ("2" (hide -2) (("2" (case "FORALL (n:posnat): EXISTS (wwn:Nz_vect2): norm(wwn) = 1 AND norm(ww-wwn)<1/n AND wwn*g > rp*g") (("1" (split +) (("1" (case "FORALL (n:posnat): ww*vv1 >= (-1/n)*norm(vv1)") (("1" (hide-all-but (-1 1)) (("1" (lemma "archimedean") (("1" (inst - "(-(ww*vv1))/norm(vv1)") (("1" (skeep -1) (("1" (inst - "n") (("1" (cross-mult -1) (("1" (cross-mult -2) nil nil)) nil)) nil)) nil) ("2" (case "FORALL (rx:real): rx > 0 IMPLIES (rx>=0 AND rx>0)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst - "n") (("2" (skeep -1) (("2" (inst - "wwn") (("2" (assert) (("2" (case "abs(wwn*vv1) <= ww*vv1 + norm(vv1)/n") (("1" (flatten) (("1" (hide-all-but (-1 -9 +)) (("1" (grind :exclude ("norm" "*")) nil nil)) nil)) nil) ("2" (lemma "schwarz") (("2" (inst - "wwn-ww" "vv1") (("2" (case "norm(wwn-ww) < 1/n") (("1" (mult-by -1 "norm(vv1)") (("1" (rewrite "dot_sub_left" -2) (("1" (expand "abs" +) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (n:posnat): ww*vv2 >= (-1/n)*norm(vv2)") (("1" (hide-all-but (-1 1)) (("1" (lemma "archimedean") (("1" (inst - "(-(ww*vv2))/norm(vv2)") (("1" (skeep -1) (("1" (inst - "n") (("1" (cross-mult -1) (("1" (cross-mult -2) nil nil)) nil)) nil)) nil) ("2" (case "FORALL (rx:real): rx > 0 IMPLIES (rx>=0 AND rx>0)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst - "n") (("2" (skeep -1) (("2" (inst - "wwn") (("2" (assert) (("2" (case "abs(wwn*vv2) <= ww*vv2 + norm(vv2)/n") (("1" (flatten) (("1" (hide-all-but (-1 -10 +)) (("1" (grind :exclude ("norm" "*")) nil nil)) nil)) nil) ("2" (lemma "schwarz") (("2" (inst - "wwn-ww" "vv2") (("2" (case "norm(wwn-ww) < 1/n") (("1" (mult-by -1 "norm(vv2)") (("1" (rewrite "dot_sub_left" -2) (("1" (expand "abs" +) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide-all-but (-1 -7 -8 -9 1)) (("2" (lemma "orthonormal_basis") (("2" (inst - "g" "perpR(g)" _) (("2" (inst-cp - "ww") (("2" (inst-cp - "rp") (("2" (assert) (("2" (case "orthonormal?(g,perpR(g))") (("1" (assert) (("1" (name "zp" "(ww*g + 1/(2*sq(n)))*g + (ww*perpR(g))*perpR(g)") (("1" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) ";;; begin continuity argument")) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (max_circle_point_in_slice_lem 0 (max_circle_point_in_slice_lem-4 nil 3529081454 ("" (case "NOT FORALL (a1,a2,b1:Nz_vect2): orthonormal?(a1,a2) AND norm(b1) = 1 AND a2*b1 = 0 IMPLIES b1 = a1 OR b1 = -a1") (("1" (hide-all-but 1) (("1" (skeep) (("1" (lemma "orthonormal_basis") (("1" (inst - "a1" "a2" "b1") (("1" (assert) (("1" (case "b1*a2 = 0") (("1" (replace -1) (("1" (assert) (("1" (case "b1*a1 = 1 OR b1*a1 = -1") (("1" (split -) (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("2" (case "norm(a1) = 1") (("1" (replace -3 -5) (("1" (rewrite "norm_scal") (("1" (replace -1) (("1" (expand "abs") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "orthonormal?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "thislem" -1) (("2" (hide "thislem") (("2" (case "NOT FORALL (a1,a2,a3:Nz_vect2): orthonormal?(a1,a3) and orthonormal?(a2,a3) IMPLIES a1=a2 OR a1=-a2") (("1" (hide-all-but (-4 1)) (("1" (skeep) (("1" (lemma "orthonormal_basis") (("1" (inst - "a1" "a3" "a2") (("1" (assert) (("1" (expand "orthonormal?") (("1" (flatten) (("1" (expand "orthogonal?") (("1" (replace -5) (("1" (assert) (("1" (case "a2*a1 = 1 OR a2*a1 = -1") (("1" (split -) (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (replace -1) (("2" (assert) (("2" (replace -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1 -6) (("2" (rewrite "norm_scal") (("2" (replace -3) (("2" (expand "abs") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "thatlem" -1) (("2" (hide "thatlem") (("2" (skeep) (("2" (case "rp=-g") (("1" (case "rp*g = -1") (("1" (replace -1) (("1" (assert) (("1" (case "sp = -g") (("1" (replace -1) (("1" (assert) (("1" (replace -3) (("1" (case "r = -s") (("1" (replace -1) (("1" (hide-all-but (-16 -17 1)) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-9 -13 -14 1 3)) (("2" (reveal "thatlem") (("2" (inst - "r" "s" "-g") (("1" (ground) nil nil) ("2" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1 2)) (("2" (expand "zero") (("2" (flatten) (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (expand "orthonormal?") (("3" (replace -1) (("3" (ground) nil nil)) nil)) nil)) nil) ("4" (flatten) (("4" (expand "orthonormal?") (("4" (replace -1) (("4" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -8 -9 1)) (("2" (lemma "schwarz_converse") (("2" (inst - "sp" "g") (("1" (assert) (("1" (replace -2) (("1" (replace -3) (("1" (split -) (("1" (skeep -1) (("1" (replace -1 :dir rl) (("1" (rewrite "norm_scal") (("1" (replace -3) (("1" (assert) (("1" (case "cr = -1") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (typepred "sqv(sp)") (("2" (expand "sqv") (("2" (expand "abs") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "schwarz") (("2" (inst - "g" "sp") (("2" (case "sp*g = g*sp") (("1" (replace -1) (("1" (expand "abs") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (case "sqv(g) =1") (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (rewrite "sqrt_eq" 1 :dir rl) (("2" (rewrite "sqrt_sqv_norm") nil nil)) nil)) nil)) nil)) nil) ("2" (label "rpng" 1) (("2" (hide "rpng") (("2" (label "newhyp" 2) (("2" (hide "newhyp") (("2" (label "thyp" -14) (("2" (case "orthonormal?(g,perpR(g))") (("1" (case "h*r > 0 AND h*s > 0") (("1" (hide (-10 -11)) (("1" (flatten) (("1" (case "(EXISTS (vv1,vv2:Nz_vect2): norm(vv1) = 1 AND norm(vv2) = 1 AND (FORALL (ww:Nz_vect2): norm(ww)  =1 IMPLIES (ww*g > rp*g IFF (ww*vv1 > 0 AND ww*vv2 > 0))))") (("1" (skeep -1) (("1" (inst-cp - "h") (("1" (assert) (("1" (flatten) (("1" (case "EXISTS (vp1,vp2:Nz_vect2): orthonormal?(vv1,vp1) and orthonormal?(vv2,vp2) AND vp1*vv2>=0 AND vp2*vv1>=0") (("1" (skeep -1) (("1" (case "norm(vp1) = 1 AND norm(vp2) = 1") (("1" (flatten) (("1" (assert) (("1" (lemma "max_circle_point_in_slice_intersection") (("1" (inst - "r" "s" "vv1" "vv2" "rp" "sp" "vp1" "vp2" "h" "g") (("1" (replace "thyp") (("1" (assert) (("1" (case "rp /= g") (("1" (replace 1) (("1" (inst-cp - "g") (("1" (assert) (("1" (replace -12 :dir rl) (("1" (case "g*g > rp*g") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (inst - "rp") (("1" (assert) nil nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst - "sp") (("1" (assert) nil nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst - "g" "perpR(g)" "rp") (("2" (split -) (("1" (lemma "orthonormal_basis_norm") (("1" (inst - "rp*g" "rp*perpR(g)" "g" "perpR(g)" "rp") (("1" (assert) (("1" (hide -4) (("1" (case "sqv(g)=1") (("1" (expand "sqv" -1) (("1" (replace -1) (("1" (case "sq(rp*g) < 1") (("1" (rewrite "sqrt_lt" -1 :dir rl) (("1" (assert) (("1" (rewrite "sqrt_sq") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (case "NOT sq(rp*g) = 1") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (lemma "sq_eq_0") (("2" (inst - "rp*perpR(g)") (("2" (assert) (("2" (case "rp = g OR rp = -g") (("1" (assert) (("1" (replace -1) (("1" (hide-all-but (-4 2)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "g" "perpR(g)" "rp") (("1" (assert) (("1" (assert) (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (hide-all-but (1 2)) (("2" (flatten) (("2" (case "g = -perpR(perpR(g))") (("1" (replace -1 +) (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (flatten) (("4" (replace -1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-20 1)) (("2" (rewrite "sq_eq" - :dir rl) (("2" (rewrite "sq_norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (case "sqv(g)=1") (("1" (expand "sqv" -1) (("1" (replace -1) (("1" (lemma "schwarz") (("1" (inst - "h" "g") (("1" (expand "abs") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-19 1)) (("2" (rewrite "sq_eq" - :dir rl) (("2" (rewrite "sq_norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil nil)) nil)) nil) ("4" (flatten) (("4" (replace -1) (("4" (assert) nil nil)) nil)) nil) ("5" (flatten) (("5" (replace -1) (("5" (assert) nil nil)) nil)) nil) ("6" (flatten) (("6" (replace -1) (("6" (assert) nil nil)) nil)) nil) ("7" (flatten) (("7" (replace -1) (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "orthonormal?") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 1)) (("2" (name "vp1" "IF perpR(vv1)*vv2 >= 0 THEN perpR(vv1) ELSE -perpR(vv1) ENDIF") (("2" (name "vp2" "IF perpR(vv2)*vv1 >= 0 THEN perpR(vv2) ELSE -perpR(vv2) ENDIF") (("2" (inst + "vp1" "vp2") (("2" (hide (-1 -2)) (("2" (split +) (("1" (expand "orthonormal?") (("1" (split +) (("1" (hide -) (("1" (expand "vp1") (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil) ("3" (case "norm(perpR(vv1)) = 1") (("1" (expand "vp1") (("1" (lift-if) (("1" (rewrite "norm_neg") (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "orthonormal?") (("2" (split) (("1" (expand "vp2") (("1" (hide -) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil) ("3" (case "norm(perpR(vv2)) = 1") (("1" (expand "vp2") (("1" (rewrite "norm_neg") (("1" (lift-if) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -) (("3" (expand "vp1") (("3" (lift-if) (("3" (grind) nil nil)) nil)) nil)) nil) ("4" (hide -) (("4" (expand "vp2") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "(EXISTS (vv1,vv2:Nz_vect2): norm(vv1) = 1 AND norm(vv2) = 1 AND g*vv1 = g*vv2 AND (FORALL (ww:Nz_vect2): norm(ww)  =1 IMPLIES (ww*g > rp*g IFF (ww*vv1 > 0 OR ww*vv2 > 0))))") (("1" (hide 1) (("1" (skeep -1) (("1" (inst-cp - "h") (("1" (assert) (("1" (case "EXISTS (vp1,vp2:Nz_vect2): orthonormal?(vv1,vp1) and orthonormal?(vv2,vp2) AND vp1*vv2>=0 AND vp2*vv1>=0") (("1" (skeep -1) (("1" (case "norm(vp1) = 1 AND norm(vp2) = 1") (("1" (flatten) (("1" (assert) (("1" (lemma "max_circle_point_in_slice_union") (("1" (inst - "r" "s" "vv1" "vv2" "rp" "sp" "vp1" "vp2" "h" "g") (("1" (replace "thyp") (("1" (assert) (("1" (replace -12) (("1" (replace 1) (("1" (case "rp /= g") (("1" (inst-cp - "g") (("1" (assert) (("1" (replace -13 :dir rl) (("1" (case "g*g > rp*g") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (inst - "rp") (("1" (assert) nil nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst - "rp") (("1" (assert) nil nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (inst - "sp") (("1" (assert) nil nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (flatten) (("4" (inst - "sp") (("1" (assert) nil nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst - "g" "perpR(g)" "rp") (("2" (split -) (("1" (lemma "orthonormal_basis_norm") (("1" (inst - "rp*g" "rp*perpR(g)" "g" "perpR(g)" "rp") (("1" (assert) (("1" (hide -4) (("1" (case "sqv(g)=1") (("1" (expand "sqv" -1) (("1" (replace -1) (("1" (case "sq(rp*g) < 1") (("1" (rewrite "sqrt_lt" -1 :dir rl) (("1" (assert) (("1" (rewrite "sqrt_sq") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (case "NOT sq(rp*g) = 1") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (lemma "sq_eq_0") (("2" (inst - "rp*perpR(g)") (("2" (assert) (("2" (case "rp = g OR rp = -g") (("1" (assert) (("1" (replace -1) (("1" (hide-all-but (-4 2)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "g" "perpR(g)" "rp") (("1" (assert) (("1" (assert) (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (hide-all-but (1 2)) (("2" (flatten) (("2" (case "g = -perpR(perpR(g))") (("1" (replace -1 +) (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (flatten) (("4" (replace -1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-20 1)) (("2" (rewrite "sq_eq" - :dir rl) (("2" (rewrite "sq_norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) (("2" (hide-all-but (-24 +)) (("2" (expand "orthonormal?") (("2" (expand "orthogonal?") (("2" (flatten) (("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil nil)) nil)) nil) ("4" (flatten) (("4" (replace -1) (("4" (assert) nil nil)) nil)) nil) ("5" (flatten) (("5" (replace -1) (("5" (assert) nil nil)) nil)) nil) ("6" (flatten) (("6" (replace -1) (("6" (assert) nil nil)) nil)) nil) ("7" (flatten) (("7" (replace -1) (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "orthonormal?") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 1)) (("2" (name "vp1" "IF perpR(vv1)*vv2 >= 0 THEN perpR(vv1) ELSE -perpR(vv1) ENDIF") (("2" (name "vp2" "IF perpR(vv2)*vv1 >= 0 THEN perpR(vv2) ELSE -perpR(vv2) ENDIF") (("2" (inst + "vp1" "vp2") (("2" (hide (-1 -2)) (("2" (split +) (("1" (expand "orthonormal?") (("1" (split +) (("1" (hide -) (("1" (expand "vp1") (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil) ("3" (case "norm(perpR(vv1)) = 1") (("1" (expand "vp1") (("1" (lift-if) (("1" (rewrite "norm_neg") (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "orthonormal?") (("2" (split) (("1" (expand "vp2") (("1" (hide -) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil) ("3" (case "norm(perpR(vv2)) = 1") (("1" (expand "vp2") (("1" (rewrite "norm_neg") (("1" (lift-if) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -) (("3" (expand "vp1") (("3" (lift-if) (("3" (grind) nil nil)) nil)) nil)) nil) ("4" (hide -) (("4" (expand "vp2") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 -8 1 2)) (("2" (lemma "dot_gt_dot_equals_slice_intersection") (("2" (inst?) (("2" (lemma "dot_gt_dot_equals_slice_union") (("2" (inst?) (("2" (assert) (("2" (reveal "rpng") (("2" (ground) (("2" (skeep -1) (("2" (inst 4 "vv1" "vv2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "h*r = 0") (("1" (hide 1) (("1" (case "h = rp OR h = -rp") (("1" (split -) (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (replace -1) (("2" (assert) (("2" (case "NOT rp*s = 0") (("1" (hide-all-but (-12 -15 1)) (("1" (grind) nil nil)) nil) ("2" (case "rp /= sp") (("1" (assert) (("1" (reveal "thislem") (("1" (inst - "sp" "s" "rp") (("1" (assert) (("1" (split -) (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (hide-all-but (-15 1)) (("2" (grind) nil nil)) nil)) nil) ("3" (hide-all-but (-14 -17 1)) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil nil)) nil)) nil) ("4" (flatten) (("4" (replace -1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) (("2" (case "r /= -s") (("1" (reveal "thislem") (("1" (inst - "s" "sp" "r") (("1" (assert) (("1" (hide-all-but (-5 1)) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil nil)) nil)) nil) ("4" (flatten) (("4" (replace -1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) (("2" (case "NOT sp*g <= 0") (("1" (hide-all-but (1 4)) (("1" (grind) nil nil)) nil) ("2" (reveal "newhyp") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "rp" "r" "h") (("1" (assert) (("1" (assert) (("1" (split +) (("1" (hide-all-but (-12 1)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil nil)) nil)) nil) ("4" (replace -1) (("4" (assert) (("4" (flatten) (("4" (replace -1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "h*s = 0") (("1" (case "h = sp OR h=-sp") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (hide-all-but (-11 -16 1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "sp" "s" "h") (("1" (assert) (("1" (assert) (("1" (expand "orthonormal?") (("1" (split +) (("1" (assert) (("1" (flatten) (("1" (hide-all-but (-14 1)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) nil nil) ("3" (replace -1) (("3" (assert) nil nil)) nil) ("4" (flatten) (("4" (replace -1) (("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil nil)) nil)) nil) ("4" (flatten) (("4" (replace -1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "orthonormal?") (("2" (assert) (("2" (hide-all-but (-3 1)) (("2" (split +) (("1" (hide -) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide -1) (("2" (expand "zero") (("2" (grind) (("2" (decompose-equality +) nil nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((orthogonal? const-decl "bool" vectors_2D vectors) (norm_neg formula-decl nil vectors_2D vectors) (neg_neg formula-decl nil vectors_2D vectors) (nonneg_real nonempty-type-eq-decl nil real_types nil) (sqrt_eq formula-decl nil sqrt reals) (sqrt_pos application-judgement "posreal" sqrt reals) (sqrt_1 formula-decl nil sqrt reals) (sqrt_sqv_norm formula-decl nil vectors_2D vectors) (neg_zero formula-decl nil vectors_2D vectors) (norm_zero formula-decl nil vectors_2D vectors) (g skolem-const-decl "Vect2" circle_optimum_2D nil) (s skolem-const-decl "Vect2" circle_optimum_2D nil) (r skolem-const-decl "Vect2" circle_optimum_2D nil) (schwarz_converse formula-decl nil vectors_2D vectors) (schwarz formula-decl nil vectors_2D vectors) (dot_scal_right formula-decl nil vectors_2D vectors) (sqv const-decl "nnreal" vectors_2D vectors) (Nz_vector type-eq-decl nil vectors_2D vectors) (sp skolem-const-decl "Vect2" circle_optimum_2D nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (perpR const-decl "Vect2" perpendicular_2D vectors) (<= const-decl "bool" reals nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (h skolem-const-decl "Vect2" circle_optimum_2D nil) (vp2 skolem-const-decl "Nz_vect2" circle_optimum_2D nil) (nz_sqv_gt_0 application-judgement "posreal" vectors_2D vectors) (vp1 skolem-const-decl "Nz_vect2" circle_optimum_2D nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (perpR_nz application-judgement "Nz_vect2" perpendicular_2D vectors) (max_circle_point_in_slice_intersection formula-decl nil circle_optimum_2D nil) (sq_norm formula-decl nil vectors_2D vectors) (sq_1 formula-decl nil sq reals) (sq_nz_pos application-judgement "posreal" sq reals) (sq_eq formula-decl nil sq reals) (< const-decl "bool" reals nil) (sq const-decl "nonneg_real" sq reals) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (sqrt_sq formula-decl nil sqrt reals) (sqrt_lt formula-decl nil sqrt reals) (sq_eq_0 formula-decl nil sq reals) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (perpR_eq_zero formula-decl nil perpendicular_2D vectors) (dot_zero_right formula-decl nil vectors_2D vectors) (sq_0 formula-decl nil sq reals) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (orthonormal_basis_norm formula-decl nil basis_2D vectors) (dot_zero_left formula-decl nil vectors_2D vectors) (rp skolem-const-decl "Vect2" circle_optimum_2D nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (dot_gt_dot_equals_slice_union formula-decl nil circle_optimum_2D nil) (dot_gt_dot_equals_slice_intersection formula-decl nil circle_optimum_2D nil) (max_circle_point_in_slice_union formula-decl nil circle_optimum_2D nil) (vp1 skolem-const-decl "Nz_vect2" circle_optimum_2D nil) (vp2 skolem-const-decl "Nz_vect2" circle_optimum_2D nil) (> const-decl "bool" reals nil) (orthonormal_basis formula-decl nil basis_2D vectors) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (scal_neg_1 formula-decl nil vectors_2D vectors) (nz_nzv application-judgement "Nz_vector" vectors_2D vectors) (scal_1 formula-decl nil vectors_2D vectors) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (norm_scal formula-decl nil vectors_2D vectors) (add_zero_right formula-decl nil vectors_2D vectors) (scal_0 formula-decl nil vectors_2D vectors) (nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors) (neg_nzv application-judgement "Nz_vector" vectors_2D vectors) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Vector type-eq-decl nil vectors_2D vectors) (/= const-decl "boolean" notequal nil) (zero const-decl "Vector" vectors_2D vectors) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (orthonormal? const-decl "bool" basis_2D vectors) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (norm const-decl "nnreal" vectors_2D vectors) (* const-decl "real" vectors_2D vectors) (OR const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "Vector" vectors_2D vectors)) nil) (max_circle_point_in_slice_lem-3 nil 3529081434 ("" (case "NOT FORALL (a1,a2,b1:Nz_vect2): orthonormal?(a1,a2) AND norm(b1) = 1 AND a2*b1 = 0 IMPLIES b1 = a1 OR b1 = -a1") (("1" (hide-all-but 1) (("1" (skeep) (("1" (lemma "orthonormal_basis") (("1" (inst - "a1" "a2" "b1") (("1" (assert) (("1" (case "b1*a2 = 0") (("1" (replace -1) (("1" (assert) (("1" (case "b1*a1 = 1 OR b1*a1 = -1") (("1" (split -) (("1" (replace -1) (("1" (assert) nil))) ("2" (replace -1) (("2" (assert) nil))))) ("2" (case "norm(a1) = 1") (("1" (replace -3 -5) (("1" (rewrite "norm_scal") (("1" (replace -1) (("1" (expand "abs") (("1" (lift-if) (("1" (ground) nil))))))))))) ("2" (expand "orthonormal?") (("2" (assert) nil))))))))))) ("2" (hide-all-but (-4 1)) (("2" (grind) nil))))))))))))))) ("2" (label "thislem" -1) (("2" (hide "thislem") (("2" (case "NOT FORALL (a1,a2,a3:Nz_vect2): orthonormal?(a1,a3) and orthonormal?(a2,a3) IMPLIES a1=a2 OR a1=-a2") (("1" (hide-all-but (-4 1)) (("1" (skeep) (("1" (lemma "orthonormal_basis") (("1" (inst - "a1" "a3" "a2") (("1" (assert) (("1" (expand "orthonormal?") (("1" (flatten) (("1" (expand "orthogonal?") (("1" (replace -5) (("1" (assert) (("1" (case "a2*a1 = 1 OR a2*a1 = -1") (("1" (split -) (("1" (replace -1) (("1" (assert) nil))) ("2" (replace -1) (("2" (assert) (("2" (replace -2) (("2" (assert) nil))))))))) ("2" (replace -1 -6) (("2" (rewrite "norm_scal") (("2" (replace -3) (("2" (expand "abs") (("2" (lift-if) (("2" (ground) nil))))))))))))))))))))))))))))))))) ("2" (label "thatlem" -1) (("2" (hide "thatlem") (("2" (skeep) (("2" (label "newhyp" 2) (("2" (label "thyp" -14) (("2" (case "orthonormal?(g,perpR(g))") (("1" (case "h*r > 0 AND h*s > 0") (("1" (hide (-10 -11)) (("1" (flatten) (("1" (case "(EXISTS (vv1,vv2:Nz_vect2): norm(vv1) = 1 AND norm(vv2) = 1 AND (FORALL (ww:Nz_vect2): norm(ww)  =1 IMPLIES (ww*g > rp*g IFF (ww*vv1 > 0 AND ww*vv2 > 0))))") (("1" (skeep -1) (("1" (inst-cp - "h") (("1" (assert) (("1" (flatten) (("1" (case "EXISTS (vp1,vp2:Nz_vect2): orthonormal?(vv1,vp1) and orthonormal?(vv2,vp2) AND vp1*vv2>=0 AND vp2*vv1>=0") (("1" (skeep -1) (("1" (case "norm(vp1) = 1 AND norm(vp2) = 1") (("1" (flatten) (("1" (assert) (("1" (lemma "max_circle_point_in_slice_intersection") (("1" (inst - "r" "s" "vv1" "vv2" "rp" "sp" "vp1" "vp2" "h" "g") (("1" (replace "thyp") (("1" (assert) (("1" (case "rp /= g") (("1" (replace 1) (("1" (inst-cp - "g") (("1" (assert) (("1" (replace -12 :dir rl) (("1" (case "g*g > rp*g") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (inst - "rp") (("1" (assert) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil))))))))) ("2" (flatten) (("2" (inst - "sp") (("1" (assert) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil))))))))))))) ("2" (lemma "orthonormal_basis") (("2" (inst - "g" "perpR(g)" "rp") (("2" (split -) (("1" (lemma "orthonormal_basis_norm") (("1" (inst - "rp*g" "rp*perpR(g)" "g" "perpR(g)" "rp") (("1" (assert) (("1" (assert) (("1" (hide -4) (("1" (case "sqv(g)=1") (("1" (expand "sqv" -1) (("1" (replace -1) (("1" (case "sq(rp*g) < 1") (("1" (rewrite "sqrt_lt" -1 :dir rl) (("1" (assert) (("1" (rewrite "sqrt_sq") (("1" (assert) nil))))))) ("2" (case "NOT sq(rp*g) = 1") (("1" (assert) nil) ("2" (replace -1) (("2" (assert) (("2" (lemma "sq_eq_0") (("2" (inst - "rp*perpR(g)") (("2" (assert) (("2" (case "rp = g OR rp = -g") (("1" (assert) (("1" (replace -1) (("1" (hide-all-but (-4 2)) (("1" (grind) nil))))))) ("2" (reveal "thislem") (("2" (inst - "g" "perpR(g)" "rp") (("1" (assert) (("1" (assert) (("1" (hide-all-but (-1 1)) (("1" (grind) nil))))))) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil))))) ("3" (case "g = zero") (("1" (replace -1) (("1" (assert) nil))) ("2" (assert) (("2" (hide-all-but (1 2)) (("2" (flatten) (("2" (case "g = -perpR(perpR(g))") (("1" (replace -1 +) (("1" (replace -2) (("1" (assert) nil))))) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil) ("2" (grind) nil))))))))))))))) ("4" (flatten) (("4" (replace -1) (("4" (assert) nil))))))))))))))))))))))))))))) ("2" (hide-all-but (-20 1)) (("2" (rewrite "sq_eq" - :dir rl) (("2" (rewrite "sq_norm") nil))))))))))))))))) ("2" (propax) nil))))))))))))) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil))))))))) ("2" (flatten) (("2" (replace -1) (("2" (case "sqv(g)=1") (("1" (expand "sqv" -1) (("1" (replace -1) (("1" (lemma "schwarz") (("1" (inst - "h" "g") (("1" (expand "abs") (("1" (lift-if) (("1" (ground) nil))))))))))))) ("2" (hide-all-but (-19 1)) (("2" (rewrite "sq_eq" - :dir rl) (("2" (rewrite "sq_norm") nil))))))))))))))))) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil))))) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil))))) ("4" (flatten) (("4" (replace -1) (("4" (assert) nil))))) ("5" (flatten) (("5" (replace -1) (("5" (assert) nil))))) ("6" (flatten) (("6" (replace -1) (("6" (assert) nil))))) ("7" (flatten) (("7" (replace -1) (("7" (assert) nil))))))))))))) ("2" (expand "orthonormal?") (("2" (flatten) (("2" (assert) nil))))))))) ("2" (hide-all-but (-1 -2 1)) (("2" (name "vp1" "IF perpR(vv1)*vv2 >= 0 THEN perpR(vv1) ELSE -perpR(vv1) ENDIF") (("2" (name "vp2" "IF perpR(vv2)*vv1 >= 0 THEN perpR(vv2) ELSE -perpR(vv2) ENDIF") (("2" (inst + "vp1" "vp2") (("2" (assert) (("2" (hide (-1 -2)) (("2" (split +) (("1" (expand "orthonormal?") (("1" (split +) (("1" (hide -) (("1" (expand "vp1") (("1" (grind) nil))))) ("2" (case "norm(perpR(vv1)) = 1") (("1" (expand "vp1") (("1" (lift-if) (("1" (rewrite "norm_neg") (("1" (ground) nil))))))) ("2" (grind) nil))))))) ("2" (expand "orthonormal?") (("2" (split) (("1" (expand "vp2") (("1" (hide -) (("1" (grind) nil))))) ("2" (case "norm(perpR(vv2)) = 1") (("1" (expand "vp2") (("1" (rewrite "norm_neg") (("1" (lift-if) (("1" (propax) nil))))))) ("2" (grind) nil))))))) ("3" (hide -) (("3" (expand "vp1") (("3" (lift-if) (("3" (grind) nil))))))) ("4" (hide -) (("4" (expand "vp2") (("4" (grind) nil))))))))))))))))))))))))) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil))))))))) ("2" (case "(EXISTS (vv1,vv2:Nz_vect2): norm(vv1) = 1 AND norm(vv2) = 1 AND g*vv1 = g*vv2 AND (FORALL (ww:Nz_vect2): norm(ww)  =1 IMPLIES (ww*g > rp*g IFF (ww*vv1 > 0 OR ww*vv2 > 0))))") (("1" (hide 1) (("1" (skeep -1) (("1" (inst-cp - "h") (("1" (assert) (("1" (case "EXISTS (vp1,vp2:Nz_vect2): orthonormal?(vv1,vp1) and orthonormal?(vv2,vp2) AND vp1*vv2>=0 AND vp2*vv1>=0") (("1" (skeep -1) (("1" (case "norm(vp1) = 1 AND norm(vp2) = 1") (("1" (flatten) (("1" (assert) (("1" (lemma "max_circle_point_in_slice_union") (("1" (inst - "r" "s" "vv1" "vv2" "rp" "sp" "vp1" "vp2" "h" "g") (("1" (replace "thyp") (("1" (assert) (("1" (replace -12) (("1" (replace 1) (("1" (case "rp /= g") (("1" (inst-cp - "g") (("1" (assert) (("1" (replace -13 :dir rl) (("1" (case "g*g > rp*g") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (inst - "rp") (("1" (assert) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil))))))))) ("2" (flatten) (("2" (inst - "rp") (("1" (assert) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil))))))))) ("3" (flatten) (("3" (inst - "sp") (("1" (assert) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil))))))))) ("4" (flatten) (("4" (inst - "sp") (("1" (assert) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil))))))))))))) ("2" (lemma "orthonormal_basis") (("2" (inst - "g" "perpR(g)" "rp") (("2" (split -) (("1" (lemma "orthonormal_basis_norm") (("1" (inst - "rp*g" "rp*perpR(g)" "g" "perpR(g)" "rp") (("1" (assert) (("1" (assert) (("1" (hide -4) (("1" (case "sqv(g)=1") (("1" (expand "sqv" -1) (("1" (replace -1) (("1" (case "sq(rp*g) < 1") (("1" (rewrite "sqrt_lt" -1 :dir rl) (("1" (assert) (("1" (rewrite "sqrt_sq") (("1" (assert) nil))))))) ("2" (case "NOT sq(rp*g) = 1") (("1" (assert) nil) ("2" (replace -1) (("2" (assert) (("2" (lemma "sq_eq_0") (("2" (inst - "rp*perpR(g)") (("2" (assert) (("2" (case "rp = g OR rp = -g") (("1" (assert) (("1" (replace -1) (("1" (hide-all-but (-4 2)) (("1" (grind) nil))))))) ("2" (reveal "thislem") (("2" (inst - "g" "perpR(g)" "rp") (("1" (assert) (("1" (assert) (("1" (hide-all-but (-1 1)) (("1" (grind) nil))))))) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil))))) ("3" (case "g = zero") (("1" (replace -1) (("1" (assert) nil))) ("2" (assert) (("2" (hide-all-but (1 2)) (("2" (flatten) (("2" (case "g = -perpR(perpR(g))") (("1" (replace -1 +) (("1" (replace -2) (("1" (assert) nil))))) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil) ("2" (grind) nil))))))))))))))) ("4" (flatten) (("4" (replace -1) (("4" (assert) nil))))))))))))))))))))))))))))) ("2" (hide-all-but (-20 1)) (("2" (rewrite "sq_eq" - :dir rl) (("2" (rewrite "sq_norm") nil))))))))))))))))) ("2" (propax) nil))))))))))))) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil))))))) ("2" (flatten) (("2" (replace -1) (("2" (assert) (("2" (hide-all-but (-24 +)) (("2" (expand "orthonormal?") (("2" (expand "orthogonal?") (("2" (flatten) (("2" (hide-all-but (-1 1)) (("2" (grind) nil))))))))))))))))))))))))))) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil))))) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil))))) ("4" (flatten) (("4" (replace -1) (("4" (assert) nil))))) ("5" (flatten) (("5" (replace -1) (("5" (assert) nil))))) ("6" (flatten) (("6" (replace -1) (("6" (assert) nil))))) ("7" (flatten) (("7" (replace -1) (("7" (assert) nil))))))))))))) ("2" (expand "orthonormal?") (("2" (flatten) (("2" (assert) nil))))))))) ("2" (hide-all-but (-1 -2 1)) (("2" (name "vp1" "IF perpR(vv1)*vv2 >= 0 THEN perpR(vv1) ELSE -perpR(vv1) ENDIF") (("2" (name "vp2" "IF perpR(vv2)*vv1 >= 0 THEN perpR(vv2) ELSE -perpR(vv2) ENDIF") (("2" (inst + "vp1" "vp2") (("2" (assert) (("2" (hide (-1 -2)) (("2" (split +) (("1" (expand "orthonormal?") (("1" (split +) (("1" (hide -) (("1" (expand "vp1") (("1" (grind) nil))))) ("2" (case "norm(perpR(vv1)) = 1") (("1" (expand "vp1") (("1" (lift-if) (("1" (rewrite "norm_neg") (("1" (ground) nil))))))) ("2" (grind) nil))))))) ("2" (expand "orthonormal?") (("2" (split) (("1" (expand "vp2") (("1" (hide -) (("1" (grind) nil))))) ("2" (case "norm(perpR(vv2)) = 1") (("1" (expand "vp2") (("1" (rewrite "norm_neg") (("1" (lift-if) (("1" (propax) nil))))))) ("2" (grind) nil))))))) ("3" (hide -) (("3" (expand "vp1") (("3" (lift-if) (("3" (grind) nil))))))) ("4" (hide -) (("4" (expand "vp2") (("4" (grind) nil))))))))))))))))))))))) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil))))))))))) ("2" (hide-all-but (-6 -8 1 2)) (("2" (postpone) nil))))))))))) ("2" (case "h*r = 0") (("1" (hide 1) (("1" (case "h = rp OR h = -rp") (("1" (split -) (("1" (replace -1) (("1" (assert) nil))) ("2" (replace -1) (("2" (assert) (("2" (case "NOT rp*s = 0") (("1" (hide-all-but (-12 -15 1)) (("1" (grind) nil))) ("2" (case "rp /= sp") (("1" (assert) (("1" (reveal "thislem") (("1" (inst - "sp" "s" "rp") (("1" (assert) (("1" (split -) (("1" (replace -1) (("1" (assert) nil))) ("2" (flatten) (("2" (hide-all-but (-15 1)) (("2" (grind) nil))))) ("3" (hide-all-but (-14 -17 1)) (("3" (grind) nil))))))) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil))))) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil))))) ("4" (flatten) (("4" (replace -1) (("4" (assert) nil))))))))))) ("2" (flatten) (("2" (replace -1) (("2" (assert) (("2" (case "r /= -s") (("1" (reveal "thislem") (("1" (inst - "s" "sp" "r") (("1" (assert) (("1" (hide-all-but (-5 1)) (("1" (grind) nil))))) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil))))) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil))))) ("4" (flatten) (("4" (replace -1) (("4" (assert) nil))))))))) ("2" (flatten) (("2" (replace -1) (("2" (assert) (("2" (case "NOT sp*g <= 0") (("1" (hide-all-but (1 4)) (("1" (grind) nil))) ("2" (postpone) nil))))))))))))))))))))))))))) ("2" (reveal "thislem") (("2" (inst - "rp" "r" "h") (("1" (assert) (("1" (assert) (("1" (split +) (("1" (hide-all-but (-12 1)) (("1" (grind) nil))) ("2" (hide-all-but (-1 1)) (("2" (grind) nil))))))))) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil))))) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil))))) ("4" (replace -1) (("4" (assert) (("4" (flatten) (("4" (replace -1) (("4" (assert) nil))))))))))))))))) ("2" (assert) (("2" (case "h*s = 0") (("1" (case "h = sp OR h=-sp") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (hide-all-but (-11 -16 1)) (("1" (grind) nil))))))))) ("2" (reveal "thislem") (("2" (inst - "sp" "s" "h") (("1" (assert) (("1" (assert) (("1" (expand "orthonormal?") (("1" (split +) (("1" (assert) (("1" (flatten) (("1" (hide-all-but (-14 1)) (("1" (grind) nil))))))) ("2" (flatten) nil) ("3" (replace -1) (("3" (assert) nil))) ("4" (flatten) (("4" (replace -1) (("4" (hide-all-but (-1 1)) (("4" (grind) nil))))))))))))))) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil))))) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil))))) ("4" (flatten) (("4" (replace -1) (("4" (assert) nil))))))))))) ("2" (assert) nil))))))))) ("2" (expand "orthonormal?") (("2" (assert) (("2" (hide-all-but (-3 1)) (("2" (split +) (("1" (hide -) (("1" (grind) nil))) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil))))) ("3" (case "g = zero") (("1" (replace -1) (("1" (assert) nil))) ("2" (hide -1) (("2" (expand "zero") (("2" (grind) (("2" (decompose-equality +) nil))))))))) ("4" (grind) nil)))))))))))))))))))))))))))) nil) nil nil) (max_circle_point_in_slice_lem-2 nil 3528817618 ("" (case "NOT FORALL (a1,a2,b1:Nz_vect2): orthonormal?(a1,a2) AND norm(b1) = 1 AND a2*b1 = 0 IMPLIES b1 = a1 OR b1 = -a1") (("1" (hide-all-but 1) (("1" (skeep) (("1" (lemma "orthonormal_basis") (("1" (inst - "a1" "a2" "b1") (("1" (assert) (("1" (case "b1*a2 = 0") (("1" (replace -1) (("1" (assert) (("1" (case "b1*a1 = 1 OR b1*a1 = -1") (("1" (split -) (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("2" (case "norm(a1) = 1") (("1" (replace -3 -5) (("1" (rewrite "norm_scal") (("1" (replace -1) (("1" (expand "abs") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "orthonormal?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "thislem" -1) (("2" (hide "thislem") (("2" (case "NOT FORALL (a1,a2,a3:Nz_vect2): orthonormal?(a1,a3) and orthonormal?(a2,a3) IMPLIES a1=a2 OR a1=-a2") (("1" (hide-all-but (-4 1)) (("1" (skeep) (("1" (lemma "orthonormal_basis") (("1" (inst - "a1" "a3" "a2") (("1" (assert) (("1" (expand "orthonormal?") (("1" (flatten) (("1" (expand "orthogonal?") (("1" (replace -5) (("1" (assert) (("1" (case "a2*a1 = 1 OR a2*a1 = -1") (("1" (split -) (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (replace -1) (("2" (assert) (("2" (replace -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1 -6) (("2" (rewrite "norm_scal") (("2" (replace -3) (("2" (expand "abs") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "thatlem" -1) (("2" (hide "thatlem") (("2" (skeep) (("2" (label "thyp" -14) (("2" (case "orthonormal?(g,perpR(g))") (("1" (case "h*r > 0 AND h*s > 0") (("1" (hide (-10 -11)) (("1" (flatten) (("1" (case "(EXISTS (vv1,vv2:Nz_vect2): norm(vv1) = 1 AND norm(vv2) = 1 AND (FORALL (ww:Nz_vect2): norm(ww)  =1 IMPLIES (ww*g > rp*g IFF (ww*vv1 > 0 AND ww*vv2 > 0))))") (("1" (skeep -1) (("1" (inst-cp - "h") (("1" (assert) (("1" (flatten) (("1" (case "EXISTS (vp1,vp2:Nz_vect2): orthonormal?(vv1,vp1) and orthonormal?(vv2,vp2) AND vp1*vv2>=0 AND vp2*vv1>=0") (("1" (skeep -1) (("1" (case "norm(vp1) = 1 AND norm(vp2) = 1") (("1" (flatten) (("1" (assert) (("1" (lemma "max_circle_point_in_slice_intersection") (("1" (inst - "r" "s" "vv1" "vv2" "rp" "sp" "vp1" "vp2" "h" "g") (("1" (replace "thyp") (("1" (assert) (("1" (case "rp /= g") (("1" (replace 1) (("1" (inst-cp - "g") (("1" (assert) (("1" (replace -12 :dir rl) (("1" (case "g*g > rp*g") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (inst - "rp") (("1" (assert) nil nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst - "sp") (("1" (assert) nil nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst - "g" "perpR(g)" "rp") (("2" (split -) (("1" (lemma "orthonormal_basis_norm") (("1" (inst - "rp*g" "rp*perpR(g)" "g" "perpR(g)" "rp") (("1" (assert) (("1" (assert) (("1" (hide -4) (("1" (case "sqv(g)=1") (("1" (expand "sqv" -1) (("1" (replace -1) (("1" (case "sq(rp*g) < 1") (("1" (rewrite "sqrt_lt" -1 :dir rl) (("1" (assert) (("1" (rewrite "sqrt_sq") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (case "NOT sq(rp*g) = 1") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (lemma "sq_eq_0") (("2" (inst - "rp*perpR(g)") (("2" (assert) (("2" (case "rp = g OR rp = -g") (("1" (assert) (("1" (replace -1) (("1" (hide-all-but (-4 2)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "g" "perpR(g)" "rp") (("1" (assert) (("1" (assert) (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (hide-all-but (1 2)) (("2" (flatten) (("2" (case "g = -perpR(perpR(g))") (("1" (replace -1 +) (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (flatten) (("4" (replace -1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-20 1)) (("2" (rewrite "sq_eq" - :dir rl) (("2" (rewrite "sq_norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (case "sqv(g)=1") (("1" (expand "sqv" -1) (("1" (replace -1) (("1" (lemma "schwarz") (("1" (inst - "h" "g") (("1" (expand "abs") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-19 1)) (("2" (rewrite "sq_eq" - :dir rl) (("2" (rewrite "sq_norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil nil)) nil)) nil) ("4" (flatten) (("4" (replace -1) (("4" (assert) nil nil)) nil)) nil) ("5" (flatten) (("5" (replace -1) (("5" (assert) nil nil)) nil)) nil) ("6" (flatten) (("6" (replace -1) (("6" (assert) nil nil)) nil)) nil) ("7" (flatten) (("7" (replace -1) (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "orthonormal?") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 1)) (("2" (name "vp1" "IF perpR(vv1)*vv2 >= 0 THEN perpR(vv1) ELSE -perpR(vv1) ENDIF") (("2" (name "vp2" "IF perpR(vv2)*vv1 >= 0 THEN perpR(vv2) ELSE -perpR(vv2) ENDIF") (("2" (inst + "vp1" "vp2") (("2" (assert) (("2" (hide (-1 -2)) (("2" (split +) (("1" (expand "orthonormal?") (("1" (split +) (("1" (hide -) (("1" (expand "vp1") (("1" (grind) nil nil)) nil)) nil) ("2" (case "norm(perpR(vv1)) = 1") (("1" (expand "vp1") (("1" (lift-if) (("1" (rewrite "norm_neg") (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "orthonormal?") (("2" (split) (("1" (expand "vp2") (("1" (hide -) (("1" (grind) nil nil)) nil)) nil) ("2" (case "norm(perpR(vv2)) = 1") (("1" (expand "vp2") (("1" (rewrite "norm_neg") (("1" (lift-if) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -) (("3" (expand "vp1") (("3" (lift-if) (("3" (grind) nil nil)) nil)) nil)) nil) ("4" (hide -) (("4" (expand "vp2") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "(EXISTS (vv1,vv2:Nz_vect2): norm(vv1) = 1 AND norm(vv2) = 1 AND g*vv1 = g*vv2 AND (FORALL (ww:Nz_vect2): norm(ww)  =1 IMPLIES (ww*g > rp*g IFF (ww*vv1 > 0 OR ww*vv2 > 0))))") (("1" (hide 1) (("1" (skeep -1) (("1" (inst-cp - "h") (("1" (assert) (("1" (case "EXISTS (vp1,vp2:Nz_vect2): orthonormal?(vv1,vp1) and orthonormal?(vv2,vp2) AND vp1*vv2>=0 AND vp2*vv1>=0") (("1" (skeep -1) (("1" (case "norm(vp1) = 1 AND norm(vp2) = 1") (("1" (flatten) (("1" (assert) (("1" (lemma "max_circle_point_in_slice_union") (("1" (inst - "r" "s" "vv1" "vv2" "rp" "sp" "vp1" "vp2" "h" "g") (("1" (replace "thyp") (("1" (assert) (("1" (replace -12) (("1" (replace 1) (("1" (case "rp /= g") (("1" (inst-cp - "g") (("1" (assert) (("1" (replace -13 :dir rl) (("1" (case "g*g > rp*g") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (inst - "rp") (("1" (assert) nil nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst - "rp") (("1" (assert) nil nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (inst - "sp") (("1" (assert) nil nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (flatten) (("4" (inst - "sp") (("1" (assert) nil nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "orthonormal_basis") (("2" (inst - "g" "perpR(g)" "rp") (("2" (split -) (("1" (lemma "orthonormal_basis_norm") (("1" (inst - "rp*g" "rp*perpR(g)" "g" "perpR(g)" "rp") (("1" (assert) (("1" (assert) (("1" (hide -4) (("1" (case "sqv(g)=1") (("1" (expand "sqv" -1) (("1" (replace -1) (("1" (case "sq(rp*g) < 1") (("1" (rewrite "sqrt_lt" -1 :dir rl) (("1" (assert) (("1" (rewrite "sqrt_sq") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (case "NOT sq(rp*g) = 1") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (lemma "sq_eq_0") (("2" (inst - "rp*perpR(g)") (("2" (assert) (("2" (case "rp = g OR rp = -g") (("1" (assert) (("1" (replace -1) (("1" (hide-all-but (-4 2)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "g" "perpR(g)" "rp") (("1" (assert) (("1" (assert) (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (hide-all-but (1 2)) (("2" (flatten) (("2" (case "g = -perpR(perpR(g))") (("1" (replace -1 +) (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (flatten) (("4" (replace -1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-20 1)) (("2" (rewrite "sq_eq" - :dir rl) (("2" (rewrite "sq_norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) (("2" (hide-all-but (-24 +)) (("2" (expand "orthonormal?") (("2" (expand "orthogonal?") (("2" (flatten) (("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil nil)) nil)) nil) ("4" (flatten) (("4" (replace -1) (("4" (assert) nil nil)) nil)) nil) ("5" (flatten) (("5" (replace -1) (("5" (assert) nil nil)) nil)) nil) ("6" (flatten) (("6" (replace -1) (("6" (assert) nil nil)) nil)) nil) ("7" (flatten) (("7" (replace -1) (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "orthonormal?") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 1)) (("2" (name "vp1" "IF perpR(vv1)*vv2 >= 0 THEN perpR(vv1) ELSE -perpR(vv1) ENDIF") (("2" (name "vp2" "IF perpR(vv2)*vv1 >= 0 THEN perpR(vv2) ELSE -perpR(vv2) ENDIF") (("2" (inst + "vp1" "vp2") (("2" (assert) (("2" (hide (-1 -2)) (("2" (split +) (("1" (expand "orthonormal?") (("1" (split +) (("1" (hide -) (("1" (expand "vp1") (("1" (grind) nil nil)) nil)) nil) ("2" (case "norm(perpR(vv1)) = 1") (("1" (expand "vp1") (("1" (lift-if) (("1" (rewrite "norm_neg") (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "orthonormal?") (("2" (split) (("1" (expand "vp2") (("1" (hide -) (("1" (grind) nil nil)) nil)) nil) ("2" (case "norm(perpR(vv2)) = 1") (("1" (expand "vp2") (("1" (rewrite "norm_neg") (("1" (lift-if) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -) (("3" (expand "vp1") (("3" (lift-if) (("3" (grind) nil nil)) nil)) nil)) nil) ("4" (hide -) (("4" (expand "vp2") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 -8 1 2)) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "h*r = 0") (("1" (hide 1) (("1" (case "h = rp OR h = -rp") (("1" (split -) (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (replace -1) (("2" (assert) (("2" (case "NOT rp*s = 0") (("1" (hide-all-but (-12 -15 1)) (("1" (grind) nil nil)) nil) ("2" (case "rp /= sp") (("1" (assert) (("1" (reveal "thislem") (("1" (inst - "sp" "s" "rp") (("1" (assert) (("1" (split -) (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (hide-all-but (-15 1)) (("2" (grind) nil nil)) nil)) nil) ("3" (hide-all-but (-14 -17 1)) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil nil)) nil)) nil) ("4" (flatten) (("4" (replace -1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) (("2" (case "r /= -s") (("1" (reveal "thislem") (("1" (inst - "s" "sp" "r") (("1" (assert) (("1" (hide-all-but (-5 1)) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil nil)) nil)) nil) ("4" (flatten) (("4" (replace -1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) (("2" (case "NOT sp*g <= 0") (("1" (hide-all-but (1 4)) (("1" (grind) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "rp" "r" "h") (("1" (assert) (("1" (assert) (("1" (split +) (("1" (hide-all-but (-12 1)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil nil)) nil)) nil) ("4" (replace -1) (("4" (assert) (("4" (flatten) (("4" (replace -1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "h*s = 0") (("1" (case "h = sp OR h=-sp") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (hide-all-but (-11 -16 1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "sp" "s" "h") (("1" (assert) (("1" (assert) (("1" (expand "orthonormal?") (("1" (split +) (("1" (assert) (("1" (flatten) (("1" (hide-all-but (-14 1)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) nil nil) ("3" (replace -1) (("3" (assert) nil nil)) nil) ("4" (flatten) (("4" (replace -1) (("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil nil)) nil)) nil) ("4" (flatten) (("4" (replace -1) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "orthonormal?") (("2" (assert) (("2" (hide-all-but (-3 1)) (("2" (split +) (("1" (hide -) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("3" (case "g = zero") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide -1) (("2" (expand "zero") (("2" (grind) (("2" (decompose-equality +) nil nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (max_circle_point_in_slice_lem-1 nil 3528474731 ("" (case "NOT FORALL (a1,a2,b1:Nz_vect2): orthonormal?(a1,a2) AND norm(b1) = 1 AND a2*b1 = 0 IMPLIES b1 = a1 OR b1 = -a1") (("1" (hide-all-but 1) (("1" (skeep) (("1" (lemma "orthonormal_basis") (("1" (inst - "a1" "a2" "b1") (("1" (assert) (("1" (case "b1*a2 = 0") (("1" (replace -1) (("1" (assert) (("1" (case "b1*a1 = 1 OR b1*a1 = -1") (("1" (split -) (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("2" (case "norm(a1) = 1") (("1" (replace -3 -5) (("1" (rewrite "norm_scal") (("1" (replace -1) (("1" (expand "abs") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "orthonormal?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "thislem" -1) (("2" (hide "thislem") (("2" (case "NOT FORALL (a1,a2,a3:Nz_vect2): orthonormal?(a1,a3) and orthonormal?(a2,a3) IMPLIES a1=a2 OR a1=-a2") (("1" (hide-all-but (-4 1)) (("1" (skeep) (("1" (lemma "orthonormal_basis") (("1" (inst - "a1" "a3" "a2") (("1" (assert) (("1" (expand "orthonormal?") (("1" (flatten) (("1" (expand "orthogonal?") (("1" (replace -5) (("1" (assert) (("1" (case "a2*a1 = 1 OR a2*a1 = -1") (("1" (split -) (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (replace -1) (("2" (assert) (("2" (replace -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1 -6) (("2" (rewrite "norm_scal") (("2" (replace -3) (("2" (expand "abs") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "thatlem" -1) (("2" (hide "thatlem") (("2" (case "NOT FORALL (aa,bb,cc,dd,ap,bp,cp,dp,h:Nz_vect2): orthonormal?(aa,ap) AND orthonormal?(bb,bp) AND orthonormal?(cc,cp) AND orthonormal?(dd,dp) and norm(h) = 1 and bp*aa>=0 AND ap*bb>=0 AND cp*dd>=0 AND dp*cc>=0 and aa/=bb AND cc/=dd AND h*aa>0 AND h*bb>0 AND h*cc>0 AND h*dd>0 IMPLIES (ap*cc>=0 AND ap*dd>=0) OR (bp*cc>=0 AND bp*dd>=0) OR (cp*aa>=0 AND cp*bb>=0) OR (dp*aa>=0 AND dp*bb>=0)") (("1" (hide 2) (("1" (skeep) (("1" (name "ff" "LAMBDA (vv:Vect2): min(min(min(vv*aa,vv*bb),vv*cc),vv*dd)") (("1" (case "ff(h)>=0") (("1" (case "EXISTS (vv:Nz_vect2): ff(vv) = 0") (("1" (case "EXISTS (vv:Nz_vect2): norm(vv)=1 AND ff(vv) = 0") (("1" (hide -2) (("1" (skeep -1) (("1" (case "(vv*aa =0 AND vv*bb>=0 AND vv*cc>=0 AND vv*dd>=0) OR (vv*aa >=0 AND vv*bb=0 AND vv*cc>=0 AND vv*dd>=0) OR (vv*aa >=0 AND vv*bb>=0 AND vv*cc=0 AND vv*dd>=0) OR (vv*aa >=0 AND vv*bb>=0 AND vv*cc>=0 AND vv*dd=0)") (("1" (split -) (("1" (flatten) (("1" (case "vv = ap") (("1" (ground) nil nil) ("2" (case "vv = -ap") (("1" (replace -1) (("1" (case "ap*bb = 0") (("1" (case "bb = -aa") (("1" (replace -1) (("1" (hide-all-but (-21 -22)) (("1" (grind) nil nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "aa" "ap" "bb") (("2" (assert) (("2" (expand "orthonormal?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -16 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (reveal "thatlem") (("2" (inst - "vv" "ap" "aa") (("2" (assert) (("2" (expand "orthonormal?") (("2" (flatten) (("2" (assert) (("2" (expand "orthogonal?") (("2" (hide-all-but (-9 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "vv = bp") (("1" (ground) nil nil) ("2" (case "vv = -bp") (("1" (replace -1) (("1" (case "bp*aa = 0") (("1" (case "aa = -bb") (("1" (replace -1) (("1" (hide-all-but (-21 -22)) (("1" (grind) nil nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "bb" "bp" "aa") (("2" (assert) (("2" (expand "orthonormal?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -15 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (reveal "thatlem") (("2" (inst - "vv" "bp" "bb") (("2" (assert) (("2" (expand "orthonormal?") (("2" (flatten) (("2" (assert) (("2" (expand "orthogonal?") (("2" (hide-all-but (-12 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (case "vv = cp") (("1" (ground) nil nil) ("2" (case "vv = -cp") (("1" (replace -1) (("1" (case "cp*dd = 0") (("1" (case "cc = -dd") (("1" (replace -1) (("1" (hide-all-but (-23 -24)) (("1" (grind) nil nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "cc" "cp" "dd") (("2" (assert) (("2" (expand "orthonormal?") (("2" (flatten) (("2" (assert) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -17 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (reveal "thatlem") (("2" (inst - "vv" "cp" "cc") (("2" (assert) (("2" (expand "orthonormal?") (("2" (flatten) (("2" (assert) (("2" (expand "orthogonal?") (("2" (hide-all-but (-15 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (flatten) (("4" (case "vv = dp") (("1" (ground) nil nil) ("2" (case "vv = -dp") (("1" (replace -1) (("1" (case "dp*cc = 0") (("1" (case "dd = -cc") (("1" (replace -1) (("1" (hide-all-but (-23 -24)) (("1" (grind) nil nil)) nil)) nil) ("2" (reveal "thislem") (("2" (inst - "dd" "dp" "cc") (("2" (assert) (("2" (expand "orthonormal?") (("2" (flatten) (("2" (assert) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 -18 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (reveal "thatlem") (("2" (inst - "vv" "dp" "dd") (("2" (assert) (("2" (expand "orthonormal?") (("2" (flatten) (("2" (assert) (("2" (expand "orthogonal?") (("2" (hide-all-but (-18 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand "ff") (("2" (flatten) (("2" (expand "min") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lift-if) (("2" (split -) (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lift-if) (("2" (split -) (("1" (assert) (("1" (flatten) (("1" (lift-if) (("1" (split -) (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lift-if) (("2" (split -) (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep -1) (("2" (inst + "^(vv)") (("2" (assert) (("2" (typepred "^(vv)") (("2" (assert) (("2" (hide-all-but (-1 -2 1)) (("2" (expand "^") (("2" (name "cck" "1/norm(vv)") (("2" (case "cck > 0") (("1" (replace -2) (("1" (hide -2) (("1" (case "FORALL (dzp:Vect2): (cck*vv)*dzp >=0 IFF vv*dzp>=0") (("1" (case "FORALL (dzp:Vect2): (cck*vv)*dzp=0 IFF vv*dzp=0") (("1" (inst-cp - "aa") (("1" (inst-cp - "bb") (("1" (inst-cp - "cc") (("1" (inst - "dd") (("1" (inst-cp - "aa") (("1" (inst-cp - "bb") (("1" (inst-cp - "cc") (("1" (inst - "dd") (("1" (hide -10) (("1" (case "(vv*aa =0 AND vv*bb>=0 AND vv*cc>=0 AND vv*dd>=0) OR (vv*aa >=0 AND vv*bb=0 AND vv*cc>=0 AND vv*dd>=0) OR (vv*aa >=0 AND vv*bb>=0 AND vv*cc=0 AND vv*dd>=0) OR (vv*aa >=0 AND vv*bb>=0 AND vv*cc>=0 AND vv*dd=0)") (("1" (case "((cck*vv)*aa =0 AND (cck*vv)*bb>=0 AND (cck*vv)*cc>=0 AND (cck*vv)*dd>=0) OR ((cck*vv)*aa >=0 AND (cck*vv)*bb=0 AND (cck*vv)*cc>=0 AND (cck*vv)*dd>=0) OR ((cck*vv)*aa >=0 AND (cck*vv)*bb>=0 AND (cck*vv)*cc=0 AND (cck*vv)*dd>=0) OR ((cck*vv)*aa >=0 AND (cck*vv)*bb>=0 AND (cck*vv)*cc>=0 AND (cck*vv)*dd=0)") (("1" (hide-all-but (-1 1)) (("1" (expand "ff") (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (replace -1) (("1" (expand "min") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -2) (("2" (expand "min") (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (replace -3) (("3" (assert) (("3" (expand "min") (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (flatten) (("4" (replace -4) (("4" (assert) (("4" (expand "min") (("4" (lift-if) (("4" (lift-if) (("4" (lift-if) (("4" (assert) (("4" (lift-if) (("4" (assert) (("4" (lift-if) (("4" (lift-if) (("4" (assert) (("4" (lift-if) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-11 2)) (("2" (flatten) (("2" (split -) (("1" (flatten) (("1" (mult-by -1 "cck") (("1" (mult-by -2 "cck") (("1" (mult-by -3 "cck") (("1" (mult-by -4 "cck") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (mult-by -1 "cck") (("2" (mult-by -2 "cck") (("2" (mult-by -3 "cck") (("2" (mult-by -4 "cck") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (mult-by -1 "cck") (("3" (mult-by -2 "cck") (("3" (mult-by -3 "cck") (("3" (mult-by -4 "cck") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (flatten) (("4" (mult-by -1 "cck") (("4" (mult-by -2 "cck") (("4" (mult-by -3 "cck") (("4" (mult-by -4 "cck") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-10 1)) (("2" (flatten) (("2" (expand "ff") (("2" (expand "min") (("2" (assert) (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (ground) (("2" (mult-by 1 "cck") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (ground) (("1" (mult-by 1 "cck") (("1" (assert) nil nil)) nil) ("2" (mult-by -1 "cck") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (max_circle_point_in_slice_lem_eq 0 (max_circle_point_in_slice_lem_eq-2 nil 3529402662 ("" (skeep) (("" (replace -14) (("" (replace -15) (("" (assert) (("" (case "g*s>=0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (hide -10) (("2" (hide (-1 -5 -8 -11 -12 -13 -14)) (("2" (lemma "orthonormal_basis") (("2" (inst - "s" "sp" "h") (("2" (assert) (("2" (replace -1 +) (("2" (rewrite "dot_add_left") (("2" (assert) (("2" (case "h*sp <= 1") (("1" (mult-ineq -1 -7) (("1" (assert) (("1" (mult-by 1 "h*s") (("1" (assert) (("1" (case "s*g = g*s") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) (("1" (lemma "schwarz") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil) ("3" (lemma "schwarz") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (1 2)) (("5" (grind) nil nil)) nil)) nil) ("3" (ground) (("1" (hide-all-but (2 3)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (lemma "schwarz") (("2" (inst?) (("2" (expand "abs") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (norm_neg formula-decl nil vectors_2D vectors) (- const-decl "Vector" vectors_2D vectors) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (le_times_le_any1 formula-decl nil extra_real_props nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (schwarz formula-decl nil vectors_2D vectors) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nzrat_abs_is_pos application-judgement "{r: posrat | r >= q}" real_defs nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (<= const-decl "bool" reals nil) (dot_scal_left formula-decl nil vectors_2D vectors) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (dot_add_left formula-decl nil vectors_2D vectors) (* const-decl "Vector" vectors_2D vectors) (orthonormal_basis formula-decl nil basis_2D vectors) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (Vector type-eq-decl nil vectors_2D vectors) (* const-decl "real" vectors_2D vectors) (Vect2 type-eq-decl nil vectors_2D_def vectors)) nil) (max_circle_point_in_slice_lem_eq-1 nil 3528819132 ("" (skeep) (("" (replace -15) (("" (replace -14) (("" (hide (-1 -5 -8 -10 -12 -13 -14 -15)) (("" (case "NOT g*s >= 0") (("1" (hide 2) (("1" (case "-sp*g >= 0") (("1" (assert) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (max_circle_point_in_slide_sym_lem 0 (max_circle_point_in_slide_sym_lem-1 nil 3528469188 ("" (skeep) (("" (label "m1" 1) (("" (hide "m1") (("" (lemma "max_norm_increasing") (("" (inst - "R" "c-p" "e1perp" "w-p") (("" (assert) (("" (split -) (("1" (flatten) (("1" (label "oldspace" -11) (("1" (hide "oldspace") (("1" (expand "inter_circle_max_norm") (("1" (case "intersects_circle_fun?(w - p, c - p, R) AND intersects_circle_fun?(e1perp, c - p, R)") (("1" (flatten) (("1" (assert) (("1" (lemma "inter_circle_max_time_def") (("1" (inst - "R" "c-p" "w-p") (("1" (assert) (("1" (flatten) (("1" (inst - "1") (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (rewrite "norm_scal") (("1" (expand "abs" -1) (("1" (assert) (("1" (replace -7 +) (("1" (assert) (("1" (rewrite "norm_scal" +) (("1" (expand "abs" +) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (expand "circle?") (("2" (assert) (("2" (grind :exclude "norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (split +) (("1" (hide -1) (("1" (lemma "intersects_circle_fun_def") (("1" (inst?) (("1" (assert) (("1" (inst + "w-p") (("1" (split +) (("1" (expand "circle?") (("1" (hide-all-but (-2 1)) (("1" (grind :exclude "norm") nil nil)) nil)) nil) ("2" (expand "segment?") (("2" (inst + "1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lift-if) (("2" (ground) (("1" (case "w = p") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (case "inter_circle_max_time(w - p, c - p, R) = 0") (("1" (expand "inter_circle_max_time" -1) (("1" (case "w-p /= zero") (("1" (assert) (("1" (hide -1) (("1" (lemma "intersects_circle_fun_def") (("1" (inst - "R" "c-p" "e1perp") (("1" (assert) (("1" (inst + "zero") (("1" (split +) (("1" (expand "circle?") (("1" (assert) (("1" (lemma "Theta_D_unique[R]") (("1" (inst - "w-p" "-(c-p)" "0") (("1" (assert) (("1" (split -) (("1" (rewrite "sqv_eq_norm_eq") nil nil) ("2" (expand "intersects_circle_fun?") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "segment?") (("2" (inst + "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (flatten) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "posreal_times_posreal_is_posreal") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "intersects_circle_fun_def") (("2" (inst?) (("2" (assert) (("2" (inst + "w-p") (("2" (split +) (("1" (expand "circle?") (("1" (assert) (("1" (hide-all-but (-3 1)) (("1" (grind :exclude "norm") nil nil)) nil)) nil)) nil) ("2" (expand "segment?") (("2" (inst + "1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "w-p/=zero") (("1" (assert) (("1" (flatten) (("1" (label "oldspace" -10) (("1" (hide "oldspace") (("1" (lemma "max_circle_point_in_slice_lem") (("1" (inst - "^(e1)" "^(e2)" "^(c-p)" "^(w-p)" "^(e1perp)" "^(e2perp)") (("1" (assert) (("1" (lemma "max_circle_point_in_slice_lem_eq") (("1" (inst - "^(e1)" "^(e2)" "^(c-p)" "^(w-p)" "^(e1perp)" "^(e2perp)") (("1" (assert) (("1" (case "(NOT (^(c - p) * ^(e1) >= 0 AND ^(c - p) * ^(e2) >= 0))
                      AND ^(e2perp) * ^(c - p) <= ^(e1perp) * ^(c - p)
                      AND ^(w - p) * ^(e1) >= 0 AND ^(w - p) * ^(e2) >= 0
                      AND orthonormal?(^(e1), ^(e1perp)) AND orthonormal?(^(e2), ^(e2perp))
                      AND ^(e1perp) * ^(e2) >= 0 AND ^(e2perp) * ^(e1) >= 0") (("1" (flatten) (("1" (assert) (("1" (hide (-1 -2 -3 -4 -5 -6 -7)) (("1" (case "^(w - p) * ^(c - p) <= ^(e1perp) * ^(c - p)") (("1" (hide -2 -3) (("1" (mult-by 3 "1/norm(c-p)") (("1" (hide-all-but (-1 3)) (("1" (grind :exclude "norm") nil nil)) nil) ("2" (split +) (("1" (cross-mult 1) (("1" (ground) (("1" (lemma "norm_eq_0") (("1" (inst?) (("1" (assert) (("1" (hide-all-but (-1 6)) (("1" (expand "zero") (("1" (decompose-equality -) (("1" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) (("2" (hide-all-but (-1 6)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (cross-mult 1) (("2" (ground) (("1" (lemma "norm_eq_0") (("1" (inst?) (("1" (assert) (("1" (hide-all-but (-1 6)) (("1" (expand "zero") (("1" (decompose-equality -) (("1" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) (("2" (hide-all-but (-1 6)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "norm_eq_0") (("3" (inst?) (("3" (assert) (("3" (hide-all-but (-1 6)) (("3" (expand "zero") (("3" (decompose-equality -) (("3" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (reveal "oldspace") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2) (("2" (split +) (("1" (reveal "m1") (("1" (flatten) (("1" (split +) (("1" (mult-by 1 "1/norm(c-p)") (("1" (mult-by 1 "1/norm(e1)") (("1" (hide-all-but (-1 1)) (("1" (grind :exclude "norm") nil nil)) nil)) nil) ("2" (split +) (("1" (cross-mult 1) (("1" (ground) (("1" (lemma "norm_eq_0") (("1" (inst?) (("1" (assert) (("1" (hide-all-but (-1 6)) (("1" (expand "zero") (("1" (decompose-equality -) (("1" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (cross-mult 1) (("2" (ground) (("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) (("2" (hide-all-but (-1 6)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "norm_eq_0") (("3" (inst?) (("3" (assert) (("3" (hide-all-but (-1 6)) (("3" (expand "zero") (("3" (decompose-equality -) (("3" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (mult-by 1 "1/norm(c-p)") (("1" (mult-by 1 "1/norm(e2)") (("1" (hide-all-but (-2 1)) (("1" (grind :exclude "norm") nil nil)) nil)) nil) ("2" (split +) (("1" (cross-mult 1) (("1" (ground) (("1" (lemma "norm_eq_0") (("1" (inst?) (("1" (assert) (("1" (hide-all-but (-1 6)) (("1" (expand "zero") (("1" (decompose-equality -) (("1" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (cross-mult 1) (("2" (ground) (("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) (("2" (hide-all-but (-1 6)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "norm_eq_0") (("3" (inst?) (("3" (assert) (("3" (hide-all-but (-1 6)) (("3" (expand "zero") (("3" (decompose-equality -) (("3" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (mult-by -9 "1/norm(c-p)") (("1" (hide-all-but (-1 1)) (("1" (grind :exclude "norm") nil nil)) nil) ("2" (cross-mult 1) (("2" (ground) (("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) (("2" (hide-all-but (-1 6)) (("2" (expand "zero") (("2" (decompose-equality -) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "norm_eq_0") (("3" (inst?) (("3" (assert) (("3" (hide-all-but (-1 6)) (("3" (expand "zero") (("3" (decompose-equality -) (("3" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (mult-by -3 "1/norm(w-p)") (("1" (mult-by -1 "1/norm(e1)") (("1" (hide-all-but (-1 1)) (("1" (grind :exclude "norm") nil nil)) nil)) nil) ("2" (cross-mult 1) nil nil)) nil) ("4" (mult-by -4 "1/norm(w-p)") (("1" (mult-by -1 "1/norm(e2)") (("1" (hide-all-but (-1 1)) (("1" (grind :exclude "norm") nil nil)) nil)) nil) ("2" (cross-mult 1) nil nil)) nil) ("5" (expand "orthonormal?") (("5" (split +) (("1" (expand "orthogonal?") (("1" (mult-by -5 "1/norm(e1)") (("1" (mult-by -1 "1/norm(e1perp)") (("1" (hide-all-but (-1 1)) (("1" (grind :exclude "norm") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "e1") (("2" (typepred "^(e1)") (("2" (flatten) (("2" (replace -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (flatten) (("3" (typepred "^(e1perp)") (("3" (replace -2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand "orthonormal?") (("6" (split +) (("1" (expand "orthogonal?") (("1" (mult-by -6 "1/norm(e2)") (("1" (mult-by -1 "1/norm(e2perp)") (("1" (hide-all-but (-1 1)) (("1" (grind :exclude "norm") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "^(e2)") (("2" (flatten) (("2" (replace -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "^(e2perp)") (("3" (flatten) (("3" (replace -2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide-all-but (-7 1)) (("7" (mult-by -1 "1/norm(e1perp)") (("7" (mult-by -1 "1/norm(e2)") (("7" (grind :exclude "norm") nil nil)) nil)) nil)) nil) ("8" (hide-all-but (-8 1)) (("8" (mult-by -1 "1/norm(e2perp)") (("8" (mult-by -1 "1/norm(e1)") (("8" (grind :exclude "norm") nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (replace -1) (("3" (assert) nil nil)) nil)) nil) ("4" (flatten) (("4" (replace -2) (("4" (assert) nil nil)) nil)) nil) ("5" (flatten) (("5" (replace -1) (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((max_norm_increasing formula-decl nil circle_optimum_2D nil) (neg_nzv application-judgement "Nz_vector" vectors_2D vectors) (nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (c skolem-const-decl "Vect2" circle_optimum_2D nil) (p skolem-const-decl "Vect2" circle_optimum_2D nil) (^ const-decl "Normalized" vectors_2D vectors) (Normalized type-eq-decl nil vectors_2D vectors) (Nz_vector type-eq-decl nil vectors_2D vectors) (max_circle_point_in_slice_lem_eq formula-decl nil circle_optimum_2D nil) (dot_zero_right formula-decl nil vectors_2D vectors) (orthogonal? const-decl "bool" vectors_2D vectors) (both_sides_times1_imp formula-decl nil extra_real_props nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (w skolem-const-decl "Vect2" circle_optimum_2D nil) (div_mult_pos_ge1 formula-decl nil real_props nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (norm_eq_0 formula-decl nil vectors_2D vectors) (nonzero_real nonempty-type-eq-decl nil reals nil) (div_mult_pos_neg_ge1 formula-decl nil extra_real_props nil) (div_mult_pos_neg_gt1 formula-decl nil extra_real_props nil) (* const-decl "Vector" vectors_2D vectors) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (nz_nzv application-judgement "Nz_vector" vectors_2D vectors) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (orthonormal? const-decl "bool" basis_2D vectors) (<= const-decl "bool" reals nil) (* const-decl "real" vectors_2D vectors) (NOT const-decl "[bool -> bool]" booleans nil) (norm_normalize formula-decl nil vectors_2D vectors) (max_circle_point_in_slice_lem formula-decl nil circle_optimum_2D nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (intersects_circle_fun? const-decl "bool" circle_optimum_2D nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (scal_1 formula-decl nil vectors_2D vectors) (real_minus_real_is_real application-judgement "real" reals nil) (circle? const-decl "bool" circle_optimum_2D nil) (inter_circle_max_time const-decl "nnreal" circle_optimum_2D nil) (norm_scal formula-decl nil vectors_2D vectors) (add_cancel formula-decl nil vectors_2D vectors) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (nnreal type-eq-decl nil real_types nil) (inter_circle_max_time_def formula-decl nil circle_optimum_2D nil) (intersects_circle_fun_def formula-decl nil circle_optimum_2D nil) (segment? const-decl "bool" circle_optimum_2D nil) (= const-decl "[T, T -> boolean]" equalities nil) (sub_eq_args formula-decl nil vectors_2D vectors) (norm_zero formula-decl nil vectors_2D vectors) (dot_zero_left formula-decl nil vectors_2D vectors) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (norm const-decl "nnreal" vectors_2D vectors) (posreal_times_posreal_is_posreal judgement-tcc nil real_types nil) (sub_zero_left formula-decl nil vectors_2D vectors) (norm_neg formula-decl nil vectors_2D vectors) (- const-decl "Vector" vectors_2D vectors) (sqv_eq_norm_eq formula-decl nil vectors_2D vectors) (sqv_neg formula-decl nil vectors_2D vectors) (add_zero_right formula-decl nil vectors_2D vectors) (scal_0 formula-decl nil vectors_2D vectors) (Theta_D_unique formula-decl nil horizontal nil) (inter_circle_max_norm const-decl "nnreal" circle_optimum_2D nil) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (zero const-decl "Vector" vectors_2D vectors) (/= const-decl "boolean" notequal nil) (- const-decl "Vector" vectors_2D vectors) (Vector type-eq-decl nil vectors_2D vectors) (Vect2 type-eq-decl nil vectors_2D_def vectors) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (max_circle_point_in_slice_def 0 (max_circle_point_in_slice_def-2 nil 3529662189 ("" (skeep) (("" (skoletin 1) (("" (expand "max_circle_point_in_slice") (("" (case "c = p AND perpR(e1) * e2 >= 0") (("1" (flatten) (("1" (assert) (("1" (replaces -3) (("1" (case "NOT circle?(c, R)(p + (R / norm(e1)) * perpR(e1))") (("1" (hide 2) (("1" (replaces -1) (("1" (assert) (("1" (expand "circle?") (("1" (assert) (("1" (rewrite "norm_scal") (("1" (rewrite "abs_div") (("1" (case "FORALL (xz:nnreal): abs(xz) = xz") (("1" (rewrite -1) (("1" (rewrite -1) (("1" (rewrite -1) (("1" (case "norm(perpR(e1)) = norm(e1)") (("1" (replaces -1) (("1" (cross-mult 1) nil nil)) nil) ("2" (hide 2) (("2" (rewrite "sq_eq" 1 :dir rl) (("2" (rewrite "sq_norm") (("2" (rewrite "sq_norm") (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (expand "abs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (split +) (("1" (flatten) (("1" (hide -1) (("1" (split +) (("1" (hide -) (("1" (grind) nil nil)) nil) ("2" (mult-by -3 "R/norm(e1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "circle?" -1) (("2" (replace -5) (("2" (replace -1) (("2" (expand "circle?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (case "c = p") (("1" (assert) (("1" (case "NOT circle?(c, R)(p - (R / norm(e1)) * perpR(e1))") (("1" (hide 3) (("1" (replaces -1) (("1" (assert) (("1" (expand "circle?") (("1" (assert) (("1" (rewrite "norm_scal") (("1" (rewrite "abs_div") (("1" (case "FORALL (xz:nnreal): abs(xz) = xz") (("1" (rewrite -1) (("1" (rewrite -1) (("1" (rewrite -1) (("1" (case "norm(perpR(e1)) = norm(e1)") (("1" (replaces -1) (("1" (cross-mult 1) nil nil)) nil) ("2" (hide 2) (("2" (rewrite "sq_eq" 1 :dir rl) (("2" (rewrite "sq_norm") (("2" (rewrite "sq_norm") (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (expand "abs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replaces -3) (("2" (assert) (("2" (split +) (("1" (flatten) (("1" (hide -1) (("1" (hide -1) (("1" (split +) (("1" (hide-all-but 1) (("1" (grind :exclude "norm") nil nil)) nil) ("2" (mult-by 2 "R/norm(e1)") (("2" (assert) (("2" (hide -) (("2" (grind :exclude "norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "circle?" -1) (("2" (replace -5) (("2" (replace -1) (("2" (expand "circle?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (case "(c - p) * e1 >= 0 AND (c - p) * e2 >= 0") (("1" (flatten) (("1" (assert) (("1" (case "NOT circle?(c, R)(vv)") (("1" (hide 3) (("1" (expand "circle?") (("1" (case "vv-c = (R/norm(c-p))*(c-p)") (("1" (replaces -1) (("1" (rewrite "norm_scal") (("1" (rewrite "abs_div") (("1" (case "FORALL (xz:nnreal): abs(xz) = xz") (("1" (rewrite -1) (("1" (rewrite -1) (("1" (hide -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (expand "abs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -3 1) (("2" (hide-all-but 1) (("2" (grind :exclude "norm") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (split +) (("1" (flatten) (("1" (hide -1) (("1" (split +) (("1" (replaces -4 +) (("1" (mult-by -2 "1 + R/norm(c-p)") (("1" (assert) nil nil) ("2" (assert) (("2" (mult-by 1 "norm(c-p)") (("1" (assert) nil nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) (("2" (hide-all-but (-1 4)) (("2" (expand "zero") (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -4) (("2" (mult-by -3 "1 + R/norm(c-p)") (("1" (assert) nil nil) ("2" (mult-by 1 "norm(c-p)") (("1" (assert) nil nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) (("2" (hide-all-but (-1 4)) (("2" (expand "zero") (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (replaces -7) (("2" (assert) (("2" (rewrite "norm_scal" +) (("2" (case "FORALL (xz:nnreal): abs(xz) = xz") (("1" (rewrite -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "norm_triangle") (("1" (inst - "w" "c" "p") (("1" (expand "circle?" -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (eg1,eg2:nnreal): eg1+eg2>=0") (("1" (rewrite -1) (("1" (cross-mult 1) (("1" (ground) (("1" (lemma "norm_eq_0") (("1" (inst?) (("1" (assert) (("1" (hide-all-but (-1 4)) (("1" (expand "zero") (("1" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (expand "abs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "e1perp" "IF perpR(e1) * e2 >= 0 THEN perpR(e1) ELSE -perpR(e1) ENDIF") (("2" (replace -1) (("2" (name "e2perp" "(IF (-sign(e1 * e2)) * (perpR(e2) * e1) >= 0
                                                            THEN (-sign(e1 * e2)) * perpR(e2)
                                                          ELSE sign(e1 * e2) * perpR(e2)
                                                          ENDIF)") (("2" (replace -1) (("2" (case "(IF (-sign(e1 * e2)) * (perpR(e2) * e1) >= 0
                                                           THEN ^((-sign(e1 * e2)) * perpR(e2))
                                                         ELSE ^(sign(e1 * e2) * perpR(e2))
                                                         ENDIF) = ^(e2perp)") (("1" (replace -1) (("1" (case "(IF perpR(e1) * e2 >= 0 THEN ^(perpR(e1))
                                                                                                                                                                                                      ELSE ^(-perpR(e1))
                                                                                                                                                                                                      ENDIF) = ^(e1perp)") (("1" (replace -1) (("1" (replace 1) (("1" (case "orthogonal?(e1,e1perp) AND orthogonal?(e2,e2perp) AND e1perp*e2>=0 AND e2perp*e1>=0") (("1" (flatten) (("1" (hide (-5 -6 -7 -8)) (("1" (label "cpe" 1) (("1" (hide 1) (("1" (split +) (("1" (flatten) (("1" (split +) (("1" (replace -6 1) (("1" (lift-if +) (("1" (split +) (("1" (flatten) (("1" (lemma "inter_circle_max_time_def") (("1" (inst - "R" "c-p" "e1perp") (("1" (assert) (("1" (flatten) (("1" (split -) (("1" (assert) (("1" (expand "circle?") (("1" (hide-all-but (-1 1)) (("1" (grind :exclude ("norm " "inter_circle_max_time")) nil nil)) nil)) nil)) nil) ("2" (replace -8 -3) (("2" (assert) (("2" (lemma "intersects_circle_fun_scal") (("2" (inst?) (("1" (assert) nil nil) ("2" (assert) (("2" (case "FORALL (egptz:nnreal): NOT egptz=0 IMPLIES egptz>0") (("1" (rewrite -1) (("1" (replace -1) (("1" (assert) (("1" (lemma "intersects_circle_fun_def") (("1" (inst?) (("1" (assert) (("1" (inst + "zero") (("1" (lemma "intersects_circle_fun_def") (("1" (inst - "R" "c-p" "zero") (("1" (assert) (("1" (skeep -1) (("1" (expand "segment?") (("1" (skeep -2) (("1" (assert) (("1" (replace -2) (("1" (expand "circle?") (("1" (assert) (("1" (hide-all-but (-1 4)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "inter_circle_max_time_def") (("2" (inst - "R" "c-p" "e2perp") (("2" (assert) (("2" (flatten) (("2" (split -) (("1" (assert) (("1" (expand "circle?") (("1" (hide-all-but (-1 3)) (("1" (grind :exclude ("norm " "inter_circle_max_time")) nil nil)) nil)) nil)) nil) ("2" (replace -7 -2) (("2" (assert) (("2" (lemma "intersects_circle_fun_scal") (("2" (inst?) (("1" (assert) nil nil) ("2" (assert) (("2" (case "FORALL (egptz:nnreal): NOT egptz=0 IMPLIES egptz>0") (("1" (rewrite -1) (("1" (hide 1) (("1" (replace -1) (("1" (assert) (("1" (lemma "intersects_circle_fun_def") (("1" (inst?) (("1" (assert) (("1" (inst + "zero") (("1" (lemma "intersects_circle_fun_def") (("1" (inst - "R" "c-p" "zero") (("1" (assert) (("1" (skeep -1) (("1" (expand "segment?") (("1" (skeep -2) (("1" (replace -2) (("1" (assert) (("1" (inst + "0") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (replace -2 1) (("1" (assert) (("1" (hide-all-but (-4 1)) (("1" (expand "orthogonal?") (("1" (mult-by -1 "inter_circle_max_time(e1perp, c - p, R)") (("1" (grind :exclude "inter_circle_max_time") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 3) (("2" (assert) (("2" (hide-all-but (-6 3)) (("2" (mult-by -1 "inter_circle_max_time(e2perp, c - p, R)") (("2" (grind :exclude "inter_circle_max_time") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lift-if) (("3" (split -) (("1" (flatten) (("1" (replace -2 1) (("1" (assert) (("1" (hide-all-but (-6 1)) (("1" (mult-by -1 "inter_circle_max_time(e1perp, c - p, R)") (("1" (grind :exclude "inter_circle_max_time") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 3) (("2" (assert) (("2" (hide-all-but (-4 3)) (("2" (expand "orthogonal?") (("2" (mult-by -1 "inter_circle_max_time(e2perp, c - p, R)") (("2" (grind :exclude "inter_circle_max_time") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (lemma "max_circle_point_in_slide_sym_lem") (("2" (lift-if) (("2" (split -) (("1" (inst - "R" "c" "e1" "e2" "p" "w" "vv" "e1perp" "e2perp") (("1" (flatten) (("1" (split -1) (("1" (flatten) (("1" (assert) (("1" (split -) (("1" (reveal 1) (("1" (propax) nil nil)) nil) ("2" (flatten) (("2" (case "(^(e2perp) * ^(c - p) <= 0 AND
                                                                                                                           ^(e1) = -^(e2) AND
                                                                                                                            ^(e1perp) = ^(e2perp) AND ^(w - p) = -^(e2perp))") (("1" (flatten) (("1" (assert) (("1" (hide 1) (("1" (case "^(e1perp) = -^(e2perp)") (("1" (assert) (("1" (replace -1) (("1" (case "^(e2perp) = zero") (("1" (assert) nil nil) ("2" (hide-all-but (-4 1)) (("2" (case "^(e2perp) - -^(e2perp) = zero") (("1" (case "^(e2perp) + ^(e2perp) = zero") (("1" (hide -2) (("1" (hide -2) (("1" (expand "zero") (("1" (decompose-equality -) (("1" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind :exclude "^") nil nil)) nil)) nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 2 3)) (("2" (expand "e1perp") (("2" (expand "e2perp") (("2" (case "perpR(e1)*e2 = 0 AND perpR(e2)*e1 = 0") (("1" (flatten) (("1" (assert) (("1" (case "e1*e2 < 0") (("1" (expand "sign") (("1" (assert) (("1" (hide (-2 -3)) (("1" (case "^(perpR(e1)) = perpR(^(e1))") (("1" (replace -1) (("1" (replace -3 +) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (hide 2) (("2" (expand "^") (("2" (rewrite "perpR_scal") (("2" (cross-mult 1) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (mult-by 1 "(1/norm(e1))*(1/norm(e2))") (("2" (assert) (("2" (typepred "sqv(^(e1))") (("2" (expand "sqv" -2) (("2" (case "^(e1)*(-^(e2)) > 0") (("1" (hide-all-but (-1 1)) (("1" (grind :exclude "norm") nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3 4) (("2" (case "e1 = -(norm(e1)/norm(e2))*e2") (("1" (replace -1) (("1" (hide -) (("1" (grind :exclude "norm") nil nil)) nil)) nil) ("2" (hide 2) (("2" (expand "^") (("2" (name "e1n" "norm(e1)") (("2" (case "e1 = norm(e1)*((1/norm(e1))*e1)") (("1" (replace -2) (("1" (replace -1 +) (("1" (replace -3) (("1" (hide -) (("1" (grind :exclude "norm") nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "c-p/=zero") (("1" (assert) (("1" (case "w = p") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (case "w-p/=zero") (("1" (hide 1) (("1" (assert) (("1" (replace 1) (("1" (hide (-1 -2)) (("1" (lemma "max_circle_point_in_slide_sym_lem") (("1" (inst - "R" "c" "e1" "e2" "p" "w" "vv" "e1perp" "e2perp") (("1" (assert) (("1" (case "NOT (^(c - p) * ^(e1) >= 0 AND ^(c - p) * ^(e2) >= 0)") (("1" (replace 1) (("1" (case "NOT ((c - p) * e1 >= 0 AND (c - p) * e2 >= 0)") (("1" (replace 1) (("1" (flatten) (("1" (assert) (("1" (hide-all-but (-1 -2)) (("1" (expand "e1perp") (("1" (expand "e2perp") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (case "e1*e2 >= 0") (("1" (expand "sign") (("1" (assert) (("1" (case "perpR(e1)*e2 = 0 AND perpR(e2)*e1 = 0") (("1" (flatten) (("1" (assert) (("1" (case "^(perpR(e1)) = ^(perpR(e2))") (("1" (replace -1 -6) (("1" (case "FORALL (zpt:Vect2): zpt = -zpt IMPLIES zpt = zero") (("1" (inst - "^(perpR(e2))") (("1" (split -) (("1" (assert) (("1" (typepred "^(perpR(e2))") (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide -) (("2" (skeep) (("2" (case "zpt - - zpt = zero") (("1" (case "2*zpt = zero") (("1" (hide-all-but (-1 1)) (("1" (expand "zero") (("1" (decompose-equality -) (("1" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (replace -1 :dir rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -5) (("2" (case "perpR(^(e1)) = perpR(^(e2))") (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3) (("2" (case "EXISTS (ccp:posreal): e1 = ccp*e2") (("1" (skeep -1) (("1" (replace -1 +) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (inst + "norm(e1)/norm(e2)") (("2" (hide -1) (("2" (expand "^") (("2" (name "c1v" "norm(e1)") (("2" (replace -1) (("2" (case "e1 = c1v*((1/c1v)*e1)") (("1" (replace -3) (("1" (replace -1 +) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (mult-by 1 "(1/norm(e1))*(1/norm(e2))") (("2" (typepred "sqv(^(e1))") (("2" (expand "sqv" -2) (("2" (case "^(e1)*^(e2) > 0") (("1" (hide-all-but (-1 1)) (("1" (grind :exclude "norm") nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide (2 3)) (("2" (mult-by -1 "(1/norm(c-p))*(1/norm(e1))") (("1" (mult-by -2 "(1/norm(c-p))*(1/norm(e2))") (("1" (hide-all-but (-1 -2 1)) (("1" (grind :exclude "norm") nil nil)) nil) ("2" (cross-mult 1) (("2" (split 1) (("1" (propax) nil nil) ("2" (assert) (("2" (lemma "norm_eq_0") (("2" (assert) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (cross-mult 1) (("2" (split 1) (("1" (propax) nil nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (lemma "norm_eq_0") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (reveal "cpe") (("2" (split +) (("1" (mult-by 1 "(1/norm(c-p))*(1/norm(e1))") (("1" (hide-all-but (-1 1)) (("1" (grind :exclude "norm") nil nil)) nil) ("2" (split +) (("1" (cross-mult 1) (("1" (split +) (("1" (propax) nil nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (cross-mult 1) (("2" (split +) (("1" (propax) nil nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "norm_eq_0") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (mult-by 1 "(1/norm(c-p))*(1/norm(e2))") (("1" (hide-all-but (-2 1)) (("1" (grind :exclude "norm") nil nil)) nil) ("2" (split +) (("1" (cross-mult 1) (("1" (split +) (("1" (propax) nil nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (cross-mult 1) (("2" (split +) (("1" (propax) nil nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "norm_eq_0") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (case "w = p+(w-p)") (("1" (replace -2 -1) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (hide-all-but 1) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "c = p + (c-p)") (("1" (replace -2 -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (replace -4) (("3" (assert) nil nil)) nil)) nil) ("4" (flatten) (("4" (case "c = p + (c-p)") (("1" (replace -2) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (inst - "R" "c" "e2" "e1" "p" "w" "vv" "e2perp" "e1perp") (("2" (assert) (("2" (split -) (("1" (flatten) (("1" (reveal "cpe") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (case "c-p/=zero") (("1" (assert) (("1" (flatten) (("1" (reveal "cpe") (("1" (split +) (("1" (mult-by 1 "(1/norm(c-p))*(1/norm(e1))") (("1" (hide-all-but (-2 1)) (("1" (grind :exclude "norm") nil nil)) nil) ("2" (split +) (("1" (cross-mult 1) (("1" (split +) (("1" (propax) nil nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (cross-mult 1) (("2" (split +) (("1" (propax) nil nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "norm_eq_0") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (mult-by 1 "(1/norm(c-p))*(1/norm(e2))") (("1" (hide-all-but (-1 1)) (("1" (grind :exclude "norm") nil nil)) nil) ("2" (split +) (("1" (cross-mult 1) (("1" (split +) (("1" (propax) nil nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (cross-mult 1) (("2" (split +) (("1" (propax) nil nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "norm_eq_0") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (case "c = p + (c-p)") (("1" (replace -2) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "e2perp") (("2" (expand "e1perp") (("2" (grind :exclude "sign") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "e1perp") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "e2perp") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (Vector type-eq-decl nil vectors_2D vectors) (/= const-decl "boolean" notequal nil) (zero const-decl "Vector" vectors_2D vectors) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (max_circle_point_in_slice const-decl "Vect2" circle_optimum_2D nil) (norm const-decl "nnreal" vectors_2D vectors) (nnreal type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (* const-decl "real" vectors_2D vectors) (circle? const-decl "bool" circle_optimum_2D nil) (- const-decl "Vector" vectors_2D vectors) (intersects_circle_fun? const-decl "bool" circle_optimum_2D nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (perpR const-decl "Vect2" perpendicular_2D vectors) (nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (nz_nzv application-judgement "Nz_vector" vectors_2D vectors) (perpR_nz application-judgement "Nz_vect2" perpendicular_2D vectors) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (+ const-decl "Vector" vectors_2D vectors) (* const-decl "Vector" vectors_2D vectors) (numfield nonempty-type-eq-decl nil number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (norm_scal formula-decl nil vectors_2D vectors) (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}" real_defs nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (times_div2 formula-decl nil real_props nil) (sq_eq formula-decl nil sq reals) (sq_nz_pos application-judgement "posreal" sq reals) (sqv const-decl "nnreal" vectors_2D vectors) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (minus_real_is_real application-judgement "real" reals nil) (nz_sqv_gt_0 application-judgement "posreal" vectors_2D vectors) (sq_norm formula-decl nil vectors_2D vectors) (abs_div formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (add_cancel formula-decl nil vectors_2D vectors) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (sqrt_pos application-judgement "posreal" sqrt reals) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (dot_scal_left formula-decl nil vectors_2D vectors) (norm_neg formula-decl nil vectors_2D vectors) (sub_cancel formula-decl nil vectors_2D vectors) (neg_nzv application-judgement "Nz_vector" vectors_2D vectors) (- const-decl "Vector" vectors_2D vectors) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (Nz_vector type-eq-decl nil vectors_2D vectors) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Sign type-eq-decl nil sign reals) (sign const-decl "Sign" sign reals) (Normalized type-eq-decl nil vectors_2D vectors) (^ const-decl "Normalized" vectors_2D vectors) (e2perp skolem-const-decl "Nz_vector" circle_optimum_2D nil) (intersects_circle_fun_scal formula-decl nil circle_optimum_2D nil) (scal_0 formula-decl nil vectors_2D vectors) (add_zero_right formula-decl nil vectors_2D vectors) (norm_zero formula-decl nil vectors_2D vectors) (sub_zero_left formula-decl nil vectors_2D vectors) (scal_zero formula-decl nil vectors_2D vectors) (segment? const-decl "bool" circle_optimum_2D nil) (intersects_circle_fun_def formula-decl nil circle_optimum_2D nil) (e1perp skolem-const-decl "Nz_vect2" circle_optimum_2D nil) (inter_circle_max_time const-decl "nnreal" circle_optimum_2D nil) (inter_circle_max_time_def formula-decl nil circle_optimum_2D nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (max_circle_point_in_slide_sym_lem formula-decl nil circle_optimum_2D nil) (sub_eq_args formula-decl nil vectors_2D vectors) (scal_div_mult_left formula-decl nil vectors_2D vectors) (nzreal nonempty-type-eq-decl nil reals nil) (scal_assoc formula-decl nil vectors_2D vectors) (times_div1 formula-decl nil real_props nil) (scal_div_mult_right formula-decl nil vectors_2D vectors) (perpR_scal formula-decl nil perpendicular_2D vectors) (scal_1 formula-decl nil vectors_2D vectors) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (< const-decl "bool" reals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (scal_neg_1 formula-decl nil vectors_2D vectors) (e2 skolem-const-decl "Nz_vect2" circle_optimum_2D nil) (div_mult_pos_ge1 formula-decl nil real_props nil) (e1 skolem-const-decl "Nz_vect2" circle_optimum_2D nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (div_mult_pos_neg_gt1 formula-decl nil extra_real_props nil) (div_mult_pos_gt1 formula-decl nil extra_real_props nil) (dot_zero_left formula-decl nil vectors_2D vectors) (orthogonal? const-decl "bool" vectors_2D vectors) (real_minus_real_is_real application-judgement "real" reals nil) (norm_eq_0 formula-decl nil vectors_2D vectors) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (R skolem-const-decl "posreal" circle_optimum_2D nil) (c skolem-const-decl "Vect2" circle_optimum_2D nil) (p skolem-const-decl "Vect2" circle_optimum_2D nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (norm_triangle formula-decl nil vectors_2D vectors) (div_mult_pos_neg_ge1 formula-decl nil extra_real_props nil) (sign_neg_clos application-judgement "Sign" sign reals)) nil) (max_circle_point_in_slice_def-1 nil 3527939535 ("" (skeep) (("" (skoletin 1) (("" (expand "max_circle_point_in_slice") (("" (case "c = p AND perpR(e1) * e2 >= 0") (("1" (flatten) (("1" (assert) (("1" (replaces -3) (("1" (case "NOT circle?(c, R)(p + (R / norm(e1)) * perpR(e1))") (("1" (hide 2) (("1" (replaces -1) (("1" (assert) (("1" (expand "circle?") (("1" (assert) (("1" (rewrite "norm_scal") (("1" (rewrite "abs_div") (("1" (case "FORALL (xz:nnreal): abs(xz) = xz") (("1" (rewrite -1) (("1" (rewrite -1) (("1" (rewrite -1) (("1" (case "norm(perpR(e1)) = norm(e1)") (("1" (replaces -1) (("1" (cross-mult 1) nil nil)) nil) ("2" (hide 2) (("2" (rewrite "sq_eq" 1 :dir rl) (("2" (rewrite "sq_norm") (("2" (rewrite "sq_norm") (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (expand "abs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (split +) (("1" (flatten) (("1" (hide -1) (("1" (split +) (("1" (hide -) (("1" (grind) nil nil)) nil) ("2" (mult-by -3 "R/norm(e1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "circle?" -1) (("2" (replace -5) (("2" (replace -1) (("2" (expand "circle?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (case "c = p") (("1" (assert) (("1" (case "NOT circle?(c, R)(p - (R / norm(e1)) * perpR(e1))") (("1" (hide 3) (("1" (replaces -1) (("1" (assert) (("1" (expand "circle?") (("1" (assert) (("1" (rewrite "norm_scal") (("1" (rewrite "abs_div") (("1" (case "FORALL (xz:nnreal): abs(xz) = xz") (("1" (rewrite -1) (("1" (rewrite -1) (("1" (rewrite -1) (("1" (case "norm(perpR(e1)) = norm(e1)") (("1" (replaces -1) (("1" (cross-mult 1) nil nil)) nil) ("2" (hide 2) (("2" (rewrite "sq_eq" 1 :dir rl) (("2" (rewrite "sq_norm") (("2" (rewrite "sq_norm") (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (expand "abs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replaces -3) (("2" (assert) (("2" (split +) (("1" (flatten) (("1" (hide -1) (("1" (hide -1) (("1" (split +) (("1" (hide-all-but 1) (("1" (grind :exclude "norm") nil nil)) nil) ("2" (mult-by 2 "R/norm(e1)") (("2" (assert) (("2" (hide -) (("2" (grind :exclude "norm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "circle?" -1) (("2" (replace -5) (("2" (replace -1) (("2" (expand "circle?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (case "(c - p) * e1 >= 0 AND (c - p) * e2 >= 0") (("1" (flatten) (("1" (assert) (("1" (case "NOT circle?(c, R)(vv)") (("1" (hide 3) (("1" (expand "circle?") (("1" (case "vv-c = (R/norm(c-p))*(c-p)") (("1" (replaces -1) (("1" (rewrite "norm_scal") (("1" (rewrite "abs_div") (("1" (case "FORALL (xz:nnreal): abs(xz) = xz") (("1" (rewrite -1) (("1" (rewrite -1) (("1" (hide -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (expand "abs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -3 1) (("2" (hide-all-but 1) (("2" (grind :exclude "norm") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (split +) (("1" (flatten) (("1" (hide -1) (("1" (split +) (("1" (replaces -4 +) (("1" (mult-by -2 "1 + R/norm(c-p)") (("1" (assert) nil nil) ("2" (assert) (("2" (mult-by 1 "norm(c-p)") (("1" (assert) nil nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) (("2" (hide-all-but (-1 4)) (("2" (expand "zero") (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -4) (("2" (mult-by -3 "1 + R/norm(c-p)") (("1" (assert) nil nil) ("2" (mult-by 1 "norm(c-p)") (("1" (assert) nil nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) (("2" (hide-all-but (-1 4)) (("2" (expand "zero") (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (replaces -7) (("2" (assert) (("2" (rewrite "norm_scal" +) (("2" (case "FORALL (xz:nnreal): abs(xz) = xz") (("1" (rewrite -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "norm_triangle") (("1" (inst - "w" "c" "p") (("1" (expand "circle?" -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (eg1,eg2:nnreal): eg1+eg2>=0") (("1" (rewrite -1) (("1" (cross-mult 1) (("1" (ground) (("1" (lemma "norm_eq_0") (("1" (inst?) (("1" (assert) (("1" (hide-all-but (-1 4)) (("1" (expand "zero") (("1" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (expand "abs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "e1perp" "IF perpR(e1) * e2 >= 0 THEN perpR(e1) ELSE -perpR(e1) ENDIF") (("2" (replace -1) (("2" (name "e2perp" "IF perpR(e2) * e1 >= 0 THEN perpR(e2) ELSE -perpR(e2) ENDIF") (("2" (replace -1) (("2" (case "(IF perpR(e2) * e1 >= 0 THEN ^(perpR(e2))
                                                                                                ELSE ^(-perpR(e2))
                                                                                                ENDIF) = ^(e2perp)") (("1" (replace -1) (("1" (case "(IF perpR(e1) * e2 >= 0 THEN ^(perpR(e1))
                                                                                                            ELSE ^(-perpR(e1))
                                                                                                            ENDIF) = ^(e1perp)") (("1" (replace -1) (("1" (replace 1) (("1" (case "orthogonal?(e1,e1perp) AND orthogonal?(e2,e2perp) AND e1perp*e2>=0 AND e2perp*e1>=0") (("1" (flatten) (("1" (hide (-5 -6 -7 -8)) (("1" (hide 1) (("1" (split +) (("1" (flatten) (("1" (split +) (("1" (replace -6 1) (("1" (lift-if +) (("1" (split +) (("1" (flatten) (("1" (lemma "inter_circle_max_time_def") (("1" (inst - "R" "c-p" "e1perp") (("1" (assert) (("1" (flatten) (("1" (split -) (("1" (assert) (("1" (expand "circle?") (("1" (hide-all-but (-1 1)) (("1" (grind :exclude ("norm " "inter_circle_max_time")) nil nil)) nil)) nil)) nil) ("2" (replace -8 -3) (("2" (assert) (("2" (lemma "intersects_circle_fun_scal") (("2" (inst?) (("1" (assert) nil nil) ("2" (assert) (("2" (case "FORALL (egptz:nnreal): NOT egptz=0 IMPLIES egptz>0") (("1" (rewrite -1) (("1" (replace -1) (("1" (assert) (("1" (lemma "intersects_circle_fun_def") (("1" (inst?) (("1" (assert) (("1" (inst + "zero") (("1" (lemma "intersects_circle_fun_def") (("1" (inst - "R" "c-p" "zero") (("1" (assert) (("1" (skeep -1) (("1" (expand "segment?") (("1" (skeep -2) (("1" (assert) (("1" (replace -2) (("1" (expand "circle?") (("1" (assert) (("1" (hide-all-but (-1 4)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "inter_circle_max_time_def") (("2" (inst - "R" "c-p" "e2perp") (("2" (assert) (("2" (flatten) (("2" (split -) (("1" (assert) (("1" (expand "circle?") (("1" (hide-all-but (-1 3)) (("1" (grind :exclude ("norm " "inter_circle_max_time")) nil nil)) nil)) nil)) nil) ("2" (replace -7 -2) (("2" (assert) (("2" (lemma "intersects_circle_fun_scal") (("2" (inst?) (("1" (assert) nil nil) ("2" (assert) (("2" (case "FORALL (egptz:nnreal): NOT egptz=0 IMPLIES egptz>0") (("1" (rewrite -1) (("1" (hide 1) (("1" (replace -1) (("1" (assert) (("1" (lemma "intersects_circle_fun_def") (("1" (inst?) (("1" (assert) (("1" (inst + "zero") (("1" (lemma "intersects_circle_fun_def") (("1" (inst - "R" "c-p" "zero") (("1" (assert) (("1" (skeep -1) (("1" (expand "segment?") (("1" (skeep -2) (("1" (replace -2) (("1" (assert) (("1" (inst + "0") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (replace -2 1) (("1" (assert) (("1" (hide-all-but (-4 1)) (("1" (expand "orthogonal?") (("1" (mult-by -1 "inter_circle_max_time(e1perp, c - p, R)") (("1" (grind :exclude "inter_circle_max_time") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 3) (("2" (assert) (("2" (hide-all-but (-6 3)) (("2" (mult-by -1 "inter_circle_max_time(e2perp, c - p, R)") (("2" (grind :exclude "inter_circle_max_time") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lift-if) (("3" (split -) (("1" (flatten) (("1" (replace -2 1) (("1" (assert) (("1" (hide-all-but (-6 1)) (("1" (mult-by -1 "inter_circle_max_time(e1perp, c - p, R)") (("1" (grind :exclude "inter_circle_max_time") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 3) (("2" (assert) (("2" (hide-all-but (-4 3)) (("2" (expand "orthogonal?") (("2" (mult-by -1 "inter_circle_max_time(e2perp, c - p, R)") (("2" (grind :exclude "inter_circle_max_time") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (lemma "max_circle_point_in_slide_sym_lem") (("2" (lift-if) (("2" (split -) (("1" (inst - "R" "c" "e1" "e2" "p" "w" "vv" "e1perp" "e2perp") (("1" (ground) (("1" (reveal 1) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (inst - "R" "c" "e2" "e1" "p" "w" "vv" "e2perp" "e1perp") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (reveal 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "e1perp") (("2" (expand "e2perp") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (hide -3) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Nz_vect2 type-eq-decl nil vectors_2D vectors) (zero const-decl "Vector" vectors_2D vectors) (Vector type-eq-decl nil vectors_2D vectors) (Vect2 type-eq-decl nil vectors_2D_def vectors) (* const-decl "real" vectors_2D vectors) (norm const-decl "nnreal" vectors_2D vectors) (perpR const-decl "Vect2" perpendicular_2D vectors) (nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors) (nz_nzv application-judgement "Nz_vector" vectors_2D vectors) (perpR_nz application-judgement "Nz_vect2" perpendicular_2D vectors) (+ const-decl "Vector" vectors_2D vectors) (* const-decl "Vector" vectors_2D vectors) (norm_scal formula-decl nil vectors_2D vectors) (sq_eq formula-decl nil sq reals) (sq_nz_pos application-judgement "posreal" sq reals) (sqv const-decl "nnreal" vectors_2D vectors) (nz_sqv_gt_0 application-judgement "posreal" vectors_2D vectors) (sq_norm formula-decl nil vectors_2D vectors) (add_cancel formula-decl nil vectors_2D vectors) (sqrt_pos application-judgement "posreal" sqrt reals) (dot_scal_left formula-decl nil vectors_2D vectors) (norm_neg formula-decl nil vectors_2D vectors) (sub_cancel formula-decl nil vectors_2D vectors) (neg_nzv application-judgement "Nz_vector" vectors_2D vectors) (Normalized type-eq-decl nil vectors_2D vectors) (Nz_vector type-eq-decl nil vectors_2D vectors) (^ const-decl "Normalized" vectors_2D vectors) (scal_zero formula-decl nil vectors_2D vectors) (sub_zero_left formula-decl nil vectors_2D vectors) (norm_zero formula-decl nil vectors_2D vectors) (add_zero_right formula-decl nil vectors_2D vectors) (scal_0 formula-decl nil vectors_2D vectors) (orthogonal? const-decl "bool" vectors_2D vectors) (norm_eq_0 formula-decl nil vectors_2D vectors) (norm_triangle formula-decl nil vectors_2D vectors)) shostak)) (max_circle_point_in_slice_complete 0 (max_circle_point_in_slice_complete-1 nil 3529671822 ("" (skeep) (("" (skoletin 1) (("" (skeep) (("" (lemma "max_circle_point_in_slice_def") (("" (inst?) (("" (assert) (("" (replace -5 :dir rl) (("" (flatten) (("" (hide -1) (("" (inst - "w") (("" (assert) (("" (case "vv = p") (("1" (replace -1) (("1" (assert) (("1" (case "w = p") (("1" (replace -1) (("1" (rewrite "intersects_circle_fun_def") (("1" (inst + "zero") (("1" (assert) (("1" (expand "circle?") (("1" (assert) (("1" (split +) (("1" (hide-all-but (-4 1)) (("1" (grind) nil nil)) nil) ("2" (expand "segment?") (("2" (inst + "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) (("2" (case "w = p + (w-p)") (("1" (replace -2) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "max_circle_point_in_slice") (("2" (name "e1perp" "IF perpR(e1)*e2 >= 0 THEN perpR(e1) ELSE -perpR(e1) ENDIF") (("2" (replace -1) (("2" (name "e2perp" "IF (-sign(e1*e2))*(perpR(e2)*e1) >= 0 THEN (-sign(e1*e2))*perpR(e2) ELSE sign(e1*e2)*perpR(e2) ENDIF") (("2" (replace -1) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (case "c = p") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (hide -) (("1" (expand "intersects_circle_fun?") (("1" (case "vv-p/=zero") (("1" (assert) (("1" (expand "Delta") (("1" (assert) (("1" (rewrite "det_zero_left") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (flatten) (("2" (case "vv = p + (vv-p)") (("1" (replace -2) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (split -7) (("1" (flatten) (("1" (replace -3 3) (("1" (assert) (("1" (hide -) (("1" (rewrite "intersects_circle_fun_def") (("1" (expand "circle?") (("1" (expand "segment?") (("1" (inst + "(c-p) + (R/norm(c-p))*(c-p)") (("1" (assert) (("1" (split +) (("1" (rewrite "norm_scal") (("1" (rewrite "abs_div") (("1" (expand "abs") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst + "1") (("2" (grind :exclude "norm") nil nil)) nil)) nil)) nil) ("2" (lemma "norm_eq_0") (("2" (inst?) (("2" (assert) (("2" (case "c = p + (c-p)") (("1" (replace -2) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality +) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -) (("1" (flatten) (("1" (split -) (("1" (flatten) (("1" (replace -2 6) (("1" (assert) (("1" (lemma "intersects_circle_fun_scal") (("1" (case "inter_circle_max_time(e1perp, c - p, R)/=0") (("1" (inst?) (("1" (assert) (("1" (expand "inter_circle_max_time" +) (("1" (assert) (("1" (expand "inter_circle_max_time" -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "inter_circle_max_time(e1perp, c - p, R) = 0") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -2 +) (("2" (assert) (("2" (case "inter_circle_max_time(e1perp, c - p, R) /= 0") (("1" (lemma "intersects_circle_fun_scal") (("1" (inst?) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -1 6) (("2" (assert) (("2" (case "inter_circle_max_time(e2perp, c - p, R) /= 0") (("1" (lemma "intersects_circle_fun_scal") (("1" (inst?) (("1" (assert) (("1" (expand "inter_circle_max_time" -1) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (Vector type-eq-decl nil vectors_2D vectors) (/= const-decl "boolean" notequal nil) (zero const-decl "Vector" vectors_2D vectors) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (max_circle_point_in_slice const-decl "Vect2" circle_optimum_2D nil) (intersects_circle_fun? const-decl "bool" circle_optimum_2D nil) (- const-decl "Vector" vectors_2D vectors) (* const-decl "real" vectors_2D vectors) (circle? const-decl "bool" circle_optimum_2D nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (max_circle_point_in_slice_def formula-decl nil circle_optimum_2D nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (sub_eq_args formula-decl nil vectors_2D vectors) (norm_zero formula-decl nil vectors_2D vectors) (norm_eq_0 formula-decl nil vectors_2D vectors) (add_zero_right formula-decl nil vectors_2D vectors) (+ const-decl "Vector" vectors_2D vectors) (sqv const-decl "nnreal" vectors_2D vectors) (norm const-decl "nnreal" vectors_2D vectors) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (nnreal type-eq-decl nil real_types nil) (scal_zero formula-decl nil vectors_2D vectors) (segment? const-decl "bool" circle_optimum_2D nil) (norm_neg formula-decl nil vectors_2D vectors) (sub_zero_left formula-decl nil vectors_2D vectors) (dot_zero_left formula-decl nil vectors_2D vectors) (intersects_circle_fun_def formula-decl nil circle_optimum_2D nil) (perpR_nz application-judgement "Nz_vect2" perpendicular_2D vectors) (neg_nzv application-judgement "Nz_vector" vectors_2D vectors) (IF const-decl "[boolean, T, T -> T]" if_def nil) (perpR const-decl "Vect2" perpendicular_2D vectors) (- const-decl "Vector" vectors_2D vectors) (nz_nzv application-judgement "Nz_vector" vectors_2D vectors) (Nz_vector type-eq-decl nil vectors_2D vectors) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Sign type-eq-decl nil sign reals) (sign const-decl "Sign" sign reals) (* const-decl "Vector" vectors_2D vectors) (Delta const-decl "real" horizontal nil) (det_zero_left formula-decl nil det_2D vectors) (sq_0 formula-decl nil sq reals) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (sqv_zero formula-decl nil vectors_2D vectors) (neg_zero formula-decl nil vectors_2D vectors) (sq_nz_pos application-judgement "posreal" sq reals) (c skolem-const-decl "Vect2" circle_optimum_2D nil) (p skolem-const-decl "Vect2" circle_optimum_2D nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (abs_div formula-decl nil real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}" real_defs nil) (norm_scal formula-decl nil vectors_2D vectors) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (scal_assoc formula-decl nil vectors_2D vectors) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (intersects_circle_fun_scal formula-decl nil circle_optimum_2D nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (e1perp skolem-const-decl "Nz_vect2" circle_optimum_2D nil) (R skolem-const-decl "posreal" circle_optimum_2D nil) (scal_0 formula-decl nil vectors_2D vectors) (inter_circle_max_time const-decl "nnreal" circle_optimum_2D nil) (e2perp skolem-const-decl "Nz_vector" circle_optimum_2D nil) (add_cancel formula-decl nil vectors_2D vectors) (nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (sign_neg_clos application-judgement "Sign" sign reals)) shostak)))
