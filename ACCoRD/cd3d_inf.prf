(cd3d_inf
 (conflict_3D_2D_inf_stable_TCC1 0
  (conflict_3D_2D_inf_stable_TCC1-1 nil 3483961475
   ("" (skeep)
    (("" (lemma "posreal_times_posreal_is_posreal")
      (("" (inst - "D" "abs(v`z)") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((posreal_times_posreal_is_posreal judgement-tcc nil real_types nil)
    (v skolem-const-decl "Vect3" cd3d_inf nil)
    (Vect3 type-eq-decl nil vectors_3D_def vectors)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (D formal-const-decl "posreal" cd3d_inf nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil))
   nil
   (conflict_3D_2D_inf_stable subtype
    "number_fields.*(cd3d_inf.D, real_defs.abs(cd3d_inf.v`z))" "posreal")))
 (conflict_3D_2D_inf_stable_TCC2 0
  (conflict_3D_2D_inf_stable_TCC2-1 nil 3483961475 ("" (subtype-tcc) nil nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (/= const-decl "boolean" notequal nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil
   (conflict_3D_2D_inf_stable subtype
    "(number_fields.-)(cd3d_inf.H, number_fields.*(sign.sign(cd3d_inf.v`z), cd3d_inf.s`z))"
    "{AB: real_types.posreal | reals.>(AB, real_defs.max((number_fields.-)((number_fields.-)(cd3d_inf.H), number_fields.*(sign.sign(cd3d_inf.v`z), cd3d_inf.s`z)), 0))}")))
 (conflict_3D_2D_inf_stable 0
  (conflict_3D_2D_inf_stable-2 "" 3790108263
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "conflict?")
          (("1" (skosimp*)
            (("1" (lemma "vertical_los_inside_Theta")
              (("1" (inst - "abs(v`z)" "sign(v`z)*s`z" "nnt!1")
                (("1" (flatten)
                  (("1" (hide -1)
                    (("1" (split -1)
                      (("1" (flatten)
                        (("1" (expand "Theta_H")
                          (("1" (case "sign(abs(v`z)) = 1")
                            (("1" (replace -1)
                              (("1" (hide -1)
                                (("1" (assert)
                                  (("1" (cross-mult -1)
                                    (("1" (cross-mult -2)
                                      (("1"
                                        (expand "conflict_2D?")
                                        (("1"
                                          (inst + "nnt!1*abs(v`z)")
                                          (("1"
                                            (rewrite "vect2_scal")
                                            (("1"
                                              (case
                                               "abs(v`z) * vect2(s) + nnt!1 * abs(v`z) * vect2(v) = abs(v`z)*(vect2(s)+nnt!1*vect2(v))")
                                              (("1"
                                                (replace -1)
                                                (("1"
                                                  (hide -1)
                                                  (("1"
                                                    (rewrite "sqv_scal")
                                                    (("1"
                                                      (rewrite "sq_times")
                                                      (("1"
                                                        (div-by 1 "sq(v`z)")
                                                        (("1"
                                                          (lemma "sq_eq_0")
                                                          (("1"
                                                            (inst?)
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (hide-all-but 1)
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (expand "max")
                                            (("2"
                                              (lift-if)
                                              (("2" (ground) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (expand "sign") (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2"
          (lemma "conflict_2D_on_open_interval[D *abs( v`z),
                               max(-H - sign(v`z) * s`z, 0),
                               H - sign(v`z) * s`z]")
          (("1" (inst?)
            (("1" (assert)
              (("1" (skosimp*)
                (("1" (name "t!2" "topen!1/abs(v`z)")
                  (("1"
                    (case "max(Theta_H[H](sign(v`z)*s`z,abs(v`z),-1),0)< t!2 AND t!2 < Theta_H[H](sign(v`z)*s`z,abs(v`z),1)")
                    (("1" (flatten)
                      (("1" (expand "conflict?")
                        (("1" (inst + "t!2")
                          (("1" (split 1)
                            (("1" (lemma "vertical_los_inside_Theta")
                              (("1" (inst - "abs(v`z)" "sign(v`z)*s`z" "t!2")
                                (("1" (flatten)
                                  (("1" (hide -2)
                                    (("1" (split -1)
                                      (("1"
                                        (hide-all-but (-1 +))
                                        (("1" (grind) nil nil))
                                        nil)
                                       ("2"
                                        (hide-all-but (-1 -2 1))
                                        (("2"
                                          (grind :exclude "Theta_H")
                                          nil
                                          nil))
                                        nil)
                                       ("3" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (rewrite "vect2_scal")
                              (("2"
                                (case "abs(v`z) * vect2(s) + topen!1 * vect2(v) = abs(v`z)*(vect2(s) + t!2*vect2(v))")
                                (("1" (replace -1)
                                  (("1" (rewrite "sqv_scal")
                                    (("1" (rewrite "sq_times")
                                      (("1" (div-by -7 "sq(v`z)") nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (replace -3 :dir rl)
                                  (("2" (hide-all-but (1 3))
                                    (("2" (grind :exclude "abs") nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide-all-but (-1 -2 1))
                            (("2" (grind :exclude "Theta_H") nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (replace -1 1 :dir rl)
                      (("2" (hide-all-but (-2 -3 -6 1))
                        (("2" (split)
                          (("1" (cross-mult 1)
                            (("1" (lemma "nneg_mult_max")
                              (("1"
                                (inst - "abs(v`z)"
                                 "Theta_H[H](sign(v`z) * s`z, abs(v`z), -1)"
                                 "0")
                                (("1" (replace -1)
                                  (("1" (expand "Theta_H")
                                    (("1" (case "v`z>0")
                                      (("1"
                                        (expand "abs")
                                        (("1"
                                          (expand "sign")
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (case "v`z < 0")
                                        (("1"
                                          (expand "abs")
                                          (("1"
                                            (expand "sign")
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil)
                                         ("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (cross-mult 1)
                            (("2" (expand "Theta_H")
                              (("2" (case "v`z>0")
                                (("1" (expand "abs")
                                  (("1" (expand "sign")
                                    (("1" (assert) nil nil)) nil))
                                  nil)
                                 ("2" (case "v`z < 0")
                                  (("1" (expand "abs")
                                    (("1" (expand "sign")
                                      (("1" (assert) nil nil)) nil))
                                    nil)
                                   ("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (hide-all-but (-2 1)) (("2" (assert) nil nil)) nil)
           ("3" (lemma "posreal_times_posreal_is_posreal")
            (("3" (inst - "D" "abs(v`z)") (("3" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (conflict_3D_2D_inf_stable-1 nil 3483961513
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "conflict?")
          (("1" (skosimp*)
            (("1" (lemma "vertical_los_inside_Theta")
              (("1" (inst - "abs(v`z)" "sign(v`z)*s`z" "nnt!1")
                (("1" (flatten)
                  (("1" (hide -1)
                    (("1" (split -1)
                      (("1" (flatten)
                        (("1" (expand "Theta_H")
                          (("1" (case "sign(abs(v`z)) = 1")
                            (("1" (replace -1)
                              (("1" (hide -1)
                                (("1" (assert)
                                  (("1" (cross-mult -1)
                                    (("1" (cross-mult -2)
                                      (("1"
                                        (expand "conflict_2D?")
                                        (("1"
                                          (inst + "nnt!1*abs(v`z)")
                                          (("1"
                                            (rewrite "vect2_scal")
                                            (("1"
                                              (case
                                               "abs(v`z) * vect2(s) + nnt!1 * abs(v`z) * vect2(v) = abs(v`z)*(vect2(s)+nnt!1*vect2(v))")
                                              (("1"
                                                (replace -1)
                                                (("1"
                                                  (hide -1)
                                                  (("1"
                                                    (rewrite "sqv_scal")
                                                    (("1"
                                                      (rewrite "sq_times")
                                                      (("1"
                                                        (div-by 1 "sq(v`z)")
                                                        (("1"
                                                          (lemma "sq_eq_0")
                                                          (("1"
                                                            (inst?)
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (hide-all-but 1)
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (expand "max")
                                            (("2"
                                              (lift-if)
                                              (("2" (ground) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (expand "sign") (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2"
          (lemma "conflict_2D_on_open_interval[D *abs( v`z),
                               max(-H - sign(v`z) * s`z, 0),
                               H - sign(v`z) * s`z]")
          (("1" (inst?)
            (("1" (assert)
              (("1" (replace -2)
                (("1" (assert)
                  (("1" (skosimp*)
                    (("1" (name "t!2" "topen!1/abs(v`z)")
                      (("1"
                        (case "max(Theta_H[H](sign(v`z)*s`z,abs(v`z),-1),0)< t!2 AND t!2 < Theta_H[H](sign(v`z)*s`z,abs(v`z),1)")
                        (("1" (flatten)
                          (("1" (expand "conflict?")
                            (("1" (inst + "t!2")
                              (("1" (split 1)
                                (("1" (lemma "vertical_los_inside_Theta")
                                  (("1"
                                    (inst - "abs(v`z)" "sign(v`z)*s`z" "t!2")
                                    (("1" (flatten)
                                      (("1"
                                        (hide -2)
                                        (("1"
                                          (split -1)
                                          (("1"
                                            (hide-all-but (-1 +))
                                            (("1" (grind) nil nil))
                                            nil)
                                           ("2"
                                            (hide-all-but (-1 -2 1))
                                            (("2"
                                              (grind :exclude "Theta_H")
                                              nil
                                              nil))
                                            nil)
                                           ("3" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (rewrite "vect2_scal")
                                  (("2"
                                    (case "abs(v`z) * vect2(s) + topen!1 * vect2(v) = abs(v`z)*(vect2(s) + t!2*vect2(v))")
                                    (("1" (replace -1)
                                      (("1"
                                        (rewrite "sqv_scal")
                                        (("1"
                                          (rewrite "sq_times")
                                          (("1"
                                            (div-by -7 "sq(v`z)")
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (replace -3 :dir rl)
                                      (("2"
                                        (hide-all-but (1 3))
                                        (("2" (grind :exclude "abs") nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (hide-all-but (-1 -2 1))
                                (("2" (grind :exclude "Theta_H") nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (replace -1 1 :dir rl)
                          (("2" (hide-all-but (-2 -3 -6 1))
                            (("2" (split)
                              (("1" (cross-mult 1)
                                (("1" (lemma "nneg_mult_max")
                                  (("1"
                                    (inst - "abs(v`z)"
                                     "Theta_H[H](sign(v`z) * s`z, abs(v`z), -1)"
                                     "0")
                                    (("1" (replace -1)
                                      (("1"
                                        (expand "Theta_H")
                                        (("1"
                                          (case "v`z>0")
                                          (("1"
                                            (expand "abs")
                                            (("1"
                                              (expand "sign")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (case "v`z < 0")
                                            (("1"
                                              (expand "abs")
                                              (("1"
                                                (expand "sign")
                                                (("1" (assert) nil nil))
                                                nil))
                                              nil)
                                             ("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (cross-mult 1)
                                (("2" (expand "Theta_H")
                                  (("2" (case "v`z>0")
                                    (("1" (expand "abs")
                                      (("1"
                                        (expand "sign")
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2" (case "v`z < 0")
                                      (("1"
                                        (expand "abs")
                                        (("1"
                                          (expand "sign")
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (hide-all-but (-2 1)) (("2" (assert) nil nil)) nil)
           ("3" (lemma "posreal_times_posreal_is_posreal")
            (("3" (inst - "D" "abs(v`z)")
              (("1" (assert) nil nil)
               ("2" (lemma "abs_eq_0")
                (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
              nil))
            nil)
           ("4" (lemma "posreal_times_posreal_is_posreal")
            (("4" (inst - "D" "abs(v`z)") (("4" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_plus_real_is_real application-judgement "real" reals nil)
    (conflict? const-decl "bool" space_3D nil)
    (H formal-const-decl "posreal" cd3d_inf nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (vertical_los_inside_Theta formula-decl nil vertical nil)
    (abs_nat formula-decl nil abs_lems reals)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (Theta_H const-decl "real" vertical nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (sq_nz_pos application-judgement "posreal" sq reals)
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D vect_analysis)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (div_mult_pos_lt2 formula-decl nil real_props nil)
    (<= const-decl "bool" reals nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (s skolem-const-decl "Vect3" cd3d_inf nil)
    (nnt!1 skolem-const-decl "nnreal" cd3d_inf nil)
    (Lookahead type-eq-decl nil Lookahead nil)
    (Vector type-eq-decl nil vectors_2D vectors)
    (+ const-decl "Vector" vectors_2D vectors)
    (* const-decl "Vector" vectors_2D vectors)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (vect2 const-decl "Vect2" vect_3D_2D vectors)
    (D formal-const-decl "posreal" cd3d_inf nil)
    (sq_times formula-decl nil sq reals) (sq_eq_0 formula-decl nil sq reals)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (times_div_cancel1 formula-decl nil extra_real_props nil)
    (times_div_cancel2 formula-decl nil extra_real_props nil)
    (sq const-decl "nonneg_real" sq reals)
    (sqv const-decl "nnreal" vectors_2D vectors)
    (both_sides_div_pos_lt1 formula-decl nil real_props nil)
    (sq_abs formula-decl nil sq reals)
    (sqv_scal formula-decl nil vectors_2D vectors)
    (minus_real_is_real application-judgement "real" reals nil)
    (vect2_scal formula-decl nil vect_3D_2D vectors)
    (conflict_2D? const-decl "bool" cd2d nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (div_mult_pos_gt2 formula-decl nil extra_real_props nil)
    (nnreal type-eq-decl nil real_types nil)
    (sign const-decl "Sign" sign reals) (Sign type-eq-decl nil sign reals)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (v skolem-const-decl "Vect3" cd3d_inf nil)
    (Vect3 type-eq-decl nil vectors_3D_def vectors)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (conflict_2D_on_open_interval formula-decl nil omega_2D nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nneg_mult_max formula-decl nil min_max reals)
    (div_mult_pos_lt1 formula-decl nil real_props nil)
    (t!2 skolem-const-decl "real" cd3d_inf nil)
    (< const-decl "bool" reals nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (Vector type-eq-decl nil vectors_3D vectors)
    (* const-decl "Vector" vectors_3D vectors)
    (posreal_times_posreal_is_posreal judgement-tcc nil real_types nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil))
   nil))
 (conflict_vz_swap 0
  (conflict_vz_swap-2 nil 3483962172
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "conflict?")
          (("1" (skosimp*)
            (("1" (inst + "nnt!1")
              (("1" (assert)
                (("1" (expand "abs")
                  (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (expand "conflict?")
          (("2" (skosimp*)
            (("2" (inst + "nnt!1")
              (("2" (assert)
                (("2" (expand "abs")
                  (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (conflict? const-decl "bool" space_3D nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (vect2_eq formula-decl nil vect_3D_2D vectors)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D vect_analysis)
    (sq_nz_pos application-judgement "posreal" sq reals))
   nil)
  (conflict_vz_swap-1 nil 3483962156 ("" (postpone) nil nil) nil shostak))
 (conflict_on_open_interval 0
  (conflict_on_open_interval-1 nil 3483962247
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "conflict?")
          (("1" (skosimp*)
            (("1"
              (case "exists (epH:posreal): FORALL (th: real): abs(th-nnt!1)<epH IMPLIES abs(s`z+th*v`z)<H")
              (("1" (skeep -1)
                (("1"
                  (case "exists (epD:posreal): FORALL (td: real): abs(td-nnt!1)<epD IMPLIES sqv(vect2(s)+td*vect2(v))<sq(D)")
                  (("1" (skeep -1)
                    (("1" (name "newt" "min(epD/2,epH/2)")
                      (("1" (case "newt > 0")
                        (("1" (case "nnt!1 = 0")
                          (("1" (replace -1)
                            (("1" (hide -1)
                              (("1" (inst + "newt")
                                (("1" (assert)
                                  (("1" (inst - "newt")
                                    (("1" (inst - "newt")
                                      (("1"
                                        (case
                                         "abs(newt)<epD and abs(newt)<epH")
                                        (("1"
                                          (flatten)
                                          (("1" (assert) nil nil))
                                          nil)
                                         ("2"
                                          (hide 2)
                                          (("2"
                                            (hide -3)
                                            (("2"
                                              (hide -3)
                                              (("2"
                                                (hide -3)
                                                (("2"
                                                  (hide -3)
                                                  (("2" (grind) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert)
                            (("2" (inst + "nnt!1") (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (case "vect2(v) = zero")
                    (("1" (replace -1) (("1" (assert) nil nil)) nil)
                     ("2" (hide -1)
                      (("2" (hide -1)
                        (("2" (hide 3)
                          (("2" (lemma "sqv_cont")
                            (("2" (expand "continuous_vr?")
                              (("2" (inst - "vect2(s) + nnt!1 * vect2(v)")
                                (("2" (expand "continuous_vr?")
                                  (("2"
                                    (inst -
                                     "sq(D) - sqv(vect2(s)+nnt!1*vect2(v))")
                                    (("1" (skosimp*)
                                      (("1"
                                        (inst + "delta!1/norm(vect2(v))")
                                        (("1"
                                          (skosimp*)
                                          (("1"
                                            (inst
                                             -
                                             "vect2(s) + td!1*vect2(v)")
                                            (("1"
                                              (split -1)
                                              (("1"
                                                (name
                                                 "const1"
                                                 "sqv(vect2(s) + td!1*vect2(v))")
                                                (("1"
                                                  (replace -1)
                                                  (("1"
                                                    (name
                                                     "const2"
                                                     "sqv(vect2(s) + nnt!1*vect2(v))")
                                                    (("1"
                                                      (replace -1)
                                                      (("1"
                                                        (hide -1)
                                                        (("1"
                                                          (hide -1)
                                                          (("1"
                                                            (hide -2)
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (case
                                                 "vect2(s) + td!1 * vect2(v) - (vect2(s) + nnt!1 * vect2(v)) = (td!1-nnt!1)*vect2(v)")
                                                (("1"
                                                  (replace -1)
                                                  (("1"
                                                    (rewrite "norm_scal")
                                                    (("1"
                                                      (cross-mult -2)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (hide-all-but 1)
                                                  (("2" (grind) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (lemma
                                           "posreal_div_posreal_is_posreal")
                                          (("2"
                                            (inst
                                             -
                                             "delta!1"
                                             "norm(vect2(v))")
                                            (("1" (assert) nil nil)
                                             ("2"
                                              (lemma "vectors_2D.norm_eq_0")
                                              (("2"
                                                (inst?)
                                                (("2" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("3"
                                          (lemma "vectors_2D.norm_eq_0")
                                          (("3"
                                            (inst?)
                                            (("3" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (case "v`z = 0")
                (("1" (replace -1) (("1" (assert) nil nil)) nil)
                 ("2" (inst + "(H-abs(s`z+nnt!1*v`z))/abs(v`z)")
                  (("1" (skosimp*)
                    (("1" (cross-mult -1)
                      (("1" (hide-all-but (-1 -2 2))
                        (("1" (rewrite "abs_mult" :dir rl)
                          (("1" (both-sides "+" "abs(s`z+nnt!1*v`z)" -1)
                            (("1" (assert)
                              (("1" (lemma "triangle")
                                (("1"
                                  (inst - "v`z * th!1 - v`z * nnt!1"
                                   "s`z + nnt!1 * v`z")
                                  (("1" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (split 1)
                    (("1" (cross-mult 1) (("1" (assert) nil nil)) nil)
                     ("2" (cross-mult 1) (("2" (assert) nil nil)) nil))
                    nil)
                   ("3" (expand "abs" 1)
                    (("3" (lift-if) (("3" (ground) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (skosimp*)
          (("2" (expand "conflict?")
            (("2" (inst + "topen!1") (("2" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((conflict? const-decl "bool" space_3D nil)
    (H formal-const-decl "posreal" cd3d_inf nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Vect3 type-eq-decl nil vectors_3D_def vectors)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnreal type-eq-decl nil real_types nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (D formal-const-decl "posreal" cd3d_inf nil)
    (sq const-decl "nonneg_real" sq reals)
    (* const-decl "Vector" vectors_2D vectors)
    (vect2 const-decl "Vect2" vect_3D_2D vectors)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (+ const-decl "Vector" vectors_2D vectors)
    (sqv const-decl "nnreal" vectors_2D vectors)
    (Vector type-eq-decl nil vectors_2D vectors)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (posreal_min application-judgement "{z: posreal | z <= x AND z <= y}"
     real_defs nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (<= const-decl "bool" reals nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (sq_nz_pos application-judgement "posreal" sq reals)
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D vect_analysis)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (scal_0 formula-decl nil vectors_2D vectors)
    (add_zero_right formula-decl nil vectors_2D vectors)
    (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}"
     real_defs nil)
    (continuous_vr? const-decl "bool" cont_vect2_real vect_analysis)
    (continuous_vr? const-decl "bool" cont_vect2_real vect_analysis)
    (posreal_div_posreal_is_posreal judgement-tcc nil real_types nil)
    (norm_eq_0 formula-decl nil vectors_2D vectors)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (div_mult_pos_lt2 formula-decl nil real_props nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (norm_scal formula-decl nil vectors_2D vectors)
    (- const-decl "Vector" vectors_2D vectors)
    (delta!1 skolem-const-decl "posreal" cd3d_inf nil)
    (norm const-decl "nnreal" vectors_2D vectors)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (v skolem-const-decl "Vect3" cd3d_inf nil)
    (nnt!1 skolem-const-decl "nnreal" cd3d_inf nil)
    (s skolem-const-decl "Vect3" cd3d_inf nil)
    (sqv_cont judgement-tcc nil vect_cont_2D vect_analysis)
    (scal_zero formula-decl nil vectors_2D vectors)
    (zero const-decl "Vector" vectors_2D vectors)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (abs_mult formula-decl nil real_props nil)
    (triangle formula-decl nil real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (both_sides_plus_lt1 formula-decl nil real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (div_mult_pos_gt1 formula-decl nil extra_real_props nil)
    (div_mult_pos_ge1 formula-decl nil real_props nil)
    (abs_nat formula-decl nil abs_lems reals)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil))
   nil))
 (detection_inf_TCC1 0
  (detection_inf_TCC1-1 nil 3483961475
   ("" (skeep)
    (("" (typepred "nzv")
      (("" (hide -3)
        (("" (expand "zero")
          (("" (grind) (("" (decompose-equality) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((Nz_vect3 type-eq-decl nil vectors_3D vectors)
    (zero const-decl "Vector" vectors_3D vectors)
    (/= const-decl "boolean" notequal nil)
    (Vector type-eq-decl nil vectors_3D vectors)
    (real nonempty-type-from-decl nil reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (zero const-decl "Vector" vectors_2D vectors)
    (vect2 const-decl "Vect2" vect_3D_2D vectors))
   nil (detection_inf subtype "cd3d_inf.nzv`z" "nzreal")))
 (detection_inf_TCC2 0
  (detection_inf_TCC2-1 nil 3483961475
   ("" (skeep)
    (("" (lemma "Delta_gt_0_nzv") (("" (inst?) (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((D formal-const-decl "posreal" cd3d_inf nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Delta_gt_0_nzv formula-decl nil horizontal nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (Vect3 type-eq-decl nil vectors_3D_def vectors)
    (vect2 const-decl "Vect2" vect_3D_2D vectors)
    (Vector type-eq-decl nil vectors_3D vectors)
    (/= const-decl "boolean" notequal nil)
    (zero const-decl "Vector" vectors_3D vectors)
    (Nz_vect3 type-eq-decl nil vectors_3D vectors))
   nil
   (detection_inf subtype "vect_3D_2D.vect2(cd3d_inf.nzv)"
    "{nzv | reals.>=(horizontal[cd3d_inf.D].Delta(vect_3D_2D.vect2(cd3d_inf.s), horizontal.nzv), 0)}")))
 (detection_inf_correct 0
  (detection_inf_correct-1 nil 3483963292
   ("" (skeep)
    (("" (skoletin 1)
      (("" (flatten)
        (("" (expand "detection_inf")
          (("" (lift-if)
            (("" (split -)
              (("1" (flatten)
                (("1" (assert)
                  (("1" (replace -1)
                    (("1" (assert)
                      (("1" (lemma "vertical_los_inside_Theta")
                        (("1" (inst?)
                          (("1" (assert)
                            (("1" (grind :exclude "Theta_H") nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (assert)
                  (("2" (split -1)
                    (("1" (flatten)
                      (("1" (assert)
                        (("1" (split -2)
                          (("1" (flatten)
                            (("1" (assert)
                              (("1" (split -)
                                (("1" (flatten) (("1" (assert) nil nil)) nil)
                                 ("2" (flatten)
                                  (("2" (lemma "vertical_los_inside_Theta")
                                    (("2" (inst? -1)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (lemma
                                           "horizontal_los_inside_Theta")
                                          (("2"
                                            (inst?)
                                            (("2"
                                              (assert)
                                              (("2"
                                                (grind
                                                 :exclude
                                                 ("sqv"
                                                  "vect2"
                                                  "Theta_D"
                                                  "Theta_H"
                                                  "Delta"))
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2" (split -2)
                              (("1" (flatten)
                                (("1" (assert)
                                  (("1" (split -)
                                    (("1" (flatten) (("1" (assert) nil nil))
                                      nil)
                                     ("2" (flatten)
                                      (("2"
                                        (lemma "horizontal_los_inside_Theta")
                                        (("2"
                                          (inst? -1)
                                          (("2"
                                            (assert)
                                            (("2"
                                              (grind
                                               :exclude
                                               ("sqv"
                                                "vect2"
                                                "Theta_D"
                                                "Theta_H"
                                                "Delta"))
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real nonempty-type-from-decl nil reals nil)
    (Vect3 type-eq-decl nil vectors_3D_def vectors)
    (Vector type-eq-decl nil vectors_3D vectors)
    (/= const-decl "boolean" notequal nil)
    (zero const-decl "Vector" vectors_3D vectors)
    (Nz_vect3 type-eq-decl nil vectors_3D vectors)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (detection_inf const-decl "[nnreal, nnreal]" cd3d_inf nil)
    (D formal-const-decl "posreal" cd3d_inf nil)
    (sq const-decl "nonneg_real" sq reals)
    (* const-decl "Vector" vectors_2D vectors)
    (vect2 const-decl "Vect2" vect_3D_2D vectors)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (+ const-decl "Vector" vectors_2D vectors)
    (sqv const-decl "nnreal" vectors_2D vectors)
    (Vector type-eq-decl nil vectors_2D vectors)
    (H formal-const-decl "posreal" cd3d_inf nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (sq_nz_pos application-judgement "posreal" sq reals)
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D vect_analysis)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (scal_zero formula-decl nil vectors_2D vectors)
    (add_zero_right formula-decl nil vectors_2D vectors)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (* const-decl "real" vectors_2D vectors)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vertical_los_inside_Theta formula-decl nil vertical nil)
    (horizontal_los_inside_Theta formula-decl nil horizontal nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (zero const-decl "Vector" vectors_2D vectors)
    (Nz_vect2 type-eq-decl nil vectors_2D vectors)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil))
   nil))
 (detection_inf_complete 0
  (detection_inf_complete-1 nil 3483963425
   ("" (skeep)
    (("" (skoletin 1)
      (("" (flatten)
        (("" (expand "detection_inf")
          (("" (lift-if)
            (("" (split -)
              (("1" (flatten)
                (("1" (assert)
                  (("1" (lemma "vertical_los_inside_Theta")
                    (("1" (inst? -1)
                      (("1" (assert)
                        (("1"
                          (grind :exclude
                           ("sqv" "vect2" "Theta_D" "Theta_H" "Delta"))
                          nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (assert)
                  (("2" (split -)
                    (("1" (flatten)
                      (("1" (split -)
                        (("1" (flatten)
                          (("1" (assert)
                            (("1" (split -)
                              (("1" (flatten) (("1" (assert) nil nil)) nil)
                               ("2" (flatten)
                                (("2" (assert)
                                  (("2" (lemma "vertical_los_inside_Theta")
                                    (("2" (inst?)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (lemma
                                           "horizontal_los_inside_Theta")
                                          (("2"
                                            (inst?)
                                            (("2"
                                              (assert)
                                              (("2"
                                                (grind
                                                 :exclude
                                                 ("sqv"
                                                  "vect2"
                                                  "Theta_D"
                                                  "Theta_H"
                                                  "Delta"))
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2" (assert)
                            (("2" (lemma "horizontal_los_inside_Theta")
                              (("2" (inst?)
                                (("2" (assert)
                                  (("2"
                                    (grind :exclude
                                     ("sqv" "vect2" "Theta_D" "Theta_H"
                                      "Delta"))
                                    nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (assert)
                        (("2" (replace 2)
                          (("2" (lemma "Delta_gt_0")
                            (("2" (inst - "s" "nzv")
                              (("2" (assert)
                                (("2" (split 1)
                                  (("1" (ground) nil nil)
                                   ("2" (expand "horizontal_conflict_ever?")
                                    (("2" (inst + "t") nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real nonempty-type-from-decl nil reals nil)
    (Vect3 type-eq-decl nil vectors_3D_def vectors)
    (Vector type-eq-decl nil vectors_3D vectors)
    (/= const-decl "boolean" notequal nil)
    (zero const-decl "Vector" vectors_3D vectors)
    (Nz_vect3 type-eq-decl nil vectors_3D vectors)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (detection_inf const-decl "[nnreal, nnreal]" cd3d_inf nil)
    (<= const-decl "bool" reals nil)
    (D formal-const-decl "posreal" cd3d_inf nil)
    (sq const-decl "nonneg_real" sq reals)
    (* const-decl "Vector" vectors_2D vectors)
    (vect2 const-decl "Vect2" vect_3D_2D vectors)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (+ const-decl "Vector" vectors_2D vectors)
    (sqv const-decl "nnreal" vectors_2D vectors)
    (Vector type-eq-decl nil vectors_2D vectors)
    (H formal-const-decl "posreal" cd3d_inf nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (sq_nz_pos application-judgement "posreal" sq reals)
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D vect_analysis)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (comp_zero_x formula-decl nil vectors_2D vectors)
    (comp_zero_y formula-decl nil vectors_2D vectors)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vertical_los_inside_Theta formula-decl nil vertical nil)
    (horizontal_conflict_ever? const-decl "bool" horizontal nil)
    (Delta_gt_0 formula-decl nil horizontal nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (horizontal_los_inside_Theta formula-decl nil horizontal nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (zero const-decl "Vector" vectors_2D vectors)
    (Nz_vect2 type-eq-decl nil vectors_2D vectors)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil))
   nil))
 (conflict_detection_inf 0
  (conflict_detection_inf-2 "" 3790108272
   ("" (skeep)
    (("" (name-replace "cd" "detection_inf(s,nzv)" :hide? nil)
      (("" (skoletin 1)
        (("" (split)
          (("1" (flatten)
            (("1" (lemma "detection_inf_complete")
              (("1" (expand "conflict?")
                (("1" (skeep -2)
                  (("1" (inst -1 "nzv" "s" "nnt")
                    (("1" (replaces -5)
                      (("1" (beta) (("1" (assert) nil nil)) nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (lemma "detection_inf_correct")
              (("2" (inst -1 "nzv" "s" "(tin+tout)/2")
                (("2" (replaces -5)
                  (("2" (beta)
                    (("2" (split)
                      (("1" (expand "conflict?")
                        (("1" (inst 1 "(tin+tout)/2") nil nil)) nil)
                       ("2" (grind-reals) nil nil)
                       ("3" (grind-reals) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (conflict_detection_inf-1 nil 3483963594
   ("" (skeep)
    (("" (name-replace "cd" "detection_inf(s,nzv)" :hide? nil)
      (("" (skoletin 1)
        (("" (split)
          (("1" (flatten)
            (("1" (lemma "detection_inf_complete")
              (("1" (expand "conflict?")
                (("1" (skeep -2)
                  (("1" (inst -1 "nzv" "s" "nnt")
                    (("1" (replaces -5)
                      (("1" (beta) (("1" (assert) nil nil)) nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (lemma "detection_inf_correct")
              (("2" (inst -1 "nzv" "s" "(tin+tout)/2")
                (("2" (replaces -5)
                  (("2" (beta)
                    (("2" (split)
                      (("1" (expand "conflict?")
                        (("1" (inst 1 "(tin+tout)/2") nil nil)) nil)
                       ("2" (grind-reals) nil nil)
                       ("3" (replaces -3 :dir rl)
                        (("3" (grind-reals) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Vect3 type-eq-decl nil vectors_3D_def vectors)
    (Vector type-eq-decl nil vectors_3D vectors)
    (/= const-decl "boolean" notequal nil)
    (zero const-decl "Vector" vectors_3D vectors)
    (Nz_vect3 type-eq-decl nil vectors_3D vectors)
    (detection_inf const-decl "[nnreal, nnreal]" cd3d_inf nil)
    (detection_inf_complete formula-decl nil cd3d_inf nil)
    (sq_nz_pos application-judgement "posreal" sq reals)
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D vect_analysis)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (detection_inf_correct formula-decl nil cd3d_inf nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (D formal-const-decl "posreal" cd3d_inf nil)
    (H formal-const-decl "posreal" cd3d_inf nil)
    (conflict? const-decl "bool" space_3D nil) (< const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil))
   nil))
 (cd3d_inf_rewrite_TCC1 0
  (cd3d_inf_rewrite_TCC1-1 nil 3483961475 ("" (subtype-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (/= const-decl "boolean" notequal nil)
    (H formal-const-decl "posreal" cd3d_inf nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Theta_H const-decl "real" vertical nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil))
   nil
   (cd3d_inf_rewrite subtype
    "vertical[cd3d_inf.H].Theta_H(cd3d_inf.s`z, cd3d_inf.v`z, 1)"
    "{AB: real_types.posreal | reals.>(AB, real_defs.max(vertical[cd3d_inf.H].Theta_H(cd3d_inf.s`z, cd3d_inf.v`z, (number_fields.-)(1)), 0))}")))
 (cd3d_inf_rewrite 0
  (cd3d_inf_rewrite-1 nil 3483963681
   ("" (skeep)
    (("" (expand "cd3d_inf?")
      (("" (split)
        (("1" (flatten)
          (("1" (split -)
            (("1" (flatten) (("1" (assert) nil nil)) nil)
             ("2" (flatten)
              (("2" (split -)
                (("1" (flatten)
                  (("1" (assert)
                    (("1" (hide 2)
                      (("1" (split)
                        (("1" (flatten)
                          (("1"
                            (lemma
                             "cd2d[D * abs(v`z), max(-H - sign(v`z) * s`z, 0),
                                                             H - sign(v`z) * s`z]")
                            (("1" (inst?)
                              (("1"
                                (lemma
                                 "cd2d[D, max(Theta_H[H](s`z, v`z, -1), 0), Theta_H[H](s`z, v`z, 1)]")
                                (("1" (inst?)
                                  (("1" (replaces (-1 -2) :dir rl)
                                    (("1" (expand "conflict_2D?")
                                      (("1"
                                        (skosimp*)
                                        (("1"
                                          (inst + "t!1/abs(v`z)")
                                          (("1"
                                            (rewrite "sqv_add")
                                            (("1"
                                              (rewrite "sqv_add")
                                              (("1"
                                                (rewrite "vect2_scal")
                                                (("1"
                                                  (rewrite "sqv_scal")
                                                  (("1"
                                                    (rewrite "sqv_scal")
                                                    (("1"
                                                      (rewrite "sqv_scal")
                                                      (("1"
                                                        (rewrite "sq_div")
                                                        (("1"
                                                          (mult-by
                                                           1
                                                           "sq(v`z)")
                                                          (("1"
                                                            (rewrite
                                                             "sq_times")
                                                            (("1"
                                                              (expand "sq")
                                                              (("1"
                                                                (hide-all-but
                                                                 (-3 1))
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (split 1)
                                            (("1" (cross-mult 1) nil nil)
                                             ("2"
                                              (assert)
                                              (("2"
                                                (typepred "t!1")
                                                (("2"
                                                  (cross-mult 1)
                                                  (("2"
                                                    (hide-all-but (-2 1 3))
                                                    (("2" (grind) nil nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("3"
                                              (cross-mult 1)
                                              (("3"
                                                (typepred "t!1")
                                                (("3"
                                                  (hide-all-but (-3 1))
                                                  (("3" (grind) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (lemma "posreal_times_posreal_is_posreal")
                              (("2" (inst - "D" "abs(v`z)") nil nil)) nil))
                            nil))
                          nil)
                         ("2" (mult-by 1 "abs(v`z)")
                          (("2" (hide-all-but (-1 1)) (("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (propax) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (split -1)
            (("1" (flatten) (("1" (assert) nil nil)) nil)
             ("2" (flatten)
              (("2" (split -)
                (("1" (flatten)
                  (("1" (assert)
                    (("1" (hide 2)
                      (("1" (split)
                        (("1" (flatten)
                          (("1"
                            (lemma
                             "cd2d[D, max(Theta_H(s`z, v`z, -1), 0), Theta_H(s`z, v`z, 1)]")
                            (("1" (inst?)
                              (("1"
                                (lemma
                                 "cd2d[D * abs(v`z), max(-H - sign(v`z) * s`z, 0),
                                                             H - sign(v`z) * s`z]")
                                (("1" (inst?)
                                  (("1" (replaces (-1 -2) :dir rl)
                                    (("1" (expand "conflict_2D?")
                                      (("1"
                                        (skosimp*)
                                        (("1"
                                          (inst + "t!1*abs(v`z)")
                                          (("1"
                                            (mult-by -3 "sq(v`z)")
                                            (("1"
                                              (hide-all-but (-3 1))
                                              (("1" (grind) nil nil))
                                              nil)
                                             ("2"
                                              (lemma "sq_eq_0")
                                              (("2"
                                                (inst?)
                                                (("2" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (split 1)
                                            (("1"
                                              (typepred "t!1")
                                              (("1"
                                                (mult-by -2 "abs(v`z)")
                                                (("1"
                                                  (hide-all-but (-1 1))
                                                  (("1"
                                                    (grind)
                                                    (("1"
                                                      (cross-mult -2)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (cross-mult 1)
                                                      nil
                                                      nil)
                                                     ("3"
                                                      (cross-mult -1)
                                                      nil
                                                      nil)
                                                     ("4"
                                                      (cross-mult 2)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (assert)
                                              (("2"
                                                (typepred "t!1")
                                                (("2"
                                                  (mult-by -3 "abs(v`z)")
                                                  (("2"
                                                    (hide-all-but (-1 1))
                                                    (("2" (grind) nil nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil)
                                 ("3"
                                  (lemma "posreal_times_posreal_is_posreal")
                                  (("3" (inst - "D" "abs(v`z)")
                                    (("3" (lemma "abs_eq_0")
                                      (("3"
                                        (inst?)
                                        (("3" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (mult-by -1 "abs(v`z)")
                          (("2" (hide -2)
                            (("2" (lemma "nneg_mult_max")
                              (("2"
                                (inst - "abs(v`z)" "Theta_H(s`z, v`z, -1)"
                                 "0")
                                (("2" (replace -1)
                                  (("2" (hide -1) (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (propax) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)
    (cd3d_inf? const-decl "bool" cd3d_inf nil)
    (nneg_mult_max formula-decl nil min_max reals)
    (abs_eq_0 formula-decl nil abs_lems reals)
    (t!1 skolem-const-decl
     "Lookahead[max(Theta_H[H](s`z, v`z, -1), 0), Theta_H[H](s`z, v`z, 1)]"
     cd3d_inf nil)
    (sq_eq_0 formula-decl nil sq reals)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (+ const-decl "Vector" vectors_2D vectors)
    (both_sides_times_pos_lt1 formula-decl nil real_props nil)
    (div_mult_neg_lt1 formula-decl nil real_props nil)
    (nonpos_real nonempty-type-eq-decl nil real_types nil)
    (negreal nonempty-type-eq-decl nil real_types nil)
    (div_mult_pos_lt1 formula-decl nil real_props nil)
    (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil)
    (posreal_times_posreal_is_posreal judgement-tcc nil real_types nil)
    (* const-decl "Vector" vectors_3D vectors)
    (Vector type-eq-decl nil vectors_3D vectors)
    (vect2 const-decl "Vect2" vect_3D_2D vectors)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (conflict_2D? const-decl "bool" cd2d nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nnreal type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil)
    (v skolem-const-decl "Vect3" cd3d_inf nil)
    (s skolem-const-decl "Vect3" cd3d_inf nil)
    (Lookahead type-eq-decl nil Lookahead nil)
    (t!1 skolem-const-decl
     "Lookahead[max(-H - sign(v`z) * s`z, 0), H - sign(v`z) * s`z]" cd3d_inf
     nil)
    (sqv_scal formula-decl nil vectors_2D vectors)
    (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil)
    (sq const-decl "nonneg_real" sq reals)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sqv const-decl "nnreal" vectors_2D vectors)
    (* const-decl "real" vectors_2D vectors)
    (sq_nz_pos application-judgement "posreal" sq reals)
    (< const-decl "bool" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (sq_times formula-decl nil sq reals) (sq_div formula-decl nil sq reals)
    (sq_abs formula-decl nil sq reals)
    (vect2_scal formula-decl nil vect_3D_2D vectors)
    (dot_scal_left formula-decl nil vectors_2D vectors)
    (dot_scal_right formula-decl nil vectors_2D vectors)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D vect_analysis)
    (sqv_add formula-decl nil vectors_2D vectors)
    (Vector type-eq-decl nil vectors_2D vectors)
    (* const-decl "Vector" vectors_2D vectors)
    (div_mult_pos_le1 formula-decl nil real_props nil)
    (div_mult_pos_le2 formula-decl nil real_props nil)
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (div_mult_pos_ge1 formula-decl nil real_props nil)
    (TRUE const-decl "bool" booleans nil)
    (Theta_H const-decl "real" vertical nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (cd2d formula-decl nil cd2d nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (D formal-const-decl "posreal" cd3d_inf nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (Vect3 type-eq-decl nil vectors_3D_def vectors)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (H formal-const-decl "posreal" cd3d_inf nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sign type-eq-decl nil sign reals) (sign const-decl "Sign" sign reals)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil))
 (cd3d_inf_correct 0
  (cd3d_inf_correct-1 nil 3483963945
   ("" (skeep)
    (("" (expand "cd3d_inf?")
      (("" (split -1)
        (("1" (flatten)
          (("1" (rewrite "cd2d_inf" :dir rl)
            (("1" (expand "horizontal_conflict?")
              (("1" (expand "conflict?")
                (("1" (skosimp*)
                  (("1" (inst + "nnt!1") (("1" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (split -1)
            (("1" (flatten)
              (("1" (hide 2)
                (("1" (lemma "conflict_3D_2D_inf_stable")
                  (("1" (inst?)
                    (("1" (assert)
                      (("1" (rewrite "cd2d")
                        (("1" (lemma "posreal_times_posreal_is_posreal")
                          (("1" (inst - "D" "abs(v`z)") nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (propax) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)
    (cd3d_inf? const-decl "bool" cd3d_inf nil)
    (conflict_3D_2D_inf_stable formula-decl nil cd3d_inf nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (posreal_times_posreal_is_posreal judgement-tcc nil real_types nil)
    (sign const-decl "Sign" sign reals) (Sign type-eq-decl nil sign reals)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (H formal-const-decl "posreal" cd3d_inf nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "Vector" vectors_3D vectors)
    (Vector type-eq-decl nil vectors_3D vectors)
    (cd2d formula-decl nil cd2d nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (horizontal_conflict? const-decl "bool" horizontal nil)
    (sq_nz_pos application-judgement "posreal" sq reals)
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D vect_analysis)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnreal type-eq-decl nil real_types nil)
    (conflict? const-decl "bool" space_3D nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (D formal-const-decl "posreal" cd3d_inf nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (vect2 const-decl "Vect2" vect_3D_2D vectors)
    (Vect3 type-eq-decl nil vectors_3D_def vectors)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (cd2d_inf formula-decl nil cd2d_inf nil))
   nil))
 (cd3d_inf_complete 0
  (cd3d_inf_complete-2 "" 3790108283
   ("" (skeep)
    (("" (expand "cd3d_inf?")
      (("" (split 1)
        (("1" (flatten)
          (("1" (rewrite "cd2d_inf" :dir rl)
            (("1" (expand "horizontal_conflict?")
              (("1" (expand "conflict?")
                (("1" (skosimp*) (("1" (inst + "nnt!1") nil nil)) nil)) nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (split 2)
            (("1" (flatten)
              (("1" (lemma "conflict_3D_2D_inf_stable")
                (("1" (inst - "s" "v")
                  (("1" (assert)
                    (("1" (rewrite "cd2d")
                      (("1" (lemma "posreal_times_posreal_is_posreal")
                        (("1" (inst - "D" "abs(v`z)") nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (case "v`z = 0")
              (("1" (assert)
                (("1" (expand "conflict?") (("1" (propax) nil nil)) nil)) nil)
               ("2" (hide 3)
                (("2" (assert)
                  (("2" (lemma "conflict_on_open_interval")
                    (("2" (inst - "s" "v")
                      (("2" (assert)
                        (("2" (skosimp*)
                          (("2" (lemma "vertical_los_inside_Theta")
                            (("2"
                              (inst - "abs(v`z)" "sign(v`z)*s`z" "topen!1")
                              (("1" (flatten)
                                (("1" (hide -1)
                                  (("1" (split -1)
                                    (("1" (flatten)
                                      (("1"
                                        (expand "Theta_H")
                                        (("1"
                                          (cross-mult -1)
                                          (("1"
                                            (case "sign(abs(v`z)) = 1")
                                            (("1"
                                              (replace -1)
                                              (("1"
                                                (hide -1)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (cross-mult -2)
                                                    (("1"
                                                      (mult-by -3 "abs(v`z)")
                                                      (("1"
                                                        (mult-by
                                                         -4
                                                         "abs(v`z)")
                                                        (("1"
                                                          (typepred "topen!1")
                                                          (("1"
                                                            (mult-by
                                                             -2
                                                             "abs(v`z)")
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (expand "sign")
                                              (("2" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (hide-all-but (-2 1))
                                      (("2" (grind) nil nil)) nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (cd3d_inf_complete-1 nil 3483964022
   ("" (skeep)
    (("" (expand "cd3d_inf?")
      (("" (split 1)
        (("1" (flatten)
          (("1" (rewrite "cd2d_inf" :dir rl)
            (("1" (expand "horizontal_conflict?")
              (("1" (expand "conflict?")
                (("1" (skosimp*) (("1" (inst + "nnt!1") nil nil)) nil)) nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (split 2)
            (("1" (flatten)
              (("1" (lemma "conflict_3D_2D_inf_stable")
                (("1" (inst - "s" "v")
                  (("1" (assert)
                    (("1" (rewrite "cd2d")
                      (("1" (lemma "posreal_times_posreal_is_posreal")
                        (("1" (inst - "D" "abs(v`z)") nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (case "v`z = 0")
              (("1" (assert)
                (("1" (expand "conflict?") (("1" (propax) nil nil)) nil)) nil)
               ("2" (hide 3)
                (("2" (assert)
                  (("2" (lemma "conflict_on_open_interval")
                    (("2" (inst - "s" "v")
                      (("2" (assert)
                        (("2" (skosimp*)
                          (("2" (lemma "vertical_los_inside_Theta")
                            (("2"
                              (inst - "abs(v`z)" "sign(v`z)*s`z" "topen!1")
                              (("1" (flatten)
                                (("1" (hide -1)
                                  (("1" (split -1)
                                    (("1" (flatten)
                                      (("1"
                                        (expand "Theta_H")
                                        (("1"
                                          (cross-mult -1)
                                          (("1"
                                            (case "sign(abs(v`z)) = 1")
                                            (("1"
                                              (replace -1)
                                              (("1"
                                                (hide -1)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (cross-mult -2)
                                                    (("1"
                                                      (mult-by -3 "abs(v`z)")
                                                      (("1"
                                                        (mult-by
                                                         -4
                                                         "abs(v`z)")
                                                        (("1"
                                                          (typepred "topen!1")
                                                          (("1"
                                                            (mult-by
                                                             -2
                                                             "abs(v`z)")
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (expand "sign")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (typepred "abs(v`z)")
                                                  (("2" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (hide-all-but (-2 1))
                                      (("2" (grind) nil nil)) nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)
    (cd3d_inf? const-decl "bool" cd3d_inf nil)
    (sign_nat formula-decl nil sign reals)
    (v skolem-const-decl "Vect3" cd3d_inf nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (div_mult_pos_gt2 formula-decl nil extra_real_props nil)
    (sq_nz_pos application-judgement "posreal" sq reals)
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D vect_analysis)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (both_sides_times_pos_lt1 formula-decl nil real_props nil)
    (Vector type-eq-decl nil vectors_2D vectors)
    (sqv const-decl "nnreal" vectors_2D vectors)
    (+ const-decl "Vector" vectors_2D vectors)
    (* const-decl "Vector" vectors_2D vectors)
    (sq const-decl "nonneg_real" sq reals)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (* const-decl "real" vectors_2D vectors)
    (both_sides_times_pos_gt1 formula-decl nil real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (div_mult_pos_lt2 formula-decl nil real_props nil)
    (Theta_H const-decl "real" vertical nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (vertical_los_inside_Theta formula-decl nil vertical nil)
    (conflict_on_open_interval formula-decl nil cd3d_inf nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (cd2d formula-decl nil cd2d nil)
    (Vector type-eq-decl nil vectors_3D vectors)
    (* const-decl "Vector" vectors_3D vectors)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (H formal-const-decl "posreal" cd3d_inf nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sign type-eq-decl nil sign reals) (sign const-decl "Sign" sign reals)
    (posreal_times_posreal_is_posreal judgement-tcc nil real_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (conflict_3D_2D_inf_stable formula-decl nil cd3d_inf nil)
    (horizontal_conflict? const-decl "bool" horizontal nil)
    (nnreal type-eq-decl nil real_types nil)
    (conflict? const-decl "bool" space_3D nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (D formal-const-decl "posreal" cd3d_inf nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (vect2 const-decl "Vect2" vect_3D_2D vectors)
    (Vect3 type-eq-decl nil vectors_3D_def vectors)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (cd2d_inf formula-decl nil cd2d_inf nil))
   nil))
 (cd3d_inf 0
  (cd3d_inf-1 nil 3483964245
   ("" (skeep)
    (("" (lemma "cd3d_inf_correct")
      (("" (inst? -1)
        (("" (lemma "cd3d_inf_complete")
          (("" (inst?) (("" (ground) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((cd3d_inf_correct formula-decl nil cd3d_inf nil)
    (cd3d_inf_complete formula-decl nil cd3d_inf nil)
    (Vect3 type-eq-decl nil vectors_3D_def vectors)
    (real nonempty-type-from-decl nil reals nil))
   nil)))

