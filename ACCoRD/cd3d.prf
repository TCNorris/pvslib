(cd3d
 (conflict_3D_2D_stable_TCC1 0
  (conflict_3D_2D_stable_TCC1-1 nil 3476708029
   ("" (skeep)
    (("" (lemma "posreal_times_posreal_is_posreal")
      (("" (inst - "D" "abs(v`z)") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((posreal_times_posreal_is_posreal judgement-tcc nil real_types nil)
    (sign_nat formula-decl nil sign "reals/")
    (abs_nat formula-decl nil abs_lems "reals/")
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil (Vect3 type-eq-decl nil vectors_3D_def "vectors/")
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (D formal-const-decl "posreal" cd3d nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil))
   nil
   (conflict_3D_2D_stable subtype
    "number_fields.*(cd3d.D, real_defs.abs(cd3d.v`z))" "posreal")))
 (conflict_3D_2D_stable_TCC2 0
  (conflict_3D_2D_stable_TCC2-1 nil 3476708029
   ("" (skeep)
    (("" (hide -1)
      (("" (lemma "nnreal_times_nnreal_is_nnreal")
        (("" (inst - "B" "abs(v`z)")
          (("" (lemma "nnreal_times_nnreal_is_nnreal")
            (("" (inst - "T" "abs(v`z)") (("" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nnreal type-eq-decl nil real_types nil)
    (B formal-const-decl "nnreal" cd3d nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (Vect3 type-eq-decl nil vectors_3D_def "vectors/")
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (T formal-const-decl "{AB: posreal | AB > B}" cd3d nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (sign const-decl "Sign" sign "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nnreal_times_nnreal_is_nnreal judgement-tcc nil real_types nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil))
   nil
   (conflict_3D_2D_stable subtype
    "real_defs.max((number_fields.-)((number_fields.-)(cd3d.H), number_fields.*(sign.sign(cd3d.v`z), cd3d.s`z)), number_fields.*(cd3d.B, real_defs.abs(cd3d.v`z)))"
    "nnreal")))
 (conflict_3D_2D_stable_TCC3 0
  (conflict_3D_2D_stable_TCC3-1 nil 3476708029
   ("" (skeep)
    ((""
      (case "min(max(-H - sign(v`z) * s`z, B * abs(v`z)), T * abs(v`z))>=0")
      (("1" (assert) nil nil)
       ("2" (hide-all-but (1 2))
        (("2" (lemma "nnreal_times_nnreal_is_nnreal")
          (("2" (inst - "B" "abs(v`z)")
            (("2" (lemma "nnreal_times_nnreal_is_nnreal")
              (("2" (inst - "T" "abs(v`z)") (("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-const-decl "{AB: posreal | AB > B}" cd3d nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (B formal-const-decl "nnreal" cd3d nil)
    (nnreal type-eq-decl nil real_types nil)
    (Vect3 type-eq-decl nil vectors_3D_def "vectors/")
    (sign const-decl "Sign" sign "reals/")
    (Sign type-eq-decl nil sign "reals/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (H formal-const-decl "posreal" cd3d nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnreal_times_nnreal_is_nnreal judgement-tcc nil real_types nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil))
   nil
   (conflict_3D_2D_stable subtype
    "real_defs.min((number_fields.-)(cd3d.H, number_fields.*(sign.sign(cd3d.v`z), cd3d.s`z)), number_fields.*(cd3d.T, real_defs.abs(cd3d.v`z)))"
    "{AB: real_types.posreal | reals.>(AB, real_defs.max((number_fields.-)((number_fields.-)(cd3d.H), number_fields.*(sign.sign(cd3d.v`z), cd3d.s`z)), number_fields.*(cd3d.B, real_defs.abs(cd3d.v`z))))}")))
 (conflict_3D_2D_stable 0
  (conflict_3D_2D_stable-1 nil 3476708029
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "conflict_3D?")
          (("1" (skosimp*)
            (("1" (lemma "vertical_los_inside_Theta")
              (("1" (inst - "abs(v`z)" "sign(v`z)*s`z" "t!1")
                (("1" (flatten)
                  (("1" (hide -1)
                    (("1" (split -1)
                      (("1" (flatten)
                        (("1" (expand "Theta_H")
                          (("1" (case "sign(abs(v`z)) = 1")
                            (("1" (replace -1)
                              (("1"
                                (hide -1)
                                (("1"
                                  (assert)
                                  (("1"
                                    (cross-mult -1)
                                    (("1"
                                      (cross-mult -2)
                                      (("1"
                                        (expand "conflict_2D?")
                                        (("1"
                                          (inst + "t!1*abs(v`z)")
                                          (("1"
                                            (rewrite "vect2_scal")
                                            (("1"
                                              (case
                                               "abs(v`z) * vect2(s) + t!1 * abs(v`z) * vect2(v) = abs(v`z)*(vect2(s)+t!1*vect2(v))")
                                              (("1"
                                                (replace -1)
                                                (("1"
                                                  (hide -1)
                                                  (("1"
                                                    (rewrite
                                                     "sqv_scal")
                                                    (("1"
                                                      (rewrite
                                                       "sq_times")
                                                      (("1"
                                                        (div-by
                                                         1
                                                         "sq(v`z)")
                                                        (("1"
                                                          (lemma
                                                           "sq_eq_0")
                                                          (("1"
                                                            (inst?)
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (hide-all-but 1)
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (hide -3)
                                            (("2"
                                              (hide -3)
                                              (("2"
                                                (typepred "T")
                                                (("2"
                                                  (mult-by
                                                   -3
                                                   "abs(v`z)")
                                                  (("2"
                                                    (typepred "t!1")
                                                    (("2"
                                                      (mult-by
                                                       -2
                                                       "abs(v`z)")
                                                      (("2"
                                                        (mult-by
                                                         -3
                                                         "abs(v`z)")
                                                        (("2"
                                                          (case
                                                           "v`z>0")
                                                          (("1"
                                                            (expand
                                                             "abs")
                                                            (("1"
                                                              (expand
                                                               "sign")
                                                              (("1"
                                                                (assert)
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (expand
                                                             "abs")
                                                            (("2"
                                                              (expand
                                                               "sign")
                                                              (("2"
                                                                (assert)
                                                                (("2"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (expand "sign")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide-all-but (-1 1))
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2"
          (lemma "conflict_2D_on_open_interval[D *abs( v`z),
                       max(-H - sign(v`z) * s`z, B * abs(v`z)),
                       min(H - sign(v`z) * s`z, T * abs(v`z))]")
          (("1" (inst?)
            (("1" (replaces -1)
              (("1" (skosimp*)
                (("1" (name "t!2" "topen!1/abs(v`z)")
                  (("1"
                    (case "max(Theta_H[H](sign(v`z)*s`z,abs(v`z),-1),B)< t!2 AND t!2 < min(Theta_H[H](sign(v`z)*s`z,abs(v`z),1),T)")
                    (("1" (flatten)
                      (("1" (expand "conflict_3D?")
                        (("1" (inst + "t!2")
                          (("1" (split 1)
                            (("1" (lemma "vertical_los_inside_Theta")
                              (("1"
                                (inst
                                 -
                                 "abs(v`z)"
                                 "sign(v`z)*s`z"
                                 "t!2")
                                (("1"
                                  (flatten)
                                  (("1"
                                    (hide -2)
                                    (("1"
                                      (split -1)
                                      (("1"
                                        (hide-all-but (-1 +))
                                        (("1" (grind) nil nil))
                                        nil)
                                       ("2"
                                        (hide-all-but (-1 -2 1))
                                        (("2"
                                          (grind :exclude "Theta_H")
                                          nil
                                          nil))
                                        nil)
                                       ("3"
                                        (hide-all-but (-1 -2 1))
                                        (("3"
                                          (grind :exclude "Theta_H")
                                          nil
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (rewrite "vect2_scal")
                              (("2"
                                (case
                                 "abs(v`z) * vect2(s) + topen!1 * vect2(v) = abs(v`z)*(vect2(s) + t!2*vect2(v))")
                                (("1"
                                  (replace -1)
                                  (("1"
                                    (rewrite "sqv_scal")
                                    (("1"
                                      (rewrite "sq_times")
                                      (("1"
                                        (div-by -7 "sq(v`z)")
                                        nil
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (replace -3 :dir rl)
                                  (("2"
                                    (hide-all-but (1 3))
                                    (("2"
                                      (grind :exclude "abs")
                                      nil
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide-all-but (-1 -2 1))
                            (("2" (grind :exclude "Theta_H") nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (replace -1 1 :dir rl)
                      (("2" (hide-all-but (-2 -3 -6 1))
                        (("2" (split)
                          (("1" (cross-mult 1)
                            (("1" (lemma "nneg_mult_max")
                              (("1"
                                (inst
                                 -
                                 "abs(v`z)"
                                 "Theta_H[H](sign(v`z) * s`z, abs(v`z), -1)"
                                 "B")
                                (("1"
                                  (replace -1)
                                  (("1"
                                    (expand "Theta_H")
                                    (("1"
                                      (case "v`z>0")
                                      (("1"
                                        (expand "abs")
                                        (("1"
                                          (expand "sign")
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (case "v`z < 0")
                                        (("1"
                                          (expand "abs")
                                          (("1"
                                            (expand "sign")
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (assert)
                                          (("2"
                                            (case-replace "v`z=0")
                                            (("1" (assert) nil nil)
                                             ("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (assert)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (cross-mult 1)
                            (("2" (lemma "nneg_mult_min")
                              (("2"
                                (inst
                                 -
                                 "abs(v`z)"
                                 "Theta_H[H](sign(v`z) * s`z, abs(v`z), 1)"
                                 "T")
                                (("1"
                                  (replace -1)
                                  (("1"
                                    (hide -1)
                                    (("1"
                                      (expand "Theta_H")
                                      (("1"
                                        (case "v`z>0")
                                        (("1"
                                          (expand "abs")
                                          (("1"
                                            (expand "sign")
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (case "v`z < 0")
                                          (("1"
                                            (expand "abs")
                                            (("1"
                                              (expand "sign")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (assert)
                                            (("2"
                                              (case-replace "v`z=0")
                                              (("1" (assert) nil nil)
                                               ("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (assert)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (hide-all-but (-2 1)) (("2" (assert) nil nil)) nil)
           ("3" (hide-all-but 1) (("3" (assert) nil nil)) nil)
           ("4" (grind-reals) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((real_plus_real_is_real application-judgement "real" reals nil)
    (conflict_3D? const-decl "bool" cd3d nil)
    (H formal-const-decl "posreal" cd3d nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (vertical_los_inside_Theta formula-decl nil vertical nil)
    (abs_nat formula-decl nil abs_lems "reals/")
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (Theta_H const-decl "real" vertical nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D
     "vect_analysis/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (div_mult_pos_lt2 formula-decl nil real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) nil
    nil (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (Vector type-eq-decl nil vectors_2D "vectors/")
    (+ const-decl "Vector" vectors_2D "vectors/")
    (* const-decl "Vector" vectors_2D "vectors/")
    (Vect2 type-eq-decl nil vectors_2D_def "vectors/")
    (vect2 const-decl "Vect2" vect_3D_2D "vectors/")
    (D formal-const-decl "posreal" cd3d nil)
    (sq_times formula-decl nil sq "reals/")
    (sq_eq_0 formula-decl nil sq "reals/")
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (times_div_cancel1 formula-decl nil extra_real_props nil)
    (times_div_cancel2 formula-decl nil extra_real_props nil)
    (sq const-decl "nonneg_real" sq "reals/")
    (sqv const-decl "nnreal" vectors_2D "vectors/")
    (both_sides_div_pos_lt1 formula-decl nil real_props nil)
    (sq_abs formula-decl nil sq "reals/")
    (sqv_scal formula-decl nil vectors_2D "vectors/")
    (minus_real_is_real application-judgement "real" reals nil)
    (vect2_scal formula-decl nil vect_3D_2D "vectors/")
    (both_sides_times_pos_gt1 formula-decl nil real_props nil)
    (both_sides_times_pos_le1_imp formula-decl nil extra_real_props
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (conflict_2D? const-decl "bool" cd2d nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (div_mult_pos_gt2 formula-decl nil extra_real_props nil)
    (Lookahead type-eq-decl nil Lookahead nil)
    (T formal-const-decl "{AB: posreal | AB > B}" cd3d nil)
    (B formal-const-decl "nnreal" cd3d nil)
    (<= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (sign const-decl "Sign" sign "reals/")
    (Sign type-eq-decl nil sign "reals/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nzreal nonempty-type-eq-decl nil reals nil) nil
    (Vect3 type-eq-decl nil vectors_3D_def "vectors/")
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (conflict_2D_on_open_interval formula-decl nil omega_2D nil)
    (TRUE const-decl "bool" booleans nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nneg_mult_max formula-decl nil min_max "reals/")
    (sign_nat formula-decl nil sign "reals/")
    (max_0_npreal formula-decl nil min_max "reals/")
    (div_mult_pos_neg_lt2 formula-decl nil extra_real_props nil)
    (nneg_mult_min formula-decl nil min_max "reals/")
    (min_0_npreal formula-decl nil min_max "reals/")
    (div_mult_pos_neg_lt1 formula-decl nil extra_real_props nil) nil
    (< const-decl "bool" reals nil)
    (Vector type-eq-decl nil vectors_3D "vectors/")
    (* const-decl "Vector" vectors_3D "vectors/")
    (pos_times_gt formula-decl nil real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil))
   shostak))
 (conflict_3D_vz_swap 0
  (conflict_3D_vz_swap-1 nil 3476710261
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "conflict_3D?")
          (("1" (skosimp*)
            (("1" (inst + "t!1")
              (("1" (assert)
                (("1" (expand "abs")
                  (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (expand "conflict_3D?")
          (("2" (skosimp*)
            (("2" (inst + "t!1")
              (("2" (assert)
                (("2" (expand "abs")
                  (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (conflict_3D? const-decl "bool" cd3d nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (B formal-const-decl "nnreal" cd3d nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (T formal-const-decl "{AB: posreal | AB > B}" cd3d nil)
    (Lookahead type-eq-decl nil Lookahead nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (vect2_eq formula-decl nil vect_3D_2D "vectors/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D
     "vect_analysis/")
    (sq_nz_pos application-judgement "posreal" sq "reals/"))
   shostak))
 (conflict_3D_on_open_interval 0
  (conflict_3D_on_open_interval-1 nil 3476715367
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "conflict_3D?")
          (("1" (skosimp*)
            (("1"
              (case "exists (epH:posreal): FORALL (th: real): abs(th-t!1)<epH IMPLIES abs(s`z+th*v`z)<H")
              (("1" (skeep -1)
                (("1"
                  (case "exists (epD:posreal): FORALL (td: real): abs(td-t!1)<epD IMPLIES sqv(vect2(s)+td*vect2(v))<sq(D)")
                  (("1" (skeep -1)
                    (("1" (name "newt" "min((T-B)/2,min(epD/2,epH/2))")
                      (("1" (case "newt > 0")
                        (("1" (case "t!1 = B")
                          (("1" (replace -1)
                            (("1" (hide -1)
                              (("1"
                                (inst + "B+newt")
                                (("1"
                                  (assert)
                                  (("1"
                                    (inst - "B+newt")
                                    (("1"
                                      (inst - "B+newt")
                                      (("1"
                                        (case
                                         "abs(newt)<epD and abs(newt)<epH")
                                        (("1"
                                          (flatten)
                                          (("1" (assert) nil nil))
                                          nil)
                                         ("2"
                                          (hide 2)
                                          (("2"
                                            (hide -3)
                                            (("2"
                                              (hide -3)
                                              (("2"
                                                (hide -3)
                                                (("2"
                                                  (hide -3)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (case "t!1 = T")
                            (("1" (replace -1)
                              (("1"
                                (hide -1)
                                (("1"
                                  (inst + "T-newt")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (inst - "T-newt")
                                      (("1"
                                        (inst - "T-newt")
                                        (("1"
                                          (case
                                           "abs(-newt)<epD and abs(-newt)<epH")
                                          (("1"
                                            (flatten)
                                            (("1" (assert) nil nil))
                                            nil)
                                           ("2"
                                            (hide 3)
                                            (("2"
                                              (hide -3)
                                              (("2"
                                                (hide -3)
                                                (("2"
                                                  (hide -3)
                                                  (("2"
                                                    (hide -3)
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (inst + "t!1")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (hide-all-but (-1 1))
                          (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (case "vect2(v) = zero")
                    (("1" (replace -1) (("1" (assert) nil nil)) nil)
                     ("2" (hide -1)
                      (("2" (hide -1)
                        (("2" (hide 3)
                          (("2" (lemma "sqv_cont")
                            (("2" (expand "continuous_vr?")
                              (("2"
                                (inst - "vect2(s) + t!1 * vect2(v)")
                                (("2"
                                  (expand "continuous_vr?")
                                  (("2"
                                    (inst
                                     -
                                     "sq(D) - sqv(vect2(s)+t!1*vect2(v))")
                                    (("1"
                                      (skosimp*)
                                      (("1"
                                        (inst
                                         +
                                         "delta!1/norm(vect2(v))")
                                        (("1"
                                          (skosimp*)
                                          (("1"
                                            (inst
                                             -
                                             "vect2(s) + td!1*vect2(v)")
                                            (("1"
                                              (split -1)
                                              (("1"
                                                (name
                                                 "const1"
                                                 "sqv(vect2(s) + td!1*vect2(v))")
                                                (("1"
                                                  (replace -1)
                                                  (("1"
                                                    (name
                                                     "const2"
                                                     "sqv(vect2(s) + t!1*vect2(v))")
                                                    (("1"
                                                      (replace -1)
                                                      (("1"
                                                        (hide -1)
                                                        (("1"
                                                          (hide -1)
                                                          (("1"
                                                            (hide -2)
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (case
                                                 "vect2(s) + td!1 * vect2(v) - (vect2(s) + t!1 * vect2(v)) = (td!1-t!1)*vect2(v)")
                                                (("1"
                                                  (replace -1)
                                                  (("1"
                                                    (rewrite
                                                     "norm_scal")
                                                    (("1"
                                                      (cross-mult -2)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (hide-all-but 1)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (lemma
                                           "posreal_div_posreal_is_posreal")
                                          (("2"
                                            (inst
                                             -
                                             "delta!1"
                                             "norm(vect2(v))")
                                            (("1" (assert) nil nil)
                                             ("2"
                                              (lemma
                                               "vectors_2D.norm_eq_0")
                                              (("2"
                                                (inst?)
                                                (("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("3"
                                          (lemma
                                           "vectors_2D.norm_eq_0")
                                          (("3"
                                            (inst?)
                                            (("3" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (case "v`z = 0")
                (("1" (replace -1) (("1" (assert) nil nil)) nil)
                 ("2" (inst + "(H-abs(s`z+t!1*v`z))/abs(v`z)")
                  (("1" (skosimp*)
                    (("1" (cross-mult -1)
                      (("1" (hide-all-but (-1 -2 2))
                        (("1" (rewrite "abs_mult" :dir rl)
                          (("1" (both-sides "+" "abs(s`z+t!1*v`z)" -1)
                            (("1" (assert)
                              (("1"
                                (lemma "triangle")
                                (("1"
                                  (inst
                                   -
                                   "v`z * th!1 - v`z * t!1"
                                   "s`z + t!1 * v`z")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (split 1)
                    (("1" (cross-mult 1) (("1" (assert) nil nil)) nil)
                     ("2" (cross-mult 1) (("2" (assert) nil nil)) nil))
                    nil)
                   ("3" (expand "abs" 1)
                    (("3" (lift-if) (("3" (ground) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (skosimp*)
          (("2" (expand "conflict_3D?")
            (("2" (inst + "topen!1") (("2" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((conflict_3D? const-decl "bool" cd3d nil)
    (H formal-const-decl "posreal" cd3d nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Vect3 type-eq-decl nil vectors_3D_def "vectors/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Lookahead type-eq-decl nil Lookahead nil)
    (T formal-const-decl "{AB: posreal | AB > B}" cd3d nil)
    (B formal-const-decl "nnreal" cd3d nil)
    (<= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (D formal-const-decl "posreal" cd3d nil)
    (sq const-decl "nonneg_real" sq "reals/")
    (* const-decl "Vector" vectors_2D "vectors/")
    (vect2 const-decl "Vect2" vect_3D_2D "vectors/")
    (Vect2 type-eq-decl nil vectors_2D_def "vectors/")
    (+ const-decl "Vector" vectors_2D "vectors/")
    (sqv const-decl "nnreal" vectors_2D "vectors/")
    (Vector type-eq-decl nil vectors_2D "vectors/")
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D
     "vect_analysis/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posreal_min application-judgement
     "{z: posreal | z <= x AND z <= y}" real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_real_is_real application-judgement "real" reals nil) nil nil
    (posreal_div_posreal_is_posreal judgement-tcc nil real_types nil)
    (norm_eq_0 formula-decl nil vectors_2D "vectors/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (div_mult_pos_lt2 formula-decl nil real_props nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (norm_scal formula-decl nil vectors_2D "vectors/") nil nil
    (norm const-decl "nnreal" vectors_2D "vectors/")
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    nil nil nil
    (sqv_cont judgement-tcc nil vect_cont_2D "vect_analysis/")
    (add_zero_right formula-decl nil vectors_2D "vectors/")
    (scal_zero formula-decl nil vectors_2D "vectors/")
    (zero const-decl "Vector" vectors_2D "vectors/")
    (abs_mult formula-decl nil real_props nil)
    (triangle formula-decl nil real_props nil)
    (both_sides_plus_lt1 formula-decl nil real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (div_mult_pos_gt1 formula-decl nil extra_real_props nil)
    (div_mult_pos_ge1 formula-decl nil real_props nil)
    (abs_nat formula-decl nil abs_lems "reals/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil))
   shostak))
 (conflict_3D_vertical_TCC1 0
  (conflict_3D_vertical_TCC1-1 nil 3477135982
   ("" (skeep)
    (("" (hide-all-but 2) (("" (grind :exclude "Theta_D") nil nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vect2 const-decl "Vect2" vect_3D_2D "vectors/")
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil))
   nil
   (conflict_3D_vertical subtype
    "real_defs.max(horizontal[cd3d.D].Theta_D(vect_3D_2D.vect2(cd3d.s), vect_3D_2D.vect2(cd3d.v), (number_fields.-)(1)), cd3d.B)"
    "nnreal")))
 (conflict_3D_vertical_TCC2 0
  (conflict_3D_vertical_TCC2-1 nil 3477135982
   ("" (skeep) (("" (grind :exclude "Theta_D") nil nil)) nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D
     "vect_analysis/")
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vect2 const-decl "Vect2" vect_3D_2D "vectors/")
    (sq const-decl "nonneg_real" sq "reals/")
    (* const-decl "real" vectors_2D "vectors/")
    (sqv const-decl "nnreal" vectors_2D "vectors/")
    (det const-decl "real" det_2D "vectors/")
    (Delta const-decl "real" horizontal nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil))
   nil
   (conflict_3D_vertical subtype
    "real_defs.min(horizontal[cd3d.D].Theta_D(vect_3D_2D.vect2(cd3d.s), vect_3D_2D.vect2(cd3d.v), 1), cd3d.T)"
    "{AB: real_types.posreal | reals.>(AB, real_defs.max(horizontal[cd3d.D].Theta_D(vect_3D_2D.vect2(cd3d.s), vect_3D_2D.vect2(cd3d.v), (number_fields.-)(1)), cd3d.B))}")))
 (conflict_3D_vertical 0
  (conflict_3D_vertical-1 nil 3477135983
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "conflict_3D?")
          (("1" (skosimp*)
            (("1" (expand "conflict_vertical?")
              (("1" (inst + "t!1")
                (("1" (lemma "horizontal_los_inside_Theta")
                  (("1" (inst - "v" "s" "t!1")
                    (("1" (assert)
                      (("1" (flatten)
                        (("1" (hide -3)
                          (("1" (hide -3)
                            (("1" (hide -3)
                              (("1"
                                (hide -3)
                                (("1"
                                  (grind :exclude "Theta_D")
                                  nil
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2"
          (lemma
           "conflict_vertical_on_open_interval[H, max(Theta_D(vect2(s), vect2(v), -1), B),
               min(Theta_D(vect2(s), vect2(v), 1), T)]")
          (("1" (inst?)
            (("1" (assert)
              (("1" (hide -2)
                (("1" (skosimp*)
                  (("1" (expand "conflict_3D?")
                    (("1" (inst + "topen!1")
                      (("1" (assert)
                        (("1" (lemma "horizontal_los_inside_Theta")
                          (("1" (inst - "v" "s" "topen!1")
                            (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (assert) nil nil) ("3" (assert) nil nil)
           ("4" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (conflict_3D? const-decl "bool" cd3d nil)
    (conflict_vertical? const-decl "bool" cd_vertical nil)
    (horizontal_los_inside_Theta formula-decl nil horizontal nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D
     "vect_analysis/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil (Lookahead type-eq-decl nil Lookahead nil)
    (T formal-const-decl "{AB: posreal | AB > B}" cd3d nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (B formal-const-decl "nnreal" cd3d nil)
    (vect2 const-decl "Vect2" vect_3D_2D "vectors/")
    (Vect3 type-eq-decl nil vectors_3D_def "vectors/")
    (Theta_D const-decl "real" horizontal nil)
    (Sign type-eq-decl nil sign "reals/")
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (Delta const-decl "real" horizontal nil)
    (D formal-const-decl "posreal" cd3d nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (Nz_vect2 type-eq-decl nil vectors_2D "vectors/")
    (zero const-decl "Vector" vectors_2D "vectors/")
    (/= const-decl "boolean" notequal nil)
    (Vector type-eq-decl nil vectors_2D "vectors/")
    (Vect2 type-eq-decl nil vectors_2D_def "vectors/")
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nnreal type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (H formal-const-decl "posreal" cd3d nil)
    (conflict_vertical_on_open_interval formula-decl nil cd_vertical
     nil))
   shostak))
 (detection_TCC1 0
  (detection_TCC1-1 nil 3460477145
   ("" (skeep) (("" (grind :exclude "Theta_H") nil nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D
     "vect_analysis/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vect2 const-decl "Vect2" vect_3D_2D "vectors/")
    (* const-decl "real" vectors_2D "vectors/")
    (sqv const-decl "nnreal" vectors_2D "vectors/")
    (sq const-decl "nonneg_real" sq "reals/")
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil))
   nil
   (detection subtype
    "real_defs.min(real_defs.max(vertical[cd3d.H].Theta_H(cd3d.s`z, cd3d.v`z, (number_fields.-)(1)), cd3d.B), cd3d.T)"
    "Lookahead[B, T]")))
 (detection_TCC2 0
  (detection_TCC2-1 nil 3460477145
   ("" (grind :exclude "Theta_H") nil nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (sq const-decl "nonneg_real" sq "reals/")
    (sqv const-decl "nnreal" vectors_2D "vectors/")
    (* const-decl "real" vectors_2D "vectors/")
    (vect2 const-decl "Vect2" vect_3D_2D "vectors/")
    (/= const-decl "boolean" notequal nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (detection subtype
    "real_defs.max(real_defs.min(vertical[cd3d.H].Theta_H(cd3d.s`z, cd3d.v`z, 1), cd3d.T), cd3d.B)"
    "Lookahead[B, T]")))
 (detection_TCC3 0
  (detection_TCC3-1 nil 3460477145
   ("" (skeep) (("" (assert) (("" (assert) nil nil)) nil)) nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D
     "vect_analysis/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil (detection subtype "cd3d.B" "Lookahead[B, T]")))
 (detection_TCC4 0
  (detection_TCC4-1 nil 3460477145
   ("" (skosimp*) (("" (assert) nil nil)) nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D
     "vect_analysis/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil (detection subtype "cd3d.T" "Lookahead[B, T]")))
 (detection_TCC5 0
  (detection_TCC5-2 nil 3461663865
   ("" (skeep)
    (("" (assert)
      (("" (flatten)
        (("" (assert)
          (("" (replaces -2)
            (("" (expand "Delta") (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D
     "vect_analysis/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil (detection subtype "cd3d.B" "Lookahead[B, T]"))
  (detection_TCC5-1 nil 3460477145
   ("" (skeep) (("" (assert) nil nil)) nil)
   ((sq_nz_pos application-judgement "posreal" sq "reals/")
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D
     "vect_analysis/"))
   nil (detection subtype "cd3d.B" "Lookahead[B, T]")))
 (detection_TCC6 0
  (detection_TCC6-2 nil 3461663954
   ("" (skeep)
    (("" (assert)
      (("" (assert)
        (("" (lemma "Delta_gt_0_nzv")
          (("" (inst?) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (D formal-const-decl "posreal" cd3d nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Delta_gt_0_nzv formula-decl nil horizontal nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D
     "vect_analysis/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Vect2 type-eq-decl nil vectors_2D_def "vectors/")
    (Vect3 type-eq-decl nil vectors_3D_def "vectors/")
    (vect2 const-decl "Vect2" vect_3D_2D "vectors/"))
   nil
   (detection subtype "vect_3D_2D.vect2(cd3d.v)"
    "{nzv | reals.>=(horizontal[cd3d.D].Delta(vect_3D_2D.vect2(cd3d.s), horizontal.nzv), 0)}"))
  (detection_TCC6-1 nil 3460477145
   ("" (skeep)
    (("" (assert)
      (("" (flatten)
        (("" (assert)
          (("" (replaces -2)
            (("" (expand "Delta") (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((sq_nz_pos application-judgement "posreal" sq "reals/")
    (Delta const-decl "real" horizontal nil)
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D
     "vect_analysis/")
    (sqv_zero formula-decl nil vectors_2D "vectors/"))
   nil
   (detection subtype "vect_3D_2D.vect2(cd3d.v)"
    "{nzv | reals.>=(horizontal[cd3d.D].Delta(vect_3D_2D.vect2(cd3d.s), horizontal.nzv), 0)}")))
 (detection_TCC7 0
  (detection_TCC7-1 nil 3460477145
   ("" (skosimp*) (("" (hide-all-but 3) (("" (grind) nil nil)) nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil))
   nil
   (detection subtype
    "real_defs.min(real_defs.max(cd3d.tin, cd3d.B), cd3d.T)"
    "Lookahead[B, T]")))
 (detection_TCC8 0
  (detection_TCC8-1 nil 3460477145
   ("" (skosimp*) (("" (hide-all-but 3) (("" (grind) nil nil)) nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil))
   nil
   (detection subtype
    "real_defs.max(real_defs.min(cd3d.tout, cd3d.T), cd3d.B)"
    "Lookahead[B, T]")))
 (detection_TCC9 0
  (detection_TCC9-1 nil 3460477145
   ("" (skosimp*) (("" (hide-all-but 2) (("" (grind) nil nil)) nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil))
   nil
   (detection subtype
    "real_defs.min(real_defs.max(cd3d.td1, cd3d.B), cd3d.T)"
    "Lookahead[B, T]")))
 (detection_TCC10 0
  (detection_TCC10-1 nil 3476701288
   ("" (skosimp*) (("" (hide-all-but 2) (("" (grind) nil nil)) nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil))
   nil
   (detection subtype
    "real_defs.max(real_defs.min(cd3d.td2, cd3d.T), cd3d.B)"
    "Lookahead[B, T]")))
 (detection_TCC11 0
  (detection_TCC11-1 nil 3476701288 ("" (subtype-tcc) nil nil)
   ((real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (vect2 const-decl "Vect2" vect_3D_2D "vectors/")
    (sq const-decl "nonneg_real" sq "reals/")
    (* const-decl "real" vectors_2D "vectors/")
    (sqv const-decl "nnreal" vectors_2D "vectors/")
    (det const-decl "real" det_2D "vectors/")
    (Delta const-decl "real" horizontal nil)
    (discr2b const-decl "real" quadratic_2b "reals/")
    (root2b const-decl "real" quadratic_2b "reals/")
    (Theta_D const-decl "real" horizontal nil)
    (/= const-decl "boolean" notequal nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil))
   nil (detection subtype "cd3d.B" "Lookahead[B, T]")))
 (detection_TCC12 0
  (detection_TCC12-1 nil 3476701288 ("" (subtype-tcc) nil nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vect2 const-decl "Vect2" vect_3D_2D "vectors/")
    (sq const-decl "nonneg_real" sq "reals/")
    (* const-decl "real" vectors_2D "vectors/")
    (sqv const-decl "nnreal" vectors_2D "vectors/")
    (det const-decl "real" det_2D "vectors/")
    (Delta const-decl "real" horizontal nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil))
   nil (detection subtype "cd3d.B" "Lookahead[B, T]")))
 (detection_correct 0
  (detection_correct-1 nil 3460479794
   ("" (skeep)
    (("" (skoletin 1)
      (("" (flatten)
        (("" (expand "detection")
          (("" (lift-if)
            (("" (split -3)
              (("1" (flatten)
                (("1" (assert)
                  (("1" (replace -1)
                    (("1" (assert)
                      (("1" (split -3)
                        (("1" (flatten)
                          (("1" (assert)
                            (("1" (lemma "vertical_los_inside_Theta")
                              (("1"
                                (inst?)
                                (("1"
                                  (assert)
                                  (("1"
                                    (grind :exclude "Theta_H")
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (flatten) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (split -1)
                  (("1" (flatten)
                    (("1" (assert)
                      (("1" (split -2)
                        (("1" (flatten)
                          (("1" (assert)
                            (("1" (split -5)
                              (("1"
                                (flatten)
                                (("1" (assert) nil nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (lemma "vertical_los_inside_Theta")
                                  (("2"
                                    (inst? -1)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (lemma
                                         "horizontal_los_inside_Theta")
                                        (("2"
                                          (inst?)
                                          (("2"
                                            (assert)
                                            (("2"
                                              (grind
                                               :exclude
                                               ("sqv"
                                                "vect2"
                                                "Theta_D"
                                                "Theta_H"
                                                "Delta"))
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2" (split -2)
                            (("1" (flatten)
                              (("1"
                                (assert)
                                (("1"
                                  (split -7)
                                  (("1"
                                    (flatten)
                                    (("1" (assert) nil nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (lemma
                                       "horizontal_los_inside_Theta")
                                      (("2"
                                        (inst? -1)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (grind
                                             :exclude
                                             ("sqv"
                                              "vect2"
                                              "Theta_D"
                                              "Theta_H"
                                              "Delta"))
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (propax) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real nonempty-type-from-decl nil reals nil)
    (Vect3 type-eq-decl nil vectors_3D_def "vectors/")
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (B formal-const-decl "nnreal" cd3d nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (T formal-const-decl "{AB: posreal | AB > B}" cd3d nil)
    (Lookahead type-eq-decl nil Lookahead nil)
    (detection const-decl "[Lookahead[B, T], Lookahead[B, T]]" cd3d
     nil)
    (D formal-const-decl "posreal" cd3d nil)
    (sq const-decl "nonneg_real" sq "reals/")
    (* const-decl "Vector" vectors_2D "vectors/")
    (vect2 const-decl "Vect2" vect_3D_2D "vectors/")
    (Vect2 type-eq-decl nil vectors_2D_def "vectors/")
    (+ const-decl "Vector" vectors_2D "vectors/")
    (sqv const-decl "nnreal" vectors_2D "vectors/")
    (Vector type-eq-decl nil vectors_2D "vectors/")
    (H formal-const-decl "posreal" cd3d nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D
     "vect_analysis/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (scal_zero formula-decl nil vectors_2D "vectors/")
    (add_zero_right formula-decl nil vectors_2D "vectors/")
    (vertical_los_inside_Theta formula-decl nil vertical nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (* const-decl "real" vectors_2D "vectors/")
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (/= const-decl "boolean" notequal nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (Nz_vect2 type-eq-decl nil vectors_2D "vectors/")
    (zero const-decl "Vector" vectors_2D "vectors/")
    (minus_real_is_real application-judgement "real" reals nil)
    (horizontal_los_inside_Theta formula-decl nil horizontal nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil))
   shostak))
 (detection_complete 0
  (detection_complete-1 nil 3460550425
   ("" (skeep)
    (("" (skoletin 1)
      (("" (flatten)
        (("" (expand "detection")
          (("" (lift-if)
            (("" (split -3)
              (("1" (flatten)
                (("1" (assert)
                  (("1" (split -3)
                    (("1" (flatten)
                      (("1" (assert)
                        (("1" (lemma "vertical_los_inside_Theta")
                          (("1" (inst? -1)
                            (("1" (assert)
                              (("1"
                                (grind
                                 :exclude
                                 ("sqv"
                                  "vect2"
                                  "Theta_D"
                                  "Theta_H"
                                  "Delta"))
                                nil
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (assert)
                        (("2" (replaces -1) (("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (assert)
                  (("2" (split -1)
                    (("1" (flatten)
                      (("1" (split -5)
                        (("1" (flatten) (("1" (assert) nil nil)) nil)
                         ("2" (flatten)
                          (("2" (assert)
                            (("2" (split -1)
                              (("1"
                                (flatten)
                                (("1"
                                  (assert)
                                  (("1"
                                    (lemma "vertical_los_inside_Theta")
                                    (("1"
                                      (inst?)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (lemma
                                           "horizontal_los_inside_Theta")
                                          (("1"
                                            (inst?)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (grind
                                                 :exclude
                                                 ("sqv"
                                                  "vect2"
                                                  "Theta_D"
                                                  "Theta_H"
                                                  "Delta"))
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (assert)
                                  (("2"
                                    (lemma
                                     "horizontal_los_inside_Theta")
                                    (("2"
                                      (inst?)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (grind
                                           :exclude
                                           ("sqv"
                                            "vect2"
                                            "Theta_D"
                                            "Theta_H"
                                            "Delta"))
                                          nil
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (assert)
                        (("2" (replace 2)
                          (("2" (lemma "Delta_gt_0")
                            (("2" (inst - "s" "v")
                              (("2"
                                (assert)
                                (("2"
                                  (split 1)
                                  (("1" (ground) nil nil)
                                   ("2"
                                    (expand
                                     "horizontal_conflict_ever?")
                                    (("2" (inst + "t") nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real nonempty-type-from-decl nil reals nil)
    (Vect3 type-eq-decl nil vectors_3D_def "vectors/")
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (B formal-const-decl "nnreal" cd3d nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (T formal-const-decl "{AB: posreal | AB > B}" cd3d nil)
    (Lookahead type-eq-decl nil Lookahead nil)
    (detection const-decl "[Lookahead[B, T], Lookahead[B, T]]" cd3d
     nil)
    (D formal-const-decl "posreal" cd3d nil)
    (sq const-decl "nonneg_real" sq "reals/")
    (* const-decl "Vector" vectors_2D "vectors/")
    (vect2 const-decl "Vect2" vect_3D_2D "vectors/")
    (Vect2 type-eq-decl nil vectors_2D_def "vectors/")
    (+ const-decl "Vector" vectors_2D "vectors/")
    (sqv const-decl "nnreal" vectors_2D "vectors/")
    (Vector type-eq-decl nil vectors_2D "vectors/")
    (H formal-const-decl "posreal" cd3d nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D
     "vect_analysis/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (vertical_los_inside_Theta formula-decl nil vertical nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (comp_zero_y formula-decl nil vectors_2D "vectors/")
    (comp_zero_x formula-decl nil vectors_2D "vectors/")
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (/= const-decl "boolean" notequal nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (horizontal_conflict_ever? const-decl "bool" horizontal nil)
    (Delta_gt_0 formula-decl nil horizontal nil)
    (horizontal_los_inside_Theta formula-decl nil horizontal nil)
    (zero const-decl "Vector" vectors_2D "vectors/")
    (Nz_vect2 type-eq-decl nil vectors_2D "vectors/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil))
   shostak))
 (conflict_detection 0
  (conflict_detection-1 nil 3460479587
   ("" (skeep)
    (("" (name-replace "cd" "detection(s,v)" :hide? nil)
      (("" (skoletin 1)
        (("" (split)
          (("1" (flatten)
            (("1" (lemma "detection_complete")
              (("1" (expand "conflict_3D?")
                (("1" (skeep -2)
                  (("1" (inst -1 "s" "t" "v")
                    (("1" (replaces -5)
                      (("1" (beta) (("1" (assert) nil nil)) nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (lemma "detection_correct")
              (("2" (inst -1 "s" "(tin+tout)/2" "v")
                (("1" (replaces -5)
                  (("1" (beta)
                    (("1" (split)
                      (("1" (expand "conflict_3D?")
                        (("1" (inst 1 "(tin+tout)/2")
                          (("1" (grind-reals) nil nil)) nil))
                        nil)
                       ("2" (replaces -3 :dir rl)
                        (("2" (grind-reals) nil nil)) nil)
                       ("3" (grind-reals) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind-reals) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (B formal-const-decl "nnreal" cd3d nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (T formal-const-decl "{AB: posreal | AB > B}" cd3d nil)
    (Lookahead type-eq-decl nil Lookahead nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Vect3 type-eq-decl nil vectors_3D_def "vectors/")
    (detection const-decl "[Lookahead[B, T], Lookahead[B, T]]" cd3d
     nil)
    (detection_complete formula-decl nil cd3d nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D
     "vect_analysis/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (detection_correct formula-decl nil cd3d nil) nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nnreal_div_posreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (< const-decl "bool" reals nil)
    (conflict_3D? const-decl "bool" cd3d nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (cd3d_rewrite_TCC1 0
  (cd3d_rewrite_TCC1-1 nil 3476725629
   ("" (skeep) (("" (grind :exclude ("Theta_H")) nil nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil))
   nil
   (cd3d_rewrite subtype
    "real_defs.max(vertical[cd3d.H].Theta_H(cd3d.s`z, cd3d.v`z, (number_fields.-)(1)), cd3d.B)"
    "nnreal")))
 (cd3d_rewrite_TCC2 0
  (cd3d_rewrite_TCC2-1 nil 3476725629
   ("" (skeep) (("" (grind :exclude ("Theta_H")) nil nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil))
   nil
   (cd3d_rewrite subtype
    "real_defs.min(vertical[cd3d.H].Theta_H(cd3d.s`z, cd3d.v`z, 1), cd3d.T)"
    "{AB: real_types.posreal | reals.>(AB, real_defs.max(vertical[cd3d.H].Theta_H(cd3d.s`z, cd3d.v`z, (number_fields.-)(1)), cd3d.B))}")))
 (cd3d_rewrite 0
  (cd3d_rewrite-1 nil 3476725629
   ("" (skeep)
    (("" (expand "cd3d?")
      (("" (split)
        (("1" (flatten)
          (("1" (split -)
            (("1" (flatten) (("1" (assert) nil nil)) nil)
             ("2" (flatten)
              (("2" (split -)
                (("1" (flatten)
                  (("1" (assert)
                    (("1" (hide 2)
                      (("1" (split)
                        (("1" (flatten)
                          (("1"
                            (lemma
                             "cd2d[D * abs(v`z), max(-H - sign(v`z) * s`z, B * abs(v`z)),
                                         min(H - sign(v`z) * s`z, T * abs(v`z))]")
                            (("1" (inst?)
                              (("1"
                                (lemma
                                 "cd2d[D, max(Theta_H(s`z, v`z, -1), B), min(Theta_H(s`z, v`z, 1), T)]")
                                (("1"
                                  (inst?)
                                  (("1"
                                    (replaces (-1 -2) :dir rl)
                                    (("1"
                                      (expand "conflict_2D?")
                                      (("1"
                                        (skosimp*)
                                        (("1"
                                          (inst + "t!1/abs(v`z)")
                                          (("1"
                                            (rewrite "sqv_add")
                                            (("1"
                                              (rewrite "sqv_add")
                                              (("1"
                                                (rewrite "vect2_scal")
                                                (("1"
                                                  (rewrite "sqv_scal")
                                                  (("1"
                                                    (rewrite
                                                     "sqv_scal")
                                                    (("1"
                                                      (rewrite
                                                       "sqv_scal")
                                                      (("1"
                                                        (rewrite
                                                         "sq_div")
                                                        (("1"
                                                          (mult-by
                                                           1
                                                           "sq(v`z)")
                                                          (("1"
                                                            (rewrite
                                                             "sq_times")
                                                            (("1"
                                                              (expand
                                                               "sq")
                                                              (("1"
                                                                (hide-all-but
                                                                 (-3
                                                                  1))
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (split 1)
                                            (("1"
                                              (cross-mult 1)
                                              nil
                                              nil)
                                             ("2"
                                              (assert)
                                              (("2"
                                                (typepred "t!1")
                                                (("2"
                                                  (cross-mult 1)
                                                  (("2"
                                                    (hide-all-but
                                                     (-2 1))
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("3"
                                              (cross-mult 1)
                                              (("3"
                                                (typepred "t!1")
                                                (("3"
                                                  (hide-all-but (-3 1))
                                                  (("3"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil)
                             ("2"
                              (lemma
                               "posreal_times_posreal_is_posreal")
                              (("2" (inst - "D" "abs(v`z)") nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (mult-by 1 "abs(v`z)")
                          (("2" (hide-all-but (-1 1))
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (propax) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (split -1)
            (("1" (flatten) (("1" (assert) nil nil)) nil)
             ("2" (flatten)
              (("2" (split -)
                (("1" (flatten)
                  (("1" (assert)
                    (("1" (hide 2)
                      (("1" (split)
                        (("1" (flatten)
                          (("1"
                            (lemma
                             "cd2d[D, max(Theta_H(s`z, v`z, -1), B), min(Theta_H(s`z, v`z, 1), T)]")
                            (("1" (inst?)
                              (("1"
                                (lemma
                                 "cd2d[D * abs(v`z), max(-H - sign(v`z) * s`z, B * abs(v`z)),
                                         min(H - sign(v`z) * s`z, T * abs(v`z))]")
                                (("1"
                                  (inst?)
                                  (("1"
                                    (replaces (-1 -2) :dir rl)
                                    (("1"
                                      (expand "conflict_2D?")
                                      (("1"
                                        (skosimp*)
                                        (("1"
                                          (inst + "t!1*abs(v`z)")
                                          (("1"
                                            (mult-by -3 "sq(v`z)")
                                            (("1"
                                              (hide-all-but (-3 1))
                                              (("1" (grind) nil nil))
                                              nil)
                                             ("2"
                                              (lemma "sq_eq_0")
                                              (("2"
                                                (inst?)
                                                (("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (split 1)
                                            (("1"
                                              (typepred "t!1")
                                              (("1"
                                                (mult-by -2 "abs(v`z)")
                                                (("1"
                                                  (hide-all-but (-1 1))
                                                  (("1"
                                                    (grind)
                                                    (("1"
                                                      (cross-mult -2)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (cross-mult 1)
                                                      nil
                                                      nil)
                                                     ("3"
                                                      (cross-mult -1)
                                                      nil
                                                      nil)
                                                     ("4"
                                                      (cross-mult 2)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (typepred "t!1")
                                              (("2"
                                                (mult-by -3 "abs(v`z)")
                                                (("2"
                                                  (hide-all-but (-1 1))
                                                  (("2"
                                                    (grind)
                                                    (("1"
                                                      (cross-mult -2)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (cross-mult 1)
                                                      nil
                                                      nil)
                                                     ("3"
                                                      (cross-mult -1)
                                                      nil
                                                      nil)
                                                     ("4"
                                                      (cross-mult 2)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil)
                                 ("3"
                                  (lemma
                                   "posreal_times_posreal_is_posreal")
                                  (("3"
                                    (inst - "D" "abs(v`z)")
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (mult-by -1 "abs(v`z)")
                          (("2" (hide -2)
                            (("2" (lemma "nneg_mult_max")
                              (("2"
                                (inst
                                 -
                                 "abs(v`z)"
                                 "Theta_H(s`z, v`z, -1)"
                                 "B")
                                (("2"
                                  (replace -1)
                                  (("2"
                                    (hide -1)
                                    (("2"
                                      (lemma "nneg_mult_min")
                                      (("2"
                                        (inst
                                         -
                                         "abs(v`z)"
                                         "Theta_H(s`z, v`z, 1)"
                                         "T")
                                        (("2"
                                          (replace -1)
                                          (("2"
                                            (hide -1)
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (propax) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (cd3d? const-decl "bool" cd3d nil)
    (nneg_mult_max formula-decl nil min_max "reals/")
    (nneg_mult_min formula-decl nil min_max "reals/") nil
    (sq_eq_0 formula-decl nil sq "reals/")
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (+ const-decl "Vector" vectors_2D "vectors/")
    (both_sides_times_pos_lt1 formula-decl nil real_props nil)
    (div_mult_pos_gt1 formula-decl nil extra_real_props nil)
    (div_mult_neg_gt1 formula-decl nil extra_real_props nil)
    (div_mult_neg_lt1 formula-decl nil real_props nil)
    (nonpos_real nonempty-type-eq-decl nil real_types nil)
    (negreal nonempty-type-eq-decl nil real_types nil)
    (div_mult_pos_lt1 formula-decl nil real_props nil)
    (both_sides_times_pos_le1_imp formula-decl nil extra_real_props
     nil)
    (posreal_times_posreal_is_posreal judgement-tcc nil real_types nil)
    (* const-decl "Vector" vectors_3D "vectors/")
    (Vector type-eq-decl nil vectors_3D "vectors/")
    (vect2 const-decl "Vect2" vect_3D_2D "vectors/")
    (Vect2 type-eq-decl nil vectors_2D_def "vectors/")
    (conflict_2D? const-decl "bool" cd2d nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    nil nil (Lookahead type-eq-decl nil Lookahead nil) nil
    (sqv_scal formula-decl nil vectors_2D "vectors/")
    (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props
     nil)
    (sq const-decl "nonneg_real" sq "reals/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sqv const-decl "nnreal" vectors_2D "vectors/")
    (* const-decl "real" vectors_2D "vectors/")
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (< const-decl "bool" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (sq_times formula-decl nil sq "reals/")
    (sq_div formula-decl nil sq "reals/")
    (sq_abs formula-decl nil sq "reals/")
    (vect2_scal formula-decl nil vect_3D_2D "vectors/")
    (dot_scal_left formula-decl nil vectors_2D "vectors/")
    (dot_scal_right formula-decl nil vectors_2D "vectors/")
    (real_plus_real_is_real application-judgement "real" reals nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D
     "vect_analysis/")
    (sqv_add formula-decl nil vectors_2D "vectors/")
    (Vector type-eq-decl nil vectors_2D "vectors/")
    (* const-decl "Vector" vectors_2D "vectors/")
    (div_mult_pos_le1 formula-decl nil real_props nil)
    (div_mult_pos_le2 formula-decl nil real_props nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers
     nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (div_mult_pos_ge1 formula-decl nil real_props nil)
    (TRUE const-decl "bool" booleans nil)
    (Theta_H const-decl "real" vertical nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cd2d formula-decl nil cd2d nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (D formal-const-decl "posreal" cd3d nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (Vect3 type-eq-decl nil vectors_3D_def "vectors/")
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (H formal-const-decl "posreal" cd3d nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sign type-eq-decl nil sign "reals/")
    (sign const-decl "Sign" sign "reals/")
    (nnreal type-eq-decl nil real_types nil)
    (B formal-const-decl "nnreal" cd3d nil)
    (<= const-decl "bool" reals nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (T formal-const-decl "{AB: posreal | AB > B}" cd3d nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak))
 (cd3d_test 0
  (cd3d_test-1 nil 3488547493
   ("" (skeep)
    (("" (expand "cd3d?")
      (("" (expand "cd2d?")
        (("" (expand "omega_vv")
          (("" (expand "tau_vv")
            (("" (replace -1)
              (("" (replace -2)
                (("" (replace -3)
                  (("" (replace -4)
                    (("" (replace -5)
                      (("" (replace -6)
                        (("" (replace -7)
                          (("" (hide -) (("" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (cd3d? const-decl "bool" cd3d nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (omega_vv const-decl "real" cd2d nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (nonneg_real_min application-judgement
     "{z: nonneg_real | z <= x AND z <= y}" real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D
     "vect_analysis/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (sq const-decl "nonneg_real" sq "reals/")
    (sqv const-decl "nnreal" vectors_2D "vectors/")
    (* const-decl "real" vectors_2D "vectors/")
    (+ const-decl "Vector" vectors_2D "vectors/")
    (* const-decl "Vector" vectors_2D "vectors/")
    (vect2 const-decl "Vect2" vect_3D_2D "vectors/")
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    nil (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (tau_vv const-decl "real" cd2d nil)
    (cd2d? const-decl "bool" cd2d nil))
   shostak))
 (cd3d_correct 0
  (cd3d_correct-1 nil 3460728037
   ("" (skeep)
    (("" (expand "cd3d?")
      (("" (split -1)
        (("1" (flatten)
          (("1" (rewrite "cd2d" :dir rl)
            (("1" (expand "conflict_2D?")
              (("1" (skosimp*)
                (("1" (expand "conflict_3D?")
                  (("1" (inst + "t!1") (("1" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (split -1)
            (("1" (flatten)
              (("1" (hide 2)
                (("1" (lemma "conflict_3D_2D_stable")
                  (("1" (inst?)
                    (("1" (assert)
                      (("1" (rewrite "cd2d")
                        (("1"
                          (lemma "posreal_times_posreal_is_posreal")
                          (("1" (inst - "D" "abs(v`z)") nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (propax) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (cd3d? const-decl "bool" cd3d nil)
    (conflict_3D_2D_stable formula-decl nil cd3d nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (posreal_times_posreal_is_posreal judgement-tcc nil real_types nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (sign const-decl "Sign" sign "reals/")
    (Sign type-eq-decl nil sign "reals/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (H formal-const-decl "posreal" cd3d nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "Vector" vectors_3D "vectors/")
    (Vector type-eq-decl nil vectors_3D "vectors/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (conflict_2D? const-decl "bool" cd2d nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (conflict_3D? const-decl "bool" cd3d nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D
     "vect_analysis/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (Lookahead type-eq-decl nil Lookahead nil)
    (T formal-const-decl "{AB: posreal | AB > B}" cd3d nil)
    (B formal-const-decl "nnreal" cd3d nil)
    (nnreal type-eq-decl nil real_types nil)
    (D formal-const-decl "posreal" cd3d nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (vect2 const-decl "Vect2" vect_3D_2D "vectors/")
    (Vect3 type-eq-decl nil vectors_3D_def "vectors/")
    (Vect2 type-eq-decl nil vectors_2D_def "vectors/")
    (cd2d formula-decl nil cd2d nil))
   nil))
 (cd3d_complete 0
  (cd3d_complete-1 nil 3460728068
   ("" (skeep)
    (("" (expand "cd3d?")
      (("" (split 1)
        (("1" (flatten)
          (("1" (rewrite "cd2d" :dir rl)
            (("1" (expand "conflict_3D?")
              (("1" (skosimp*)
                (("1" (expand "conflict_2D?")
                  (("1" (inst + "t!1") nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (split 2)
            (("1" (flatten)
              (("1" (lemma "conflict_3D_2D_stable")
                (("1" (inst - "s" "v")
                  (("1" (assert)
                    (("1" (rewrite "cd2d")
                      (("1" (lemma "posreal_times_posreal_is_posreal")
                        (("1" (inst - "D" "abs(v`z)") nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (case "v`z = 0")
              (("1" (assert)
                (("1" (expand "conflict_3D?") (("1" (propax) nil nil))
                  nil))
                nil)
               ("2" (hide 3)
                (("2" (assert)
                  (("2" (lemma "conflict_3D_on_open_interval")
                    (("2" (inst - "s" "v")
                      (("2" (assert)
                        (("2" (skosimp*)
                          (("2" (lemma "vertical_los_inside_Theta")
                            (("2"
                              (inst - "abs(v`z)" "sign(v`z)*s`z"
                               "topen!1")
                              (("2"
                                (flatten)
                                (("2"
                                  (hide -1)
                                  (("2"
                                    (split -1)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (expand "Theta_H")
                                        (("1"
                                          (cross-mult -1)
                                          (("1"
                                            (case "sign(abs(v`z)) = 1")
                                            (("1"
                                              (replace -1)
                                              (("1"
                                                (hide -1)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (cross-mult -2)
                                                    (("1"
                                                      (mult-by
                                                       -3
                                                       "abs(v`z)")
                                                      (("1"
                                                        (mult-by
                                                         -4
                                                         "abs(v`z)")
                                                        (("1"
                                                          (typepred
                                                           "T")
                                                          (("1"
                                                            (mult-by
                                                             -3
                                                             "abs(v`z)")
                                                            (("1"
                                                              (hide-all-but
                                                               (-3
                                                                -4
                                                                -5
                                                                -6
                                                                +))
                                                              (("1"
                                                                (typepred
                                                                 "topen!1")
                                                                (("1"
                                                                  (mult-by
                                                                   -2
                                                                   "abs(v`z)")
                                                                  (("1"
                                                                    (mult-by
                                                                     -3
                                                                     "abs(v`z)")
                                                                    (("1"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (expand "sign")
                                              (("2" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (hide-all-but (-4 1))
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (cd3d? const-decl "bool" cd3d nil)
    (abs_nat formula-decl nil abs_lems "reals/")
    (sign_nat formula-decl nil sign "reals/")
    (nzreal nonempty-type-eq-decl nil reals nil)
    (div_mult_pos_gt2 formula-decl nil extra_real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D
     "vect_analysis/")
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (both_sides_times_pos_lt1 formula-decl nil real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (both_sides_times_pos_le1_imp formula-decl nil extra_real_props
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (both_sides_times_pos_gt1 formula-decl nil real_props nil)
    (div_mult_pos_lt2 formula-decl nil real_props nil)
    (Theta_H const-decl "real" vertical nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (vertical_los_inside_Theta formula-decl nil vertical nil)
    (conflict_3D_on_open_interval formula-decl nil cd3d nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Vector type-eq-decl nil vectors_3D "vectors/")
    (* const-decl "Vector" vectors_3D "vectors/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (H formal-const-decl "posreal" cd3d nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sign type-eq-decl nil sign "reals/")
    (sign const-decl "Sign" sign "reals/")
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (posreal_times_posreal_is_posreal judgement-tcc nil real_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (conflict_3D_2D_stable formula-decl nil cd3d nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (conflict_3D? const-decl "bool" cd3d nil)
    (conflict_2D? const-decl "bool" cd2d nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (Lookahead type-eq-decl nil Lookahead nil)
    (T formal-const-decl "{AB: posreal | AB > B}" cd3d nil)
    (B formal-const-decl "nnreal" cd3d nil)
    (nnreal type-eq-decl nil real_types nil)
    (D formal-const-decl "posreal" cd3d nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (vect2 const-decl "Vect2" vect_3D_2D "vectors/")
    (Vect3 type-eq-decl nil vectors_3D_def "vectors/")
    (Vect2 type-eq-decl nil vectors_2D_def "vectors/")
    (cd2d formula-decl nil cd2d nil))
   nil))
 (cd3d 0
  (cd3d-1 nil 3460727492
   ("" (skeep)
    (("" (lemma "cd3d_correct")
      (("" (inst? -1)
        (("" (lemma "cd3d_complete")
          (("" (inst?) (("" (ground) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((cd3d_correct formula-decl nil cd3d nil)
    (cd3d_complete formula-decl nil cd3d nil)
    (Vect3 type-eq-decl nil vectors_3D_def "vectors/")
    (real nonempty-type-from-decl nil reals nil))
   shostak))
 (cd3d_rewrite_vertical_TCC1 0
  (cd3d_rewrite_vertical_TCC1-1 nil 3477138052
   ("" (skeep)
    (("" (lemma "Delta_gt_0_nzv")
      (("" (inst?) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((D formal-const-decl "posreal" cd3d nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Delta_gt_0_nzv formula-decl nil horizontal nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Vect2 type-eq-decl nil vectors_2D_def "vectors/")
    (Vect3 type-eq-decl nil vectors_3D_def "vectors/")
    (vect2 const-decl "Vect2" vect_3D_2D "vectors/"))
   nil
   (cd3d_rewrite_vertical subtype "vect_3D_2D.vect2(cd3d.v)"
    "{nzv | reals.>=(horizontal[cd3d.D].Delta(vect_3D_2D.vect2(cd3d.s), horizontal.nzv), 0)}")))
 (cd3d_rewrite_vertical_TCC2 0
  (cd3d_rewrite_vertical_TCC2-1 nil 3477138052
   ("" (skeep)
    (("" (hide-all-but 2) (("" (grind :exclude "Theta_D") nil nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vect2 const-decl "Vect2" vect_3D_2D "vectors/")
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil))
   nil
   (cd3d_rewrite_vertical subtype
    "real_defs.max(horizontal[cd3d.D].Theta_D(vect_3D_2D.vect2(cd3d.s), vect_3D_2D.vect2(cd3d.v), (number_fields.-)(1)), cd3d.B)"
    "nnreal")))
 (cd3d_rewrite_vertical_TCC3 0
  (cd3d_rewrite_vertical_TCC3-1 nil 3477138052
   ("" (skeep) (("" (grind :exclude "Theta_D") nil nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D
     "vect_analysis/")
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cd_vertical? const-decl "bool" cd_vertical nil)
    (sign const-decl "Sign" sign "reals/")
    (/= const-decl "boolean" notequal nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (Delta const-decl "real" horizontal nil)
    (det const-decl "real" det_2D "vectors/")
    (sqv const-decl "nnreal" vectors_2D "vectors/")
    (* const-decl "real" vectors_2D "vectors/")
    (sq const-decl "nonneg_real" sq "reals/")
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (vect2 const-decl "Vect2" vect_3D_2D "vectors/")
    (minus_real_is_real application-judgement "real" reals nil))
   nil
   (cd3d_rewrite_vertical subtype
    "real_defs.min(horizontal[cd3d.D].Theta_D(vect_3D_2D.vect2(cd3d.s), vect_3D_2D.vect2(cd3d.v), 1), cd3d.T)"
    "{AB: real_types.posreal | reals.>(AB, real_defs.max(horizontal[cd3d.D].Theta_D(vect_3D_2D.vect2(cd3d.s), vect_3D_2D.vect2(cd3d.v), (number_fields.-)(1)), cd3d.B))}")))
 (cd3d_rewrite_vertical 0
  (cd3d_rewrite_vertical-1 nil 3477138052
   ("" (skeep)
    (("" (lemma "conflict_3D_vertical")
      (("" (inst - "s" "v")
        (("" (lemma "cd3d")
          (("" (inst?)
            (("" (split +)
              (("1" (flatten +)
                (("1" (assert)
                  (("1" (case "vect2(v) = zero")
                    (("1" (expand "conflict_3D?")
                      (("1" (skosimp*)
                        (("1" (replace -1)
                          (("1" (assert)
                            (("1" (lemma "cd_vertical[H,B,T]")
                              (("1"
                                (inst?)
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand "conflict_vertical?")
                                    (("1" (inst + "t!1") nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (assert)
                      (("2" (hide 2)
                        (("2" (lemma "Delta_gt_0")
                          (("2" (inst - "s" "v")
                            (("2" (assert)
                              (("2"
                                (split -1)
                                (("1"
                                  (assert)
                                  (("1"
                                    (case
                                     "max(Theta_D(vect2(s), vect2(v), -1), B) <
                                 min(Theta_D(vect2(s), vect2(v), 1), T)")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (lemma
                                         "cd_vertical[H, max(Theta_D(vect2(s), vect2(v), -1), B),
                     min(Theta_D(vect2(s), vect2(v), 1), T)]")
                                        (("1"
                                          (inst?)
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (lemma
                                       "conflict_3D_on_open_interval")
                                      (("2"
                                        (inst?)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (skosimp*)
                                            (("2"
                                              (lemma
                                               "horizontal_los_inside_Theta")
                                              (("2"
                                                (inst
                                                 -
                                                 "v"
                                                 "s"
                                                 "topen!1")
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (flatten)
                                                    (("2"
                                                      (hide-all-but
                                                       (-1 -2 -3 -4 1))
                                                      (("2"
                                                        (grind
                                                         :exclude
                                                         "Theta_D")
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (expand "conflict_3D?")
                                  (("2"
                                    (skosimp*)
                                    (("2"
                                      (expand
                                       "horizontal_conflict_ever?")
                                      (("2" (inst + "t!1") nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten +)
                (("2" (split -1)
                  (("1" (flatten)
                    (("1" (lemma "cd_vertical[H,B,T]")
                      (("1" (inst?)
                        (("1" (assert)
                          (("1" (expand "conflict_vertical?")
                            (("1" (skosimp*)
                              (("1"
                                (expand "conflict_3D?")
                                (("1"
                                  (inst + "t!1")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (replace -2)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (assert)
                      (("2"
                        (lemma
                         "cd_vertical[H, max(Theta_D(vect2(s), vect2(v), -1), B),
                 min(Theta_D(vect2(s), vect2(v), 1), T)]")
                        (("2" (inst?)
                          (("2" (assert)
                            (("2" (flatten)
                              (("2"
                                (lemma "Delta_gt_0_nzv")
                                (("2"
                                  (inst?)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((conflict_3D_vertical formula-decl nil cd3d nil)
    (cd3d formula-decl nil cd3d nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Delta_gt_0 formula-decl nil horizontal nil)
    (D formal-const-decl "posreal" cd3d nil)
    (horizontal_conflict_ever? const-decl "bool" horizontal nil)
    (conflict_3D_on_open_interval formula-decl nil cd3d nil)
    (horizontal_los_inside_Theta formula-decl nil horizontal nil)
    (< const-decl "bool" reals nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (/= const-decl "boolean" notequal nil)
    (Nz_vect2 type-eq-decl nil vectors_2D "vectors/")
    (Delta const-decl "real" horizontal nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (Sign type-eq-decl nil sign "reals/")
    (Theta_D const-decl "real" horizontal nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (conflict_3D? const-decl "bool" cd3d nil)
    (cd_vertical formula-decl nil cd_vertical nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (H formal-const-decl "posreal" cd3d nil)
    (nnreal type-eq-decl nil real_types nil)
    (B formal-const-decl "nnreal" cd3d nil)
    (T formal-const-decl "{AB: posreal | AB > B}" cd3d nil)
    (Lookahead type-eq-decl nil Lookahead nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (conflict_vertical? const-decl "bool" cd_vertical nil)
    (add_zero_right formula-decl nil vectors_2D "vectors/")
    (scal_zero formula-decl nil vectors_2D "vectors/")
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D
     "vect_analysis/")
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (Vect2 type-eq-decl nil vectors_2D_def "vectors/")
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (vect2 const-decl "Vect2" vect_3D_2D "vectors/")
    (Vector type-eq-decl nil vectors_2D "vectors/")
    (zero const-decl "Vector" vectors_2D "vectors/")
    (Delta_gt_0_nzv formula-decl nil horizontal nil)
    (Vect3 type-eq-decl nil vectors_3D_def "vectors/")
    (real nonempty-type-from-decl nil reals nil))
   shostak))
 (vertical_solution_not_conflict_3D 0
  (vertical_solution_not_conflict_3D-1 nil 3466183120
   ("" (skeep)
    (("" (lemma "vertical_solution_vertical_sep")
      (("" (inst?)
        (("" (assert)
          (("" (expand "conflict_3D?")
            (("" (skeep -3)
              (("" (inst -1 "t") (("" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((H formal-const-decl "posreal" cd3d nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (vertical_solution_vertical_sep formula-decl nil vertical nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D
     "vect_analysis/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (Lookahead type-eq-decl nil Lookahead nil)
    (conflict_3D? const-decl "bool" cd3d nil)
    (T formal-const-decl "{AB: posreal | AB > B}" cd3d nil)
    (B formal-const-decl "nnreal" cd3d nil)
    (nnreal type-eq-decl nil real_types nil)
    (Vect3 type-eq-decl nil vectors_3D_def "vectors/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil))
   nil))
 (conflict_3D_horizontal_conflict 0
  (conflict_3D_horizontal_conflict-1 nil 3466174101
   ("" (skeep)
    (("" (expand "conflict_3D?")
      (("" (skeep -1)
        (("" (expand "horizontal_conflict?")
          (("" (inst 1 "t") nil nil)) nil))
        nil))
      nil))
    nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (conflict_3D? const-decl "bool" cd3d nil)
    (horizontal_conflict? const-decl "bool" horizontal nil)
    (Lookahead type-eq-decl nil Lookahead nil)
    (T formal-const-decl "{AB: posreal | AB > B}" cd3d nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (B formal-const-decl "nnreal" cd3d nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nnreal type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (conflict_3D_vertical_conflict 0
  (conflict_3D_vertical_conflict-1 nil 3466339066
   ("" (skeep)
    (("" (expand "conflict_3D?")
      (("" (skeep -1)
        (("" (expand "vertical_conflict?") (("" (inst 1 "t") nil nil))
          nil))
        nil))
      nil))
    nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (conflict_3D? const-decl "bool" cd3d nil)
    (vertical_conflict? const-decl "bool" vertical nil)
    (Lookahead type-eq-decl nil Lookahead nil)
    (T formal-const-decl "{AB: posreal | AB > B}" cd3d nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (B formal-const-decl "nnreal" cd3d nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nnreal type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (circle_solution_2D_not_conflict_3D 0
  (circle_solution_2D_not_conflict_3D-1 nil 3466174731
   ("" (skeep)
    (("" (lemma "circle_solution_2D_horizontal_sep")
      (("" (inst? -1)
        (("" (assert)
          (("" (expand "conflict_3D?")
            (("" (skeep -3)
              (("" (inst -1 "t") (("" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((D formal-const-decl "posreal" cd3d nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (circle_solution_2D_horizontal_sep formula-decl nil horizontal nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (sqv_cont name-judgement "continuous_vr_fun" vect_cont_2D
     "vect_analysis/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (Lookahead type-eq-decl nil Lookahead nil)
    (conflict_3D? const-decl "bool" cd3d nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (T formal-const-decl "{AB: posreal | AB > B}" cd3d nil)
    (B formal-const-decl "nnreal" cd3d nil)
    (nnreal type-eq-decl nil real_types nil)
    (vect2 const-decl "Vect2" vect_3D_2D "vectors/")
    (Vect3 type-eq-decl nil vectors_3D_def "vectors/")
    (Vect2 type-eq-decl nil vectors_2D_def "vectors/"))
   nil)))

