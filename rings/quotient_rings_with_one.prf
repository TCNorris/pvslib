(quotient_rings_with_one
 (IMP_quotient_rings_TCC1 0
  (IMP_quotient_rings_TCC1-1 nil 3780573108
   ("" (lemma "fullset_is_ring_with_one")
    (("" (expand "ring_with_one?") (("" (assert) nil nil)) nil)) nil)
   ((ring_with_one? const-decl "bool" ring_with_one_def algebra)
    (fullset_is_ring_with_one formula-decl nil quotient_rings_with_one
     nil))
   nil
   (IMP_quotient_rings assuming
    "quotient_rings[quotient_rings_with_one.T, quotient_rings_with_one.+, quotient_rings_with_one.*, quotient_rings_with_one.zero].quotient_rings"
    "fullset_is_ring: ASSUMPTION ring_def[quotient_rings.T, quotient_rings.+, quotient_rings.*, quotient_rings.zero].ring?(sets[quotient_rings.T].fullset)")))
 (quotient_ring_with_one_TCC1 0
  (quotient_ring_with_one_TCC1-1 nil 3780573108
   ("" (skeep)
    (("" (inst 1 "I!1") (("" (rewrite "ideal_is_coset") nil nil)) nil))
    nil)
   ((T formal-nonempty-type-decl nil quotient_rings_with_one nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (+ formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (coset? const-decl "bool" cosets_def nil)
    (* formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (zero formal-const-decl "T" quotient_rings_with_one nil)
    (one formal-const-decl "T" quotient_rings_with_one nil)
    (ring_with_one? const-decl "bool" ring_with_one_def algebra)
    (ring? const-decl "bool" ring_def algebra)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (coset type-eq-decl nil cosets_def nil)
    (I!1 skolem-const-decl "ideal[T, +, *, zero](R)"
     quotient_rings_with_one nil)
    (R skolem-const-decl "(ring_with_one?[T, +, *, zero, one])"
     quotient_rings_with_one nil)
    (ideal_is_coset formula-decl nil ring_cosets_lemmas nil)
    (ring nonempty-type-eq-decl nil ring algebra))
   nil
   (quotient_ring_with_one existence ""
    "cosets_def[quotient_rings_with_one.T, quotient_rings_with_one.+].coset(quotient_rings_with_one.R, quotient_rings_with_one.I)")))
 (quotient_ring_with_one_TCC2 0
  (quotient_ring_with_one_TCC2-1 nil 3780573108
   ("" (skeep*)
    (("" (lemma "coset_add")
      (("" (inst -1 "R" "I!1" "x1`1" "x1`2") (("" (assert) nil nil))
        nil))
      nil))
    nil)
   ((zero formal-const-decl "T" quotient_rings_with_one nil)
    (* formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (+ formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (T formal-nonempty-type-decl nil quotient_rings_with_one nil)
    (coset_add formula-decl nil quotient_rings nil)
    (coset type-eq-decl nil cosets_def nil)
    (coset? const-decl "bool" cosets_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ring_with_one? const-decl "bool" ring_with_one_def algebra)
    (one formal-const-decl "T" quotient_rings_with_one nil)
    (ring nonempty-type-eq-decl nil ring algebra)
    (ring? const-decl "bool" ring_def algebra)
    (set type-eq-decl nil sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (quotient_ring_with_one subtype
    "quotient_ring_def[quotient_rings_with_one.T, quotient_rings_with_one.+, quotient_rings_with_one.*].add(quotient_rings_with_one.R, quotient_rings_with_one.I)"
    "[[cosets_def[quotient_rings_with_one.T, quotient_rings_with_one.+].coset(quotient_rings_with_one.R, quotient_rings_with_one.I), cosets_def[quotient_rings_with_one.T, quotient_rings_with_one.+].coset(quotient_rings_with_one.R, quotient_rings_with_one.I)] -> cosets_def[quotient_rings_with_one.T, quotient_rings_with_one.+].coset(quotient_rings_with_one.R, quotient_rings_with_one.I)]")))
 (quotient_ring_with_one_TCC3 0
  (quotient_ring_with_one_TCC3-1 nil 3780573108
   ("" (skeep*)
    (("" (lemma "coset_product")
      (("" (inst -1 "R" "I!1" "x1`1" "x1`2") (("" (assert) nil nil))
        nil))
      nil))
    nil)
   ((zero formal-const-decl "T" quotient_rings_with_one nil)
    (* formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (+ formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (T formal-nonempty-type-decl nil quotient_rings_with_one nil)
    (coset_product formula-decl nil quotient_rings nil)
    (coset type-eq-decl nil cosets_def nil)
    (coset? const-decl "bool" cosets_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ring_with_one? const-decl "bool" ring_with_one_def algebra)
    (one formal-const-decl "T" quotient_rings_with_one nil)
    (ring nonempty-type-eq-decl nil ring algebra)
    (ring? const-decl "bool" ring_def algebra)
    (set type-eq-decl nil sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (quotient_ring_with_one subtype
    "quotient_ring_def[quotient_rings_with_one.T, quotient_rings_with_one.+, quotient_rings_with_one.*].product(quotient_rings_with_one.R, quotient_rings_with_one.I)"
    "[[cosets_def[quotient_rings_with_one.T, quotient_rings_with_one.+].coset(quotient_rings_with_one.R, quotient_rings_with_one.I), cosets_def[quotient_rings_with_one.T, quotient_rings_with_one.+].coset(quotient_rings_with_one.R, quotient_rings_with_one.I)] -> cosets_def[quotient_rings_with_one.T, quotient_rings_with_one.+].coset(quotient_rings_with_one.R, quotient_rings_with_one.I)]")))
 (quotient_ring_with_one_TCC4 0
  (quotient_ring_with_one_TCC4-1 nil 3780573108
   ("" (skeep) (("" (rewrite "ideal_is_coset") nil nil)) nil)
   ((ideal_is_coset formula-decl nil ring_cosets_lemmas nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (ring? const-decl "bool" ring_def algebra)
    (ring nonempty-type-eq-decl nil ring algebra)
    (one formal-const-decl "T" quotient_rings_with_one nil)
    (ring_with_one? const-decl "bool" ring_with_one_def algebra)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (T formal-nonempty-type-decl nil quotient_rings_with_one nil)
    (+ formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (* formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (zero formal-const-decl "T" quotient_rings_with_one nil))
   nil
   (quotient_ring_with_one subtype "quotient_rings_with_one.I"
    "cosets_def[quotient_rings_with_one.T, quotient_rings_with_one.+].coset(quotient_rings_with_one.R, quotient_rings_with_one.I)")))
 (quotient_ring_with_one_TCC5 0
  (quotient_ring_with_one_TCC5-1 nil 3780573108
   ("" (skeep)
    (("" (rewrite "lcoset_iff_coset" :dir rl)
      (("" (expand "left_coset?")
        (("" (inst 1 "one")
          (("" (typepred "R")
            (("" (expand "ring_with_one?")
              (("" (expand "monoid?")
                (("" (expand "monad?")
                  (("" (expand "member") (("" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (+ const-decl "set[T]" cosets_def nil)
    (one formal-const-decl "T" quotient_rings_with_one nil)
    (ring? const-decl "bool" ring_def algebra)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ring_with_one? const-decl "bool" ring_with_one_def algebra)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (T formal-nonempty-type-decl nil quotient_rings_with_one nil)
    (+ formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (* formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (zero formal-const-decl "T" quotient_rings_with_one nil)
    (R skolem-const-decl "(ring_with_one?[T, +, *, zero, one])"
     quotient_rings_with_one nil)
    (monad? const-decl "bool" monad_def algebra)
    (member const-decl "bool" sets nil)
    (monoid? const-decl "bool" monoid_def algebra)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (left_coset? const-decl "bool" cosets_def nil))
   nil
   (quotient_ring_with_one subtype
    "(cosets_def[quotient_rings_with_one.T, quotient_rings_with_one.+].+)(quotient_rings_with_one.one, quotient_rings_with_one.I)"
    "cosets_def[quotient_rings_with_one.T, quotient_rings_with_one.+].coset(quotient_rings_with_one.R, quotient_rings_with_one.I)")))
 (quotient_ring_with_one 0
  (quotient_ring_with_one-1 nil 3780573164
   ("" (skosimp)
    (("" (expand "ring_with_one?")
      (("" (split)
        (("1" (rewrite "quotient_group_is_ring") nil nil)
         ("2" (expand "monoid?")
          (("2" (split)
            (("1" (expand "monad?")
              (("1" (lemma "quotient_group_is_ring")
                (("1" (inst?)
                  (("1" (expand "ring?")
                    (("1" (flatten)
                      (("1" (hide -1 -3 -4 -5)
                        (("1" (assert)
                          (("1" (expand "restrict")
                            (("1" (split)
                              (("1"
                                (hide -1)
                                (("1"
                                  (expand "/")
                                  (("1"
                                    (rewrite
                                     "lcoset_iff_coset"
                                     :dir
                                     rl)
                                    (("1"
                                      (expand "left_coset?")
                                      (("1"
                                        (inst 1 "one")
                                        (("1"
                                          (typepred "R!1")
                                          (("1"
                                            (expand "ring_with_one?")
                                            (("1"
                                              (expand "monoid?")
                                              (("1"
                                                (expand "monad?")
                                                (("1"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (expand "identity?")
                                (("2"
                                  (hide -1)
                                  (("2"
                                    (skosimp)
                                    (("2"
                                      (typepred "x!1")
                                      (("2"
                                        (expand "coset?")
                                        (("2"
                                          (expand "left_coset?")
                                          (("2"
                                            (flatten)
                                            (("2"
                                              (skosimp)
                                              (("2"
                                                (hide -2 -3)
                                                (("2"
                                                  (replaces -1)
                                                  (("2"
                                                    (rewrite
                                                     "product_charac")
                                                    (("1"
                                                      (rewrite
                                                       "product_charac")
                                                      (("1"
                                                        (rewrite
                                                         "times_one[T,+,*,zero,one]")
                                                        (("1"
                                                          (rewrite
                                                           "one_times[T,+,*,zero,one]")
                                                          (("1"
                                                            (rewrite
                                                             "fullset_is_ring_with_one")
                                                            nil
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (rewrite
                                                           "fullset_is_ring_with_one")
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (hide 2)
                                                        (("2"
                                                          (typepred
                                                           "R!1")
                                                          (("2"
                                                            (expand
                                                             "ring_with_one?")
                                                            (("2"
                                                              (expand
                                                               "monoid?")
                                                              (("2"
                                                                (expand
                                                                 "monad?")
                                                                (("2"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (hide 2)
                                                      (("2"
                                                        (typepred
                                                         "R!1")
                                                        (("2"
                                                          (expand
                                                           "ring_with_one?")
                                                          (("2"
                                                            (expand
                                                             "monoid?")
                                                            (("2"
                                                              (expand
                                                               "monad?")
                                                              (("2"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (lemma "quotient_group_is_ring")
              (("2" (inst?)
                (("2" (inst -1 "I!1")
                  (("2" (expand "ring?") (("2" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ring_with_one? const-decl "bool" ring_with_one_def algebra)
    (monoid? const-decl "bool" monoid_def algebra)
    (monad? const-decl "bool" monad_def algebra)
    (member const-decl "bool" sets nil)
    (/ const-decl "setof[set[T]]" quotient_ring_def nil)
    (left_coset? const-decl "bool" cosets_def nil)
    (NOT const-decl "[bool -> bool]" booleans nil) nil
    (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil) nil
    (coset? const-decl "bool" cosets_def nil)
    (coset type-eq-decl nil cosets_def nil)
    (setof type-eq-decl nil defined_types nil)
    (one_times formula-decl nil ring_with_one algebra)
    (fullset_is_ring_with_one formula-decl nil quotient_rings_with_one
     nil)
    (times_one formula-decl nil ring_with_one algebra)
    (fullset const-decl "set" sets nil)
    (product_charac formula-decl nil quotient_rings nil)
    (identity? const-decl "bool" operator_defs nil)
    (restrict const-decl "R" restrict nil)
    (quotient_group_is_ring formula-decl nil quotient_rings nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (ring? const-decl "bool" ring_def algebra)
    (ring nonempty-type-eq-decl nil ring algebra)
    (one formal-const-decl "T" quotient_rings_with_one nil)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (T formal-nonempty-type-decl nil quotient_rings_with_one nil)
    (+ formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (* formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (zero formal-const-decl "T" quotient_rings_with_one nil))
   nil))
 (one_diff_zero_coset 0
  (one_diff_zero_coset-1 nil 3780573200
   ("" (skosimp)
    (("" (lemma "self_coset")
      (("" (inst -1 "I!1" "R!1" "one")
        (("" (typepred "I!1")
          (("" (expand "ideal?")
            (("" (expand "left_ideal?")
              (("" (flatten)
                (("" (assert)
                  (("" (hide -5)
                    (("" (decompose-equality)
                      (("" (iff)
                        (("" (prop)
                          (("1" (expand "subring?")
                            (("1" (expand "subset?")
                              (("1"
                                (flatten)
                                (("1"
                                  (hide-all-but (-1 -2 1))
                                  (("1"
                                    (inst -2 "x!1")
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide -2 -4)
                            (("2" (expand "left_swallow?")
                              (("2"
                                (inst -2 "x!1" "one")
                                (("2"
                                  (rewrite "times_one[T,+,*,zero,one]")
                                  (("1" (assert) nil nil)
                                   ("2"
                                    (rewrite
                                     "fullset_is_ring_with_one")
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((zero formal-const-decl "T" quotient_rings_with_one nil)
    (* formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (+ formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (T formal-nonempty-type-decl nil quotient_rings_with_one nil)
    (self_coset formula-decl nil ring_cosets_lemmas nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (left_ideal? const-decl "bool" ring_ideal_def nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (subring? const-decl "bool" ring_def algebra)
    (left_swallow? const-decl "bool" ring_ideal_def nil)
    (fullset const-decl "set" sets nil)
    (times_one formula-decl nil ring_with_one algebra)
    (fullset_is_ring_with_one formula-decl nil quotient_rings_with_one
     nil)
    nil nil (ring nonempty-type-eq-decl nil ring algebra)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (ring_with_one? const-decl "bool" ring_with_one_def algebra)
    (one formal-const-decl "T" quotient_rings_with_one nil)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ring? const-decl "bool" ring_def algebra)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil)))

