(ring_basic_properties
 (fullset_is_ring 0
  (fullset_is_ring-1 nil 3706534671 ("" (postpone) nil nil) nil
   shostak))
 (IMP_ring_TCC1 0
  (IMP_ring_TCC1-1 nil 3780361376
   ("" (rewrite "fullset_is_ring") nil nil)
   ((fullset_is_ring formula-decl nil ring_basic_properties nil)) nil))
 (zero_is_member_R 0
  (zero_is_member_R-1 nil 3746441338
   ("" (skosimp)
    (("" (expand "member")
      (("" (typepred "R!1")
        (("" (expand "ring?")
          (("" (expand "abelian_group?")
            (("" (expand "group?")
              (("" (expand "monoid?")
                (("" (expand "monad?")
                  (("" (flatten)
                    (("" (hide-all-but (-2 1))
                      (("" (expand "member") (("" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((member const-decl "bool" sets nil)
    (group? const-decl "bool" group_def "algebra/")
    (monad? const-decl "bool" monad_def "algebra/")
    (monoid? const-decl "bool" monoid_def "algebra/")
    (abelian_group? const-decl "bool" group_def "algebra/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (set type-eq-decl nil sets nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (ring? const-decl "bool" ring_def "algebra/"))
   shostak))
 (inv_is_member_R 0
  (inv_is_member_R-1 nil 3707057272
   ("" (skosimp)
    (("" (expand "member")
      (("" (typepred "R!1")
        (("" (expand "ring?")
          (("" (expand "abelian_group?")
            (("" (expand "group?")
              (("" (flatten)
                (("" (hide-all-but (-1 -2 -8 1))
                  (("" (expand "inv_exists?")
                    (("" (inst -2 "x!1")
                      (("" (skosimp)
                        (("" (hide -3)
                          (("" (typepred "inv(x!1)")
                            (("" (hide -2)
                              ((""
                                (replace -1 -3 rl)
                                ((""
                                  (hide -1)
                                  ((""
                                    (rewrite "cancel_left_plus")
                                    (("" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((member const-decl "bool" sets nil)
    (group? const-decl "bool" group_def "algebra/")
    (R!1 skolem-const-decl "(ring?)" ring_basic_properties nil)
    (x!1 skolem-const-decl "T" ring_basic_properties nil)
    (cancel_left_plus formula-decl nil ring "algebra/")
    (inv const-decl "{y | x * y = one AND y * x = one}" group
     "algebra/")
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (inv_exists? const-decl "bool" group_def "algebra/")
    (abelian_group? const-decl "bool" group_def "algebra/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (set type-eq-decl nil sets nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (ring? const-decl "bool" ring_def "algebra/"))
   shostak))
 (R_sum_star_closed 0
  (R_sum_star_closed-1 nil 3707058623
   ("" (skosimp)
    (("" (expand "member")
      (("" (typepred "R!1")
        (("" (expand "ring?")
          (("" (expand "abelian_group?")
            (("" (expand "group?")
              (("" (expand "monoid?")
                (("" (expand "monad?")
                  (("" (flatten)
                    (("" (hide-all-but (-1 -11 -12 1))
                      (("" (expand "star_closed?")
                        (("" (inst -1 "x!1" "y!1")
                          (("" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((member const-decl "bool" sets nil)
    (group? const-decl "bool" group_def "algebra/")
    (monad? const-decl "bool" monad_def "algebra/")
    (R!1 skolem-const-decl "(ring?)" ring_basic_properties nil)
    (x!1 skolem-const-decl "T" ring_basic_properties nil)
    (y!1 skolem-const-decl "T" ring_basic_properties nil)
    (star_closed? const-decl "bool" groupoid_def "algebra/")
    (monoid? const-decl "bool" monoid_def "algebra/")
    (abelian_group? const-decl "bool" group_def "algebra/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (set type-eq-decl nil sets nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (ring? const-decl "bool" ring_def "algebra/"))
   shostak))
 (R_prod_star_closed 0
  (R_prod_star_closed-1 nil 3707059869
   ("" (skosimp)
    (("" (typepred "R!1")
      (("" (expand "ring?")
        (("" (flatten)
          (("" (hide-all-but (-2 -6 -7 1))
            (("" (expand "star_closed?")
              (("" (inst -1 "x!1" "y!1")
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ring? const-decl "bool" ring_def "algebra/")
    (zero formal-const-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (set type-eq-decl nil sets nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (star_closed? const-decl "bool" groupoid_def "algebra/")
    (member const-decl "bool" sets nil)
    (y!1 skolem-const-decl "T" ring_basic_properties nil)
    (R!1 skolem-const-decl "(ring?)" ring_basic_properties nil)
    (x!1 skolem-const-decl "T" ring_basic_properties nil))
   shostak))
 (subring_transitive_TCC1 0
  (subring_transitive_TCC1-1 nil 3749913722
   ("" (skosimp) (("" (expand "subring?") (("" (assert) nil nil)) nil))
    nil)
   ((subring? const-decl "bool" ring_def "algebra/")
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil))
   nil))
 (subring_transitive 0
  (subring_transitive-1 nil 3749913726
   ("" (skosimp)
    (("" (expand "subring?")
      (("" (flatten)
        (("" (assert)
          (("" (hide -2 -4)
            (("" (lemma "subset_transitive[T]")
              (("" (inst -1 "I!1" "H!1" "R!1") (("" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subring? const-decl "bool" ring_def "algebra/")
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (subset_transitive formula-decl nil sets_lemmas nil)
    (ring? const-decl "bool" ring_def "algebra/")
    (zero formal-const-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (subring_equiv 0
  (subring_equiv-2 nil 3713800191
   ("" (skosimp)
    (("" (prop)
      (("1" (expand "subring?")
        (("1" (expand "ring?")
          (("1" (expand "abelian_group?")
            (("1" (expand "group?")
              (("1" (expand "monoid?")
                (("1" (expand "monad?")
                  (("1" (flatten)
                    (("1" (hide-all-but (-3 1))
                      (("1" (expand "member")
                        (("1" (expand "nonempty?")
                          (("1" (expand "empty?")
                            (("1" (inst -1 "zero")
                              (("1"
                                (expand "member")
                                (("1" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "subring?") (("2" (assert) nil nil)) nil)
       ("3" (skosimp)
        (("3" (split)
          (("1" (expand "member")
            (("1" (typepred "x!1")
              (("1" (typepred "y!1")
                (("1" (lemma "inv_is_member_R")
                  (("1" (inst -1 "S!1" "y!1")
                    (("1" (assert)
                      (("1" (lemma "R_sum_star_closed")
                        (("1" (inst -1 "S!1" "x!1" "inv(y!1)")
                          (("1" (assert) nil nil)
                           ("2" (expand "subring?")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand "subring?") (("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (typepred "x!1" "y!1")
            (("2" (rewrite "R_prod_star_closed")
              (("2" (expand "subring?") (("2" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("4" (expand "subring?")
        (("4" (split)
          (("1" (propax) nil nil)
           ("2" (expand "ring?")
            (("2" (expand "abelian_group?")
              (("2" (expand "group?")
                (("2" (expand "monoid?")
                  (("2" (expand "monad?")
                    (("2" (expand "star_closed?")
                      (("2" (split)
                        (("1" (skosimp)
                          (("1" (copy -3)
                            (("1" (inst -1 "x!1" "inv(y!1)")
                              (("1"
                                (flatten)
                                (("1"
                                  (hide -2)
                                  (("1"
                                    (rewrite "negate_negate")
                                    nil
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (copy -3)
                                (("2"
                                  (inst -1 "zero" "y!1")
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (hide -2)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (inst -3 "x!1" "x!1")
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand "nonempty?")
                          (("2" (expand "empty?")
                            (("2" (skosimp)
                              (("2"
                                (copy -3)
                                (("2"
                                  (inst -1 "x!1" "x!1")
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (hide -2)
                                      (("1"
                                        (expand "member")
                                        (("1"
                                          (rewrite
                                           " negate_is_right_inv")
                                          nil
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (expand "member")
                                    (("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (expand "identity?")
                          (("3" (skosimp)
                            (("3" (expand "restrict")
                              (("3"
                                (split)
                                (("1" (rewrite "plus_zero") nil nil)
                                 ("2" (rewrite "zero_plus") nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("4" (expand "associative?")
                          (("4" (skosimp)
                            (("4" (expand "restrict")
                              (("4"
                                (rewrite "plus_associative")
                                nil
                                nil))
                              nil))
                            nil))
                          nil)
                         ("5" (expand "inv_exists?")
                          (("5" (skosimp)
                            (("5" (inst 1 "inv(x!1)")
                              (("1"
                                (split)
                                (("1"
                                  (rewrite "negate_is_right_inv")
                                  nil
                                  nil)
                                 ("2"
                                  (rewrite "negate_is_left_inv")
                                  nil
                                  nil))
                                nil)
                               ("2"
                                (copy -3)
                                (("2"
                                  (inst -1 "zero" "x!1")
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (hide -2)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (expand "nonempty?")
                                    (("2"
                                      (expand "empty?")
                                      (("2"
                                        (skosimp)
                                        (("2"
                                          (copy -3)
                                          (("2"
                                            (inst -1 "x!2" "x!2")
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (hide -2)
                                                (("1"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (expand "member")
                                              (("2" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("6" (expand "commutative?")
                          (("6" (skosimp)
                            (("6" (expand "restrict")
                              (("6"
                                (rewrite "plus_commutative")
                                nil
                                nil))
                              nil))
                            nil))
                          nil)
                         ("7" (skosimp)
                          (("7" (copy -3)
                            (("7" (inst -1 "x!1" "y!1")
                              (("7" (flatten) nil nil)) nil))
                            nil))
                          nil)
                         ("8" (expand "associative?")
                          (("8" (skosimp)
                            (("8" (expand "restrict")
                              (("8"
                                (rewrite "times_associative")
                                nil
                                nil))
                              nil))
                            nil))
                          nil)
                         ("9" (expand "left_distributive?")
                          (("9" (skosimp)
                            (("9" (expand "restrict")
                              (("9"
                                (rewrite "left_distributive")
                                nil
                                nil))
                              nil))
                            nil))
                          nil)
                         ("10" (expand "right_distributive?")
                          (("10" (skosimp)
                            (("10" (expand "restrict")
                              (("10"
                                (rewrite "right_distributive")
                                nil
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ring? const-decl "bool" ring_def "algebra/")
    (group? const-decl "bool" group_def "algebra/")
    (monad? const-decl "bool" monad_def "algebra/")
    (nonempty? const-decl "bool" sets nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (monoid? const-decl "bool" monoid_def "algebra/")
    (abelian_group? const-decl "bool" group_def "algebra/")
    (subring? const-decl "bool" ring_def "algebra/")
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (set type-eq-decl nil sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (inv_is_member_R formula-decl nil ring_basic_properties nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group
     "algebra/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (R_sum_star_closed formula-decl nil ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (S!1 skolem-const-decl "set[T]" ring_basic_properties nil)
    (R_prod_star_closed formula-decl nil ring_basic_properties nil)
    (star_closed? const-decl "bool" groupoid_def "algebra/")
    (right_distributive? const-decl "bool" operator_defs_more
     "algebra/")
    (right_distributive formula-decl nil ring "algebra/")
    (left_distributive? const-decl "bool" operator_defs_more
     "algebra/")
    (left_distributive formula-decl nil ring "algebra/")
    (times_associative formula-decl nil ring "algebra/")
    (commutative? const-decl "bool" operator_defs nil)
    (plus_commutative formula-decl nil ring "algebra/")
    (inv_exists? const-decl "bool" group_def "algebra/")
    (x!1 skolem-const-decl "(S!1)" ring_basic_properties nil)
    (negate_is_left_inv formula-decl nil ring "algebra/")
    (x!2 skolem-const-decl "T" ring_basic_properties nil)
    (associative? const-decl "bool" operator_defs nil)
    (plus_associative formula-decl nil ring "algebra/")
    (identity? const-decl "bool" operator_defs nil)
    (restrict const-decl "R" restrict nil)
    (zero_plus formula-decl nil ring "algebra/")
    (plus_zero formula-decl nil ring "algebra/")
    (x!1 skolem-const-decl "T" ring_basic_properties nil)
    (negate_is_right_inv formula-decl nil ring "algebra/")
    (y!1 skolem-const-decl "(S!1)" ring_basic_properties nil)
    (negate_negate formula-decl nil ring "algebra/")
    (left_identity formula-decl nil monad "algebra/")
    (inv_right formula-decl nil group "algebra/"))
   nil)
  (subring_equiv-1 nil 3706983053
   ("" (skosimp)
    (("" (split)
      (("1" (flatten)
        (("1" (lemma "subgroup_def")
          (("1" (inst -1 "R!1" "S!1")
            (("1" (case "subgroup?(S!1, R!1)")
              (("1" (assert)
                (("1" (flatten)
                  (("1" (assert)
                    (("1" (skosimp)
                      (("1" (split)
                        (("1" (expand "inv_closed?")
                          (("1" (inst -5 "y!1")
                            (("1" (expand "member")
                              (("1"
                                (lemma "closed")
                                (("1"
                                  (inst -1 "S!1" "x!1" "inv(y!1)")
                                  (("1"
                                    (expand "member")
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand "subring?")
                          (("2" (expand "ring?")
                            (("2" (flatten)
                              (("2"
                                (hide-all-but (-7 1))
                                (("2"
                                  (expand "star_closed?")
                                  (("2"
                                    (inst -1 "x!1" "y!1")
                                    (("2"
                                      (expand "member")
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide -1 2)
                (("2" (expand "subgroup?")
                  (("2" (expand "subring?")
                    (("2" (expand "ring?")
                      (("2" (expand "abelian_group?")
                        (("2" (flatten)
                          (("2" (hide-all-but (-1 -2 1))
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (lemma "subgroup_def")
          (("2" (inst -1 "R!1" "S!1")
            (("2" (assert)
              (("2" (expand "subring?") (("2" (postpone) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ring? const-decl "bool" ring_def "algebra/")
    (group? const-decl "bool" group_def "algebra/")
    (monad? const-decl "bool" monad_def "algebra/")
    (nonempty? const-decl "bool" sets nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (monoid? const-decl "bool" monoid_def "algebra/")
    (abelian_group? const-decl "bool" group_def "algebra/")
    (subring? const-decl "bool" ring_def "algebra/")
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (set type-eq-decl nil sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (inv_is_member_R formula-decl nil ring_basic_properties nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group
     "algebra/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (R_sum_star_closed formula-decl nil ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (R_prod_star_closed formula-decl nil ring_basic_properties nil)
    (star_closed? const-decl "bool" groupoid_def "algebra/")
    (right_distributive? const-decl "bool" operator_defs_more
     "algebra/")
    (right_distributive formula-decl nil ring "algebra/")
    (left_distributive? const-decl "bool" operator_defs_more
     "algebra/")
    (left_distributive formula-decl nil ring "algebra/")
    (times_associative formula-decl nil ring "algebra/")
    (commutative? const-decl "bool" operator_defs nil)
    (plus_commutative formula-decl nil ring "algebra/")
    (inv_exists? const-decl "bool" group_def "algebra/")
    (negate_is_left_inv formula-decl nil ring "algebra/")
    (associative? const-decl "bool" operator_defs nil)
    (plus_associative formula-decl nil ring "algebra/")
    (identity? const-decl "bool" operator_defs nil)
    (restrict const-decl "R" restrict nil)
    (zero_plus formula-decl nil ring "algebra/")
    (plus_zero formula-decl nil ring "algebra/")
    (negate_is_right_inv formula-decl nil ring "algebra/")
    (negate_negate formula-decl nil ring "algebra/")
    (left_identity formula-decl nil monad "algebra/")
    (inv_right formula-decl nil group "algebra/"))
   nil))
 (times_member 0
  (times_member-1 nil 3708547978
   ("" (lemma "expt_member")
    (("" (skosimp)
      (("" (inst -1 "R!1" "x!1" "k!1")
        (("" (expand "times") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((times const-decl "T" ring_basic_properties nil)
    (member const-decl "bool" sets nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (ring? const-decl "bool" ring_def "algebra/")
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (group nonempty-type-eq-decl nil group "algebra/")
    (group? const-decl "bool" group_def "algebra/")
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (expt_member formula-decl nil group "algebra/")
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil))
   shostak))
 (left_times 0
  (left_times-1 nil 3712676070
   ("" (skolem 1 ("_" "x!1" "y!1"))
    (("" (measure-induct+ "abs(k)" "k")
      (("" (expand "times")
        (("" (expand "^")
          (("" (lift-if)
            (("" (prop)
              (("1" (expand "power" 1)
                (("1" (lift-if)
                  (("1" (prop)
                    (("1" (assert) nil nil)
                     ("2" (case-replace "x!2=-1")
                      (("1" (hide -3)
                        (("1" (assert)
                          (("1" (rewrite "negative_times") nil nil))
                          nil))
                        nil)
                       ("2" (inst -2 "x!2+1")
                        (("2" (expand "abs")
                          (("2" (assert)
                            (("2" (lemma "negative_times")
                              (("2"
                                (inst -1 "x!1" "y!1")
                                (("2"
                                  (replace -1 3 rl)
                                  (("2"
                                    (lemma left_distributive)
                                    (("2"
                                      (inst?)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand "power" 2)
                (("2" (lift-if)
                  (("2" (assert)
                    (("2" (prop)
                      (("2" (inst -1 "x!2 -1")
                        (("2" (expand "abs")
                          (("2" (assert)
                            (("2" (rewrite "left_distributive")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (measure_induction formula-decl nil measure_induction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (< const-decl "bool" reals nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (times const-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (^ const-decl "T" group "algebra/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (power_0 formula-decl nil monoid "algebra/")
    (right_identity formula-decl nil monad "algebra/")
    (negative_times formula-decl nil ring "algebra/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group
     "algebra/")
    (left_distributive formula-decl nil ring "algebra/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero_times formula-decl nil ring "algebra/")
    (minus_int_is_int application-judgement "int" integers nil)
    (power def-decl "T" monoid_def "algebra/"))
   nil))
 (right_times 0
  (right_times-2 nil 3712676242
   ("" (skolem 1 ("_" "x!1" "y!1"))
    (("" (measure-induct+ "abs(k)" "k")
      (("" (expand "times")
        (("" (expand "^")
          (("" (lift-if)
            (("" (prop)
              (("1" (case-replace "x!2 = -1")
                (("1" (hide -3)
                  (("1" (assert)
                    (("1" (rewrite "times_negative") nil nil)) nil))
                  nil)
                 ("2" (inst -2 "x!2+1")
                  (("2" (expand "abs")
                    (("2" (assert)
                      (("2" (expand "power" 2)
                        (("2" (rewrite "right_distributive")
                          (("2" (replace -2 2)
                            (("2" (rewrite "times_negative")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (case-replace "x!2 = 0")
                (("1" (expand "power" 2) (("1" (assert) nil nil)) nil)
                 ("2" (inst -1 "x!2-1")
                  (("2" (expand "abs")
                    (("2" (assert)
                      (("2" (expand "power" 3)
                        (("2" (rewrite "right_distributive")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (measure_induction formula-decl nil measure_induction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (< const-decl "bool" reals nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (times const-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (^ const-decl "T" group "algebra/")
    (int_plus_int_is_int application-judgement "int" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group
     "algebra/")
    (right_distributive formula-decl nil ring "algebra/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (power def-decl "T" monoid_def "algebra/")
    (times_negative formula-decl nil ring "algebra/")
    (power_1 formula-decl nil monoid "algebra/")
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (times_zero formula-decl nil ring "algebra/"))
   nil)
  (right_times-1 nil 3708596740
   ("" (skolem 1 ("_" "x!1" "y!1"))
    (("" (measure-induct+ "abs(k)" "k")
      (("" (expand "times")
        (("" (lift-if)
          (("" (prop)
            (("1" (case-replace "x!2 = -1")
              (("1" (hide -3)
                (("1" (expand "abs")
                  (("1" (assert)
                    (("1" (rewrite "times_negative") nil nil)) nil))
                  nil))
                nil)
               ("2" (inst -2 "x!2+1")
                (("2" (expand "abs")
                  (("2" (assert)
                    (("2" (expand "power" 2)
                      (("2" (rewrite "negate_plus")
                        (("2" (rewrite "negate_plus")
                          (("2" (rewrite "right_distributive")
                            (("2" (replace -2 2)
                              (("2"
                                (rewrite "times_negative")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (case-replace "x!2 = 0")
              (("1" (expand "power" 2) (("1" (assert) nil nil)) nil)
               ("2" (inst -1 "x!2-1")
                (("2" (expand "abs" -1)
                  (("2" (assert)
                    (("2" (expand "power" 3)
                      (("2" (rewrite "right_distributive")
                        (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (measure_induction formula-decl nil measure_induction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (< const-decl "bool" reals nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (times const-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (times_zero formula-decl nil ring "algebra/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (times_negative formula-decl nil ring "algebra/")
    (power_1 formula-decl nil monoid "algebra/")
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (power def-decl "T" monoid_def "algebra/")
    (right_distributive formula-decl nil ring "algebra/")
    (inv const-decl "{y | x * y = one AND y * x = one}" group
     "algebra/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (negate_plus formula-decl nil ring "algebra/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil))
   shostak))
 (inv_times_neg 0
  (inv_times_neg-1 nil 3708982496
   ("" (skosimp)
    (("" (expand "times")
      (("" (expand "^")
        (("" (lift-if)
          (("" (prop)
            (("1" (assert)
              (("1" (rewrite "inv_power" :dir rl) nil nil)) nil)
             ("2" (lift-if)
              (("2" (prop)
                (("1" (lemma "inv_expt")
                  (("1" (inst -1 "x!1" "k!1")
                    (("1" (expand "^")
                      (("1" (assert)
                        (("1" (replace -1 1 rl)
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (case-replace "k!1 = 0")
                  (("1" (expand "power") (("1" (assert) nil nil)) nil)
                   ("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((times const-decl "T" ring_basic_properties nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (inv_one formula-decl nil group "algebra/")
    (minus_even_is_even application-judgement "even_int" integers nil)
    (power def-decl "T" monoid_def "algebra/")
    (inv_expt formula-decl nil group "algebra/")
    (inv_inv formula-decl nil group "algebra/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (inv_power formula-decl nil group "algebra/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (^ const-decl "T" group "algebra/")
    (minus_int_is_int application-judgement "int" integers nil))
   nil))
 (inv_times_inv 0
  (inv_times_inv-1 nil 3708981396
   ("" (lemma "inv_expt")
    (("" (skosimp)
      (("" (inst -1 "x!1" "k!1")
        (("" (expand "times") (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((times const-decl "T" ring_basic_properties nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (inv_expt formula-decl nil group "algebra/")
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil))
   shostak))
 (times_inv_neg 0
  (times_inv_neg-1 nil 3708983884
   ("" (skosimp)
    (("" (rewrite "inv_times_neg")
      (("" (rewrite "inv_times_inv") nil nil)) nil))
    nil)
   ((inv_times_neg formula-decl nil ring_basic_properties nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (inv_times_inv formula-decl nil ring_basic_properties nil))
   shostak))
 (times_int_zero 0
  (times_int_zero-1 nil 3708601163
   ("" (lemma "one_expt")
    (("" (skosimp)
      (("" (inst -1 "k!1")
        (("" (expand "times") (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((times const-decl "T" ring_basic_properties nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (one_expt formula-decl nil group "algebra/")
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil))
   shostak))
 (times_int_one 0
  (times_int_one-1 nil 3714313402
   ("" (skosimp)
    (("" (expand "times") (("" (rewrite "expt_1") nil nil)) nil)) nil)
   ((times const-decl "T" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (expt_1 formula-decl nil group "algebra/"))
   shostak))
 (times_sum 0
  (times_sum-1 nil 3708600010
   ("" (lemma "expt_mult")
    (("" (skosimp)
      (("" (inst -1 "x!1" "z!1" "k!1")
        (("" (expand "times") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((times const-decl "T" ring_basic_properties nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (expt_mult formula-decl nil group "algebra/")
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil))
   shostak))
 (times_o 0
  (times_o-1 nil 3709147130
   ("" (lemma "expt_expt")
    (("" (expand "times")
      (("" (skosimp) (("" (inst?) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((times const-decl "T" ring_basic_properties nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (expt_expt formula-decl nil group "algebra/")
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil))
   shostak))
 (times_product 0
  (times_product-1 nil 3709148264
   ("" (skosimp)
    (("" (rewrite "left_times")
      (("" (rewrite "right_times") (("" (rewrite "times_o") nil nil))
        nil))
      nil))
    nil)
   ((left_times formula-decl nil ring_basic_properties nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (times const-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (times_o formula-decl nil ring_basic_properties nil)
    (right_times formula-decl nil ring_basic_properties nil))
   shostak))
 (R_sigma_TCC1 0
  (R_sigma_TCC1-1 nil 3701277422 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (R_sigma_TCC2 0
  (R_sigma_TCC2-1 nil 3701278375 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil))
 (R_sigma_first 0
  (R_sigma_first-2 nil 3709151519
   ("" (induct "high")
    (("1" (skosimp)
      (("1" (expand "R_sigma") (("1" (assert) nil nil)) nil)) nil)
     ("2" (skosimp*)
      (("2" (inst -1 "F!1" "low!1")
        (("2" (case "j!1 + 1 = low!1")
          (("1" (replace -1 1)
            (("1" (hide -)
              (("1" (expand "R_sigma") (("1" (assert) nil nil)) nil))
              nil))
            nil)
           ("2" (assert)
            (("2" (expand "R_sigma" 2 2)
              (("2" (lift-if)
                (("2" (prop)
                  (("1" (hide -2)
                    (("1" (expand* "R_sigma" "R_sigma")
                      (("1" (assert) nil nil)) nil))
                    nil)
                   ("2" (rewrite "plus_associative" 2 :dir rl)
                    (("2" (replace -1 2 rl)
                      (("2" (expand "R_sigma" 2 1)
                        (("2" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (plus_associative formula-decl nil ring "algebra/")
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (right_identity formula-decl nil monad "algebra/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (R_sigma def-decl "T" ring_basic_properties nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil)
  (R_sigma_first-1 nil 3709151435 ("" (postpone) nil nil) nil shostak))
 (R_sigma_eq_k 0
  (R_sigma_eq_k-1 nil 3709151819
   ("" (induct "high")
    (("1" (skosimp)
      (("1" (expand "R_sigma")
        (("1" (lift-if)
          (("1" (prop)
            (("1" (assert) nil nil)
             ("2" (assert)
              (("2" (inst -1 "low!1") (("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skosimp*)
      (("2" (inst -1 "F!1" "G!1" "low!1" "k!1")
        (("2" (prop)
          (("1" (expand "R_sigma" 1)
            (("1" (lift-if)
              (("1" (prop)
                (("1" (assert) nil nil)
                 ("2" (assert)
                  (("2" (inst -3 "low!1") (("2" (assert) nil nil))
                    nil))
                  nil)
                 ("3" (assert)
                  (("3" (inst -2 "1+j!1") (("3" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (hide 2)
            (("2" (skosimp) (("2" (inst -1 "n!1") nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (R_sigma def-decl "T" ring_basic_properties nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (subrange type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (R_sigma_eq 0
  (R_sigma_eq-1 nil 3702649294
   ("" (skosimp)
    (("" (lemma "R_sigma_eq_k")
      (("" (inst -1 "F!1" "G!1" "high!1" "low!1" "0")
        (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((R_sigma_eq_k formula-decl nil ring_basic_properties nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (R_sigma_eq2 0
  (R_sigma_eq2-1 nil 3702919670
   ("" (skosimp)
    (("" (lemma "R_sigma_eq_k")
      (("" (inst -1 "F!1" "G!1" "high!1" "low!1" "1")
        (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((R_sigma_eq_k formula-decl nil ring_basic_properties nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (R_sigma_sum 0
  (R_sigma_sum-1 nil 3702762176
   ("" (induct "high")
    (("1" (skosimp)
      (("1" (expand "R_sigma")
        (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil))
      nil)
     ("2" (skosimp*)
      (("2" (inst -1 "F!1" "G!1" "low!1")
        (("2" (expand "R_sigma" 1)
          (("2" (lift-if)
            (("2" (assert)
              (("2" (prop)
                (("2" (replace -1 2 rl)
                  (("2" (rewrite "plus_associative")
                    (("2" (rewrite "plus_associative" :dir rl)
                      (("2" (rewrite "plus_commutative")
                        (("2" (rewrite "plus_associative")
                          (("2" (rewrite "plus_associative") nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (plus_commutative formula-decl nil ring "algebra/")
    (plus_associative formula-decl nil ring "algebra/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (left_identity formula-decl nil monad "algebra/")
    (zero formal-const-decl "T" ring_basic_properties nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (R_sigma def-decl "T" ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (ast_R_sigma 0
  (ast_R_sigma-1 nil 3701277439
   ("" (induct "high")
    (("1" (skeep)
      (("1" (expand* "R_sigma" "R_sigma")
        (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil))
      nil)
     ("2" (skosimp*)
      (("2" (expand "R_sigma" 1)
        (("2" (lift-if)
          (("2" (prop)
            (("1" (assert) nil nil)
             ("2" (inst -1 "F!1" "low!1" "x!1")
              (("2" (rewrite "right_distributive")
                (("2" (replaces -1) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (right_distributive formula-decl nil ring "algebra/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (times_zero formula-decl nil ring "algebra/")
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (R_sigma def-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (R_sigma_ast 0
  (R_sigma_ast-1 nil 3701278711
   ("" (induct "high")
    (("1" (skeep)
      (("1" (expand* "R_sigma" "R_sigma")
        (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil))
      nil)
     ("2" (skosimp*)
      (("2" (expand "R_sigma" 1)
        (("2" (lift-if)
          (("2" (prop)
            (("1" (assert) nil nil)
             ("2" (inst -1 "F!1" "low!1" "x!1")
              (("2" (rewrite "left_distributive")
                (("2" (replaces -1) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (left_distributive formula-decl nil ring "algebra/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (zero_times formula-decl nil ring "algebra/")
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (R_sigma def-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (R_sigma_inv 0
  (R_sigma_inv-1 nil 3779035006
   ("" (induct "high")
    (("1" (skeep)
      (("1" (expand "R_sigma")
        (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil)) nil))
          nil))
        nil))
      nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand "R_sigma" 1)
          (("2" (lift-if)
            (("2" (prop)
              (("1" (assert) nil nil)
               ("2" (inst -1 "F" "low")
                (("2" (replace -1 2 rl)
                  (("2" (rewrite "negate_plus")
                    (("2" (rewrite "plus_commutative") nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (plus_commutative formula-decl nil ring "algebra/")
    (negate_plus formula-decl nil ring "algebra/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (inv_one formula-decl nil group "algebra/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (R_sigma def-decl "T" ring_basic_properties nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group
     "algebra/")
    (zero formal-const-decl "T" ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (R_sigma_o 0
  (R_sigma_o-1 nil 3709158981
   ("" (induct "high")
    (("1" (skosimp)
      (("1" (expand "R_sigma" 1 (1 3))
        (("1" (assert)
          (("1" (lift-if)
            (("1" (prop)
              (("1" (assert) nil nil)
               ("2" (case-replace "low!1 = 0")
                (("1" (hide 1) (("1" (rewrite "ast_R_sigma") nil nil))
                  nil)
                 ("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skosimp*)
      (("2" (inst -1 "F!1" "G!1" "high1!1" "low!1" "low1!1")
        (("2" (expand "R_sigma" 1 (1 3))
          (("2" (lift-if)
            (("2" (prop)
              (("1" (assert) nil nil)
               ("2" (hide -2) (("2" (rewrite "ast_R_sigma") nil nil))
                nil)
               ("3" (rewrite "left_distributive")
                (("3" (replace -1 2 rl)
                  (("3" (hide -1)
                    (("3" (rewrite "cancel_left_plus")
                      (("3" (rewrite "ast_R_sigma") nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (cancel_left_plus formula-decl nil ring "algebra/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (left_distributive formula-decl nil ring "algebra/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (zero_times formula-decl nil ring "algebra/")
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (ast_R_sigma formula-decl nil ring_basic_properties nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (R_sigma def-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (R_sigma_R_sigma_TCC1 0
  (R_sigma_R_sigma_TCC1-1 nil 3778525032 ("" (subtype-tcc) nil nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil))
 (R_sigma_R_sigma_TCC2 0
  (R_sigma_R_sigma_TCC2-1 nil 3778525032 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (R_sigma_R_sigma 0
  (R_sigma_R_sigma-1 nil 3778525118
   ("" (measure-induct+ "high1 - low1 " ("low1" "high1"))
    (("1" (typepred "x!2")
      (("1" (case "x!2 = x!1")
        (("1" (replaces -1)
          (("1" (assert)
            (("1" (expand "R_sigma" 1 3)
              (("1" (expand "R_sigma" 1 2)
                (("1" (lemma " R_sigma_eq_k")
                  (("1" (skeep)
                    (("1"
                      (inst -1 "F" "LAMBDA (i: nat):
                       IF (i >= low AND i <= high) THEN F(i)
                       ELSIF (i > high AND i <= 1 + high)
                         THEN G(i - 1 - high + x!1)
                       ELSE zero
                       ENDIF" "high" "low" "0")
                      (("1" (assert) nil nil)
                       ("2" (skeep) (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (expand "R_sigma" 2 2)
            (("2" (expand "R_sigma" 2 3)
              (("2" (inst -2 "x!1" "x!2 -1")
                (("1" (inst -2 "F" "G" "low" "high")
                  (("1" (assert)
                    (("1" (rewrite "plus_associative" :dir rl)
                      (("1" (replace -2 2)
                        (("1"
                          (case-replace " R_sigma(low, high - x!1 + x!2,
              LAMBDA (i: nat):
                IF (i >= low AND i <= high) THEN F(i)
                ELSIF (i > high AND i <= high - x!1 + x!2)
                  THEN G(i - 1 - high + x!1)
                ELSE zero
                ENDIF) = R_sigma(low, high - x!1 + x!2,
               LAMBDA (i: nat):
                 IF (i >= low AND i <= high) THEN F(i)
                 ELSIF (i > high AND i <= 1 - x!1 + high + x!2)
                   THEN G(i - 1 - high + x!1)
                 ELSE zero
                 ENDIF)")
                          (("1" (hide -2 3)
                            (("1" (rewrite "R_sigma_eq")
                              (("1"
                                (hide 2)
                                (("1"
                                  (skeep)
                                  (("1" (assert) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (hide 2)
                                (("2"
                                  (skeep)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (skeep) (("2" (assert) nil nil)) nil)
                           ("3" (skeep) (("3" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (typepred "x!1")
                  (("2" (hide 3) (("2" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep) (("2" (assert) nil nil)) nil)
     ("3" (skeep) (("3" (assert) nil nil)) nil)
     ("4" (skeep) (("4" (assert) nil nil)) nil)
     ("5" (skeep) (("5" (assert) nil nil)) nil)
     ("6" (skeep) (("6" (assert) nil nil)) nil)
     ("7" (skeep) (("7" (assert) nil nil)) nil)
     ("8" (skeep) (("8" (assert) nil nil)) nil)
     ("9" (skeep) (("9" (assert) nil nil)) nil)
     ("10" (skeep) (("10" (assert) nil nil)) nil)
     ("11" (skeep) (("11" (assert) nil nil)) nil)
     ("12" (skeep) (("12" (assert) nil nil)) nil))
    nil)
   ((* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (plus_associative formula-decl nil ring "algebra/")
    (R_sigma_eq formula-decl nil ring_basic_properties nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (x!2 skolem-const-decl "{high1: nat | high1 >= x!1}"
     ring_basic_properties nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (R_sigma_eq_k formula-decl nil ring_basic_properties nil)
    (low skolem-const-decl "nat" ring_basic_properties nil)
    (high skolem-const-decl "{high: nat | high >= low}"
     ring_basic_properties nil)
    (x!1 skolem-const-decl "nat" ring_basic_properties nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (R_sigma def-decl "T" ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (nlzd_TCC1 0
  (nlzd_TCC1-1 nil 3720274509 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (nzd_cancel_left 0
  (nzd_cancel_left-1 nil 3711987483
   ("" (skosimp)
    (("" (lemma "negate_is_right_inv")
      (("" (inst -1 "a!1 * c!1")
        (("" (rewrite "times_negative" :dir rl)
          (("" (replace -2 -1 rl)
            (("" (rewrite "right_distributive" :dir rl)
              (("" (hide -2)
                (("" (typepred "a!1")
                  (("" (assert)
                    (("" (expand "left_zd?")
                      (("" (inst 1 "b!1 + inv(c!1)")
                        (("" (flatten)
                          (("" (lemma "cancel_right_plus")
                            ((""
                              (inst -1 "b!1 + inv[T, +, zero](c!1)"
                               "zero" "c!1")
                              ((""
                                (assert)
                                ((""
                                  (hide -2 -3)
                                  ((""
                                    (rewrite "plus_associative")
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((zero formal-const-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (negate_is_right_inv formula-decl nil ring "algebra/")
    (times_negative formula-decl nil ring "algebra/")
    (right_distributive formula-decl nil ring "algebra/")
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group
     "algebra/")
    (plus_associative formula-decl nil ring "algebra/")
    (inv_left formula-decl nil group "algebra/")
    (right_identity formula-decl nil monad "algebra/")
    (left_identity formula-decl nil monad "algebra/")
    (cancel_right_plus formula-decl nil ring "algebra/")
    (c!1 skolem-const-decl "T" ring_basic_properties nil)
    (b!1 skolem-const-decl "T" ring_basic_properties nil)
    (nlzd type-eq-decl nil ring_basic_properties nil)
    (left_zd? const-decl "bool" ring_basic_properties nil)
    (nz_T type-eq-decl nil ring_basic_properties nil)
    (/= const-decl "boolean" notequal nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (nzd_cancel_right 0
  (nzd_cancel_right-1 nil 3719346921
   ("" (skosimp)
    (("" (lemma "negate_is_right_inv")
      (("" (inst -1 "c!1 * a!1")
        (("" (rewrite "negative_times" :dir rl)
          (("" (replace -2 -1 rl)
            (("" (rewrite "left_distributive" :dir rl)
              (("" (hide -2)
                (("" (typepred "a!1")
                  (("" (assert)
                    (("" (expand "right_zd?")
                      (("" (inst 1 "b!1 + inv(c!1)")
                        (("" (flatten)
                          (("" (lemma "cancel_right_plus")
                            ((""
                              (inst -1 "b!1 + inv[T, +, zero](c!1)"
                               "zero" "c!1")
                              ((""
                                (assert)
                                ((""
                                  (hide -2 -3)
                                  ((""
                                    (rewrite "plus_associative")
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((zero formal-const-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (negate_is_right_inv formula-decl nil ring "algebra/")
    (negative_times formula-decl nil ring "algebra/")
    (left_distributive formula-decl nil ring "algebra/")
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group
     "algebra/")
    (plus_associative formula-decl nil ring "algebra/")
    (inv_left formula-decl nil group "algebra/")
    (right_identity formula-decl nil monad "algebra/")
    (left_identity formula-decl nil monad "algebra/")
    (cancel_right_plus formula-decl nil ring "algebra/")
    (c!1 skolem-const-decl "T" ring_basic_properties nil)
    (b!1 skolem-const-decl "T" ring_basic_properties nil)
    (nrzd type-eq-decl nil ring_basic_properties nil)
    (right_zd? const-decl "bool" ring_basic_properties nil)
    (nz_T type-eq-decl nil ring_basic_properties nil)
    (/= const-decl "boolean" notequal nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak)))

