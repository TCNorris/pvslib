(power_sets
 (B_TCC1 0
  (B_TCC1-1 nil 3306497013
   ("" (expand "is_finite")
    (("" (inst + "2" "LAMBDA (x: ({n: nat | n <= 1})): x")
      (("" (subtype-tcc) nil nil)) nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil))
   nil (B subtype "{n | reals.<=(power_sets.n, 1)}" "finite_set[nat]")))
 (card_B 0
  (card_B-1 nil 3306497096
   ("" (rewrite "card_bij")
    (("" (inst + "LAMBDA (x: (B)): x")
      (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (B const-decl "finite_set[nat]" power_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (card_bij formula-decl nil finite_sets nil))
   shostak))
 (powerset_bijection 0
  (powerset_bijection-1 nil 3306497138
   ("" (skosimp)
    ((""
      (inst +
       "LAMBDA (U: (powerset(S!1))): LAMBDA (x: (S!1)): IF U(x) THEN 1 ELSE 0 ENDIF")
      (("1" (grind-reals)
        (("1" (grind)
          (("1" (reveal 1)
            (("1" (inst + "{z: T | member(z, S!1) AND y!1(z) = 1}")
              (("1" (apply-extensionality :hide? t)
                (("1" (lift-if)
                  (("1" (ground)
                    (("1" (typepred "y!1(x!1)")
                      (("1" (expand "B") (("1" (assert) nil nil)) nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (skosimp) nil nil) ("3" (skosimp) nil nil))
              nil))
            nil)
           ("2" (apply-extensionality :hide? t)
            (("2" (decompose-equality)
              (("2" (iff)
                (("2" (smash)
                  (("1" (inst -3 "x!1")
                    (("1" (assert)
                      (("1" (inst - "x!1") (("1" (assert) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (inst -4 "x!1")
                    (("2" (assert)
                      (("2" (inst - "x!1") (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "B") (("2" (propax) nil nil)) nil)
       ("3" (expand "B") (("3" (propax) nil nil)) nil))
      nil))
    nil)
   ((B const-decl "finite_set[nat]" power_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (S!1 skolem-const-decl "set[T]" power_sets nil)
    (powerset const-decl "setofsets" sets nil)
    (setofsets type-eq-decl nil sets nil) (set type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil power_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil)
    (bijective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas
     nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (y!1 skolem-const-decl "[(S!1) -> (B)]" power_sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (finite_powerset_bijection 0
  (finite_powerset_bijection-2 "" 3790091289
   ("" (skolem!)
    (("" (lemma "powerset_bijection" ("S" "A!1"))
      (("" (expand "bijective?")
        (("" (skosimp)
          (("" (inst + "f!1")
            (("1" (split)
              (("1" (propax) nil nil)
               ("2" (expand "surjective?")
                (("2" (skolem!) (("2" (inst - "y!1") nil nil)) nil)) nil))
              nil)
             ("2" (delete -) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (finite_powerset_bijection-1 nil 3306497359
   ("" (skolem!)
    (("" (lemma "powerset_bijection" ("S" "A!1"))
      (("" (expand "bijective?")
        (("" (skosimp)
          (("" (inst + "f!1")
            (("1" (split)
              (("1" (expand "injective?") (("1" (propax) nil nil)) nil)
               ("2" (expand "surjective?")
                (("2" (skolem!) (("2" (inst - "y!1") nil nil)) nil)) nil))
              nil)
             ("2" (delete -) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil power_sets nil)
    (powerset_bijection formula-decl nil power_sets nil)
    (fullset const-decl "set" sets nil)
    (surjective? const-decl "bool" functions nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (powerset const-decl "setofsets" sets nil)
    (A!1 skolem-const-decl "finite_set[T]" power_sets nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (funset const-decl "finite_set[[(A) -> (B)]]" set_of_functions nil)
    (B const-decl "finite_set[nat]" power_sets nil)
    (f!1 skolem-const-decl "[(powerset(A!1)) -> [(A!1) -> (B)]]" power_sets
     nil)
    (bijective? const-decl "bool" functions nil))
   shostak))
 (card_powerset 0
  (card_powerset-1 nil 3306497849
   ("" (skolem!)
    (("" (lemma "finite_powerset_bijection" ("A" "A!1"))
      (("" (rewrite "card_eq_bij" :dir rl)
        (("" (rewrite "card_funset") (("" (rewrite "card_B") nil nil)) nil))
        nil))
      nil))
    nil)
   ((finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil power_sets nil)
    (finite_powerset_bijection formula-decl nil power_sets nil)
    (card_funset formula-decl nil set_of_functions nil)
    (nat_exp application-judgement "nat" exponentiation nil)
    (card_B formula-decl nil power_sets nil)
    (B const-decl "finite_set[nat]" power_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (setof type-eq-decl nil defined_types nil)
    (funset const-decl "finite_set[[(A) -> (B)]]" set_of_functions nil)
    (powerset const-decl "setofsets" sets nil)
    (setofsets type-eq-decl nil sets nil)
    (card_eq_bij formula-decl nil finite_sets_card_eq finite_sets)
    (powerset_finite application-judgement "finite_set[set[T]]" power_sets
     nil)
    (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas
     nil))
   shostak))
 (elem_finite_powerset 0
  (elem_finite_powerset-1 nil 3306497912
   ("" (skolem-typepred)
    (("" (expand "powerset") (("" (forward-chain "finite_subset") nil nil))
      nil))
    nil)
   ((finite_subset formula-decl nil finite_sets nil)
    (powerset const-decl "setofsets" sets nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (T formal-type-decl nil power_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (finite_subset_of_powerset 0
  (finite_subset_of_powerset-1 nil 3306497940
   ("" (skosimp)
    (("" (typepred "powerset(A!1)")
      (("" (use "finite_subset[set[T]]") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (powerset const-decl "setofsets" sets nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (T formal-type-decl nil power_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (powerset_finite application-judgement "finite_set[set[T]]" power_sets
     nil)
    (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas
     nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (finite_subset formula-decl nil finite_sets nil))
   shostak)))

