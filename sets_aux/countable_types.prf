(countable_types
 (nat_rational 0
  (nat_rational-1 nil 3318689178
   ("" (expand "is_countably_infinite_type")
    (("" (lemma "countable_rat") (("" (skolem!) (("" (inst?) nil nil)) nil))
      nil))
    nil)
   ((countable_rat formula-decl nil countable_set nil)
    (f!1 skolem-const-decl "[rat -> nat]" countable_types nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (bijective? const-decl "bool" functions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (is_countably_infinite_type const-decl "bool" countability nil))
   shostak))
 (nat_nonzero_rational 0
  (nat_nonzero_rational-1 nil 3318689222
   ("" (lemma "nat_rational")
    (("" (rewrite "countably_infinite_full")
      (("" (rewrite "countably_infinite_full")
        ((""
          (lemma "countably_infinite_remove[rational]"
           ("t" "0" "CountInf" "fullset[rational]"))
          (("1" (expand "is_countably_infinite")
            (("1" (hide -2)
              (("1" (skosimp)
                (("1" (typepred "f!1")
                  (("1" (inst + "f!1")
                    (("1" (split)
                      (("1" (skosimp)
                        (("1" (expand "fullset")
                          (("1" (expand "remove")
                            (("1" (expand "member")
                              (("1" (assert)
                                (("1" (split)
                                  (("1" (flatten) (("1" (assert) nil nil))
                                    nil)
                                   ("2" (flatten) (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand "bijective?")
                        (("2" (flatten)
                          (("2" (split)
                            (("1" (expand "injective?")
                              (("1" (skosimp)
                                (("1" (inst - "x1!1" "x2!1")
                                  (("1" (assert) nil nil)) nil))
                                nil))
                              nil)
                             ("2" (expand "surjective?")
                              (("2" (skosimp)
                                (("2" (inst - "y!1")
                                  (("2" (skosimp)
                                    (("2" (inst + "x!1")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (expand "fullset")
                                          (("2"
                                            (typepred "x!1")
                                            (("2"
                                              (expand "fullset")
                                              (("2"
                                                (expand "remove")
                                                (("2"
                                                  (flatten)
                                                  (("2" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((countably_infinite_full formula-decl nil countability nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (fullset const-decl "set" sets nil)
    (countably_infinite_set type-eq-decl nil countability nil)
    (is_countably_infinite const-decl "bool" countability nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (countably_infinite_remove judgement-tcc nil countable_props nil)
    (bijective? const-decl "bool" functions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (remove const-decl "set" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (surjective? const-decl "bool" functions nil)
    (x!1 skolem-const-decl "(remove[rational](0, fullset[rational]))"
     countable_types nil)
    (injective? const-decl "bool" functions nil)
    (f!1 skolem-const-decl
     "(bijective?[(remove[rational](0, fullset[rational])), nat])"
     countable_types nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonzero_rational nonempty-type-eq-decl nil rationals nil)
    (/= const-decl "boolean" notequal nil)
    (nat_rational formula-decl nil countable_types nil))
   shostak))
 (nat_nonneg_rat 0
  (nat_nonneg_rat-1 nil 3318690204
   ("" (lemma "nat_rational")
    (("" (rewrite "countably_infinite_full")
      (("" (rewrite "countably_infinite_full")
        (("" (rewrite "countably_infinite_def")
          (("" (flatten)
            (("" (rewrite "countably_infinite_def")
              (("" (split)
                (("1" (hide 2)
                  (("1"
                    (lemma "countable_subset[rational]"
                     ("S" "fullset[nonneg_rat]" "Count" "fullset[rational]"))
                    (("1" (split)
                      (("1" (hide -2)
                        (("1" (expand "fullset")
                          (("1" (expand "extend")
                            (("1" (expand "is_countable")
                              (("1" (skosimp)
                                (("1" (typepred "f!1")
                                  (("1" (inst + "f!1") nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide-all-but 1)
                        (("2" (expand "fullset")
                          (("2" (expand "extend")
                            (("2" (expand "subset?")
                              (("2" (expand "member") (("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (propax) nil nil))
                    nil))
                  nil)
                 ("2" (hide -2)
                  (("2" (expand "fullset")
                    (("2" (expand "is_finite")
                      (("2" (skosimp)
                        (("2" (case-replace "N!1=0")
                          (("1" (inst + "N!1" "lambda (x:rat): f!1(abs(x))")
                            (("1" (expand "injective?")
                              (("1" (skosimp)
                                (("1" (inst - "abs(x1!1)" "abs(x2!1)")
                                  (("1" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil)
                           ("2" (case "N!1>0")
                            (("1" (hide 1)
                              (("1"
                                (inst + "2*N!1"
                                 "lambda (x:rat): if x < 0 then 2*f!1(-x)+1 else 2*f!1(x) endif")
                                (("1" (expand "injective?")
                                  (("1" (skosimp)
                                    (("1" (case-replace "x1!1 < 0")
                                      (("1"
                                        (case-replace "x2!1 < 0")
                                        (("1"
                                          (inst - "-x1!1" "-x2!1")
                                          (("1" (assert) nil nil)
                                           ("2" (assert) nil nil)
                                           ("3"
                                            (case "-x1!1<0")
                                            (("1" (assert) nil nil)
                                             ("2" (assert) nil nil))
                                            nil))
                                          nil)
                                         ("2" (assert) nil nil))
                                        nil)
                                       ("2"
                                        (case-replace "x2!1 < 0")
                                        (("1" (assert) nil nil)
                                         ("2"
                                          (assert)
                                          (("2"
                                            (inst - "x1!1" "x2!1")
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (skosimp) (("2" (assert) nil nil)) nil)
                                 ("3" (skosimp) (("3" (assert) nil nil)) nil)
                                 ("4" (skosimp) (("4" (assert) nil nil)) nil)
                                 ("5" (skosimp) (("5" (assert) nil nil)) nil))
                                nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((countably_infinite_full formula-decl nil countability nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (fullset const-decl "set" sets nil) (set type-eq-decl nil sets nil)
    (countably_infinite_def formula-decl nil countable_props nil)
    (is_finite const-decl "bool" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil)
    (rat_abs_is_nonneg application-judgement "{r: nonneg_rat | r >= q}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (x1!1 skolem-const-decl "rational" countable_types nil)
    (x2!1 skolem-const-decl "rational" countable_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (f!1 skolem-const-decl "[nonneg_rat -> below[N!1]]" countable_types nil)
    (N!1 skolem-const-decl "nat" countable_types nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (minus_rat_is_rat application-judgement "rat" rationals nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (> const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (TRUE const-decl "bool" booleans nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (injective? const-decl "bool" functions nil)
    (restrict const-decl "R" restrict nil)
    (restrict_of_inj_is_inj application-judgement "(injective?[S, R])"
     restrict nil)
    (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)
    (countable_subset formula-decl nil countability nil)
    (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil)
    (is_countable const-decl "bool" countability nil)
    (countable_set nonempty-type-eq-decl nil countability nil)
    (nonneg_rat nonempty-type-eq-decl nil rationals nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (nat_rational formula-decl nil countable_types nil))
   shostak))
 (nat_nonpos_rat 0
  (nat_nonpos_rat-1 nil 3318693616
   ("" (lemma "nat_nonneg_rat")
    (("" (expand "is_countably_infinite_type")
      (("" (skolem-typepred)
        (("" (inst + "LAMBDA (r: nonpos_rat): f!1(-r)")
          (("" (grind :if-match nil)
            (("1" (inst - "y!1")
              (("1" (skolem!)
                (("1" (inst + "-x!1") (("1" (assert) nil nil)) nil)) nil))
              nil)
             ("2" (inst - "-x1!1" "-x2!1") (("2" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((is_countably_infinite_type const-decl "bool" countability nil)
    (minus_rat_is_rat application-judgement "rat" rationals nil)
    (<= const-decl "bool" reals nil)
    (nonpos_rat nonempty-type-eq-decl nil rationals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (f!1 skolem-const-decl "(bijective?[nonneg_rat, nat])" countable_types
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (injective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (bijective? const-decl "bool" functions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (nonneg_rat nonempty-type-eq-decl nil rationals nil)
    (>= const-decl "bool" reals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nat_nonneg_rat formula-decl nil countable_types nil))
   shostak))
 (nat_negrat 0
  (nat_negrat-1 nil 3318693743
   ("" (lemma "nat_nonpos_rat")
    (("" (rewrite "countably_infinite_full")
      (("" (rewrite "countably_infinite_full")
        ((""
          (lemma "countably_infinite_remove[nonpos_rat]"
           ("t" "0" "CountInf" "fullset[nonpos_rat]"))
          (("1" (hide -2)
            (("1" (expand "fullset")
              (("1" (expand "remove")
                (("1" (expand "member")
                  (("1" (expand "is_countably_infinite")
                    (("1" (skosimp)
                      (("1" (typepred "f!1")
                        (("1" (inst + "f!1")
                          (("1" (split)
                            (("1" (skosimp)
                              (("1" (typepred "x2!1")
                                (("1" (assert)
                                  (("1" (expand "<=")
                                    (("1" (split)
                                      (("1" (assert) nil nil)
                                       ("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (expand "bijective?")
                              (("2" (flatten)
                                (("2" (split)
                                  (("1" (expand "injective?")
                                    (("1" (skosimp)
                                      (("1"
                                        (inst - "x1!1" "x2!1")
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (expand "surjective?")
                                    (("2" (skosimp)
                                      (("2"
                                        (inst - "y!1")
                                        (("2"
                                          (skosimp)
                                          (("2" (inst + "x!1") nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((countably_infinite_full formula-decl nil countability nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (<= const-decl "bool" reals nil)
    (nonpos_rat nonempty-type-eq-decl nil rationals nil)
    (fullset const-decl "set" sets nil)
    (countably_infinite_set type-eq-decl nil countability nil)
    (is_countably_infinite const-decl "bool" countability nil)
    (set type-eq-decl nil sets nil)
    (countably_infinite_remove judgement-tcc nil countable_props nil)
    (member const-decl "bool" sets nil) (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (f!1 skolem-const-decl "(bijective?[({y | 0 /= y}), nat])" countable_types
     nil)
    (injective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (bijective? const-decl "bool" functions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (/= const-decl "boolean" notequal nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (remove const-decl "set" sets nil)
    (negrat nonempty-type-eq-decl nil rationals nil)
    (< const-decl "bool" reals nil)
    (nat_nonpos_rat formula-decl nil countable_types nil))
   shostak))
 (nat_posrat 0
  (nat_posrat-1 nil 3318693929
   ("" (lemma "nat_negrat")
    (("" (expand "is_countably_infinite_type")
      (("" (skolem-typepred)
        (("" (inst + "LAMBDA (r: posrat): f!1(-r)")
          (("" (grind :if-match nil)
            (("1" (inst - "y!1")
              (("1" (skolem!)
                (("1" (inst + "-x!1") (("1" (assert) nil nil)) nil)) nil))
              nil)
             ("2" (inst - "-x1!1" "-x2!1") (("2" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((is_countably_infinite_type const-decl "bool" countability nil)
    (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (nonneg_rat nonempty-type-eq-decl nil rationals nil)
    (> const-decl "bool" reals nil)
    (posrat nonempty-type-eq-decl nil rationals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (f!1 skolem-const-decl "(bijective?[negrat, nat])" countable_types nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (injective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (bijective? const-decl "bool" functions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (negrat nonempty-type-eq-decl nil rationals nil)
    (< const-decl "bool" reals nil)
    (nonpos_rat nonempty-type-eq-decl nil rationals nil)
    (<= const-decl "bool" reals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nat_negrat formula-decl nil countable_types nil))
   shostak))
 (nat_integer 0
  (nat_integer-1 nil 3318693996
   ("" (expand "is_countably_infinite_type")
    (("" (inst + "int_to_nat") nil nil)) nil)
   ((int_to_nat_bijective name-judgement "(bijective?[int, nat])"
     countable_set nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (integer nonempty-type-from-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (int_to_nat const-decl "nat" countable_set nil)
    (is_countably_infinite_type const-decl "bool" countability nil))
   shostak))
 (nat_nonzero_integer 0
  (nat_nonzero_integer-1 nil 3318694019
   ("" (lemma "nat_integer")
    (("" (expand "is_countably_infinite_type")
      (("" (skolem-typepred)
        ((""
          (inst +
           "LAMBDA (x: nonzero_integer): f!1(IF x >= 0 THEN x - 1 ELSE x ENDIF)")
          (("" (grind :if-match nil)
            (("1" (inst - "y!1")
              (("1" (skolem!)
                (("1" (case "x!1 >= 0")
                  (("1" (inst + "x!1 + 1")
                    (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
                   ("2" (inst + "x!1")
                    (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (inst - "x1!1 - 1" "x2!1 - 1") (("2" (assert) nil nil)) nil)
             ("3" (inst - "x1!1 - 1" "x2!1") (("3" (assert) nil nil)) nil)
             ("4" (inst - "x1!1" "x2!1 - 1") (("4" (assert) nil nil)) nil)
             ("5" (inst - "x1!1" "x2!1") (("5" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((is_countably_infinite_type const-decl "bool" countability nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (/= const-decl "boolean" notequal nil)
    (nonzero_integer nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (f!1 skolem-const-decl "(bijective?[integer, nat])" countable_types nil)
    (x!1 skolem-const-decl "integer" countable_types nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (injective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (bijective? const-decl "bool" functions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer nonempty-type-from-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nat_integer formula-decl nil countable_types nil))
   shostak))
 (nat_upfrom 0
  (nat_upfrom-1 nil 3318694531
   ("" (skolem!)
    (("" (expand "is_countably_infinite_type")
      (("" (inst + "LAMBDA (x: upfrom(i!1)): x - i!1")
        (("" (grind :if-match nil)
          (("" (inst + "y!1 + i!1") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((is_countably_infinite_type const-decl "bool" countability nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (i!1 skolem-const-decl "int" countable_types nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (bijective? const-decl "bool" functions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (nat_above 0
  (nat_above-1 nil 3318694575
   ("" (skolem!)
    (("" (expand "is_countably_infinite_type")
      (("" (inst + "LAMBDA (x: above(i!1)): x - i!1 - 1")
        (("" (grind :if-match nil)
          (("" (inst + "y!1 + i!1 + 1") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((is_countably_infinite_type const-decl "bool" countability nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (i!1 skolem-const-decl "int" countable_types nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (bijective? const-decl "bool" functions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (nat_nonpos_int 0
  (nat_nonpos_int-1 nil 3318694630
   ("" (expand "is_countably_infinite_type")
    (("" (inst + "LAMBDA (x: nonpos_int): -x")
      (("" (grind :if-match nil)
        (("" (inst + "-y!1") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (injective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (is_countably_infinite_type const-decl "bool" countability nil))
   shostak))
 (nat_negint 0
  (nat_negint-1 nil 3318694663
   ("" (expand "is_countably_infinite_type")
    (("" (inst + "LAMBDA (x: negint): -x - 1")
      (("" (grind :if-match nil)
        (("" (inst + "-y!1 - 1") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (injective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (is_countably_infinite_type const-decl "bool" countability nil))
   shostak))
 (nat_posint 0
  (nat_posint-1 nil 3318694689
   ("" (expand "is_countably_infinite_type")
    (("" (inst + "LAMBDA (x: posint): x - 1")
      (("" (grind :if-match nil)
        (("" (inst + "y!1 + 1") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (is_countably_infinite_type const-decl "bool" countability nil))
   shostak))
 (nat_even_int 0
  (nat_even_int-1 nil 3318694713
   ("" (expand "is_countably_infinite_type")
    (("" (inst + "LAMBDA (x: even_int): IF x >= 0 THEN x ELSE -x - 1 ENDIF")
      (("1" (expand* "bijective?" "injective?" "surjective?")
        (("1" (split)
          (("1" (skosimp :preds? t)
            (("1" (rewrite "even_or_odd")
              (("1" (expand* "even?" "odd?")
                (("1" (skolem!)
                  (("1" (inst + "-j!1 - 1")
                    (("1" (lift-if)
                      (("1" (lift-if)
                        (("1" (ground)
                          (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (skolem!)
            (("2" (lemma "even_or_odd" ("x" "y!1"))
              (("2" (prop)
                (("1" (inst + "y!1") (("1" (assert) nil nil)) nil)
                 ("2" (expand "odd?")
                  (("2" (skolem!)
                    (("2" (inst + "-y!1 - 1")
                      (("1" (assert) nil nil)
                       ("2" (expand "even?")
                        (("2" (inst + "-j!1 - 1") (("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skosimp) (("2" (assert) nil nil)) nil))
      nil))
    nil)
   ((minus_even_is_even application-judgement "even_int" integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (even? const-decl "bool" integers nil)
    (even_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (even_or_odd formula-decl nil naturalnumbers nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (odd? const-decl "bool" integers nil)
    (y!1 skolem-const-decl "nat" countable_types nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (is_countably_infinite_type const-decl "bool" countability nil))
   shostak))
 (nat_odd_int 0
  (nat_odd_int-1 nil 3318694881
   ("" (lemma "nat_even_int")
    (("" (expand "is_countably_infinite_type")
      (("" (skolem-typepred)
        (("" (inst + "LAMBDA (x: odd_int): f!1(x - 1)")
          (("" (grind :if-match nil)
            (("1" (inst - "y!1")
              (("1" (skolem!)
                (("1" (inst + "x!1 + 1") (("1" (assert) nil nil)) nil)) nil))
              nil)
             ("2" (inst - "2 * j!1" "2 * j!2") (("2" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((is_countably_infinite_type const-decl "bool" countability nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers nil)
    (odd? const-decl "bool" integers nil)
    (odd_int nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (f!1 skolem-const-decl "(bijective?[even_int, nat])" countable_types nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (injective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (bijective? const-decl "bool" functions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (even_int nonempty-type-eq-decl nil integers nil)
    (even? const-decl "bool" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nat_even_int formula-decl nil countable_types nil))
   shostak)))

