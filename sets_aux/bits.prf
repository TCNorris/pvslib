(bits
 (bounding_bits_has_least 0
  (bounding_bits_has_least-1 nil 3316868811
   ("" (skosimp)
    (("" (use "every_nonempty_set_has_least")
      (("" (hide 2) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((every_nonempty_set_has_least judgement-tcc nil bounded_nats orders)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (n!1 skolem-const-decl "nat" bits nil)
    (bounding_bits const-decl "set[nat]" bits nil)
    (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (exp2 def-decl "posnat" exp2 nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nil application-judgement "above(n)" exp2 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (bit_decoding_TCC1 0
  (bit_decoding_TCC1-2 nil 3508504742
   ("" (skosimp*)
    (("" (use "least_def" ("t" "1 + bit!1"))
      (("" (expand* "least?" "lower_bound?" "restrict")
        (("" (ground)
          (("" (inst - "bit!1")
            (("1" (assert) nil nil)
             ("2" (expand "bounding_bits" +) (("2" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (least_def formula-decl nil minmax_orders orders)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (bounding_bits const-decl "set[nat]" bits nil)
    (has_least? const-decl "bool" minmax_orders orders)
    (pred type-eq-decl nil defined_types nil) (set type-eq-decl nil sets nil)
    (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil)
    (antisymmetric? const-decl "bool" relations nil)
    (PRED type-eq-decl nil defined_types nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nil application-judgement "above(n)" exp2 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (bit!1 skolem-const-decl "nat" bits nil)
    (n!1 skolem-const-decl "nat" bits nil)
    (least? const-decl "bool" minmax_orders orders)
    (lower_bound? const-decl "bool" bounded_orders orders))
   nil
   (bit_decoding subtype "(number_fields.-)(bits.n, exp2.exp2(bits.bit))"
    "nat"))
  (bit_decoding_TCC1-1 nil 3316868576
   ("" (skosimp)
    (("" (use "bounding_bits_has_least") (("" (assert) nil nil)) nil)) nil)
   nil nil
   (bit_decoding subtype "(number_fields.-)(bits.n, exp2.exp2(bits.bit))"
    "nat")))
 (bit_decoding_TCC2 0
  (bit_decoding_TCC2-1 nil 3316868576
   ("" (skosimp*) (("" (grind) nil nil)) nil)
   ((nil application-judgement "above(n)" exp2 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (bit_decoding termination
    "bits.bit_decoding((number_fields.-)(bits.n, exp2.exp2(bits.bit)))"
    "nil")))
 (bit_decoding_TCC3 0
  (bit_decoding_TCC3-2 nil 3508504937
   ("" (skosimp)
    (("" (use "bounding_bits_has_least") (("" (assert) nil nil)) nil)) nil)
   ((bounding_bits_has_least formula-decl nil bits nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (bit_decoding subtype "bits.bounding_bits(bits.n)"
    "(LAMBDA (S: sets[nat].set): minmax_orders[nat].has_least?(S, restrict[[real, real], [nat, nat], booleans.boolean].restrict(reals.<=)))"))
  (bit_decoding_TCC3-1 nil 3316868576
   ("" (skosimp*)
    (("" (use "least_def" ("t" "1 + bit!1"))
      (("" (expand* "least?" "lower_bound?" "restrict")
        (("" (ground)
          (("" (inst - "bit!1")
            (("1" (assert) nil nil)
             ("2" (expand "bounding_bits" +) (("2" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((least_def formula-decl nil minmax_orders orders)
    (antisymmetric? const-decl "bool" relations nil)
    (set type-eq-decl nil sets nil)
    (has_least? const-decl "bool" minmax_orders orders)
    (least? const-decl "bool" minmax_orders orders)
    (lower_bound? const-decl "bool" bounded_orders orders))
   nil
   (bit_decoding subtype "bits.bounding_bits(bits.n)"
    "(LAMBDA (S: sets[nat].set): minmax_orders[nat].has_least?(S, restrict[[real, real], [nat, nat], booleans.boolean].restrict(reals.<=)))")))
 (bit_decoding_TCC4 0
  (bit_decoding_TCC4-2 nil 3508504990
   ("" (skosimp)
    ((""
      (typepred
       "least[nat](restrict[[real, real], [nat, nat], boolean](<=))(bounding_bits(n!1))")
      (("" (expand "least?")
        (("" (expand "bounding_bits" -1 :occurrence 1)
          (("" (rewrite "exp2_def" -1)
            (("" (lemma "expt_x0" ("x" "2")) (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil)
    (least const-decl "{t: (S) | least?(t, S, <=)}" minmax_orders orders)
    (least? const-decl "bool" minmax_orders orders)
    (has_least? const-decl "bool" minmax_orders orders)
    (pred type-eq-decl nil defined_types nil)
    (bounding_bits const-decl "set[nat]" bits nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (exp2_def formula-decl nil exp2 nil))
   nil
   (bit_decoding subtype
    "(number_fields.-)(minmax_orders[nat].least(restrict[[real, real], [nat, nat], booleans.boolean].restrict(reals.<=))(bits.bounding_bits(bits.n)), 1)"
    "nat"))
  (bit_decoding_TCC4-1 nil 3316868576 ("" (termination-tcc) nil nil) nil nil
   (bit_decoding subtype
    "(number_fields.-)(minmax_orders[nat].least(restrict[[real, real], [nat, nat], booleans.boolean].restrict(reals.<=))(bits.bounding_bits(bits.n)), 1)"
    "nat")))
 (bit_decoding_has_greatest 0
  (bit_decoding_has_greatest-1 nil 3316869847
   ("" (skosimp)
    (("" (use "non_empty_finite_has_greatest")
      (("" (expand "bit_decoding") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((non_empty_finite_has_greatest formula-decl nil minmax_orders orders)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (n!1 skolem-const-decl "nat" bits nil) (<= const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bit_decoding def-decl "finite_set" bits nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set[nat]"
     bits nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nil application-judgement "above(n)" exp2 nil))
   shostak))
 (bit_decoding_max1_TCC1 0
  (bit_decoding_max1_TCC1-1 nil 3316868576
   ("" (skosimp) (("" (forward-chain "bit_decoding_has_greatest") nil nil))
    nil)
   ((bit_decoding_has_greatest formula-decl nil bits nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   nil
   (bit_decoding_max1 subtype "bits.bit_decoding(bits.n)"
    "(LAMBDA (S: sets[nat].set): minmax_orders[nat].has_greatest?(S, restrict[[real, real], [nat, nat], booleans.boolean].restrict(reals.<=)))")))
 (bit_decoding_max1 0
  (bit_decoding_max1-2 nil 3508505373
   ("" (lemma "bit_decoding_max1_TCC1")
    (("" (induct "n" :name "NAT_induction")
      (("" (skosimp*)
        (("" (inst-cp -3 "j!1")
          (("" (assert)
            (("" (use "bit_decoding_TCC4")
              (("" (use "bit_decoding_TCC3")
                (("" (assert)
                  (("" (typepred "greatest(lesseq)(bit_decoding(j!1))")
                    (("" (expand "greatest?")
                      (("" (expand "bit_decoding" -1 :occurrence 1)
                        (("" (expand* "add" "member")
                          (("" (lemma "least_le")
                            ((""
                              (inst - "lesseq" "bounding_bits(j!1)"
                               "least(lesseq)(bounding_bits(j!1)) - 1")
                              (("1" (expand "restrict")
                                (("1" (assert) nil nil)) nil)
                               ("2" (expand "bounding_bits" 1 :occurrence 1)
                                (("2" (assert)
                                  (("2"
                                    (inst -
                                     "j!1 - exp2(least[nat](lesseq)(bounding_bits(j!1)) - 1)")
                                    (("2" (ground)
                                      (("1"
                                        (inst
                                         -
                                         "j!1 - exp2(least[nat](lesseq)(bounding_bits(j!1)) - 1)")
                                        (("1"
                                          (assert)
                                          (("1"
                                            (both-sides
                                             "+"
                                             "exp2(least[nat](restrict[[real, real], [nat, nat], boolean](<=))(bounding_bits(j!1)) - 1)"
                                             -1)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (typepred
                                                 "greatest(lesseq)(bit_decoding(j!1 - exp2(least(lesseq)(bounding_bits(j!1)) - 1)))")
                                                (("1"
                                                  (expand*
                                                   "greatest?"
                                                   "upper_bound?")
                                                  (("1"
                                                    (inst
                                                     -
                                                     "greatest(lesseq)(bit_decoding(j!1))")
                                                    (("1"
                                                      (expand
                                                       "restrict"
                                                       -2
                                                       :occurrence
                                                       1)
                                                      (("1"
                                                        (expand
                                                         "restrict"
                                                         -5
                                                         :occurrence
                                                         1)
                                                        (("1"
                                                          (lemma "exp2_def")
                                                          (("1"
                                                            (inst-cp
                                                             -
                                                             "greatest(lesseq)(bit_decoding(j!1 - exp2(least(lesseq)(bounding_bits(j!1)) - 1)))")
                                                            (("1"
                                                              (inst
                                                               -
                                                               "greatest(lesseq)(bit_decoding(j!1))")
                                                              (("1"
                                                                (lemma
                                                                 "both_sides_expt_gt1_lt")
                                                                (("1"
                                                                  (inst
                                                                   -
                                                                   "2"
                                                                   "greatest(lesseq)(bit_decoding(j!1))"
                                                                   "greatest(lesseq)(bit_decoding(j!1 - exp2(least(lesseq)(bounding_bits(j!1)) - 1)))")
                                                                  (("1"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (use "bit_decoding_TCC3")
                                        (("2"
                                          (assert)
                                          (("2"
                                            (inst
                                             -
                                             "least(lesseq)(bounding_bits(j!1)) - 1")
                                            (("2"
                                              (expand
                                               "bit_decoding"
                                               -2
                                               :occurrence
                                               1)
                                              (("2"
                                                (expand "emptyset")
                                                (("2" (propax) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil)
    (bit_decoding def-decl "finite_set" bits nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (has_greatest? const-decl "bool" minmax_orders orders)
    (pred type-eq-decl nil defined_types nil) (set type-eq-decl nil sets nil)
    (> const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (greatest? const-decl "bool" minmax_orders orders)
    (greatest const-decl "{t: (S) | greatest?(t, S, <=)}" minmax_orders
     orders)
    (NAT_induction formula-decl nil naturalnumbers nil)
    (bit_decoding_TCC4 subtype-tcc nil bits nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (bounding_bits const-decl "set[nat]" bits nil)
    (j!1 skolem-const-decl "nat" bits nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (has_least? const-decl "bool" minmax_orders orders)
    (least? const-decl "bool" minmax_orders orders)
    (least const-decl "{t: (S) | least?(t, S, <=)}" minmax_orders orders)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (upper_bound? const-decl "bool" bounded_orders orders)
    (exp2_def formula-decl nil exp2 nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (both_sides_expt_gt1_lt formula-decl nil exponentiation nil)
    (both_sides_plus_ge1 formula-decl nil real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (emptyset const-decl "set" sets nil)
    (least_le formula-decl nil minmax_orders orders)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (bit_decoding_TCC3 subtype-tcc nil bits nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nil application-judgement "above(n)" exp2 nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (bit_decoding_max1_TCC1 subtype-tcc nil bits nil))
   nil)
  (bit_decoding_max1-1 nil 3316869877
   ("" (lemma "bit_decoding_max1_TCC1")
    (("" (induct "n" :name "NAT_induction")
      (("" (skosimp*)
        (("" (inst-cp -3 "j!1")
          (("" (assert)
            (("" (use "bit_decoding_TCC2")
              (("" (use "bit_decoding_TCC1")
                (("" (assert)
                  (("" (typepred "greatest(lesseq)(bit_decoding(j!1))")
                    (("" (expand "greatest?")
                      (("" (flatten)
                        (("" (expand "bit_decoding" -1 :occurrence 1)
                          (("" (expand* "add" "member")
                            (("" (lemma "least_le")
                              ((""
                                (inst - "lesseq" "bounding_bits(j!1)"
                                 "least(lesseq)(bounding_bits(j!1)) - 1")
                                (("1" (expand "restrict")
                                  (("1" (assert) nil nil)) nil)
                                 ("2" (expand "bounding_bits" 1 :occurrence 1)
                                  (("2" (assert)
                                    (("2"
                                      (inst
                                       -
                                       "j!1 - exp2(least[nat](lesseq)(bounding_bits(j!1)) - 1)")
                                      (("2"
                                        (ground)
                                        (("1"
                                          (inst
                                           -
                                           "j!1 - exp2(least[nat](lesseq)(bounding_bits(j!1)) - 1)")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (both-sides
                                               "+"
                                               "exp2(least[nat](restrict[[real, real], [nat, nat], boolean](<=))(bounding_bits(j!1)) - 1)"
                                               -1)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (typepred
                                                   "greatest(lesseq)(bit_decoding(j!1 - exp2(least(lesseq)(bounding_bits(j!1)) - 1)))")
                                                  (("1"
                                                    (expand*
                                                     "greatest?"
                                                     "upper_bound?")
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (inst
                                                         -
                                                         "greatest(lesseq)(bit_decoding(j!1))")
                                                        (("1"
                                                          (expand
                                                           "restrict"
                                                           -2
                                                           :occurrence
                                                           1)
                                                          (("1"
                                                            (expand
                                                             "restrict"
                                                             -5
                                                             :occurrence
                                                             1)
                                                            (("1"
                                                              (lemma
                                                               "exp2_def")
                                                              (("1"
                                                                (inst-cp
                                                                 -
                                                                 "greatest(lesseq)(bit_decoding(j!1 - exp2(least(lesseq)(bounding_bits(j!1)) - 1)))")
                                                                (("1"
                                                                  (inst
                                                                   -
                                                                   "greatest(lesseq)(bit_decoding(j!1))")
                                                                  (("1"
                                                                    (lemma
                                                                     "both_sides_expt_gt1_lt")
                                                                    (("1"
                                                                      (inst
                                                                       -
                                                                       "2"
                                                                       "greatest(lesseq)(bit_decoding(j!1))"
                                                                       "greatest(lesseq)(bit_decoding(j!1 - exp2(least(lesseq)(bounding_bits(j!1)) - 1)))")
                                                                      (("1"
                                                                        (assert)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (use "bit_decoding_TCC3")
                                          (("2"
                                            (assert)
                                            (("2"
                                              (inst
                                               -
                                               "least(lesseq)(bounding_bits(j!1)) - 1")
                                              (("2"
                                                (expand
                                                 "bit_decoding"
                                                 -2
                                                 :occurrence
                                                 1)
                                                (("2"
                                                  (expand "emptyset")
                                                  (("2" (propax) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (has_greatest? const-decl "bool" minmax_orders orders)
    (set type-eq-decl nil sets nil)
    (greatest? const-decl "bool" minmax_orders orders)
    (greatest const-decl "{t: (S) | greatest?(t, S, <=)}" minmax_orders
     orders)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (has_least? const-decl "bool" minmax_orders orders)
    (least? const-decl "bool" minmax_orders orders)
    (least const-decl "{t: (S) | least?(t, S, <=)}" minmax_orders orders)
    (upper_bound? const-decl "bool" bounded_orders orders)
    (emptyset const-decl "set" sets nil)
    (least_le formula-decl nil minmax_orders orders))
   shostak))
 (bit_decoding_max2_TCC1 0
  (bit_decoding_max2_TCC1-1 nil 3316868576
   ("" (skosimp) (("" (forward-chain "bounding_bits_has_least") nil nil)) nil)
   ((bounding_bits_has_least formula-decl nil bits nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   nil
   (bit_decoding_max2 subtype "bits.bounding_bits(bits.n)"
    "(LAMBDA (S: sets[nat].set): minmax_orders[nat].has_least?(S, restrict[[real, real], [nat, nat], booleans.boolean].restrict(reals.<=)))")))
 (bit_decoding_max2 0
  (bit_decoding_max2-2 nil 3508505405
   ("" (lemma "bit_decoding_max2_TCC1")
    (("" (lemma "bit_decoding_max1_TCC1")
      (("" (induct "n" :name "NAT_induction")
        (("" (skosimp*)
          (("" (expand "bit_decoding" +)
            (("" (ground)
              (("" (use "bit_decoding_TCC3")
                (("" (use "bit_decoding_TCC4")
                  (("" (use "bit_decoding_TCC1")
                    (("" (assert :quant-simp? t)
                      (("" (assert)
                        ((""
                          (case-replace
                           "j!1 - exp2(least(lesseq)(bounding_bits(j!1)) - 1) = 0")
                          (("1" (expand "bit_decoding" +)
                            (("1" (rewrite "singleton_as_add" :dir rl)
                              (("1" (rewrite "greatest_equals_lub")
                                (("1" (rewrite "lub_singleton") nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (use "greatest_add")
                            (("1" (lift-if)
                              (("1" (ground)
                                (("1" (replace -1)
                                  (("1"
                                    (inst -
                                     "j!1 - exp2(least(lesseq)(bounding_bits(j!1)) - 1)")
                                    (("1" (assert)
                                      (("1"
                                        (replace -5)
                                        (("1"
                                          (hide -1 -5)
                                          (("1"
                                            (typepred
                                             "least(lesseq)(bounding_bits(j!1 - exp2(least(lesseq)(bounding_bits(j!1)) - 1)))")
                                            (("1"
                                              (expand*
                                               "least?"
                                               "lower_bound?")
                                              (("1"
                                                (expand
                                                 "restrict"
                                                 -2
                                                 :occurrence
                                                 1)
                                                (("1"
                                                  (expand
                                                   "bounding_bits"
                                                   -1
                                                   :occurrence
                                                   1)
                                                  (("1"
                                                    (inst
                                                     -
                                                     "least(lesseq)(bounding_bits(j!1)) - 1")
                                                    (("1" (assert) nil nil)
                                                     ("2"
                                                      (expand
                                                       "bounding_bits"
                                                       1
                                                       :occurrence
                                                       1)
                                                      (("2"
                                                        (lemma "exp2_n")
                                                        (("2"
                                                          (inst
                                                           -
                                                           "least(lesseq)(bounding_bits(j!1)) - 1")
                                                          (("2"
                                                            (typepred
                                                             "least(lesseq)(bounding_bits(j!1))")
                                                            (("2"
                                                              (expand
                                                               "least?")
                                                              (("2"
                                                                (expand
                                                                 "bounding_bits"
                                                                 -1
                                                                 :occurrence
                                                                 1)
                                                                (("2"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2"
                              (inst -6
                               "j!1 - exp2(least(lesseq)(bounding_bits(j!1)) - 1)")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((bit_decoding_max1_TCC1 subtype-tcc nil bits nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set[nat]"
     bits nil)
    (bit_decoding_TCC4 subtype-tcc nil bits nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (singleton_as_add formula-decl nil sets_lemmas nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" bits nil)
    (partial_order? const-decl "bool" orders nil)
    (lub_singleton formula-decl nil bounded_orders orders)
    (greatest_equals_lub formula-decl nil minmax_orders orders)
    (PRED type-eq-decl nil defined_types nil)
    (antisymmetric? const-decl "bool" relations nil)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lower_bound? const-decl "bool" bounded_orders orders)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (exp2_n formula-decl nil exp2 nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (j!1 skolem-const-decl "nat" bits nil)
    (greatest_add formula-decl nil total_lattices orders)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (bit_decoding_TCC1 subtype-tcc nil bits nil)
    (bit_decoding_TCC3 subtype-tcc nil bits nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nil application-judgement "above(n)" exp2 nil)
    (NAT_induction formula-decl nil naturalnumbers nil)
    (least const-decl "{t: (S) | least?(t, S, <=)}" minmax_orders orders)
    (least? const-decl "bool" minmax_orders orders)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (greatest const-decl "{t: (S) | greatest?(t, S, <=)}" minmax_orders
     orders)
    (greatest? const-decl "bool" minmax_orders orders)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (has_least? const-decl "bool" minmax_orders orders)
    (bounding_bits const-decl "set[nat]" bits nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil) (set type-eq-decl nil sets nil)
    (pred type-eq-decl nil defined_types nil)
    (has_greatest? const-decl "bool" minmax_orders orders)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (bit_decoding def-decl "finite_set" bits nil)
    (restrict const-decl "R" restrict nil) (<= const-decl "bool" reals nil)
    (bit_decoding_max2_TCC1 subtype-tcc nil bits nil))
   nil)
  (bit_decoding_max2-1 nil 3316870891
   ("" (lemma "bit_decoding_max2_TCC1")
    (("" (lemma "bit_decoding_max1_TCC1")
      (("" (induct "n" :name "NAT_induction")
        (("" (skosimp*)
          (("" (expand "bit_decoding" +)
            (("" (ground)
              (("" (use "bit_decoding_TCC1")
                (("" (use "bit_decoding_TCC2")
                  (("" (use "bit_decoding_TCC3")
                    (("" (assert :quant-simp? t)
                      (("" (assert)
                        ((""
                          (case-replace
                           "j!1 - exp2(least(lesseq)(bounding_bits(j!1)) - 1) = 0")
                          (("1" (expand "bit_decoding" +)
                            (("1" (rewrite "singleton_as_add" :dir rl)
                              (("1" (rewrite "greatest_equals_lub")
                                (("1" (rewrite "lub_singleton") nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (use "greatest_add")
                            (("1" (lift-if)
                              (("1" (ground)
                                (("1" (replace -1)
                                  (("1"
                                    (inst -
                                     "j!1 - exp2(least(lesseq)(bounding_bits(j!1)) - 1)")
                                    (("1" (assert)
                                      (("1"
                                        (replace -5)
                                        (("1"
                                          (hide -1 -5)
                                          (("1"
                                            (typepred
                                             "least(lesseq)(bounding_bits(j!1 - exp2(least(lesseq)(bounding_bits(j!1)) - 1)))")
                                            (("1"
                                              (expand*
                                               "least?"
                                               "lower_bound?")
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (expand
                                                   "restrict"
                                                   -2
                                                   :occurrence
                                                   1)
                                                  (("1"
                                                    (expand
                                                     "bounding_bits"
                                                     -1
                                                     :occurrence
                                                     1)
                                                    (("1"
                                                      (inst
                                                       -
                                                       "least(lesseq)(bounding_bits(j!1)) - 1")
                                                      (("1" (assert) nil nil)
                                                       ("2"
                                                        (expand
                                                         "bounding_bits"
                                                         1
                                                         :occurrence
                                                         1)
                                                        (("2"
                                                          (lemma "exp2_n")
                                                          (("2"
                                                            (inst
                                                             -
                                                             "least(lesseq)(bounding_bits(j!1)) - 1")
                                                            (("2"
                                                              (typepred
                                                               "least(lesseq)(bounding_bits(j!1))")
                                                              (("2"
                                                                (expand
                                                                 "least?")
                                                                (("2"
                                                                  (flatten)
                                                                  (("2"
                                                                    (expand
                                                                     "bounding_bits"
                                                                     -1
                                                                     :occurrence
                                                                     1)
                                                                    (("2"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2"
                              (inst -6
                               "j!1 - exp2(least(lesseq)(bounding_bits(j!1)) - 1)")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((partial_order? const-decl "bool" orders nil)
    (lub_singleton formula-decl nil bounded_orders orders)
    (greatest_equals_lub formula-decl nil minmax_orders orders)
    (antisymmetric? const-decl "bool" relations nil)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (lower_bound? const-decl "bool" bounded_orders orders)
    (greatest_add formula-decl nil total_lattices orders)
    (least const-decl "{t: (S) | least?(t, S, <=)}" minmax_orders orders)
    (least? const-decl "bool" minmax_orders orders)
    (greatest const-decl "{t: (S) | greatest?(t, S, <=)}" minmax_orders
     orders)
    (greatest? const-decl "bool" minmax_orders orders)
    (has_least? const-decl "bool" minmax_orders orders)
    (set type-eq-decl nil sets nil)
    (has_greatest? const-decl "bool" minmax_orders orders)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil))
   shostak))
 (bit_decoding_max3 0
  (bit_decoding_max3-2 nil 3508505431
   ("" (induct "n" :name "NAT_induction")
    (("" (skosimp*)
      (("" (expand "bit_decoding" -2)
        (("" (expand* "emptyset" "member")
          (("" (prop)
            (("" (expand* "add" "member")
              (("" (use "bit_decoding_max2")
                (("" (use "bit_decoding_max1")
                  (("" (assert)
                    (("" (forward-chain "bit_decoding_TCC3")
                      (("" (forward-chain "bit_decoding_TCC4")
                        ((""
                          (inst -
                           "j!1 - exp2(least(lesseq)(bounding_bits(j!1)) - 1)")
                          (("" (assert)
                            (("" (inst - "m!1") (("" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((emptyset const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (bit_decoding_max1 formula-decl nil bits nil)
    (bit_decoding_TCC3 subtype-tcc nil bits nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (has_least? const-decl "bool" minmax_orders orders)
    (least? const-decl "bool" minmax_orders orders)
    (least const-decl "{t: (S) | least?(t, S, <=)}" minmax_orders orders)
    (restrict const-decl "R" restrict nil)
    (bounding_bits const-decl "set[nat]" bits nil)
    (j!1 skolem-const-decl "nat" bits nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (bit_decoding_TCC4 subtype-tcc nil bits nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (bit_decoding_max2 formula-decl nil bits nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nil application-judgement "above(n)" exp2 nil)
    (NAT_induction formula-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (bit_decoding def-decl "finite_set" bits nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil)
  (bit_decoding_max3-1 nil 3316907107
   ("" (induct "n" :name "NAT_induction")
    (("" (skosimp*)
      (("" (expand "bit_decoding" -2)
        (("" (expand* "emptyset" "member")
          (("" (prop)
            (("" (expand* "add" "member")
              (("" (use "bit_decoding_max2")
                (("" (use "bit_decoding_max1")
                  (("" (assert)
                    (("" (forward-chain "bit_decoding_TCC1")
                      (("" (forward-chain "bit_decoding_TCC2")
                        ((""
                          (inst -
                           "j!1 - exp2(least(lesseq)(bounding_bits(j!1)) - 1)")
                          (("" (assert)
                            (("" (inst - "m!1") (("" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((emptyset const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (has_least? const-decl "bool" minmax_orders orders)
    (least? const-decl "bool" minmax_orders orders)
    (least const-decl "{t: (S) | least?(t, S, <=)}" minmax_orders orders)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil))
   shostak))
 (bit_encoding_TCC1 0
  (bit_encoding_TCC1-1 nil 3316868576
   ("" (skosimp) (("" (use "non_empty_finite_has_greatest") nil nil)) nil)
   ((S!1 skolem-const-decl "finite_set[nat]" bits nil)
    (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (non_empty_finite_has_greatest formula-decl nil minmax_orders orders)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   nil
   (bit_encoding subtype "bits.S"
    "(LAMBDA (S: sets[nat].set): minmax_orders[nat].has_greatest?(S, restrict[[real, real], [nat, nat], booleans.boolean].restrict(reals.<=)))")))
 (bit_encoding_TCC2 0
  (bit_encoding_TCC2-2 "" 3790091296
   ("" (skosimp)
    (("" (forward-chain "bit_encoding_TCC1")
      (("" (use "card_remove") (("" (assert) nil nil)) nil)) nil))
    nil)
   nil shostak
   (bit_encoding termination
    "bits.bit_encoding(sets[nat].remove(minmax_orders[nat].greatest(restrict[[real, real], [nat, nat], booleans.boolean].restrict(reals.<=))(bits.S), bits.S))"
    "nil"))
  (bit_encoding_TCC2-1 nil 3316868576
   ("" (skosimp)
    (("" (forward-chain "bit_encoding_TCC1")
      (("" (use "card_remove")
        (("" (use "greatest_member") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((bit_encoding_TCC1 subtype-tcc nil bits nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_remove application-judgement "finite_set[nat]" bits nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (pred type-eq-decl nil defined_types nil)
    (has_greatest? const-decl "bool" minmax_orders orders)
    (greatest? const-decl "bool" minmax_orders orders)
    (greatest const-decl "{t: (S) | greatest?(t, S, <=)}" minmax_orders
     orders)
    (restrict const-decl "R" restrict nil) (<= const-decl "bool" reals nil)
    (card_remove formula-decl nil finite_sets nil))
   nil
   (bit_encoding termination
    "bits.bit_encoding(sets[nat].remove(minmax_orders[nat].greatest(restrict[[real, real], [nat, nat], booleans.boolean].restrict(reals.<=))(bits.S), bits.S))"
    "nil")))
 (bit_encoding_member1 0
  (bit_encoding_member1-1 nil 3316907428
   ("" (measure-induct+ "card(S)" ("S"))
    (("" (skolem!)
      (("" (expand "bit_encoding" +)
        (("" (lift-if)
          (("" (ground)
            (("1" (expand* "empty?" "member")
              (("1" (inst - "x!2") (("1" (assert) nil nil)) nil)) nil)
             ("2" (forward-chain "bit_encoding_TCC2")
              (("2" (forward-chain "bit_encoding_TCC1")
                (("2" (inst - "remove(greatest(lesseq)(x!1), x!1)")
                  (("2" (inst - "x!2")
                    (("1" (assert) nil nil)
                     ("2" (expand* "remove" "member") nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((bit_encoding_TCC2 termination-tcc nil bits nil)
    (restrict const-decl "R" restrict nil)
    (greatest const-decl "{t: (S) | greatest?(t, S, <=)}" minmax_orders
     orders)
    (greatest? const-decl "bool" minmax_orders orders)
    (has_greatest? const-decl "bool" minmax_orders orders)
    (remove const-decl "set" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (x!2 skolem-const-decl "(x!1)" bits nil)
    (x!1 skolem-const-decl "finite_set[nat]" bits nil)
    (bit_encoding_TCC1 subtype-tcc nil bits nil)
    (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (finite_remove application-judgement "finite_set[nat]" bits nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (nil application-judgement "above(n)" exp2 nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bit_encoding def-decl "nat" bits nil) (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (bit_encoding_member2 0
  (bit_encoding_member2-2 "" 3790091297
   ("" (measure-induct+ "card(S)" ("S"))
    (("" (expand "bit_encoding" +)
      (("" (rewrite "exp2_sum")
        (("" (expand "exp2" 1 :occurrence 2)
          (("" (expand "exp2" 1 :occurrence 2)
            (("" (case "empty?(remove(greatest(lesseq)(x!1), x!1))")
              (("1" (expand "bit_encoding" +) (("1" (assert) nil nil)) nil)
               ("2" (inst - "remove(greatest(lesseq)(x!1), x!1)")
                (("2" (prop)
                  (("1" (lemma "exp2_def")
                    (("1" (inst-cp - "greatest(lesseq)(x!1)")
                      (("1"
                        (inst -
                         "1 + greatest(lesseq)(remove(greatest(lesseq)(x!1), x!1))")
                        (("1" (lemma "both_sides_expt_gt1_le")
                          (("1"
                            (inst - "2"
                             "1 + greatest(lesseq)(remove(greatest(lesseq)(x!1), x!1))"
                             "greatest(lesseq)(x!1)")
                            (("1" (assert)
                              (("1" (use "remove_greatest")
                                (("1" (expand "nonempty?")
                                  (("1" (propax) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (use "bit_encoding_TCC2") (("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (bit_encoding_member2-1 nil 3316907588
   ("" (measure-induct+ "card(S)" ("S"))
    (("1" (expand "bit_encoding" +)
      (("1" (rewrite "exp2_sum")
        (("1" (expand "exp2" 1 :occurrence 2)
          (("1" (expand "exp2" 1 :occurrence 2)
            (("1" (case "empty?(remove(greatest(lesseq)(x!1), x!1))")
              (("1" (expand "bit_encoding" +) (("1" (assert) nil nil)) nil)
               ("2" (inst - "remove(greatest(lesseq)(x!1), x!1)")
                (("2" (prop)
                  (("1" (lemma "exp2_def")
                    (("1" (inst-cp - "greatest(lesseq)(x!1)")
                      (("1"
                        (inst -
                         "1 + greatest(lesseq)(remove(greatest(lesseq)(x!1), x!1))")
                        (("1" (lemma "both_sides_expt_gt1_le")
                          (("1"
                            (inst - "2"
                             "1 + greatest(lesseq)(remove(greatest(lesseq)(x!1), x!1))"
                             "greatest(lesseq)(x!1)")
                            (("1" (assert)
                              (("1" (use "remove_greatest")
                                (("1" (expand "nonempty?")
                                  (("1" (propax) nil nil)) nil)
                                 ("2" (use "non_empty_finite_bounded_above")
                                  nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (use "bit_encoding_TCC2") (("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (use "bit_encoding_member2_TCC1") nil nil))
    nil)
   ((remove_preserves_bounded application-judgement "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], bool](<=)))" bits nil)
    (finite_remove application-judgement "finite_set[nat]" bits nil)
    (remove const-decl "set" sets nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (both_sides_expt_gt1_le formula-decl nil exponentiation nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (nonempty? const-decl "bool" sets nil)
    (non_empty_bounded_above? const-decl "bool" non_empty_bounded_sets orders)
    (remove_greatest formula-decl nil bounded_integers orders)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (exp2_def formula-decl nil exp2 nil)
    (bit_encoding_TCC2 termination-tcc nil bits nil)
    (x!1 skolem-const-decl "non_empty_finite_set[nat]" bits nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (nil application-judgement "above(n)" exp2 nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (exp2_sum formula-decl nil exp2 nil) (<= const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (greatest const-decl "{t: (S) | greatest?(t, S, <=)}" minmax_orders
     orders)
    (greatest? const-decl "bool" minmax_orders orders)
    (has_greatest? const-decl "bool" minmax_orders orders)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (bit_encoding def-decl "nat" bits nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (bit_encoding_member3_TCC1 0
  (bit_encoding_member3_TCC1-1 nil 3316868576
   ("" (skolem!)
    (("" (use "bit_decoding_TCC3")
      (("" (assert)
        (("" (expand "bit_encoding" -) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((bit_decoding_TCC3 subtype-tcc nil bits nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bit_encoding def-decl "nat" bits nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (remove_preserves_bounded application-judgement "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], bool](<=)))" bits nil)
    (finite_remove application-judgement "finite_set[nat]" bits nil)
    (nil application-judgement "above(n)" exp2 nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (bit_encoding_member3 subtype
    "bits.bounding_bits(bits.bit_encoding(bits.S))"
    "(LAMBDA (S: sets[nat].set): minmax_orders[nat].has_least?(S, restrict[[real, real], [nat, nat], booleans.boolean].restrict(reals.<=)))")))
 (bit_encoding_member3 0
  (bit_encoding_member3-2 "" 3790091297
   ("" (skolem!)
    (("" (use "bit_encoding_member3_TCC1")
      (("" (assert)
        (("" (typepred "least(lesseq)(bounding_bits(bit_encoding(S!1)))")
          (("" (expand* "least?" "lower_bound?")
            (("" (expand "bounding_bits" -1 :occurrence 1)
              (("" (expand "restrict" -2 :occurrence 1)
                (("" (use "bit_encoding_member2")
                  (("" (assert)
                    (("" (inst - "greatest(lesseq)(S!1) + 1")
                      (("1" (lemma "bit_encoding_member1")
                        (("1" (inst - "S!1" "greatest(lesseq)(S!1)")
                          (("1" (lemma "exp2_lt")
                            (("1"
                              (inst - "greatest(lesseq)(S!1)"
                               "least(lesseq)(bounding_bits(bit_encoding(S!1)))")
                              (("1" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand "bounding_bits" 1)
                        (("2" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (bit_encoding_member3-1 nil 3316908262
   ("" (skolem!)
    (("" (use "bit_encoding_member3_TCC1")
      (("" (assert)
        (("" (typepred "least(lesseq)(bounding_bits(bit_encoding(S!1)))")
          (("" (expand* "least?" "lower_bound?")
            (("" (flatten)
              (("" (expand "bounding_bits" -1 :occurrence 1)
                (("" (expand "restrict" -2 :occurrence 1)
                  (("" (use "bit_encoding_member2")
                    (("" (assert)
                      (("" (inst - "greatest(lesseq)(S!1) + 1")
                        (("1" (lemma "bit_encoding_member1")
                          (("1" (inst - "S!1" "greatest(lesseq)(S!1)")
                            (("1" (lemma "exp2_lt")
                              (("1"
                                (inst - "greatest(lesseq)(S!1)"
                                 "least(lesseq)(bounding_bits(bit_encoding(S!1)))")
                                (("1" (assert) nil nil)) nil))
                              nil)
                             ("2" (use "greatest_member") nil nil))
                            nil))
                          nil)
                         ("2" (expand "bounding_bits" 1)
                          (("2" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((bit_encoding_member3_TCC1 subtype-tcc nil bits nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil)
    (least const-decl "{t: (S) | least?(t, S, <=)}" minmax_orders orders)
    (least? const-decl "bool" minmax_orders orders)
    (has_least? const-decl "bool" minmax_orders orders)
    (pred type-eq-decl nil defined_types nil)
    (bit_encoding def-decl "nat" bits nil)
    (bounding_bits const-decl "set[nat]" bits nil)
    (bit_encoding_member2 formula-decl nil bits nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (nil application-judgement "above(n)" exp2 nil)
    (S!1 skolem-const-decl "non_empty_finite_set[nat]" bits nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (has_greatest? const-decl "bool" minmax_orders orders)
    (greatest? const-decl "bool" minmax_orders orders)
    (greatest const-decl "{t: (S) | greatest?(t, S, <=)}" minmax_orders
     orders)
    (exp2_lt formula-decl nil exp2 nil)
    (bit_encoding_member1 formula-decl nil bits nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lower_bound? const-decl "bool" bounded_orders orders)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (decoding_encoding_max_TCC1 0
  (decoding_encoding_max_TCC1-1 nil 3316868576
   ("" (skolem!)
    (("" (use "bit_decoding_max1_TCC1")
      (("" (assert)
        (("" (expand "bit_encoding" 1) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((bit_decoding_max1_TCC1 subtype-tcc nil bits nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bit_encoding def-decl "nat" bits nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (remove_preserves_bounded application-judgement "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], bool](<=)))" bits nil)
    (finite_remove application-judgement "finite_set[nat]" bits nil)
    (nil application-judgement "above(n)" exp2 nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (decoding_encoding_max subtype
    "bits.bit_decoding(bits.bit_encoding(bits.S))"
    "(LAMBDA (S: sets[nat].set): minmax_orders[nat].has_greatest?(S, restrict[[real, real], [nat, nat], booleans.boolean].restrict(reals.<=)))")))
 (decoding_encoding_max 0
  (decoding_encoding_max-1 nil 3316909101
   ("" (skolem!)
    (("" (use "bit_decoding_max2")
      (("" (use "bit_encoding_member3")
        (("" (assert)
          (("" (expand "bit_encoding" 1) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((bit_decoding_max2 formula-decl nil bits nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bit_encoding def-decl "nat" bits nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nil application-judgement "above(n)" exp2 nil)
    (finite_remove application-judgement "finite_set[nat]" bits nil)
    (remove_preserves_bounded application-judgement "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], bool](<=)))" bits nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (bit_encoding_member3 formula-decl nil bits nil))
   shostak))
 (decoding_encoding_empty 0
  (decoding_encoding_empty-1 nil 3316909141
   ("" (skolem!)
    (("" (expand* "bit_encoding" "bit_decoding")
      (("" (smash) (("" (rewrite "emptyset_is_empty?[nat]") nil nil)) nil))
      nil))
    nil)
   ((bit_decoding def-decl "finite_set" bits nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_emptyset name-judgement "finite_set[nat]" bits nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nil application-judgement "above(n)" exp2 nil)
    (bit_encoding def-decl "nat" bits nil)
    (emptyset_is_empty? formula-decl nil sets_lemmas nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set[nat]"
     bits nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (finite_remove application-judgement "finite_set[nat]" bits nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil))
   shostak))
 (decoding_encoding_remove 0
  (decoding_encoding_remove-2 "" 3790091299
   ("" (skolem!)
    (("" (expand "bit_decoding" :occurrence 1)
      (("" (lift-if)
        (("" (ground)
          (("1" (expand "bit_encoding" -) (("1" (assert) nil nil)) nil)
           ("2" (use "bit_encoding_member3")
            (("2" (replace -1)
              (("2" (lemma "bit_encoding_member1")
                (("2" (inst - "S!1" "greatest(lesseq)(S!1)")
                  (("2" (assert)
                    (("2" (use "remove_add_member[nat]")
                      (("2" (prop)
                        (("1" (replace -1)
                          (("1" (expand "bit_encoding" 2 :occurrence 1)
                            (("1" (propax) nil nil)) nil))
                          nil)
                         ("2" (forward-chain "bit_decoding_max3")
                          (("2" (use "bit_encoding_member2")
                            (("2" (expand "exp2" -1) (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (decoding_encoding_remove-1 nil 3316909203
   ("" (skolem!)
    (("" (expand "bit_decoding" :occurrence 1)
      (("" (lift-if)
        (("" (ground)
          (("1" (expand "bit_encoding" -) (("1" (assert) nil nil)) nil)
           ("2" (use "bit_encoding_member3")
            (("2" (replace -1)
              (("2" (lemma "bit_encoding_member1")
                (("2" (inst - "S!1" "greatest(lesseq)(S!1)")
                  (("1" (assert)
                    (("1" (use "remove_add_member[nat]")
                      (("1" (prop)
                        (("1" (replace -1)
                          (("1" (expand "bit_encoding" 2 :occurrence 1)
                            (("1" (propax) nil nil)) nil))
                          nil)
                         ("2" (forward-chain "bit_decoding_max3")
                          (("2" (use "bit_encoding_member2")
                            (("2" (expand "exp2" -1) (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (use "greatest_member") nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nil application-judgement "above(n)" exp2 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (bit_decoding def-decl "finite_set" bits nil)
    (remove_preserves_bounded application-judgement "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], bool](<=)))" bits nil)
    (finite_remove application-judgement "finite_set[nat]" bits nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set[nat]"
     bits nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[nat]" bits nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (bit_encoding def-decl "nat" bits nil) (<= const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (greatest const-decl "{t: (S) | greatest?(t, S, <=)}" minmax_orders
     orders)
    (greatest? const-decl "bool" minmax_orders orders)
    (has_greatest? const-decl "bool" minmax_orders orders)
    (pred type-eq-decl nil defined_types nil)
    (remove_add_member formula-decl nil sets_lemmas nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (bit_decoding_max3 formula-decl nil bits nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers nil)
    (bit_encoding_member2 formula-decl nil bits nil)
    (bit_encoding_member1 formula-decl nil bits nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (empty? const-decl "bool" sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (bit_encoding_member3 formula-decl nil bits nil))
   shostak))
 (encoding_decoding 0
  (encoding_decoding-2 "" 3790091300
   ("" (induct "n" :name "NAT_induction")
    (("" (skosimp)
      (("" (expand "bit_encoding" +)
        (("" (lift-if)
          (("" (ground)
            (("1" (expand "bit_decoding" -1) (("1" (assert) nil nil)) nil)
             ("2" (inst - "j!1 - exp2(greatest(lesseq)(bit_decoding(j!1)))")
              (("1" (assert)
                (("1" (expand "bit_decoding" 2 :occurrence 2)
                  (("1" (assert)
                    (("1" (use "bit_decoding_max2")
                      (("1" (assert)
                        (("1" (use "non_empty_finite_has_greatest")
                          (("1" (replace -2 2 :dir rl)
                            (("1" (use "remove_add_member[nat]")
                              (("1" (assert)
                                (("1" (forward-chain "bit_decoding_max3")
                                  (("1"
                                    (both-sides "+"
                                     "exp2(greatest(lesseq)(bit_decoding(j!1)))"
                                     -1)
                                    (("1" (assert)
                                      (("1"
                                        (rewrite "exp2_n" -1 :dir rl)
                                        (("1"
                                          (replace -4 -1)
                                          (("1"
                                            (assert)
                                            (("1"
                                              (typepred
                                               "least(lesseq)(bounding_bits(j!1))")
                                              (("1"
                                                (expand "least?")
                                                (("1"
                                                  (expand
                                                   "bounding_bits"
                                                   -1
                                                   :occurrence
                                                   1)
                                                  (("1" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (use "bit_decoding_max1")
                (("2" (assert)
                  (("2" (expand "bit_decoding" 3)
                    (("2" (rewrite "emptyset_is_empty?[nat]") nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (encoding_decoding-1 nil 3316909396
   ("" (induct "n" :name "NAT_induction")
    (("" (skosimp)
      (("" (expand "bit_encoding" +)
        (("" (lift-if)
          (("" (ground)
            (("1" (expand "bit_decoding" -1) (("1" (assert) nil nil)) nil)
             ("2" (inst - "j!1 - exp2(greatest(lesseq)(bit_decoding(j!1)))")
              (("1" (assert)
                (("1" (expand "bit_decoding" 2 :occurrence 2)
                  (("1" (assert)
                    (("1" (use "bit_decoding_max2")
                      (("1" (assert)
                        (("1" (use "non_empty_finite_has_greatest")
                          (("1" (replace -2 2 :dir rl)
                            (("1" (use "remove_add_member[nat]")
                              (("1" (assert)
                                (("1" (forward-chain "bit_decoding_max3")
                                  (("1"
                                    (both-sides "+"
                                     "exp2(greatest(lesseq)(bit_decoding(j!1)))"
                                     -1)
                                    (("1" (assert)
                                      (("1"
                                        (rewrite "exp2_n" -1 :dir rl)
                                        (("1"
                                          (replace -4 -1)
                                          (("1"
                                            (assert)
                                            (("1"
                                              (typepred
                                               "least(lesseq)(bounding_bits(j!1))")
                                              (("1"
                                                (expand "least?")
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (expand
                                                     "bounding_bits"
                                                     -1
                                                     :occurrence
                                                     1)
                                                    (("1" (assert) nil nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (use "bit_decoding_max1")
                (("2" (assert)
                  (("2" (expand "bit_decoding" 3)
                    (("2" (rewrite "emptyset_is_empty?[nat]") nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil)
    (greatest const-decl "{t: (S) | greatest?(t, S, <=)}" minmax_orders
     orders)
    (greatest? const-decl "bool" minmax_orders orders)
    (has_greatest? const-decl "bool" minmax_orders orders)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (j!1 skolem-const-decl "nat" bits nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (bit_decoding_max2 formula-decl nil bits nil)
    (remove_preserves_bounded application-judgement "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], bool](<=)))" bits nil)
    (non_empty_finite_has_greatest formula-decl nil minmax_orders orders)
    (total_order? const-decl "bool" orders nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (empty? const-decl "bool" sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (remove_add_member formula-decl nil sets_lemmas nil)
    (bit_decoding_max3 formula-decl nil bits nil)
    (bounding_bits const-decl "set[nat]" bits nil)
    (has_least? const-decl "bool" minmax_orders orders)
    (least? const-decl "bool" minmax_orders orders)
    (least const-decl "{t: (S) | least?(t, S, <=)}" minmax_orders orders)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (exp2_n formula-decl nil exp2 nil)
    (both_sides_plus_le2 formula-decl nil real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (emptyset const-decl "set" sets nil)
    (emptyset_is_empty? formula-decl nil sets_lemmas nil)
    (finite_emptyset name-judgement "finite_set[nat]" bits nil)
    (bit_decoding_max1 formula-decl nil bits nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set[nat]"
     bits nil)
    (nil application-judgement "above(n)" exp2 nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (finite_remove application-judgement "finite_set[nat]" bits nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (NAT_induction formula-decl nil naturalnumbers nil)
    (bit_decoding def-decl "finite_set" bits nil)
    (bit_encoding def-decl "nat" bits nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (decoding_encoding 0
  (decoding_encoding-2 "" 3790091301
   ("" (measure-induct+ "card(S)" ("S"))
    (("" (use "decoding_encoding_empty")
      (("" (prop)
        (("1" (expand "bit_encoding" +)
          (("1" (expand "bit_decoding" +)
            (("1" (ground) (("1" (rewrite "emptyset_is_empty?[nat]") nil nil))
              nil))
            nil))
          nil)
         ("2" (apply-extensionality :hide? t)
          (("2" (iff)
            (("2" (prop)
              (("1" (lemma "total_order_restrict[real, nat]" ("R" "reals.<="))
                (("1" (lemma "non_empty_finite_has_greatest")
                  (("1" (inst-cp - "bit_decoding(bit_encoding(x!1))" "lesseq")
                    (("1" (inst - "x!1" "lesseq")
                      (("1" (use "decoding_encoding_remove")
                        (("1" (inst - "remove(greatest(lesseq)(x!1), x!1)")
                          (("1" (ground)
                            (("1" (replace -1)
                              (("1" (decompose-equality -2)
                                (("1" (expand* "remove" "member")
                                  (("1" (inst - "x!2")
                                    (("1" (assert) nil nil)) nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (use "card_remove") (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (lemma "total_order_restrict[real, nat]" ("R" "reals.<="))
                (("2" (use "non_empty_finite_has_greatest")
                  (("2" (inst - "remove(greatest(lesseq)(x!1), x!1)")
                    (("2" (use "bit_encoding_TCC2")
                      (("2" (assert)
                        (("2" (replace -5 -1 :dir rl)
                          (("2" (use "decoding_encoding_remove")
                            (("2" (replace -1 :dir rl)
                              (("2" (use "decoding_encoding_max")
                                (("2" (decompose-equality -7)
                                  (("2" (expand* "remove" "member")
                                    (("2" (inst - "x!2")
                                      (("2"
                                        (iff)
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (decoding_encoding-1 nil 3316909662
   ("" (measure-induct+ "card(S)" ("S"))
    (("" (use "decoding_encoding_empty")
      (("" (prop)
        (("1" (expand "bit_encoding" +)
          (("1" (expand "bit_decoding" +)
            (("1" (ground) (("1" (rewrite "emptyset_is_empty?[nat]") nil nil))
              nil))
            nil))
          nil)
         ("2" (apply-extensionality :hide? t)
          (("2" (iff)
            (("2" (prop)
              (("1" (lemma "total_order_restrict[real, nat]" ("R" "reals.<="))
                (("1" (lemma "non_empty_finite_has_greatest")
                  (("1" (inst-cp - "bit_decoding(bit_encoding(x!1))" "lesseq")
                    (("1" (inst - "x!1" "lesseq")
                      (("1" (use "decoding_encoding_remove")
                        (("1" (inst - "remove(greatest(lesseq)(x!1), x!1)")
                          (("1" (ground)
                            (("1" (replace -1)
                              (("1" (decompose-equality -2)
                                (("1" (expand* "remove" "member")
                                  (("1" (inst - "x!2")
                                    (("1" (assert)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (use "greatest_member")
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (use "card_remove")
                              (("2" (use "greatest_member")
                                (("2" (assert) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (lemma "total_order_restrict[real, nat]" ("R" "reals.<="))
                (("2" (use "non_empty_finite_has_greatest")
                  (("2" (inst - "remove(greatest(lesseq)(x!1), x!1)")
                    (("2" (use "bit_encoding_TCC2")
                      (("2" (assert)
                        (("2" (replace -5 -1 :dir rl)
                          (("2" (use "decoding_encoding_remove")
                            (("2" (replace -1 :dir rl)
                              (("2" (use "decoding_encoding_max")
                                (("2" (decompose-equality -7)
                                  (("2" (expand* "remove" "member")
                                    (("2" (inst - "x!2")
                                      (("2"
                                        (iff)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (flatten)
                                            (("2"
                                              (lemma "greatest_member")
                                              (("2"
                                                (inst
                                                 -
                                                 "lesseq"
                                                 "bit_decoding(bit_encoding(x!1))")
                                                (("2" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((decoding_encoding_empty formula-decl nil bits nil)
    (non_empty_finite_has_greatest formula-decl nil minmax_orders orders)
    (finite_remove application-judgement "finite_set[nat]" bits nil)
    (greatest const-decl "{t: (S) | greatest?(t, S, <=)}" minmax_orders
     orders)
    (greatest? const-decl "bool" minmax_orders orders)
    (has_greatest? const-decl "bool" minmax_orders orders)
    (remove const-decl "set" sets nil)
    (card_remove formula-decl nil finite_sets nil)
    (member const-decl "bool" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (decoding_encoding_remove formula-decl nil bits nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (empty? const-decl "bool" sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (restrict const-decl "R" restrict nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (<= const-decl "bool" reals nil)
    (total_order? const-decl "bool" orders nil)
    (total_order_restrict judgement-tcc nil restrict_order_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (bit_encoding_TCC2 termination-tcc nil bits nil)
    (decoding_encoding_max formula-decl nil bits nil)
    (x!1 skolem-const-decl "finite_set[nat]" bits nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[nat]" bits nil)
    (emptyset_is_empty? formula-decl nil sets_lemmas nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nil application-judgement "above(n)" exp2 nil)
    (bit_decoding def-decl "finite_set" bits nil)
    (bit_encoding def-decl "nat" bits nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (encoding_bijection 0
  (encoding_bijection-1 nil 3316868576
   ("" (lemma "encoding_decoding")
    (("" (lemma "decoding_encoding")
      (("" (use "left_right_bij[finite_set, nat]")
        (("" (expand* "right_inverse?" "left_inverse?")
          (("" (ground) nil nil)) nil))
        nil))
      nil))
    nil)
   ((decoding_encoding formula-decl nil bits nil)
    (left_inverse? const-decl "bool" function_inverse_def nil)
    (right_inverse? const-decl "bool" function_inverse_def nil)
    (bit_decoding def-decl "finite_set" bits nil)
    (bit_encoding def-decl "nat" bits nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (left_right_bij formula-decl nil function_inverse_def nil)
    (encoding_decoding formula-decl nil bits nil))
   nil
   (encoding_bijection subtype "bits.bit_encoding"
    "(functions[finite_set[nat], nat].bijective?)")))
 (decoding_bijection 0
  (decoding_bijection-1 nil 3316868576
   ("" (lemma "encoding_decoding")
    (("" (lemma "decoding_encoding")
      (("" (use "left_right_bij[nat, finite_set]")
        (("" (expand* "right_inverse?" "left_inverse?")
          (("" (ground) nil nil)) nil))
        nil))
      nil))
    nil)
   ((decoding_encoding formula-decl nil bits nil)
    (left_inverse? const-decl "bool" function_inverse_def nil)
    (encoding_bijection name-judgement "(bijective?[finite_set[nat], nat])"
     bits nil)
    (right_inverse? const-decl "bool" function_inverse_def nil)
    (bit_encoding def-decl "nat" bits nil)
    (bit_decoding def-decl "finite_set" bits nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (left_right_bij formula-decl nil function_inverse_def nil)
    (encoding_decoding formula-decl nil bits nil))
   nil
   (decoding_bijection subtype "bits.bit_decoding"
    "(functions[nat, finite_set[nat]].bijective?)")))
 (encoding_decoding_inverse 0
  (encoding_decoding_inverse-1 nil 3316910617
   ("" (apply-extensionality :hide? t)
    (("" (use "function_inverse[nat, finite_set].bijective_inverse")
      (("" (use "decoding_encoding") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((bijective_inverse formula-decl nil function_inverse nil)
    (bijective? const-decl "bool" functions nil)
    (decoding_encoding formula-decl nil bits nil)
    (decoding_bijection name-judgement "(bijective?[nat, finite_set[nat]])"
     bits nil)
    (bijective_inverse_is_bijective application-judgement
     "(bijective?[finite_set[nat], nat])" bits nil)
    (unique_bijective_inverse application-judgement "{x: nat | f(x) = y}" bits
     nil)
    (encoding_bijection name-judgement "(bijective?[finite_set[nat], nat])"
     bits nil)
    (bit_encoding def-decl "nat" bits nil)
    (inverse const-decl "D" function_inverse nil)
    (bit_decoding def-decl "finite_set" bits nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (decoding_encoding_inverse 0
  (decoding_encoding_inverse-1 nil 3316910643
   ("" (apply-extensionality :hide? t)
    (("" (use "function_inverse[finite_set, nat].bijective_inverse")
      (("" (use "encoding_decoding") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((bijective_inverse formula-decl nil function_inverse nil)
    (bijective? const-decl "bool" functions nil)
    (encoding_decoding formula-decl nil bits nil)
    (encoding_bijection name-judgement "(bijective?[finite_set[nat], nat])"
     bits nil)
    (bijective_inverse_is_bijective application-judgement
     "(bijective?[nat, finite_set[nat]])" bits nil)
    (unique_bijective_inverse application-judgement
     "{x: finite_set[nat] | f(x) = y}" bits nil)
    (decoding_bijection name-judgement "(bijective?[nat, finite_set[nat]])"
     bits nil)
    (bit_decoding def-decl "finite_set" bits nil)
    (inverse const-decl "D" function_inverse nil)
    (bit_encoding def-decl "nat" bits nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak)))

