(relation_inverse_extension
 (le_U_induces_equivalence 0
  (le_U_induces_equivalence-1 nil 3571899483
   ("" (skolem-typepred)
    (("" (expand "equivalence?")
      (("" (prop)
        (("1" (expand "reflexive?")
          (("1" (expand "l_T")
            (("1" (skolem!)
              (("1" (expand "image_inverse") (("1" (inst?) nil nil)) nil))
              nil))
            nil))
          nil)
         ("2" (expand "symmetric?")
          (("2" (expand "l_T")
            (("2" (expand "image_inverse")
              (("2" (skolem!) (("2" (inst -2 "f!1(x!1)" "f!1(y!1)") nil nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (expand "transitive?")
          (("3" (expand "l_T")
            (("3" (expand "image_inverse")
              (("3" (skolem!)
                (("3" (inst -3 "f!1(x!1)" "f!1(y!1)" "f!1(z!1)") nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((transitive? const-decl "bool" relations nil)
    (symmetric? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (T formal-nonempty-type-decl nil relation_inverse_extension nil)
    (image_inverse const-decl "pred[[T, T]]" relation_inverse_image nil)
    (l_T const-decl "pred[[T, T]]" relation_inverse_extension nil)
    (equivalence type-eq-decl nil relations nil)
    (equivalence? const-decl "bool" relations nil)
    (PRED type-eq-decl nil defined_types nil)
    (U formal-nonempty-type-decl nil relation_inverse_extension nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (le_U_induces_equivalence subtype
    "relation_inverse_extension.l_T(relation_inverse_extension.re_U, relation_inverse_extension.f)"
    "equivalence[T]")))
 (le_T_induces_equivalence 0
  (le_T_induces_equivalence-1 nil 3571899483
   ("" (skolem-typepred)
    (("" (expand "equivalence?")
      (("" (prop)
        (("1" (expand "reflexive?")
          (("1" (expand "l_U")
            (("1" (skolem!)
              (("1" (expand "image_inverse") (("1" (inst?) nil nil)) nil))
              nil))
            nil))
          nil)
         ("2" (expand "symmetric?")
          (("2" (expand "l_U")
            (("2" (expand "image_inverse")
              (("2" (skolem!) (("2" (inst -2 "g!1(x!1)" "g!1(y!1)") nil nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (expand "transitive?")
          (("3" (expand "l_U")
            (("3" (expand "image_inverse")
              (("3" (skolem!)
                (("3" (inst -3 "g!1(x!1)" "g!1(y!1)" "g!1(z!1)") nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((transitive? const-decl "bool" relations nil)
    (symmetric? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (U formal-nonempty-type-decl nil relation_inverse_extension nil)
    (image_inverse const-decl "pred[[T, T]]" relation_inverse_image nil)
    (l_U const-decl "pred[[U, U]]" relation_inverse_extension nil)
    (equivalence type-eq-decl nil relations nil)
    (equivalence? const-decl "bool" relations nil)
    (PRED type-eq-decl nil defined_types nil)
    (T formal-nonempty-type-decl nil relation_inverse_extension nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (le_T_induces_equivalence subtype
    "relation_inverse_extension.l_U(relation_inverse_extension.re_T, relation_inverse_extension.g)"
    "equivalence[U]")))
 (rel_inv_extension_is_equivalence 0
  (rel_inv_extension_is_equivalence-1 nil 3572021945
   ("" (skolem!)
    (("" (expand "equivalence?")
      (("" (prop)
        (("1" (expand "reflexive?")
          (("1" (skolem!)
            (("1" (expand "rel_inv_extension")
              (("1" (prop)
                (("1" (expand "l_T")
                  (("1" (expand "image_inverse")
                    (("1" (typepred "re_U!1")
                      (("1" (expand "equivalence?")
                        (("1" (prop)
                          (("1" (expand "reflexive?") (("1" (inst?) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "l_U")
                  (("2" (expand "image_inverse")
                    (("2" (typepred "re_T!1")
                      (("2" (expand "equivalence?")
                        (("2" (prop)
                          (("2" (expand "reflexive?") (("2" (inst?) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "symmetric?")
          (("2" (skolem!)
            (("2" (flatten)
              (("2" (expand "rel_inv_extension")
                (("2" (prop)
                  (("1" (expand "l_T")
                    (("1" (expand "image_inverse")
                      (("1" (hide -2)
                        (("1" (typepred "re_U!1")
                          (("1" (expand "equivalence?")
                            (("1" (prop)
                              (("1" (expand "symmetric?")
                                (("1" (inst -2 "f!1(y!1`1)" "f!1(x!1`1)")
                                  (("1" (prop) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand "l_U")
                    (("2" (expand "image_inverse")
                      (("2" (hide -1)
                        (("2" (typepred "re_T!1")
                          (("2" (expand "equivalence?")
                            (("2" (prop)
                              (("2" (expand "symmetric?")
                                (("2" (inst -2 "g!1(y!1`2)" "g!1(x!1`2)")
                                  (("2" (prop) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (expand "transitive?")
          (("3" (skolem!)
            (("3" (prop)
              (("3" (expand "rel_inv_extension")
                (("3" (prop)
                  (("1" (expand "l_T")
                    (("1" (expand "image_inverse")
                      (("1" (hide -4 -2)
                        (("1" (typepred "re_U!1")
                          (("1" (expand "equivalence?")
                            (("1" (prop)
                              (("1" (hide -1 -2)
                                (("1" (expand "transitive?")
                                  (("1"
                                    (inst -1 "f!1(z!1`1)" "f!1(y!1`1)"
                                     "f!1(x!1`1)")
                                    (("1" (prop) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand "l_U")
                    (("2" (expand "image_inverse")
                      (("2" (hide -1 -3)
                        (("2" (typepred "re_T!1")
                          (("2" (expand "equivalence?")
                            (("2" (prop)
                              (("2" (hide -1 -2)
                                (("2" (expand "transitive?")
                                  (("2"
                                    (inst -1 "g!1(z!1`2)" "g!1(y!1`2)"
                                     "g!1(x!1`2)")
                                    (("2" (prop) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equivalence? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (symmetric? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (rel_inv_extension const-decl "set[[[T, U], [T, U]]]"
     relation_inverse_extension nil)
    (l_U const-decl "pred[[U, U]]" relation_inverse_extension nil)
    (l_T const-decl "pred[[T, T]]" relation_inverse_extension nil)
    (equivalence type-eq-decl nil relations nil)
    (PRED type-eq-decl nil defined_types nil)
    (U formal-nonempty-type-decl nil relation_inverse_extension nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-nonempty-type-decl nil relation_inverse_extension nil)
    (image_inverse const-decl "pred[[T, T]]" relation_inverse_image nil))
   nil
   (rel_inv_extension_is_equivalence subtype
    "relation_inverse_extension.rel_inv_extension(relation_inverse_extension.re_T, relation_inverse_extension.re_U, relation_inverse_extension.f, relation_inverse_extension.g)"
    "equivalence[[T, U]]")))
 (rel_extension_IFF_rel_ext 0
  (rel_extension_IFF_rel_ext-1 nil 3572022562
   ("" (assert) (("" (grind) nil nil)) nil)
   ((rel_inv_extension const-decl "set[[[T, U], [T, U]]]"
     relation_inverse_extension nil)
    (l_U const-decl "pred[[U, U]]" relation_inverse_extension nil)
    (image_inverse const-decl "pred[[T, T]]" relation_inverse_image nil)
    (l_T const-decl "pred[[T, T]]" relation_inverse_extension nil)
    (rel_extension const-decl "set[[[T, U], [T, U]]]" relation_extension nil)
    (T formal-nonempty-type-decl nil relation_inverse_extension nil)
    (U formal-nonempty-type-decl nil relation_inverse_extension nil)
    (reflexive? const-decl "bool" relations nil)
    (symmetric? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (equivalence type-eq-decl nil relations nil)
    (equivalence? const-decl "bool" relations nil)
    (PRED type-eq-decl nil defined_types nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (rel_inv_extension2_is_equivalence 0
  (rel_inv_extension2_is_equivalence-1 nil 3572023029
   ("" (skolem!)
    (("" (expand "equivalence?")
      (("" (prop)
        (("1" (expand "reflexive?")
          (("1" (skolem!)
            (("1" (expand "rel_inv_extension2")
              (("1" (expand "rel_extension")
                (("1" (prop)
                  (("1" (typepred "re_T!1")
                    (("1" (expand "equivalence?")
                      (("1" (prop)
                        (("1" (expand "reflexive?") (("1" (inst?) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (typepred "re_U!1")
                    (("2" (expand "equivalence?")
                      (("2" (prop)
                        (("2" (expand "reflexive?") (("2" (inst?) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "symmetric?")
          (("2" (skolem!)
            (("2" (prop)
              (("2" (expand "rel_inv_extension2")
                (("2" (expand "rel_extension")
                  (("2" (prop)
                    (("1" (hide -2)
                      (("1" (typepred "re_T!1")
                        (("1" (expand "equivalence?")
                          (("1" (prop)
                            (("1" (expand "symmetric?")
                              (("1" (inst -2 "g!1(y!1`2)" "g!1(x!1`2)")
                                (("1" (prop) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide -1)
                      (("2" (typepred "re_U!1")
                        (("2" (expand "equivalence?")
                          (("2" (prop)
                            (("2" (expand "symmetric?")
                              (("2" (inst -2 "f!1(y!1`1)" "f!1(x!1`1)")
                                (("2" (prop) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (expand "transitive?")
          (("3" (skolem!)
            (("3" (prop)
              (("3" (expand "rel_inv_extension2")
                (("3" (expand "rel_extension")
                  (("3" (prop)
                    (("1" (hide -2 -4)
                      (("1" (typepred "re_T!1")
                        (("1" (expand "equivalence?")
                          (("1" (prop)
                            (("1" (hide -1 -2)
                              (("1" (expand "transitive?")
                                (("1"
                                  (inst -1 "g!1(z!1`2)" "g!1(y!1`2)"
                                   "g!1(x!1`2)")
                                  (("1" (prop) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide -1 -3)
                      (("2" (typepred "re_U!1")
                        (("2" (expand "equivalence?")
                          (("2" (prop)
                            (("2" (hide -1 -2)
                              (("2" (expand "transitive?")
                                (("2"
                                  (inst -1 "f!1(z!1`1)" "f!1(y!1`1)"
                                   "f!1(x!1`1)")
                                  (("2" (prop) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equivalence? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (symmetric? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (rel_inv_extension2 const-decl "set[[[T, U], [T, U]]]"
     relation_inverse_extension nil)
    (U formal-nonempty-type-decl nil relation_inverse_extension nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-nonempty-type-decl nil relation_inverse_extension nil)
    (PRED type-eq-decl nil defined_types nil)
    (equivalence type-eq-decl nil relations nil)
    (rel_extension const-decl "set[[[T, U], [T, U]]]" relation_extension nil))
   nil
   (rel_inv_extension2_is_equivalence subtype
    "relation_inverse_extension.rel_inv_extension2(relation_inverse_extension.re_T, relation_inverse_extension.re_U, relation_inverse_extension.f, relation_inverse_extension.g)"
    "equivalence[[T, U]]"))))

