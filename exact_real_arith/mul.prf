(mul
 (D1 0
  (D1-1 nil 3250064094 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil))
   nil))
 (D2 0
  (D2-1 nil 3250064094 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (D3 0
  (D3-1 nil 3250064094 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (negreal_times_posreal_is_negreal 0
  (negreal_times_posreal_is_negreal-1 nil 3250064094
   ("" (skosimp*)
    (("" (lemma "neg_lt" ("x" "nx!1"))
      ((""
        (lemma "posreal_times_posreal_is_posreal" ("px" "py!1" "py" "-nx!1"))
        (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((negreal nonempty-type-eq-decl nil real_types nil)
    (< const-decl "bool" reals nil)
    (nonpos_real nonempty-type-eq-decl nil real_types nil)
    (<= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (neg_lt formula-decl nil real_props nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)
    (posreal_times_posreal_is_posreal judgement-tcc nil real_types nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil))
   nil))
 (lt_times_lt_nonneg1 0
  (lt_times_lt_nonneg1-1 nil 3250064094
   ("" (skosimp*)
    (("" (case "nnx!1=0")
      (("1" (replace -1)
        (("1"
          (lemma "both_sides_times_pos_lt2"
           ("pz" "x!1" "x" "nny!1" "y" "y!1"))
          (("1" (replace -1 -4 rl)
            (("1"
              (lemma "both_sides_times_pos_lt2"
               ("pz" "nny!1" "x" "0" "y" "x!1"))
              (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
            nil)
           ("2" (assert) nil nil))
          nil))
        nil)
       ("2" (case "0<nnx!1")
        (("1"
          (lemma "lt_times_lt_pos1"
           ("px" "nnx!1" "nnz" "nny!1" "y" "x!1" "w" "y!1"))
          (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (both_sides_times_pos_lt2 formula-decl nil real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (lt_times_lt_pos1 formula-decl nil real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (< const-decl "bool" reals nil))
   nil))
 (lt_times_lt_nonneg2 0
  (lt_times_lt_nonneg2-1 nil 3250064094
   ("" (skosimp*)
    (("" (typepred "nnx!1")
      (("" (expand ">=")
        (("" (expand "<=")
          (("" (split)
            (("1"
              (lemma "both_sides_times_neg_lt2"
               ("nz" "-1" "x" "x!1" "y" "nnx!1"))
              (("1"
                (lemma "lt_times_lt_neg1"
                 ("ny" "-1 * nnx!1" "x" "-1 * x!1" "z" "y!1" "npw" "npy!1"))
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
              nil)
             ("2" (replace -1 (-2 1) rl)
              (("2"
                (lemma "both_sides_times_pos_lt2"
                 ("pz" "x!1" "y" "npy!1" "x" "y!1"))
                (("1"
                  (lemma "negreal_times_posreal_is_negreal"
                   ("nx" "y!1" "py" "x!1"))
                  (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
                 ("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (<= const-decl "bool" reals nil)
    (negreal_times_posreal_is_negreal formula-decl nil mul nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (both_sides_times_pos_lt2 formula-decl nil real_props nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (negreal nonempty-type-eq-decl nil real_types nil)
    (< const-decl "bool" reals nil)
    (nonpos_real nonempty-type-eq-decl nil real_types nil)
    (both_sides_times_neg_lt2 formula-decl nil real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (lt_times_lt_neg1 formula-decl nil real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   nil))
 (D_pp 0
  (D_pp-1 nil 3250064094
   ("" (skosimp*)
    (("" (lemma "D3" ("x" "px!1" "n" "n!1"))
      (("" (lemma "D3" ("x" "py!1" "n" "m!1"))
        ((""
          (lemma "lt_times_lt_nonneg1"
           ("nnx" "px!1" "x" "1+n!1" "nny" "py!1" "y" "1+m!1"))
          (("" (grind)
            (("" (case "1<=n!1")
              (("1" (case "1<=m!1")
                (("1"
                  (lemma "lt_times_lt_nonneg1"
                   ("nnx" "n!1 - 1" "x" "px!1" "nny" "m!1 - 1" "y" "py!1"))
                  (("1" (assert) nil nil) ("2" (assert) nil nil)
                   ("3" (assert) nil nil))
                  nil)
                 ("2" (case "m!1=0")
                  (("1" (grind) nil nil)
                   ("2" (grind)
                    (("2" (expand "<=" -5) (("2" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (lemma "le_equiv_not_lt" ("x" "1" "y" "n!1"))
                (("2" (replace -1 1 lr)
                  (("2" (hide -1)
                    (("2" (rewrite "lt_equiv_le_plus_one")
                      (("2"
                        (lemma "both_sides_plus_le1"
                         ("x" "n!1" "y" "0" "z" "1"))
                        (("2" (replace -1 -2 lr)
                          (("2" (hide -1)
                            (("2" (lemma "total_le")
                              (("2" (expand "total_order?")
                                (("2" (expand "partial_order?")
                                  (("2" (expand "antisymmetric?")
                                    (("2" (flatten)
                                      (("2"
                                        (inst -2 "n!1" "0")
                                        (("2"
                                          (prop)
                                          (("2"
                                            (replace -1)
                                            (("2"
                                              (case "1<=m!1")
                                              (("1"
                                                (lemma
                                                 "lt_times_lt_nonneg1"
                                                 ("nnx"
                                                  "0"
                                                  "x"
                                                  "px!1"
                                                  "nny"
                                                  "m!1 - 1"
                                                  "y"
                                                  "py!1"))
                                                (("1" (grind) nil nil)
                                                 ("2" (assert) nil nil))
                                                nil)
                                               ("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil) (D3 formula-decl nil mul nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (lt_times_lt_nonneg1 formula-decl nil mul nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (lt_equiv_le_plus_one formula-decl nil prelude_aux nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers nil)
    (total_le formula-decl nil real_props nil)
    (partial_order? const-decl "bool" orders nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (antisymmetric? const-decl "bool" relations nil)
    (total_order? const-decl "bool" orders nil)
    (both_sides_plus_le1 formula-decl nil real_props nil)
    (le_equiv_not_lt formula-decl nil prelude_aux nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (D_pn 0
  (D_pn-1 nil 3250064094
   ("" (skosimp*)
    (("" (lemma "D_pp" ("px" "px!1" "n" "n!1" "py" "-ny!1" "m" "-m!1"))
      (("" (grind) nil nil)) nil))
    nil)
   ((negreal nonempty-type-eq-decl nil real_types nil)
    (< const-decl "bool" reals nil)
    (nonpos_real nonempty-type-eq-decl nil real_types nil)
    (<= const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (D_pp formula-decl nil mul nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil))
   nil))
 (D_nn 0
  (D_nn-1 nil 3250064094
   ("" (skosimp*)
    (("" (lemma "D_pp" ("px" "-nx!1" "n" "-n!1" "py" "-ny!1" "m" "-m!1"))
      (("" (grind) nil nil)) nil))
    nil)
   ((negreal nonempty-type-eq-decl nil real_types nil)
    (< const-decl "bool" reals nil)
    (nonpos_real nonempty-type-eq-decl nil real_types nil)
    (<= const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (D_pp formula-decl nil mul nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (negreal_times_negreal_is_posreal application-judgement "posreal"
     real_types nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil))
   nil))
 (D_p0 0
  (D_p0-1 nil 3250064094
   ("" (skosimp*)
    (("" (lemma "D1" ("x" "y!1" "n" "m!1"))
      (("" (lemma "D3" ("x" "px!1" "n" "n!1")) (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil) (D1 formula-decl nil mul nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (D3 formula-decl nil mul nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil))
   nil))
 (D_n0 0
  (D_n0-1 nil 3250064094
   ("" (skosimp*)
    (("" (lemma "D_p0" ("px" "-nx!1" "n" "-n!1" "y" "y!1" "m" "m!1"))
      (("" (grind) nil nil)) nil))
    nil)
   ((negreal nonempty-type-eq-decl nil real_types nil)
    (< const-decl "bool" reals nil)
    (nonpos_real nonempty-type-eq-decl nil real_types nil)
    (<= const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (D_p0 formula-decl nil mul nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil))
   nil))
 (D 0
  (D-1 nil 3250064094
   ("" (skosimp*)
    (("" (lemma "trich_lt" ("x" "x!1" "y" "0"))
      (("" (split)
        (("1" (lemma "trich_lt" ("x" "y!1" "y" "0"))
          (("1" (split)
            (("1" (lemma "D_nn" ("n" "n!1" "m" "m!1" "nx" "x!1" "ny" "y!1"))
              (("1" (grind) nil nil) ("2" (assert) nil nil)
               ("3" (assert) nil nil))
              nil)
             ("2" (lemma "D_n0" ("n" "n!1" "m" "m!1" "nx" "x!1" "y" "y!1"))
              (("1" (grind) nil nil) ("2" (assert) nil nil)) nil)
             ("3" (lemma "D_pn" ("m" "n!1" "n" "m!1" "ny" "x!1" "px" "y!1"))
              (("1" (grind) nil nil) ("2" (assert) nil nil)
               ("3" (assert) nil nil))
              nil))
            nil))
          nil)
         ("2" (lemma "trich_lt" ("x" "y!1" "y" "0"))
          (("2" (split)
            (("1" (lemma "D_n0" ("m" "n!1" "n" "m!1" "y" "x!1" "nx" "y!1"))
              (("1" (grind) nil nil) ("2" (assert) nil nil)) nil)
             ("2" (grind) nil nil)
             ("3" (lemma "D_p0" ("m" "n!1" "n" "m!1" "y" "x!1" "px" "y!1"))
              (("1" (grind) nil nil) ("2" (assert) nil nil)) nil))
            nil))
          nil)
         ("3" (lemma "trich_lt" ("x" "y!1" "y" "0"))
          (("3" (split)
            (("1" (lemma "D_pn" ("n" "n!1" "m" "m!1" "ny" "y!1" "px" "x!1"))
              (("1" (grind) nil nil) ("2" (assert) nil nil)
               ("3" (assert) nil nil))
              nil)
             ("2" (lemma "D_p0" ("n" "n!1" "m" "m!1" "y" "y!1" "px" "x!1"))
              (("1" (grind) nil nil) ("2" (assert) nil nil)) nil)
             ("3" (lemma "D_pp" ("n" "n!1" "m" "m!1" "py" "y!1" "px" "x!1"))
              (("1" (grind) nil nil) ("2" (assert) nil nil)
               ("3" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (trich_lt formula-decl nil real_props nil) (D_pp formula-decl nil mul nil)
    (D_p0 formula-decl nil mul nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil) (D_pn formula-decl nil mul nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (D_n0 formula-decl nil mul nil)
    (negreal nonempty-type-eq-decl nil real_types nil)
    (< const-decl "bool" reals nil)
    (nonpos_real nonempty-type-eq-decl nil real_types nil)
    (<= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (D_nn formula-decl nil mul nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil))
   nil))
 (mul_p1 0
  (mul_p1-1 nil 3250064094
   ("" (skosimp*)
    (("" (typepred "cx!1")
      (("" (expand "cauchy_real?")
        (("" (skolem!)
          (("" (expand "cauchy_prop")
            (("" (inst - "0")
              (("" (lemma "dich_le" ("x" "cx!1(0)" "y" "0"))
                (("" (name "r!1" "floor(log2(abs(cx!1(0))+2))")
                  (("" (replace -1)
                    ((""
                      (lemma "lemma_A3" ("i" "r!1" "px" "abs(cx!1(0)) + 2"))
                      (("" (replace -2)
                        (("" (simplify -1)
                          (("" (flatten)
                            (("" (split -4)
                              (("1" (lemma "abs_nonpos" ("npx" "cx!1(0)"))
                                (("1" (replace -1)
                                  (("1"
                                    (lemma "both_sides_plus1"
                                     ("x" "s!1-3" "y" "r!1" "z" "3"))
                                    (("1" (simplify -1)
                                      (("1"
                                        (replace -1 -9)
                                        (("1"
                                          (lemma
                                           "expt_plus"
                                           ("n0x" "2" "i" "s!1-2" "j" "-1"))
                                          (("1"
                                            (simplify -1)
                                            (("1"
                                              (replace -10 1)
                                              (("1"
                                                (replace -10 -6 rl)
                                                (("1"
                                                  (simplify -6)
                                                  (("1" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (propax) nil nil))
                                nil)
                               ("2" (lemma "abs_nonneg" ("nnx" "cx!1(0)"))
                                (("1"
                                  (lemma "lemma_A3"
                                   ("i" "r!1" "px" "abs(cx!1(0)) + 2"))
                                  (("1" (replace -6 -1)
                                    (("1" (replace -2)
                                      (("1"
                                        (simplify -1)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (lemma
                                             "both_sides_plus1"
                                             ("x" "s!1-3" "y" "r!1" "z" "3"))
                                            (("1"
                                              (replace -1 -11)
                                              (("1"
                                                (replace -11 -7 rl)
                                                (("1"
                                                  (replace -11 -6 rl)
                                                  (("1" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cauchy_real nonempty-type-eq-decl nil cauchy nil)
    (cauchy_real? const-decl "bool" cauchy nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (log2 const-decl "real" prelude_aux nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (integer nonempty-type-from-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (lemma_A3 formula-decl nil appendix nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (expt_plus formula-decl nil exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat" rationals
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (both_sides_plus1 formula-decl nil real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (npreal type-eq-decl nil real_types nil)
    (abs_nonpos formula-decl nil prelude_aux nil)
    (nnreal type-eq-decl nil real_types nil)
    (abs_nonneg formula-decl nil prelude_aux nil)
    (dich_le formula-decl nil real_props nil)
    (cauchy_prop const-decl "bool" cauchy nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil))
   nil))
 (mul_p2 0
  (mul_p2-1 nil 3250064094
   ("" (skosimp*)
    (("" (split)
      (("1" (typepred "cx!1")
        (("1" (expand "cauchy_real?")
          (("1" (skolem!)
            (("1" (expand "cauchy_prop")
              (("1" (inst-cp - "p!1")
                (("1" (inst - "0")
                  (("1" (expand "^" -1)
                    (("1" (expand "expt")
                      (("1" (flatten)
                        (("1" (lemma "trich_lt" ("x" "x!1" "y" "0"))
                          (("1" (split)
                            (("1" (lemma "expt_ge1" ("b" "2" "n" "p!1-1"))
                              (("1" (lemma "expt_ge1" ("b" "2" "n" "p!1"))
                                (("1"
                                  (lemma "expt_plus"
                                   ("n0x" "2" "i" "p!1-1" "j" "1"))
                                  (("1" (expand "^" -1 3)
                                    (("1" (expand "expt")
                                      (("1"
                                        (expand "expt")
                                        (("1"
                                          (expand ">=")
                                          (("1"
                                            (lemma
                                             "both_sides_times_pos_le1"
                                             ("x"
                                              "1"
                                              "y"
                                              "2 ^ (p!1 - 1)"
                                              "pz"
                                              "2"))
                                            (("1"
                                              (replace -4)
                                              (("1"
                                                (replace -2 -1 rl)
                                                (("1"
                                                  (simplify -1)
                                                  (("1"
                                                    (lemma "strict_lt")
                                                    (("1"
                                                      (expand
                                                       "strict_total_order?")
                                                      (("1"
                                                        (expand
                                                         "strict_order?")
                                                        (("1"
                                                          (expand
                                                           "transitive?")
                                                          (("1"
                                                            (flatten)
                                                            (("1"
                                                              (inst-cp
                                                               -
                                                               "cx!1(0) - 1"
                                                               "x!1"
                                                               "0")
                                                              (("1"
                                                                (lemma
                                                                 "both_sides_times_pos_lt1"
                                                                 ("x"
                                                                  "x!1"
                                                                  "y"
                                                                  "0"
                                                                  "pz"
                                                                  "2^p!1"))
                                                                (("1"
                                                                  (rewrite
                                                                   "zero_times1")
                                                                  (("1"
                                                                    (inst-cp
                                                                     -
                                                                     "cx!1(p!1) - 1"
                                                                     "x!1 * 2 ^ p!1"
                                                                     "0")
                                                                    (("1"
                                                                      (replace
                                                                       -11)
                                                                      (("1"
                                                                        (replace
                                                                         -14)
                                                                        (("1"
                                                                          (replace
                                                                           -12)
                                                                          (("1"
                                                                            (replace
                                                                             -1)
                                                                            (("1"
                                                                              (simplify)
                                                                              (("1"
                                                                                (rewrite
                                                                                 "lt_equiv_le_plus_one"
                                                                                 -4)
                                                                                (("1"
                                                                                  (rewrite
                                                                                   "lt_equiv_le_plus_one"
                                                                                   -5)
                                                                                  (("1"
                                                                                    (lemma
                                                                                     "abs_nonpos"
                                                                                     ("npx"
                                                                                      "cx!1(0)"))
                                                                                    (("1"
                                                                                      (lemma
                                                                                       "abs_nonpos"
                                                                                       ("npx"
                                                                                        "cx!1(p!1)"))
                                                                                      (("1"
                                                                                        (replace
                                                                                         -19)
                                                                                        (("1"
                                                                                          (replace
                                                                                           -1)
                                                                                          (("1"
                                                                                            (replace
                                                                                             -2)
                                                                                            (("1"
                                                                                              (lemma
                                                                                               "both_sides_times_neg_le1"
                                                                                               ("y"
                                                                                                "1 + -cx!1(p!1)"
                                                                                                "x"
                                                                                                "2 * 2 ^ p!1 + -cx!1(0) * 2 ^ p!1"
                                                                                                "nz"
                                                                                                "-1"))
                                                                                              (("1"
                                                                                                (replace
                                                                                                 -1
                                                                                                 1
                                                                                                 rl)
                                                                                                (("1"
                                                                                                  (simplify
                                                                                                   1)
                                                                                                  (("1"
                                                                                                    (simplify
                                                                                                     1)
                                                                                                    (("1"
                                                                                                      (lemma
                                                                                                       "both_sides_minus_lt1"
                                                                                                       ("x"
                                                                                                        "x!1 * 2 ^ p!1"
                                                                                                        "y"
                                                                                                        "1 + cx!1(p!1)"
                                                                                                        "z"
                                                                                                        "2"))
                                                                                                      (("1"
                                                                                                        (replace
                                                                                                         -1
                                                                                                         -19
                                                                                                         rl)
                                                                                                        (("1"
                                                                                                          (simplify
                                                                                                           -19)
                                                                                                          (("1"
                                                                                                            (lemma
                                                                                                             "both_sides_times_pos_lt1"
                                                                                                             ("x"
                                                                                                              "cx!1(0) - 1"
                                                                                                              "y"
                                                                                                              "x!1"
                                                                                                              "pz"
                                                                                                              "2^p!1"))
                                                                                                            (("1"
                                                                                                              (replace
                                                                                                               -1
                                                                                                               -17
                                                                                                               rl)
                                                                                                              (("1"
                                                                                                                (lemma
                                                                                                                 "lt_minus_lt2"
                                                                                                                 ("x"
                                                                                                                  "(cx!1(0) - 1) * 2 ^ p!1"
                                                                                                                  "y"
                                                                                                                  "x!1 * 2 ^ p!1"
                                                                                                                  "w"
                                                                                                                  "2"
                                                                                                                  "z"
                                                                                                                  "2 ^ p!1"))
                                                                                                                (("1"
                                                                                                                  (replace
                                                                                                                   -13)
                                                                                                                  (("1"
                                                                                                                    (replace
                                                                                                                     -18)
                                                                                                                    (("1"
                                                                                                                      (simplify
                                                                                                                       -1)
                                                                                                                      (("1"
                                                                                                                        (inst
                                                                                                                         -
                                                                                                                         "cx!1(0) * 2 ^ p!1 - 2 * 2 ^ p!1"
                                                                                                                         "x!1 * 2 ^ p!1 - 2"
                                                                                                                         "cx!1(p!1) - 1")
                                                                                                                        (("1"
                                                                                                                          (assert)
                                                                                                                          nil
                                                                                                                          nil))
                                                                                                                        nil))
                                                                                                                      nil))
                                                                                                                    nil))
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil)
                                                                                       ("2"
                                                                                        (propax)
                                                                                        nil
                                                                                        nil))
                                                                                      nil)
                                                                                     ("2"
                                                                                      (propax)
                                                                                      nil
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (assert) nil nil))
                              nil)
                             ("2" (replace -1)
                              (("2" (rewrite "lt_equiv_le_plus_one")
                                (("2" (rewrite "lt_plus_one_equiv_le")
                                  (("2" (rewrite "zero_times1")
                                    (("2" (rewrite "lt_equiv_le_plus_one")
                                      (("2"
                                        (rewrite "lt_plus_one_equiv_le")
                                        (("2"
                                          (lemma "total_le")
                                          (("2"
                                            (expand "total_order?")
                                            (("2"
                                              (expand "partial_order?")
                                              (("2"
                                                (expand "antisymmetric?")
                                                (("2"
                                                  (flatten)
                                                  (("2"
                                                    (inst-cp - "cx!1(0)" "0")
                                                    (("2"
                                                      (inst - "cx!1(p!1)" "0")
                                                      (("2"
                                                        (replace -6)
                                                        (("2"
                                                          (replace -7)
                                                          (("2"
                                                            (replace -8)
                                                            (("2"
                                                              (replace -9)
                                                              (("2"
                                                                (simplify)
                                                                (("2"
                                                                  (replace -2)
                                                                  (("2"
                                                                    (replace
                                                                     -3)
                                                                    (("2"
                                                                      (replace
                                                                       -11)
                                                                      (("2"
                                                                        (expand
                                                                         "abs")
                                                                        (("2"
                                                                          (lemma
                                                                           "expt_ge1"
                                                                           ("b"
                                                                            "2"
                                                                            "n"
                                                                            "p!1"))
                                                                          (("2"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("3" (lemma "expt_ge1" ("b" "2" "n" "p!1"))
                              (("3" (lemma "strict_lt")
                                (("3" (expand "strict_total_order?")
                                  (("3" (expand "strict_order?")
                                    (("3" (expand "transitive?")
                                      (("3"
                                        (flatten)
                                        (("3"
                                          (inst-cp - "0" "x!1" "1 + cx!1(0)")
                                          (("3"
                                            (lemma
                                             "both_sides_times_pos_lt1"
                                             ("x" "0" "y" "x!1" "pz" "2^p!1"))
                                            (("3"
                                              (replace -7)
                                              (("3"
                                                (rewrite "zero_times1")
                                                (("3"
                                                  (simplify -1)
                                                  (("3"
                                                    (inst-cp
                                                     -
                                                     "0"
                                                     "x!1 * 2 ^ p!1"
                                                     "1 + cx!1(p!1)")
                                                    (("3"
                                                      (replace -1)
                                                      (("3"
                                                        (replace -12)
                                                        (("3"
                                                          (replace -10)
                                                          (("3"
                                                            (simplify)
                                                            (("3"
                                                              (rewrite
                                                               "lt_plus_one_equiv_le")
                                                              (("3"
                                                                (rewrite
                                                                 "lt_plus_one_equiv_le")
                                                                (("3"
                                                                  (lemma
                                                                   "abs_nonneg"
                                                                   ("nnx"
                                                                    "cx!1(0)"))
                                                                  (("1"
                                                                    (lemma
                                                                     "abs_nonneg"
                                                                     ("nnx"
                                                                      "cx!1(p!1)"))
                                                                    (("1"
                                                                      (replace
                                                                       -16)
                                                                      (("1"
                                                                        (replace
                                                                         -1)
                                                                        (("1"
                                                                          (replace
                                                                           -2)
                                                                          (("1"
                                                                            (lemma
                                                                             "both_sides_plus_lt1"
                                                                             ("x"
                                                                              "cx!1(p!1) - 1"
                                                                              "y"
                                                                              "x!1* 2 ^ p!1"
                                                                              "z"
                                                                              "2"))
                                                                            (("1"
                                                                              (replace
                                                                               -1
                                                                               -14
                                                                               rl)
                                                                              (("1"
                                                                                (simplify
                                                                                 -14)
                                                                                (("1"
                                                                                  (lemma
                                                                                   "expt_ge1"
                                                                                   ("b"
                                                                                    "2"
                                                                                    "n"
                                                                                    "p!1-1"))
                                                                                  (("1"
                                                                                    (lemma
                                                                                     "both_sides_times_pos_lt1"
                                                                                     ("x"
                                                                                      "x!1"
                                                                                      "y"
                                                                                      "1 + cx!1(0)"
                                                                                      "pz"
                                                                                      "2^p!1"))
                                                                                    (("1"
                                                                                      (replace
                                                                                       -15
                                                                                       -1)
                                                                                      (("1"
                                                                                        (simplify
                                                                                         -1)
                                                                                        (("1"
                                                                                          (lemma
                                                                                           "expt_plus"
                                                                                           ("n0x"
                                                                                            "2"
                                                                                            "i"
                                                                                            "p!1-1"
                                                                                            "j"
                                                                                            "1"))
                                                                                          (("1"
                                                                                            (expand
                                                                                             "^"
                                                                                             -1
                                                                                             3)
                                                                                            (("1"
                                                                                              (expand
                                                                                               "expt")
                                                                                              (("1"
                                                                                                (expand
                                                                                                 "expt")
                                                                                                (("1"
                                                                                                  (lemma
                                                                                                   "both_sides_times_pos_ge1"
                                                                                                   ("x"
                                                                                                    "2 ^ (p!1 - 1)"
                                                                                                    "y"
                                                                                                    "1"
                                                                                                    "pz"
                                                                                                    "2"))
                                                                                                  (("1"
                                                                                                    (replace
                                                                                                     -1
                                                                                                     -4
                                                                                                     rl)
                                                                                                    (("1"
                                                                                                      (replace
                                                                                                       -2
                                                                                                       -4
                                                                                                       rl)
                                                                                                      (("1"
                                                                                                        (simplify
                                                                                                         -4)
                                                                                                        (("1"
                                                                                                          (expand
                                                                                                           ">=")
                                                                                                          (("1"
                                                                                                            (lemma
                                                                                                             "lt_plus_lt1"
                                                                                                             ("x"
                                                                                                              "2"
                                                                                                              "y"
                                                                                                              "2 ^ p!1"
                                                                                                              "z"
                                                                                                              "x!1 * 2 ^ p!1"
                                                                                                              "w"
                                                                                                              "2 ^ p!1 + cx!1(0) * 2 ^ p!1"))
                                                                                                            (("1"
                                                                                                              (replace
                                                                                                               -5)
                                                                                                              (("1"
                                                                                                                (replace
                                                                                                                 -4)
                                                                                                                (("1"
                                                                                                                  (assert)
                                                                                                                  nil
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil)
                                                                                   ("2"
                                                                                    (assert)
                                                                                    nil
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (lemma "expt_plus" ("n0x" "2" "i" "p!1" "j" "s!1-2"))
        (("2" (replace -1)
          (("2" (lemma "mul_p1" ("s" "s!1" "cx" "cx!1"))
            (("2" (replace -3 -1 rl)
              (("2" (simplify -1)
                (("2" (flatten)
                  (("2" (lemma "expt_ge1" ("b" "2" "n" "s!1-3"))
                    (("1"
                      (lemma "both_sides_times_pos_lt1"
                       ("x" "2 + abs(cx!1(0))" "y" "2 ^ (s!1 - 2)" "pz"
                        "2 ^ p!1"))
                      (("1" (replace -1 1) (("1" (propax) nil nil)) nil)) nil)
                     ("2" (assert)
                      (("2" (hide-all-but (-4 1))
                        (("2" (lemma "int_abs_is_nonneg" ("i" "cx!1(0)"))
                          (("2" (flatten -1)
                            (("2" (expand ">=")
                              (("2" (expand "<=" -2)
                                (("2" (split -2)
                                  (("1" (lemma "log2_strict_increasing")
                                    (("1" (expand "strict_increasing?")
                                      (("1"
                                        (inst - "2" "2 + abs(cx!1(0))")
                                        (("1"
                                          (expand "log2" -1 1)
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (replace -1 * rl)
                                    (("2" (expand "log2")
                                      (("2"
                                        (rewrite "div_simp")
                                        (("2"
                                          (rewrite "floor_int")
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_exp application-judgement "posint" exponentiation nil)
    (cauchy_prop const-decl "bool" cauchy nil)
    (expt def-decl "real" exponentiation nil)
    (trich_lt formula-decl nil real_props nil)
    (abs_nonneg formula-decl nil prelude_aux nil)
    (nnreal type-eq-decl nil real_types nil)
    (both_sides_times_pos_ge1 formula-decl nil real_props nil)
    (lt_plus_lt1 formula-decl nil real_props nil)
    (abs_nat formula-decl nil abs_lems reals)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (both_sides_plus_lt1 formula-decl nil real_props nil)
    (lt_plus_one_equiv_le formula-decl nil prelude_aux nil)
    (total_le formula-decl nil real_props nil)
    (partial_order? const-decl "bool" orders nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (antisymmetric? const-decl "bool" relations nil)
    (total_order? const-decl "bool" orders nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (expt_ge1 formula-decl nil exponentiation nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (expt_plus formula-decl nil exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_times_even_is_even application-judgement "even_int" integers nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (strict_total_order? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (zero_times1 formula-decl nil real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat" rationals
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (both_sides_times_neg_le1 formula-decl nil real_props nil)
    (nonpos_real nonempty-type-eq-decl nil real_types nil)
    (< const-decl "bool" reals nil)
    (negreal nonempty-type-eq-decl nil real_types nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (both_sides_minus_lt1 formula-decl nil real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (lt_minus_lt2 formula-decl nil real_props nil)
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (npreal type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil)
    (abs_nonpos formula-decl nil prelude_aux nil)
    (lt_equiv_le_plus_one formula-decl nil prelude_aux nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (both_sides_times_pos_lt1 formula-decl nil real_props nil)
    (strict_order? const-decl "bool" orders nil)
    (strict_lt formula-decl nil real_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (both_sides_times_pos_le1 formula-decl nil real_props nil)
    (^ const-decl "real" exponentiation nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (cauchy_real? const-decl "bool" cauchy nil)
    (cauchy_real nonempty-type-eq-decl nil cauchy nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (int_abs_is_nonneg judgement-tcc nil real_defs nil)
    (strict_increasing? const-decl "bool" real_fun_preds reals)
    (log2 const-decl "real" prelude_aux nil)
    (log2_strict_increasing formula-decl nil prelude_aux nil)
    (integer nonempty-type-from-decl nil integers nil)
    (floor_int formula-decl nil floor_ceil nil)
    (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers nil)
    (div_simp formula-decl nil real_props nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (ln const-decl "real" ln_exp lnexp)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (mul_p1 formula-decl nil mul nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil))
   nil))
 (mul_p3 0
  (mul_p3-1 nil 3250064094
   ("" (skosimp*)
    (("" (lemma "mul_p2" ("s" "s!1" "n" "cx!1(p!1)" "p" "p!1" "cx" "cx!1"))
      (("" (replace -2 -1 rl)
        (("" (replace -3 -1)
          (("" (assert)
            (("" (flatten)
              ((""
                (lemma "lt_le_transitivity"
                 ("x" "1 + abs(cx!1(p!1))" "y"
                  "2 * 2 ^ p!1 + abs(cx!1(0)) * 2 ^ p!1" "z"
                  "2 ^ (p!1 - 2 + s!1)"))
                (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cauchy_real nonempty-type-eq-decl nil cauchy nil)
    (cauchy_real? const-decl "bool" cauchy nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (mul_p2 formula-decl nil mul nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (lt_le_transitivity formula-decl nil prelude_aux nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil))
   nil))
 (mul_p4 0
  (mul_p4-1 nil 3250064094
   ("" (skosimp*)
    (("" (name "r!1" "floor(log2(abs(cx!1(0)) + 2))")
      (("" (name "r!2" "floor(log2(abs(cy!1(0)) + 2))")
        (("" (replace -1)
          (("" (replace -2)
            (("" (lemma "mul_p3" ("s" "s1!1" "cx" "cx!1" "p" "p!1+s2!1"))
              (("" (lemma "mul_p3" ("s" "s2!1" "cx" "cy!1" "p" "p!1+s1!1"))
                (("" (case "r!1>=0")
                  (("1" (case "r!2>=0")
                    (("1" (assert)
                      (("1"
                        (lemma "le_plus_le"
                         ("x" "1 + abs(cy!1(p!1 + s1!1))" "y"
                          "2 ^ (p!1 - 2 + s1!1 + s2!1)" "z"
                          "1 + abs(cx!1(p!1 + s2!1))" "w"
                          "2 ^ (p!1 - 2 + s1!1 + s2!1)"))
                        (("1"
                          (lemma "expt_plus"
                           ("n0x" "2" "i" "p!1 - 2 + s1!1 + s2!1" "j" "1"))
                          (("1" (rewrite "expt_x1") (("1" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide-all-but (1 -4))
                      (("2" (lemma "log2_strict_increasing")
                        (("2" (expand "strict_increasing?")
                          (("2" (lemma "int_abs_is_nonneg" ("i" "cy!1(0)"))
                            (("2" (flatten)
                              (("2" (inst - "1" "2+abs(cy!1(0))")
                                (("2" (expand "log2" -4 1)
                                  (("2" (rewrite "ln_1")
                                    (("2" (assert) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide-all-but (1 -4))
                    (("2" (lemma "log2_strict_increasing")
                      (("2" (expand "strict_increasing?")
                        (("2" (lemma "int_abs_is_nonneg" ("i" "cx!1(0)"))
                          (("2" (flatten)
                            (("2" (inst - "1" "2+abs(cx!1(0))")
                              (("2" (expand "log2" -4 1)
                                (("2" (rewrite "ln_1")
                                  (("2" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cauchy_real nonempty-type-eq-decl nil cauchy nil)
    (cauchy_real? const-decl "bool" cauchy nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (log2 const-decl "real" prelude_aux nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (integer nonempty-type-from-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (real nonempty-type-from-decl nil reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (mul_p3 formula-decl nil mul nil)
    (strict_increasing? const-decl "bool" real_fun_preds reals)
    (ln_1 formula-decl nil ln_exp lnexp)
    (int_abs_is_nonneg judgement-tcc nil real_defs nil)
    (log2_strict_increasing formula-decl nil prelude_aux nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (expt_plus formula-decl nil exponentiation nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat" rationals
     nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (expt_x1 formula-decl nil exponentiation nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (le_plus_le formula-decl nil real_props nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil))
   nil))
 (mul_p5 0
  (mul_p5-1 nil 3250064094
   ("" (skosimp*)
    ((""
      (lemma "mul_p4"
       ("cx" "cx!1" "cy" "cy!1" "s1" "s1!1" "s2" "s2!1" "p" "p!1"))
      (("" (assert)
        (("" (replace -4 -1 rl)
          (("" (replace -5 -1 rl)
            ((""
              (lemma "both_sides_times_neg_lt1"
               ("y" "1 + abs(n1!1) + abs(n2!1)" "x"
                "2 ^ (p!1 - 1 + s1!1 + s2!1)" "nz" "-1"))
              (("" (replace -2 -1)
                (("" (split)
                  (("1"
                    (lemma "lemma_A2"
                     ("r" "r!1" "p" "n1!1 * n2!1" "q"
                      "2 ^ (p!1 + s1!1 + s2!1)"))
                    (("1" (replace -8 -1 rl)
                      (("1" (simplify -1)
                        (("1" (flatten)
                          (("1" (hide-all-but (-1 -3 1))
                            (("1"
                              (lemma "expt_plus"
                               ("n0x" "2" "i" "p!1 + s1!1 + s2!1" "j" "-1"))
                              (("1" (expand "^" -1 3)
                                (("1" (expand "expt")
                                  (("1" (expand "expt")
                                    (("1" (replace -1 -2 rl)
                                      (("1"
                                        (lemma
                                         "lt_plus_lt1"
                                         ("x"
                                          "2 ^ (p!1 + s1!1 + s2!1) * r!1 - 2 ^ (p!1 - 1 + s1!1 + s2!1)"
                                          "y"
                                          "n1!1 * n2!1"
                                          "z"
                                          "2 ^ (p!1 - 1 + s1!1 + s2!1) * -1"
                                          "w"
                                          "(1 + abs(n1!1) + abs(n2!1)) * -1"))
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2"
                      (lemma "lemma_A2"
                       ("r" "r!1" "p" "n1!1 * n2!1" "q"
                        "2 ^ (p!1 + s1!1 + s2!1)"))
                      (("2" (replace -8 -1 rl)
                        (("2" (simplify -1)
                          (("2" (flatten)
                            (("2"
                              (lemma "expt_plus"
                               ("n0x" "2" "i" "p!1 + s1!1 + s2!1" "j" "-1"))
                              (("2" (expand "^" -1 3)
                                (("2" (expand "expt")
                                  (("2" (expand "expt")
                                    (("2" (replace -1 -3 rl)
                                      (("2"
                                        (hide-all-but (1 -3 -5))
                                        (("2"
                                          (lemma
                                           "lt_plus_lt1"
                                           ("x"
                                            "n1!1 * n2!1"
                                            "y"
                                            "2 ^ (p!1 - 1 + s1!1 + s2!1) + 2 ^ (p!1 + s1!1 + s2!1) * r!1"
                                            "z"
                                            "1 + abs(n1!1) + abs(n2!1)"
                                            "w"
                                            "2 ^ (p!1 - 1 + s1!1 + s2!1)"))
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cauchy_real nonempty-type-eq-decl nil cauchy nil)
    (cauchy_real? const-decl "bool" cauchy nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (mul_p4 formula-decl nil mul nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (negreal nonempty-type-eq-decl nil real_types nil)
    (< const-decl "bool" reals nil)
    (nonpos_real nonempty-type-eq-decl nil real_types nil)
    (<= const-decl "bool" reals nil)
    (both_sides_times_neg_lt1 formula-decl nil real_props nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (rat_plus_rat_is_rat application-judgement "rat" rationals nil)
    (expt_plus formula-decl nil exponentiation nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (expt def-decl "real" exponentiation nil)
    (lt_plus_lt1 formula-decl nil real_props nil)
    (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat" rationals
     nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (lemma_A2 formula-decl nil appendix nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers nil)
    (even_plus_even_is_even application-judgement "even_int" integers nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil))
   nil))
 (mul_p6 0
  (mul_p6-1 nil 3250064094
   ("" (skosimp*)
    (("" (expand "cauchy_prop")
      (("" (inst -6 "p!1+s2!1")
        (("" (inst -7 "p!1+s1!1")
          (("" (replace -3 -6 rl)
            (("" (replace -4 -7 rl)
              (("" (flatten)
                ((""
                  (lemma "mul_p5"
                   ("s1" "s1!1" "s2" "s2!1" "cx" "cx!1" "cy" "cy!1" "p" "p!1"
                    "r" "r!1" "n1" "n1!1" "n2" "n2!1"))
                  (("" (assert)
                    (("" (flatten)
                      ((""
                        (lemma "D"
                         ("n" "n1!1" "x" "x!1* 2 ^ (p!1 + s2!1)" "m" "n2!1"
                          "y" "y!1* 2 ^ (p!1 + s1!1)"))
                        (("" (assert)
                          (("" (flatten)
                            ((""
                              (lemma "lt_le_transitivity"
                               ("x"
                                "2 ^ (p!1 + s1!1 + s2!1) * r!1 - 2 ^ (p!1 + s1!1 + s2!1)"
                                "y" "-1 - abs(n1!1) - abs(n2!1) + n1!1 * n2!1"
                                "z"
                                "2 ^ (p!1 + s1!1) * 2 ^ (p!1 + s2!1) * x!1 * y!1"))
                              (("" (replace -2 -1)
                                (("" (replace -4 -1)
                                  (("" (simplify -1)
                                    ((""
                                      (lemma
                                       "expt_plus"
                                       ("n0x"
                                        "2"
                                        "i"
                                        "p!1 + s1!1"
                                        "j"
                                        "p!1 + s2!1"))
                                      ((""
                                        (simplify -1)
                                        ((""
                                          (lemma
                                           "expt_plus"
                                           ("n0x"
                                            "2"
                                            "i"
                                            "p!1 + s1!1 + s2!1"
                                            "j"
                                            "p!1"))
                                          ((""
                                            (simplify -1)
                                            ((""
                                              (replace -1 -2 lr)
                                              ((""
                                                (lemma "strict_lt")
                                                ((""
                                                  (expand
                                                   "strict_total_order?")
                                                  ((""
                                                    (expand "strict_order?")
                                                    ((""
                                                      (expand "transitive?")
                                                      ((""
                                                        (flatten)
                                                        ((""
                                                          (lemma
                                                           "le_lt_transitivity"
                                                           ("x"
                                                            "2^ (p!1 + s1!1) * 2 ^ (p!1 + s2!1) * x!1 * y!1"
                                                            "y"
                                                            "1 + abs(n1!1) + abs(n2!1) + n1!1 * n2!1"
                                                            "z"
                                                            "2 ^ (p!1 + s1!1 + s2!1) + 2 ^ (p!1 + s1!1 + s2!1) * r!1"))
                                                          ((""
                                                            (lemma
                                                             "expt_ge1"
                                                             ("b"
                                                              "2"
                                                              "n"
                                                              "p!1 + s1!1 + s2!1"))
                                                            ((""
                                                              (lemma
                                                               "both_sides_times_pos_lt1"
                                                               ("x"
                                                                "r!1 - 1"
                                                                "y"
                                                                "x!1 * y!1 * 2 ^ p!1"
                                                                "pz"
                                                                "2 ^ (p!1 + s1!1 + s2!1)"))
                                                              ((""
                                                                (lemma
                                                                 "both_sides_times_pos_lt1"
                                                                 ("y"
                                                                  "r!1 + 1"
                                                                  "x"
                                                                  "x!1 * y!1 * 2 ^ p!1"
                                                                  "pz"
                                                                  "2 ^ (p!1 + s1!1 + s2!1)"))
                                                                ((""
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_exp application-judgement "posint" exponentiation nil)
    (cauchy_prop const-decl "bool" cauchy nil)
    (mul_p5 formula-decl nil mul nil)
    (cauchy_real? const-decl "bool" cauchy nil)
    (cauchy_real nonempty-type-eq-decl nil cauchy nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (lt_le_transitivity formula-decl nil prelude_aux nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (expt_plus formula-decl nil exponentiation nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (strict_total_order? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (le_lt_transitivity formula-decl nil prelude_aux nil)
    (both_sides_times_pos_lt1 formula-decl nil real_props nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (expt_ge1 formula-decl nil exponentiation nil)
    (strict_order? const-decl "bool" orders nil)
    (strict_lt formula-decl nil real_props nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (D formula-decl nil mul nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil))
   nil))
 (cauchy_mul_type_TCC1 0
  (cauchy_mul_type_TCC1-1 nil 3287383145
   ("" (skosimp*)
    (("" (lemma "int_abs_is_nonneg" ("i" "cy!1(0)"))
      (("" (flatten)
        (("" (expand ">=")
          (("" (expand "<=" -2)
            (("" (split -2)
              (("1" (lemma "log2_strict_increasing")
                (("1" (expand "strict_increasing?")
                  (("1" (inst - "2" "2+abs(cy!1(0))")
                    (("1" (expand "log2" -1 1)
                      (("1" (rewrite "div_simp") (("1" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (replace -1 * rl)
                (("2" (expand "log2" 1)
                  (("2" (rewrite "div_simp")
                    (("2" (rewrite "floor_int") (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cauchy_real nonempty-type-eq-decl nil cauchy nil)
    (cauchy_real? const-decl "bool" cauchy nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_abs_is_nonneg judgement-tcc nil real_defs nil)
    (strict_increasing? const-decl "bool" real_fun_preds reals)
    (log2 const-decl "real" prelude_aux nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (div_simp formula-decl nil real_props nil)
    (/= const-decl "boolean" notequal nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (ln const-decl "real" ln_exp lnexp)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (log2_strict_increasing formula-decl nil prelude_aux nil)
    (integer nonempty-type-from-decl nil integers nil)
    (floor_int formula-decl nil floor_ceil nil)
    (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (<= const-decl "bool" reals nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil))
   shostak
   (cauchy_mul_type subtype
    "(number_fields.+)(mul.p, ((number_fields.+)(floor_ceil.floor(prelude_aux.log2((number_fields.+)(real_defs.abs(mul.cy(0)), 2))), 3)))"
    "nat")))
 (cauchy_mul_type 0
  (cauchy_mul_type-1 nil 3250064094
   ("" (skosimp*)
    (("" (typepred "cx!1" "cy!1")
      (("" (expand "cauchy_real?")
        (("" (skosimp*)
          (("" (inst + "x!1*x!2")
            (("" (expand "cauchy_prop" 1)
              (("" (skosimp*)
                ((""
                  (lemma "mul_p6"
                   ("s1" "floor(log2(abs(cx!1(0))+2))+3" "s2"
                    "floor(log2(abs(cy!1(0))+2))+3" "n1"
                    "cx!1(p!1+floor(log2(abs(cy!1(0))+2))+3)" "n2"
                    "cy!1(p!1+floor(log2(abs(cx!1(0))+2))+3)" "p" "p!1" "r"
                    "round((cx!1(3 + p!1 + floor(log2(2 + abs(cy!1(0))))) *
                 cy!1(3 + p!1 + floor(log2(2 + abs(cx!1(0))))))
                /
                2 ^
                 (6 + p!1 + floor(log2(2 + abs(cx!1(0)))) +
                   floor(log2(2 + abs(cy!1(0))))))" "x" "x!1" "y" "x!2" "cx"
                    "cx!1" "cy" "cy!1"))
                  (("1" (assert) nil nil)
                   ("2" (hide-all-but 1)
                    (("2" (lemma "int_abs_is_nonneg" ("i" "cy!1(0)"))
                      (("2" (flatten)
                        (("2" (lemma "log2_strict_increasing")
                          (("2" (expand "strict_increasing?")
                            (("2" (inst - "1" "2 + abs(cy!1(0))")
                              (("2" (expand "log2" -1 1)
                                (("2" (rewrite "ln_1")
                                  (("2" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (hide-all-but 1)
                    (("3" (lemma "int_abs_is_nonneg" ("i" "cx!1(0)"))
                      (("3" (flatten)
                        (("3" (lemma "log2_strict_increasing")
                          (("3" (expand "strict_increasing?")
                            (("3" (inst - "1" "2 + abs(cx!1(0))")
                              (("3" (expand "log2" -1 1)
                                (("3" (rewrite "ln_1")
                                  (("3" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("4" (hide-all-but 1)
                    (("4" (lemma "int_abs_is_nonneg" ("i" "cx!1(0)"))
                      (("4" (flatten)
                        (("4" (lemma "log2_strict_increasing")
                          (("4" (expand "strict_increasing?")
                            (("4" (inst - "1" "2 + abs(cx!1(0))")
                              (("4" (expand "log2" -1 1)
                                (("4" (rewrite "ln_1")
                                  (("4" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("5" (hide-all-but 1)
                    (("5" (lemma "int_abs_is_nonneg" ("i" "cy!1(0)"))
                      (("5" (flatten)
                        (("5" (lemma "log2_strict_increasing")
                          (("5" (expand "strict_increasing?")
                            (("5" (inst - "1" "2 + abs(cy!1(0))")
                              (("5" (expand "log2" -1 1)
                                (("5" (rewrite "ln_1")
                                  (("5" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("6" (hide-all-but 1)
                    (("6" (lemma "int_abs_is_nonneg" ("i" "cx!1(0)"))
                      (("6" (flatten)
                        (("6" (lemma "log2_strict_increasing")
                          (("6" (expand "strict_increasing?")
                            (("6" (inst - "1" "2 + abs(cx!1(0))")
                              (("6" (expand "log2" -1 1)
                                (("6" (rewrite "ln_1")
                                  (("6" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("7" (hide-all-but 1)
                    (("7" (lemma "int_abs_is_nonneg" ("i" "cy!1(0)"))
                      (("7" (flatten)
                        (("7" (lemma "log2_strict_increasing")
                          (("7" (expand "strict_increasing?")
                            (("7" (inst - "1" "2 + abs(cy!1(0))")
                              (("7" (expand "log2" -1 1)
                                (("7" (rewrite "ln_1")
                                  (("7" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cauchy_real nonempty-type-eq-decl nil cauchy nil)
    (cauchy_real? const-decl "bool" cauchy nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (cauchy_prop const-decl "bool" cauchy nil)
    (^ const-decl "real" exponentiation nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (round const-decl "int" prelude_aux nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (log2 const-decl "real" prelude_aux nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil)
    (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (integer nonempty-type-from-decl nil integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (mul_p6 formula-decl nil mul nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_abs_is_nonneg judgement-tcc nil real_defs nil)
    (log2_strict_increasing formula-decl nil prelude_aux nil)
    (ln_1 formula-decl nil ln_exp lnexp)
    (strict_increasing? const-decl "bool" real_fun_preds reals)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil))
   nil))
 (cauchy_mul_TCC1 0
  (cauchy_mul_TCC1-1 nil 3250064094
   ("" (skosimp)
    (("" (lemma "cauchy_mul_type" ("cx" "c1!1" "cy" "c2!1"))
      (("" (rewrite "floor_log2_def")
        (("" (rewrite "floor_log2_def") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((cauchy_real nonempty-type-eq-decl nil cauchy nil)
    (cauchy_real? const-decl "bool" cauchy nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (cauchy_mul_type formula-decl nil mul nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (floor_log2_def formula-decl nil appendix nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil))
   nil
   (cauchy_mul subtype
    "(LAMBDA p: LET s1 = (number_fields.+)(appendix.floor_log2((number_fields.+)(real_defs.abs(mul.c1(0)), 2)), 3), s2 = (number_fields.+)(appendix.floor_log2((number_fields.+)(real_defs.abs(mul.c2(0)), 2)), 3) IN prelude_aux.round(number_fields./((number_fields.*(mul.c1((number_fields.+)(mul.p, mul.s2)), mul.c2((number_fields.+)(mul.p, mul.s1)))), exponentiation.^(2, ((number_fields.+)((number_fields.+)(mul.p, mul.s1), mul.s2))))))"
    "cauchy_real")))
 (mul_lemma 0
  (mul_lemma-1 nil 3250064094
   ("" (skosimp*)
    (("" (expand "cauchy_mul")
      (("" (expand "cauchy_prop" 1)
        (("" (skosimp*)
          ((""
            (lemma "mul_p6"
             ("s1" "floor(log2(abs(cx!1(0))+2))+3" "s2"
              "floor(log2(abs(cy!1(0))+2))+3" "n1"
              "cx!1(p!1+floor(log2(abs(cy!1(0))+2))+3)" "n2"
              "cy!1(p!1+floor(log2(abs(cx!1(0))+2))+3)" "p" "p!1" "r"
              "round((cx!1(3 + p!1 + floor(log2(2 + abs(cy!1(0))))) *
                 cy!1(3 + p!1 + floor(log2(2 + abs(cx!1(0))))))
                /
                2 ^
                 (6 + p!1 + floor(log2(2 + abs(cx!1(0)))) +
                   floor(log2(2 + abs(cy!1(0))))))" "x" "x!1" "y" "y!1" "cx"
              "cx!1" "cy" "cy!1"))
            (("1" (assert)
              (("1" (rewrite "floor_log2_def")
                (("1" (rewrite "floor_log2_def") nil nil)) nil))
              nil)
             ("2" (hide -1 -2 2)
              (("2" (lemma "int_abs_is_nonneg" ("i" "cy!1(0)"))
                (("2" (flatten)
                  (("2" (lemma "log2_strict_increasing")
                    (("2" (expand "strict_increasing?")
                      (("2" (inst - "1" "2 + abs(cy!1(0))")
                        (("2" (expand "log2" -1 1)
                          (("2" (rewrite "ln_1") (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (hide-all-but 1)
              (("3" (lemma "int_abs_is_nonneg" ("i" "cx!1(0)"))
                (("3" (flatten)
                  (("3" (lemma "log2_strict_increasing")
                    (("3" (expand "strict_increasing?")
                      (("3" (inst - "1" "2 + abs(cx!1(0))")
                        (("3" (expand "log2" -1 1)
                          (("3" (rewrite "ln_1") (("3" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("4" (hide-all-but 1)
              (("4" (lemma "log2_strict_increasing")
                (("4" (expand "strict_increasing?")
                  (("4" (lemma "int_abs_is_nonneg" ("i" "cx!1(0)"))
                    (("4" (flatten)
                      (("4" (inst - "1" "2 + abs(cx!1(0))")
                        (("4" (expand "log2" -4 1)
                          (("4" (rewrite "ln_1") (("4" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("5" (hide-all-but 1)
              (("5" (lemma "int_abs_is_nonneg" ("i" "cy!1(0)"))
                (("5" (flatten)
                  (("5" (lemma "log2_strict_increasing")
                    (("5" (expand "strict_increasing?")
                      (("5" (inst - "1" "2 + abs(cy!1(0))")
                        (("5" (expand "log2" -1 1)
                          (("5" (rewrite "ln_1") (("5" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("6" (hide-all-but 1)
              (("6" (lemma "int_abs_is_nonneg" ("i" "cx!1(0)"))
                (("6" (flatten)
                  (("6" (lemma "log2_strict_increasing")
                    (("6" (expand "strict_increasing?")
                      (("6" (inst - "1" "2 + abs(cx!1(0))")
                        (("6" (expand "log2" -1 1)
                          (("6" (rewrite "ln_1") (("6" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("7" (hide-all-but 1)
              (("7" (lemma "int_abs_is_nonneg" ("i" "cy!1(0)"))
                (("7" (flatten)
                  (("7" (lemma "log2_strict_increasing")
                    (("7" (expand "strict_increasing?")
                      (("7" (inst - "1" "2 + abs(cy!1(0))")
                        (("7" (expand "log2" -1 1)
                          (("7" (rewrite "ln_1") (("7" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (cauchy_mul const-decl "cauchy_real" mul nil)
    (strict_increasing? const-decl "bool" real_fun_preds reals)
    (ln_1 formula-decl nil ln_exp lnexp)
    (log2_strict_increasing formula-decl nil prelude_aux nil)
    (int_abs_is_nonneg judgement-tcc nil real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (floor_log2_def formula-decl nil appendix nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (mul_p6 formula-decl nil mul nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (cauchy_real? const-decl "bool" cauchy nil)
    (cauchy_real nonempty-type-eq-decl nil cauchy nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (integer nonempty-type-from-decl nil integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (log2 const-decl "real" prelude_aux nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (round const-decl "int" prelude_aux nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (^ const-decl "real" exponentiation nil)
    (cauchy_prop const-decl "bool" cauchy nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil))
   nil)))

