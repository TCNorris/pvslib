(int
 (cauchy_int_TCC1 0
  (cauchy_int_TCC1-1 nil 3287600938 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (^ const-decl "real" exponentiation nil)
    (cauchy_prop const-decl "bool" cauchy nil)
    (cauchy_real? const-decl "bool" cauchy nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (int_times_int_is_int application-judgement "int" integers nil))
   nil
   (cauchy_int subtype
    "(LAMBDA p: number_fields.*(int.n, exponentiation.^(2, int.p)))"
    "cauchy_real")))
 (cauchy_nat_TCC1 0
  (cauchy_nat_TCC1-1 nil 3287600939
   ("" (expand "cauchy_nnreal?")
    (("" (skosimp*)
      (("" (inst + "n!1")
        (("" (expand "cauchy_prop") (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (cauchy_prop const-decl "bool" cauchy nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (cauchy_nnreal? const-decl "bool" cauchy nil)
    (posint_exp application-judgement "posint" exponentiation nil))
   shostak
   (cauchy_nat subtype
    "(LAMBDA p: number_fields.*(int.n, exponentiation.^(2, int.p)))"
    "cauchy_nnreal")))
 (int_lemma 0
  (int_lemma-1 nil 3287600938 ("" (grind) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (cauchy_int const-decl "cauchy_real" int nil)
    (cauchy_prop const-decl "bool" cauchy nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (posnat_expt application-judgement "posnat" exponentiation nil))
   nil))
 (nat_lemma 0
  (nat_lemma-1 nil 3287601015
   ("" (expand "cauchy_prop")
    (("" (skosimp*) (("" (expand "cauchy_nat") (("" (propax) nil nil)) nil))
      nil))
    nil)
   ((cauchy_nat const-decl "cauchy_nnreal" int nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (cauchy_prop const-decl "bool" cauchy nil)
    (posint_exp application-judgement "posint" exponentiation nil))
   shostak)))

