(modulo
 (cauchy_mod_TCC1 0
  (cauchy_mod_TCC1-1 nil 3674987581 ("" (subtype-tcc) nil nil)
   ((cauchy_nzreal nonempty-type-eq-decl nil cauchy nil)
    (cauchy_nzreal? const-decl "bool" cauchy nil)
    (cauchy_real nonempty-type-eq-decl nil cauchy nil)
    (cauchy_real? const-decl "bool" cauchy nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cauchy_prop const-decl "bool" cauchy nil)
    (cauchy_noninteger? const-decl "bool" floor nil)
    (divides const-decl "bool" divides nil)
    (cauchy_mul const-decl "cauchy_real" mul nil)
    (cauchy_nz_inv const-decl "cauchy_nzreal" inv nil)
    (round const-decl "int" prelude_aux nil)
    (minimum_inv_impl const-decl "nat" inv nil)
    (^ const-decl "real" exponentiation nil)
    (cauchy_div const-decl "cauchy_real" div nil)
    (cauchy_inv const-decl "cauchy_nzreal" inv nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (even_plus_even_is_even application-judgement "even_int" integers
     nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (posnat_expt application-judgement "posnat" exponentiation nil))
   nil))
 (mod_lemma_TCC1 0
  (mod_lemma_TCC1-1 nil 3674987581
   ("" (skeep)
    (("" (typepred "y")
      (("" (expand "cauchy_nzreal?") (("" (inst 1 "y") nil nil)) nil))
      nil))
    nil)
   ((nzreal nonempty-type-eq-decl nil reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (/= const-decl "boolean" notequal nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cauchy_nzreal? const-decl "bool" cauchy nil))
   nil))
 (mod_lemma 0
  (mod_lemma-1 nil 3674989306
   ("" (skeep)
    (("" (expand "cauchy_mod")
      (("" (expand "mod")
        (("" (lemma "sub_lemma")
          ((""
            (inst -1 "cx"
             "cauchy_mul(cy, cauchy_floor(cauchy_div(cx, cy)))" "x"
             "y * floor(x / y)")
            (("" (split)
              (("1" (propax) nil nil) ("2" (propax) nil nil)
               ("3" (hide 2)
                (("3" (lemma "mul_lemma")
                  (("3"
                    (inst -1 "cy" "cauchy_floor(cauchy_div(cx, cy))"
                     "y" "floor(x / y)")
                    (("3" (split)
                      (("1" (propax) nil nil) ("2" (propax) nil nil)
                       ("3" (hide 2)
                        (("3" (lemma "floor_lemma")
                          (("3" (inst -1 "cauchy_div(cx, cy)" "x / y")
                            (("3" (split)
                              (("1" (propax) nil nil)
                               ("2"
                                (hide 2)
                                (("2"
                                  (lemma "div_lemma")
                                  (("2"
                                    (inst -1 "cx" "cy" "y" "x")
                                    (("2"
                                      (split)
                                      (("1" (propax) nil nil)
                                       ("2" (propax) nil nil)
                                       ("3" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cauchy_mod const-decl "cauchy_real" modulo nil)
    (sub_lemma formula-decl nil sub nil)
    (mul_lemma formula-decl nil mul nil)
    (floor_lemma formula-decl nil floor nil)
    (div_lemma formula-decl nil div nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (integer nonempty-type-from-decl nil integers nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (cauchy_div const-decl "cauchy_real" div nil)
    (cauchy_nzreal nonempty-type-eq-decl nil cauchy nil)
    (cauchy_nzreal? const-decl "bool" cauchy nil)
    (cauchy_floor const-decl
     "{cx: cauchy_real | EXISTS i: cx = cauchy_int(i)}" floor nil)
    (cauchy_int const-decl "cauchy_real" int nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cauchy_noninteger nonempty-type-eq-decl nil floor nil)
    (cauchy_noninteger? const-decl "bool" floor nil)
    (cauchy_mul const-decl "cauchy_real" mul nil)
    (cauchy_real nonempty-type-eq-decl nil cauchy nil)
    (cauchy_real? const-decl "bool" cauchy nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (mod const-decl "{k | abs(k) < abs(j)}" reals_mod "reals/")
    (real_times_real_is_real application-judgement "real" reals nil))
   shostak)))

