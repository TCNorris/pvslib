(computable_rat
 (cauchy_rat_TCC1 0
  (cauchy_rat_TCC1-1 nil 3674477879 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (minus_rat_is_rat application-judgement "rat" rationals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil (cauchy_rat subtype "(number_fields.-)(computable_rat.r)" "posrat")))
 (cauchy_rat_TCC2 0
  (cauchy_rat_TCC2-1 nil 3674481796
   ("" (skeep)
    (("" (hide 1)
      (("" (skolem! +)
        (("" (flatten)
          (("" (typepred "prp!1`den")
            (("" (assert)
              (("" (expand "cauchy_nzreal?")
                (("" (inst 1 "prp!1`den")
                  (("" (assert)
                    (("" (lemma "int_lemma")
                      (("" (assert) (("" (inst -1 "prp!1`den") nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((minus_rat_is_rat application-judgement "rat" rationals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (int_lemma formula-decl nil int nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (cauchy_nzreal? const-decl "bool" cauchy nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (PosRatPair type-eq-decl nil clear_denominators Sturm)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_rat nonempty-type-eq-decl nil rationals nil)
    (posrat nonempty-type-eq-decl nil rationals nil)
    (posratpair_convert const-decl "posrat" clear_denominators Sturm)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (rat nonempty-type-eq-decl nil rationals nil))
   nil
   (cauchy_rat subtype "int.cauchy_int(computable_rat.prp`den)"
    "cauchy_nzreal")))
 (cauchy_rat_TCC3 0
  (cauchy_rat_TCC3-1 nil 3674481796 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil (cauchy_rat subtype "computable_rat.r" "posrat")))
 (cauchy_rat_TCC4 0
  (cauchy_rat_TCC4-1 nil 3674481796
   ("" (skeep)
    (("" (skolem! +)
      (("" (flatten)
        (("" (expand "cauchy_nzreal?")
          (("" (inst + "prp!1`den")
            (("" (lemma "int_lemma") (("" (inst - "prp!1`den") nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cauchy_nzreal? const-decl "bool" cauchy nil)
    (int_lemma formula-decl nil int nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (posratpair_convert const-decl "posrat" clear_denominators Sturm)
    (posrat nonempty-type-eq-decl nil rationals nil)
    (> const-decl "bool" reals nil)
    (nonneg_rat nonempty-type-eq-decl nil rationals nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PosRatPair type-eq-decl nil clear_denominators Sturm)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil
   (cauchy_rat subtype "int.cauchy_int(computable_rat.prp`den)"
    "cauchy_nzreal")))
 (negative_numerator_TCC1 0
  (negative_numerator_TCC1-1 nil 3674486012 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (minus_rat_is_rat application-judgement "rat" rationals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (negative_numerator subtype "(number_fields.-)(computable_rat.r)"
    "posrat")))
 (negative_numerator 0
  (negative_numerator-1 nil 3674486014
   ("" (skeep)
    (("" (typepred "compute_posratpair(-r)")
      (("1" (expand "posratpair_convert") (("1" (assert) nil nil)) nil)
       ("2" (assert) nil nil))
      nil))
    nil)
   ((rat nonempty-type-eq-decl nil rationals nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (compute_posratpair def-decl "{prp | posratpair_convert(prp) = x}"
     clear_denominators Sturm)
    (posratpair_convert const-decl "posrat" clear_denominators Sturm)
    (posrat nonempty-type-eq-decl nil rationals nil)
    (> const-decl "bool" reals nil)
    (nonneg_rat nonempty-type-eq-decl nil rationals nil)
    (>= const-decl "bool" reals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (PosRatPair type-eq-decl nil clear_denominators Sturm)
    (posnat nonempty-type-eq-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (minus_rat_is_rat application-judgement "rat" rationals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals
     nil))
   shostak))
 (rat_lemma 0
  (rat_lemma-1 nil 3674478089
   ("" (skeep)
    (("" (expand "cauchy_rat")
      (("" (lemma "div_lemma")
        (("" (lemma "int_lemma")
          (("" (typepred "compute_posratpair(r)")
            (("1" (expand "posratpair_convert")
              (("1" (assert)
                (("1" (inst-cp -2 "compute_posratpair(r)`num")
                  (("1" (inst -2 "compute_posratpair(r)`den")
                    (("1"
                      (inst -4 "cauchy_int(compute_posratpair(r)`num)"
                       "cauchy_int(compute_posratpair(r)`den)"
                       "compute_posratpair(r)`den"
                       "compute_posratpair(r)`num")
                      (("1" (split)
                        (("1" (rewrite -2) nil nil) ("2" (propax) nil nil)
                         ("3" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (case "r < 0")
              (("1" (assert)
                (("1" (hide 1)
                  (("1" (lemma "negative_numerator")
                    (("1" (inst -1 "r")
                      (("1" (rewrite -2)
                        (("1"
                          (inst -3 "cauchy_int(-compute_posratpair(-r)`num)"
                           "cauchy_int(compute_posratpair(-r)`den)"
                           "compute_posratpair(-r)`den"
                           "-compute_posratpair(-r)`num")
                          (("1" (split)
                            (("1" (rewrite -2) nil nil)
                             ("2" (inst -2 "-compute_posratpair(-r)`num") nil
                              nil)
                             ("3" (inst -2 "compute_posratpair(-r)`den") nil
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (assert) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cauchy_rat const-decl "cauchy_real" computable_rat nil)
    (int_lemma formula-decl nil int nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (negative_numerator formula-decl nil computable_rat nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_rat_is_rat application-judgement "rat" rationals nil)
    (cauchy_zero const-decl "cauchy_nnreal" cauchy nil)
    (^ const-decl "real" exponentiation nil)
    (cauchy_prop const-decl "bool" cauchy nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (cauchy_real? const-decl "bool" cauchy nil)
    (cauchy_real nonempty-type-eq-decl nil cauchy nil)
    (cauchy_int const-decl "cauchy_real" int nil)
    (cauchy_nzreal? const-decl "bool" cauchy nil)
    (cauchy_nzreal nonempty-type-eq-decl nil cauchy nil)
    (/= const-decl "boolean" notequal nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (PosRatPair type-eq-decl nil clear_denominators Sturm)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_rat nonempty-type-eq-decl nil rationals nil)
    (> const-decl "bool" reals nil)
    (posrat nonempty-type-eq-decl nil rationals nil)
    (posratpair_convert const-decl "posrat" clear_denominators Sturm)
    (compute_posratpair def-decl "{prp | posratpair_convert(prp) = x}"
     clear_denominators Sturm)
    (rat nonempty-type-eq-decl nil rationals nil)
    (div_lemma formula-decl nil div nil))
   shostak)))

