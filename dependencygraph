#!/usr/bin/env perl
# Script for generating a library dependency graph (requires dot) 
# Based on code written by George Hagen (NASA)

use Getopt::Long;
use File::Basename;
use Cwd;

# use lib(lib);
use Graph;
use Graph::Writer::Dot;

$usageln = "Usage: $0 [--help] [<option> ...] [<file>]";

sub usage() {
  print <<EOF;
$0 -- generates a library dependency graph for <file>.

This script builds a dot graph of library dependencies. 

$usageln

File <file> is an ordered list of libraries to be processed by proveit. 

The available options (<option>) are shown below.

 OUPUT

  --dot                    generate a dot file. Do not generate PDF unless --pdf is specified
  --pdf                    generate a pdf file (default)
  --title=<string>         use <string> as the title of the graph
  --out=<outfile>          use <outfile> as name of the output file

 SCOPE the scope of the visited libraries can be controlled with the following options

  --do=<dir1>,..,<dirn>    process libraries <dir1>,...,<dirn> 
  --but=<dir1>,..,<dirn>   do not process libraries <dir1>,...,<dirn>
  --after=<dir>            process all libraries after <dir>, exclusive
  --from=<dir>             process all libraries from <dir>, inclusive
  --before=<dir>           process all libraries before <dir>, exclusive
  --to=<dir>               process all libraries to <dir>, inclusive
  --reach-from=<lib>@<th>  print (only) every reachable theory from <lib@th>. 
  --closure=[lib|theory]   automatically grows the scope in order to 
                           - (lib) include every library reachable from theories in it.
                           - (theory) zoom into those theories.

 FINE-GRAINED CONTROL

  --top=<topfile>          specify name of the top file directory (default: "top")
  --zoom=<dir1>,...,<dirn> zoom into libraries <dir1>,...,<dirn>

 VISUALIZATION

  --full-path              print library full paths 
  --show-top               show top file in the graph (not shown by default)
  --splines=<mode>         control the way in which edges are drawn ('spline' by default)
                           For details, see Vizgraph documentation.

 EXTRAS

  --force                  regenerate .dep files
  --help                   print this message

DESCRIPTION

If <file> is not provided, the file name all-theories is assumed.

If <outfile> is not specified, <file><postfix> is used. The <postfix> depends 
on library selection option, i.e., --do,--but,--from,--to,--after,--before,--zoom.
$0 depends on Graphviz's dot utility to produce a pdf output.

Particular developments in <file> can be selected using the options: --do,
--after, --before, --from, --to. The option --but unselect a list of developments.

When the option --zoom is used, the specified developments are zoomed such 
that the each theory in those developments in represented by a node in the 
dependency graph.

The --reach-from=<lib>@<th> option allows to print only the theories which are 
reachable from <lib>@<th>. Note, also, that <lib> will be added to the visible 
scope if not already part of it. Additionally, DEPENDENCYGRAPH will zoom into 
<lib> as if it were mentioned in the --zoom option. Theories from other libraries 
are explicitly mentioned in the resulting graph only if they belong to a zoomed 
library, otherwise only the referenced library is mentioned.


EOF
  exit;
}

sub deslash($)
{
  my $string = shift;
  $string =~ s|/||g;
  return $string;
}

sub trim($)
{
  my $string = shift;
  $string =~ s/^\s+//;
  $string =~ s/\s+$//;
  return $string;
}

my $graph = Graph->new; 

sub library_label {
  my ($string,$short) = @_;
  if ($short || ! $fullpath){
    $string =~ s/^\/.*\/([^\/]+)$/$1/;
  }
  return $string;
}

sub collection_label($){
  my $lib = shift;
  my $result = $lib;
  $result =~ s/^\/.*\/([^\/]+)\/[^\/]+$/$1/;
  if (! $result) {
    $result = getcwd; # it's a local library.
    $result =~ s/^\/.*\/([^\/]+)$/$1/ if ! $fullpath;
  }
  return $result;
}

sub unqualify_library_name($) {
  my $lib = shift;
  if ( $lib =~/^.+\/([^\/]+)$/ ) {
    return $1;
  } else {
    return $lib;
  }
}

sub add_theory_vertex {
  my ($lib,$thy) = @_;

  my $node_id = $lib."@".$thy;

  $graph->set_vertex_attribute($node_id,'label',$thy);
  $graph->set_vertex_attribute($node_id,'group',$lib);
  $graph->set_vertex_attribute($node_id,'style','filled');
  $graph->set_vertex_attribute($node_id,'fillcolor','#e6f3ff');

  return ($node_id eq $reach_from);
}

sub add_library_vertex {
  my ($lib) = @_;

  $graph->set_vertex_attribute($lib,'label',library_label($lib,true));
  $graph->set_vertex_attribute($lib,'group',collection_label($lib));
  $graph->set_vertex_attribute($lib,'style','filled');
  $graph->set_vertex_attribute($lib,'fillcolor','#fcfcd7');
  $graph->set_vertex_attribute($lib,'shape','box');
}

sub add_edge {
  my ($libsrc,$thysrc,$libtgt,$thytgt) = @_;
  my $reach_from_theory_found=add_theory_vertex($libsrc,$thysrc);

  my $uname = unqualify_library_name($libtgt);
  if (grep(/^$uname$/,@zoomlist)) {
    $reach_from_theory_found = add_theory_vertex($libtgt,$thytgt) || $reach_from_theory_found;
    $graph->add_edge($libsrc."@".$thysrc,$libtgt."@".$thytgt);
  } else {
    add_library_vertex($libtgt);
    $graph->add_edge($libsrc."@".$thysrc,$libtgt);
  }

  return $reach_from_theory_found;
}

sub add_libraries_edge {
  my ($libsrc,$libtgt) = @_;
  add_library_vertex($libsrc);
  add_library_vertex($libtgt);
  $graph->add_edge($libsrc,$libtgt);
}

# Every vertex in the TARGET graph receive the attributes
# that it holds in the SOURCE graph.
#
sub transfer_vertex_attributes {
  my ($tgt,$src) = @_;

  foreach $tgtv ($tgt->vertices) {
    my $srcatt = $src->get_vertex_attributes($tgtv);
    $tgt->set_vertex_attributes($tgtv,$srcatt);
  }
}

#
# -- Main 
#

GetOptions('dot'=>\$dot,
	   'pdf'=>\$pdf,
	   'out=s'=>\$out,
	   'title=s'=>\$title,
           'after=s'=>\$after,
           'before=s'=>\$before,
	   'but=s'=>\@but,
	   'do=s'=>\@do,
	   'zoom=s'=>\@zoom,
           'from=s'=>\$from,
	   'help'=>\$help,
	   'top=s'=>\$top,
           'to=s'=>\$to,
	   'force'=>\$force,
	   'full-path'=>\$fullpath,
	   'show-top'=>\$showtop,
	   'reach-from=s'=>\$reach_from,
	   'splines=s'=>\$splines,
	   'closure=s'=>\$closure) or exit 1;

die("Error: unkonwn value for splines: $splines.\n") if $splines && ($splines ne "ortho")  && ($splines ne "none") && ($splines ne "line") && ($splines ne "false") && ($splines ne "polyline") && ($splines ne "curved") && ($splines ne "spline") && ($splines ne "true");

$splines="spline" if !$splines;

$after = deslash($after);
$before = deslash($before);
$to = deslash($to);
$from = deslash($from);
$do = deslash(join(',',@do));
$but = deslash(join(',',@but));
$zoom = deslash(join(',',@zoom));
my ($reach_from_library,$reach_from_theory) = split(/@/,$reach_from) if $reach_from;

# my $reach_from_checked = 0;

usage if $help;

$file = shift;
if (!$file) {
    $file = 'all-theories';
} elsif ( ! -f $file ) {
  die 'File $file not found';
}
die "$usageln\n" if shift; 

@butlist = split /,/,$but;
@dolist = split /,/,$do;
@zoomlist = split /,/,$zoom;

die "$file is a directory\n" if -d $file;
open (INFILE,$file) || die "File $file doesn't exist\n";

# Compute graph name and output file name.
#
my $graphName;
if ($out) {
  my ($base,$path,$type) = fileparse($out,qr{\..*});
  $graphName=$base;
  if ($type eq ".pdf") {
    $pdf = 1;
    $dot = 0;
  } elsif ($type eq ".dot") {
    $dot = 1;
    $pdf = 0;
  }
} else {
  my ($base,$path,$type) = fileparse($file,qr{\..*});  
  $graphName = "$base";
  my $dol = join('_',@dolist);
  $graphName .= "-$dol" if $dol;
  my $butl = join('_',@butlist);
  $graphName .= "-but_$butl" if $butl;
  $graphName .= "-from_$from" if $from;
  $graphName .= "-to_$to" if $to;
  $graphName .= "-after_$after" if $after;
  $graphName .= "-below_$below" if $below;
  my $zooml = join('_',@zoomlist);
  $graphName .= "-zoom_$zooml" if $zooml;
  $graphName .= "-top_$top" if $top;
  $graphName .= "-rf_$reach_from" if $reach_from;
  $graphName .= "-closure_$closure" if $closure;
  $graphName .= "-fullpath" if $fullpath;
}
$graphName =~ s/@/AT/g;

$out = $path . $graphName;

# Process input file (all-theories by default)
#
my $all = !($from || $after || @dolist || @zoomlist);
my @all_libs;
while (<INFILE>) {
  $line = $_;
  $line =~ s/\#.*$//;
  $line = trim($line);
  if ($line) {
    @listline = split /:/,$line;
    $lib = trim($listline[0]);
    push(@all_libs,$lib);
    if ($lib && -d $lib) {
      push(@nasalib,$lib);
      if ($lib eq $from) {
	$all = 1;
      } elsif ($lib eq $before) {
	$all = 0;
      }
      if (!grep(/^$lib$/,@butlist) && 
	  ($all || grep(/^$lib$/,@dolist) || grep(/^$lib$/,@zoomlist))) { 
	push(@targets,$lib);
      }
      if ($lib eq $after) {
	$all = 1;
      } elsif ($lib eq $to) {
	$all = 0;
      }
      # $reach_from_checked = ($lib eq $reach_from_library) || $reach_from_checked if $reach_from;
    } elsif ($lib) {
      die "Directory $lib not found\n";
    }
  }
}
close(INFILE);

# die("ERROR in --reach-from option value: library '$reach_from_library' is not visible.\n(HINT: Doublecheck spelling and values for --do, --from, --to, --but options.)\n")
#  if $reach_from && !$reach_from_checked;
if ($reach_from) {
  push(@targets, $reach_from_library) if !grep(/^$reach_from_library$/,@targets);
  push(@zoomlist, $reach_from_library) if !grep(/^$reach_from_library$/,@zoomlist);
}

die "Nothing to generate\n" if !@targets;

if ($top) {
  $topfile = $top;
} else {
  $topfile = "top";
}

my @libraries=@targets;

while (@libraries) {
  $lib = pop(@libraries);
  
  push(@nodes,$lib);

  if ($force || ! -f "$lib/pvsbin/$topfile.dep" ) {
    if ($force) {
      print "Generating $lib/pvsbin/$topfile.dep... ";
    } elsif (! -f "$lib/pvsbin/$topfile.dep") {
      print "File $lib/pvsbin/$topfile.dep not found. Generating it... ";
    }
    my $prove_it_result = `proveit -T -i -q --dependencies $lib/$topfile`;      
    die("Error: could not generate dep file (reported error: $!)\n")
      if !defined($prove_it_result);
    print "done.\n";
  }

  my $fullyQualifiedLibName = getcwd."/".$lib;
  my $librarylabel = library_label($fullyQualifiedLibName);

  my $reach_from_theory_found=0;
  if (-f "$lib/pvsbin/$topfile.dep") {
    open(FILE,"$lib/pvsbin/$topfile.dep");
    $zoom = grep(/^$lib$/,@zoomlist);
    while($line = <FILE>) {
      if ($zoom) {
	if ($line =~/(.+):(.*)/ && ($showtop || $1 ne "$topfile")) {
	  
	  add_theory_vertex($librarylabel,$1);
	  
	  if ($2) {
	    my $lib=$fullyQualifiedLibName;
	    my $from=$1;
	    my $tos=$2;
	    @tolist = split /,/,$tos;
	    foreach $to (@tolist) {
	      if ($to =~/^(.*\/)([^\/]+)\/([^\/]+)$/) { # if it has a slash, it is a fully qualified name

		my $uname = unqualify_library_name($1.$2);
		if ($closure) {
		  if (!grep(/^$uname$/,@libraries) && !grep(/^$uname$/,@libraries) && grep(/^$uname$/,@all_libs)) {
		    push(@libraries, $uname);
		    if ($closure eq "theory" && !grep(/^$uname$/,@zoomlist)) {
		      push(@zoomlist, $uname);
		    }
		  } 
		}

		$reach_from_theory_found = add_edge(library_label($lib),$from,$1.$2,$3) || $reach_from_theory_found;
	      } else {
		$reach_from_theory_found = add_edge(library_label($lib),$from,library_label($lib),$to) || $reach_from_theory_found;
	      }
	      # print "\n";
	    }
	  }
	}
      } elsif ($line =~/(.+)\/$/) {
	# omit path-only library entry in the dep file
      } elsif ($line =~/(.+)\/$lib\/([^\/]+)$/) {
	# omit own library entry
      } elsif ($line =~/^(\/.+)\//) {
	my $uname = unqualify_library_name($1);
	if ($closure) {
	  if (!grep(/^$uname$/,@libraries) && !grep(/^$uname$/,@libraries) && grep(/^$uname$/,@all_libs)) {
	    push(@libraries, $uname);
	    push(@zoomlist, $uname) if ($closure eq "theory") && !grep(/^$uname$/,@zoomlist);
	  } 
	}
	add_libraries_edge($fullyQualifiedLibName,$1);
      }
    } 
    close FILE;
  } else {
    die "File $lib/pvsbin/$topfile.dep not found\n";
  }
  die("ERROR in --reach-from option value: theory '$reach_from' is not visible.\n".
      "(HINT: Doublecheck spelling and values for --do, --from, --to, --but options.)\n")
    if ($reach_from && ($lib eq $reach_from_library) && !$reach_from_theory_found);

}

# Add graphs attributes
$graph->set_graph_attribute('name',"\"$graphName\"");
$graph->set_graph_attribute('rankdir','LR');
$graph->set_graph_attribute('splines',$splines);
$graph->set_graph_attribute('concentrate',true);

# Print dot file
#
my $writer = Graph::Writer::Dot->new(cluster => 'group');
if ($reach_from) {
  # Compute Shortest Path Tree from $reach_from node.
  my @reachables = $graph->all_successors($reach_from);
  push(@reachables, $reach_from);
  my $tree = $graph->subgraph(\@reachables);
  # Copy attributes
  $tree->set_graph_attributes($graph->get_graph_attributes());  
  transfer_vertex_attributes($tree,$graph);
  # Write graph
  $writer->write_graph($tree, "$out.dot");
} else {
  $writer->write_graph($graph, "$out.dot");
}
print "File $out.dot has been generated\n" if $dot;

# Print pdf file
#
if (!$dot || $pdf) {
  die "To produce $out.pdf, install Graphviz and add it to PATH\n" if !`which dot`;
  my $dotresult = `dot -Tpdf $out.dot -o $out.pdf`;
  die("Error: could not generate dot file (reported error: $!)\n")
    if !defined($dotresult);
  print "File $out.pdf has been generated\n";
} 

# Clean
#
`rm $out.dot` if !$dot;
