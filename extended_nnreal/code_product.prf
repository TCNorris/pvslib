(code_product
 (double_index_n_TCC1 0
  (double_index_n_TCC1-1 nil 3397569382
   ("" (skosimp)
    (("" (name-replace "N" "i!1 + j!1")
      (("" (case-replace "1 + i!1 + j!1=1+N")
        (("1" (hide -1)
          (("1" (case "even?(N)")
            (("1" (expand "even?")
              (("1" (skosimp)
                (("1" (replace -1)
                  (("1" (assert)
                    (("1"
                      (lemma "div_cancel1" ("x" "2*(j!2*j!2)+j!2" "n0z" "2"))
                      (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (rewrite "even_or_odd")
              (("2" (expand "odd?")
                (("2" (skosimp)
                  (("2" (replace -1)
                    (("2" (assert)
                      (("2"
                        (lemma "div_cancel1"
                         ("x" "1+3*j!2+2*j!2*j!2" "n0z" "2"))
                        (("2" (replace -1) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (assert) (("2" (expand "N") (("2" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (nnrat_plus_nnrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (N skolem-const-decl "nonneg_int" code_product nil)
    (even_or_odd formula-decl nil naturalnumbers nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers nil)
    (int_times_even_is_even application-judgement "even_int" integers nil)
    (odd? const-decl "bool" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (div_cancel1 formula-decl nil real_props nil)
    (/= const-decl "boolean" notequal nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (rat_plus_rat_is_rat application-judgement "rat" rationals nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (even_plus_even_is_even application-judgement "even_int" integers nil)
    (even? const-decl "bool" integers nil)
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers nil))
   nil
   (double_index_n subtype
    "(number_fields.+)(number_fields./((number_fields.*(((number_fields.+)(code_product.i, code_product.j)), ((number_fields.+)((number_fields.+)(1, code_product.i), code_product.j)))), 2), code_product.j)"
    "nat")))
 (double_index_triangle_TCC1 0
  (double_index_triangle_TCC1-1 nil 3397625108
   ("" (expand "singleton?")
    (("" (skosimp)
      (("" (name "II" "floor(sqrt(2*n!1))")
        (("" (typepred "floor(sqrt(2 * n!1))")
          (("" (replace -4)
            (("" (lemma "sq_le" ("nna" "II" "nnb" "sqrt(2 * n!1)"))
              (("" (assert)
                (("" (lemma "sq_lt" ("nna" "sqrt(2 * n!1)" "nnb" "1 + II"))
                  (("" (assert)
                    (("" (hide -3 -4)
                      (("" (case "II+II*II<= 2*n!1")
                        (("1" (inst + "II")
                          (("1" (skosimp)
                            (("1" (lemma "trich_lt" ("x" "II" "y" "y!1"))
                              (("1" (split -1)
                                (("1"
                                  (lemma "sq_le" ("nna" "II+1" "nnb" "y!1"))
                                  (("1" (assert)
                                    (("1" (typepred "y!1")
                                      (("1"
                                        (expand "sq")
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (propax) nil nil)
                                 ("3"
                                  (lemma "sq_le" ("nnb" "II" "nna" "y!1+1"))
                                  (("3" (typepred "y!1")
                                    (("3" (expand "sq")
                                      (("3" (assert) nil nil)) nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert)
                            (("2" (expand "sq") (("2" (assert) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (case "2*n!1<II + II * II")
                          (("1" (hide 1)
                            (("1" (inst + "II-1")
                              (("1" (skosimp)
                                (("1" (typepred "y!1")
                                  (("1" (expand "sq")
                                    (("1"
                                      (lemma
                                       "trich_lt"
                                       ("x" "II-1" "y" "y!1"))
                                      (("1"
                                        (split -1)
                                        (("1"
                                          (lemma
                                           "sq_le"
                                           ("nna" "II" "nnb" "y!1"))
                                          (("1"
                                            (expand "sq")
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil)
                                         ("2" (propax) nil nil)
                                         ("3"
                                          (lemma
                                           "sq_le"
                                           ("nnb" "II-1" "nna" "y!1+1"))
                                          (("1"
                                            (expand "sq")
                                            (("1" (assert) nil nil))
                                            nil)
                                           ("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (assert)
                                (("2" (expand "sq") (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (sq_le formula-decl nil sq reals) (sq_lt formula-decl nil sq reals)
    (int_times_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (n!1 skolem-const-decl "nat" code_product nil)
    (II skolem-const-decl "{i | i <= sqrt(2 * n!1) & sqrt(2 * n!1) < 1 + i}"
     code_product nil)
    (trich_lt formula-decl nil real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (sq const-decl "nonneg_real" sq reals)
    (sq_nz_pos application-judgement "posreal" sq reals)
    (sq_sqrt formula-decl nil sqrt reals)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real nonempty-type-from-decl nil reals nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (integer nonempty-type-from-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (singleton? const-decl "bool" sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil))
   nil
   (double_index_triangle subtype
    "{i | booleans.AND(reals.<=(number_fields./((number_fields.*(code_product.i, ((number_fields.+)(code_product.i, 1)))), 2), code_product.n), reals.<(code_product.n, number_fields./((number_fields.*(((number_fields.+)(code_product.i, 1)), ((number_fields.+)(code_product.i, 2)))), 2)))}"
    "(sets[nat].singleton?)")))
 (double_index_triangle_def 0
  (double_index_triangle_def-1 nil 3397625855
   ("" (skosimp)
    (("" (expand "double_index_triangle")
      (("" (expand "singleton_elt")
        (("" (expand "member")
          ((""
            (typepred "the! (x: nat):
             (x + x * x) / 2 <= n!1 AND n!1 < (2 + 3 * x + x * x) / 2")
            (("1" (assert) nil nil)
             ("2" (hide 2)
              (("2" (lemma "double_index_triangle_TCC1" ("n" "n!1"))
                (("2" (expand "singleton?")
                  (("2" (skosimp)
                    (("2" (inst + "x!1")
                      (("2" (skosimp) (("2" (inst - "y!1") nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (double_index_triangle const-decl "nat" code_product nil)
    (member const-decl "bool" sets nil)
    (double_index_triangle_TCC1 subtype-tcc nil code_product nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil) (singleton? const-decl "bool" sets nil)
    (the const-decl "(p)" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil) (singleton_elt const-decl "T" sets nil))
   shostak))
 (double_index_triangle_increasing 0
  (double_index_triangle_increasing-1 nil 3397632138
   ("" (skolem + ("i" "j"))
    (("" (flatten)
      (("" (case "double_index_triangle(j)+1<=double_index_triangle(i)")
        (("1" (hide 1)
          (("1" (name "Tj" "double_index_triangle(j)")
            (("1" (name "Ti" "double_index_triangle(i)")
              (("1" (replace -1)
                (("1" (replace -2)
                  (("1" (expand "double_index_triangle")
                    (("1" (expand "singleton_elt")
                      (("1" (expand "member")
                        (("1"
                          (typepred
                           "the! (x: nat): (x + x * x) / 2 <= i AND i < (2 + 3 * x + x * x) / 2")
                          (("1" (replace -3)
                            (("1" (hide -3)
                              (("1"
                                (typepred "the! (x_1: nat):
        (x_1 + x_1 * x_1) / 2 <= j AND j < (2 + 3 * x_1 + x_1 * x_1) / 2")
                                (("1" (replace -5)
                                  (("1" (hide -5)
                                    (("1"
                                      (case
                                       "2 + 3 * Tj + Tj * Tj<=Ti + Ti * Ti")
                                      (("1" (assert) nil nil)
                                       ("2"
                                        (hide -1 -2 -3 -4 -6)
                                        (("2"
                                          (lemma
                                           "sq_le"
                                           ("nna" "Tj+1" "nnb" "Ti"))
                                          (("2"
                                            (expand "sq")
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (hide-all-but 1)
                                  (("2"
                                    (lemma "double_index_triangle_TCC1"
                                     ("n" "j"))
                                    (("2" (expand "singleton?")
                                      (("2"
                                        (skosimp)
                                        (("2"
                                          (inst + "x!1")
                                          (("2"
                                            (skosimp)
                                            (("2" (inst - "y!1") nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide-all-but 1)
                            (("2"
                              (lemma "double_index_triangle_TCC1" ("n" "i"))
                              (("2" (expand "singleton?")
                                (("2" (skosimp)
                                  (("2" (inst + "x!1")
                                    (("2" (skosimp)
                                      (("2" (inst - "y!1") nil nil)) nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((singleton_elt const-decl "T" sets nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (set type-eq-decl nil sets nil) (singleton? const-decl "bool" sets nil)
    (the const-decl "(p)" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (double_index_triangle_TCC1 subtype-tcc nil code_product nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sq_le formula-decl nil sq reals)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (sq const-decl "nonneg_real" sq reals) (member const-decl "bool" sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (double_index_triangle const-decl "nat" code_product nil))
   shostak))
 (double_index_triangle_bound 0
  (double_index_triangle_bound-1 nil 3397625692
   ("" (skosimp)
    (("" (lemma "double_index_triangle_def" ("n" "n!1"))
      (("" (flatten)
        (("" (name-replace "II" "double_index_triangle(n!1)")
          (("" (hide -2)
            (("" (rewrite "div_mult_pos_le1")
              (("" (case "II<=II*II")
                (("1" (assert) nil nil)
                 ("2" (hide -1 2)
                  (("2" (case-replace "II=0")
                    (("1" (assert) nil nil)
                     ("2"
                      (lemma "both_sides_times_pos_le1"
                       ("pz" "II" "x" "1" "y" "II"))
                      (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (double_index_triangle_def formula-decl nil code_product nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (double_index_triangle const-decl "nat" code_product nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (div_mult_pos_le1 formula-decl nil real_props nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_times_even_is_even application-judgement "even_int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (both_sides_times_pos_le1 formula-decl nil real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (<= const-decl "bool" reals nil))
   shostak))
 (double_index_j_TCC1 0
  (double_index_j_TCC1-1 nil 3397569382
   ("" (skosimp)
    (("" (lemma "double_index_triangle_def" ("n" "n!1"))
      (("" (flatten)
        (("" (assert)
          (("" (hide -1 -2)
            (("" (name-replace "II" "double_index_triangle(n!1)")
              (("" (case "even?(II)")
                (("1" (expand "even?")
                  (("1" (skosimp)
                    (("1" (replace -1)
                      (("1"
                        (case-replace
                         "(2 * j!1 + 2 * j!1 * (2 * j!1)) / 2 = j!1+2*j!1*j!1")
                        (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (rewrite "even_or_odd")
                  (("2" (expand "odd?")
                    (("2" (skosimp)
                      (("2" (replace -1)
                        (("2" (assert)
                          (("2"
                            (case-replace
                             "(2 + 4 * (j!1 * j!1) + 6 * j!1) / 2= 1+2*j!1*j!1+3*j!1")
                            (("1" (assert) nil nil) ("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (double_index_triangle_def formula-decl nil code_product nil)
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (double_index_triangle const-decl "nat" code_product nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (even_or_odd formula-decl nil naturalnumbers nil)
    (odd_times_odd_is_odd application-judgement "odd_int" integers nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (odd? const-decl "bool" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (int_times_even_is_even application-judgement "even_int" integers nil)
    (even_plus_even_is_even application-judgement "even_int" integers nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (even? const-decl "bool" integers nil))
   nil
   (double_index_j subtype
    "(number_fields.-)(code_product.n, number_fields./((number_fields.*(code_product.double_index_triangle(code_product.n), ((number_fields.+)(code_product.double_index_triangle(code_product.n), 1)))), 2))"
    "nat")))
 (double_index_j_bound 0
  (double_index_j_bound-1 nil 3397578298
   ("" (skosimp)
    (("" (expand "double_index_j")
      (("" (lemma "double_index_triangle_def" ("n" "n!1"))
        (("" (flatten)
          (("" (name-replace "II" "double_index_triangle(n!1)")
            (("" (case "n!1<= (II + II * II+2*II) / 2")
              (("1" (assert) nil nil)
               ("2" (hide 2)
                (("2" (assert)
                  (("2" (case "n!1+1 <= (2 + II + (2 * II + II * II)) / 2")
                    (("1" (hide -3)
                      (("1" (hide -2) (("1" (assert) nil nil)) nil)) nil)
                     ("2" (hide 2 -1)
                      (("2" (name "DRL" "2 + II + (2 * II + II * II)")
                        (("2" (replace -1)
                          (("2" (assert)
                            (("2" (case "forall (i,j:nat): i<j => i+1<=j")
                              (("1" (inst - "n!1" "DRL/2")
                                (("1" (assert) nil nil)
                                 ("2" (hide -2 2)
                                  (("2" (expand "DRL")
                                    (("2" (hide -1)
                                      (("2"
                                        (case "even?(II)")
                                        (("1"
                                          (expand "even?")
                                          (("1"
                                            (skosimp)
                                            (("1"
                                              (replace -1)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (case-replace
                                                   "(2 + 4 * (j!1 * j!1) + 6 * j!1) / 2= 1+2*j!1*j!1+3*j!1")
                                                  (("1" (assert) nil nil)
                                                   ("2" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (rewrite "even_or_odd")
                                          (("2"
                                            (expand "odd?")
                                            (("2"
                                              (skosimp)
                                              (("2"
                                                (replace -1)
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (case-replace
                                                     "(6 + 4 * (j!1 * j!1) + 10 * j!1) / 2=3+2*j!1*j!1+5*j!1")
                                                    (("1" (assert) nil nil)
                                                     ("2" (assert) nil nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (hide-all-but 1)
                                (("2" (skosimp) (("2" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (double_index_j const-decl "nat" code_product nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (even_or_odd formula-decl nil naturalnumbers nil)
    (odd_times_odd_is_odd application-judgement "odd_int" integers nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers nil)
    (odd? const-decl "bool" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (even_plus_even_is_even application-judgement "even_int" integers nil)
    (int_times_even_is_even application-judgement "even_int" integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (even? const-decl "bool" integers nil)
    (DRL skolem-const-decl "posint" code_product nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (double_index_triangle const-decl "nat" code_product nil)
    (double_index_triangle_def formula-decl nil code_product nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   shostak))
 (double_index_i_TCC1 0
  (double_index_i_TCC1-1 nil 3397569382
   ("" (skosimp)
    (("" (lemma "double_index_j_bound" ("n" "n!1")) (("" (assert) nil nil))
      nil))
    nil)
   ((nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (double_index_j_bound formula-decl nil code_product nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (double_index_i subtype
    "(number_fields.-)(code_product.double_index_triangle(code_product.n), code_product.double_index_j(code_product.n))"
    "nat")))
 (double_index_i_bound 0
  (double_index_i_bound-1 nil 3397632740
   ("" (skosimp) (("" (expand "double_index_i") (("" (assert) nil nil)) nil))
    nil)
   ((double_index_i const-decl "nat" code_product nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (double_index_n_increasing 0
  (double_index_n_increasing-1 nil 3397619747
   ("" (skosimp)
    (("" (expand "double_index_n")
      ((""
        (lemma "both_sides_div_pos_lt1"
         ("pz" "2" "x"
          "j!1 * j!1 + j!1 * n!1 + j!1 + (j!1 * n!1 + n!1 * n!1 + n!1)" "y"
          "j!1 * j!1 + j!1 * m!1 + j!1 + (j!1 * m!1 + m!1 * m!1 + m!1)"))
        (("" (flatten)
          (("" (hide -1)
            (("" (split -1)
              (("1" (assert) nil nil)
               ("2" (hide 2)
                (("2" (assert)
                  (("2"
                    (lemma "both_sides_times_pos_lt1"
                     ("pz" "2*j!1+1" "x" "n!1" "y" "m!1"))
                    (("2" (assert)
                      (("2" (case "n!1*n!1<m!1*m!1")
                        (("1" (assert) nil nil)
                         ("2" (hide -1 2)
                          (("2" (case-replace "n!1=0")
                            (("1"
                              (lemma "posreal_times_posreal_is_posreal"
                               ("px" "m!1" "py" "m!1"))
                              (("1" (assert) nil nil)) nil)
                             ("2"
                              (lemma "lt_times_lt_pos1"
                               ("px" "n!1" "y" "m!1" "nnz" "n!1" "w" "m!1"))
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (double_index_n const-decl "nat" code_product nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (nnrat_plus_nnrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (lt_times_lt_pos1 formula-decl nil real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posreal_times_posreal_is_posreal judgement-tcc nil real_types nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (both_sides_times_pos_lt1 formula-decl nil real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (both_sides_div_pos_lt1 formula-decl nil real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   shostak))
 (double_index_n_ij 0
  (double_index_n_ij-1 nil 3397579394
   ("" (skosimp)
    (("" (expand "double_index_i")
      (("" (expand "double_index_j")
        (("" (name-replace "II" "double_index_triangle(n!1)")
          (("" (expand "double_index_n") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((double_index_i const-decl "nat" code_product nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (double_index_triangle const-decl "nat" code_product nil)
    (nnrat_plus_nnrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (double_index_n const-decl "nat" code_product nil)
    (double_index_j const-decl "nat" code_product nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil))
   shostak))
 (double_index_ij_n 0
  (double_index_ij_n-1 nil 3397618898
   ("" (skosimp)
    (("" (expand "double_index_i")
      (("" (case-replace "double_index_j(double_index_n(i!1, j!1)) = j!1")
        (("1" (hide -1)
          (("1"
            (lemma "double_index_triangle_def"
             ("n" "double_index_n(i!1, j!1)"))
            (("1" (flatten)
              (("1"
                (name-replace "N"
                 "double_index_triangle(double_index_n(i!1, j!1))")
                (("1" (lemma "trich_lt" ("x" "N" "y" "i!1+j!1"))
                  (("1" (name "M" "i!1+j!1")
                    (("1"
                      (case-replace
                       "double_index_n(i!1, j!1)=(M*(M+1))/2+j!1")
                      (("1" (hide -1)
                        (("1" (replace -1)
                          (("1" (split -2)
                            (("1" (assert)
                              (("1" (lemma "sq_le" ("nna" "N+1" "nnb" "M"))
                                (("1" (expand "sq") (("1" (propax) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert) nil nil)
                             ("3" (assert)
                              (("3" (lemma "sq_le" ("nna" "M+1" "nnb" "N"))
                                (("3" (expand "sq") (("3" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand "double_index_n")
                        (("2" (expand "M") (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 2)
          (("2" (expand "double_index_j")
            (("2" (name "M" "i!1+j!1")
              (("2" (case-replace "double_index_n(i!1, j!1)=(M*(M+1))/2+j!1")
                (("1" (hide -1)
                  (("1" (assert)
                    (("1"
                      (lemma "double_index_triangle_def"
                       ("n" "((M + M * M) / 2 + j!1)"))
                      (("1" (flatten)
                        (("1"
                          (name-replace "II"
                           "double_index_triangle((M + M * M) / 2 + j!1)")
                          (("1" (lemma "trich_lt" ("x" "M" "y" "II"))
                            (("1" (split -1)
                              (("1" (lemma "sq_le" ("nna" "M+1" "nnb" "II"))
                                (("1" (expand "sq") (("1" (assert) nil nil))
                                  nil))
                                nil)
                               ("2" (assert) nil nil)
                               ("3" (lemma "sq_le" ("nna" "II+1" "nnb" "M"))
                                (("3" (expand "sq") (("3" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide-all-but 1)
                            (("2" (case "even?(M)")
                              (("1" (expand "even?")
                                (("1" (skosimp)
                                  (("1" (replace -1)
                                    (("1"
                                      (case-replace
                                       "(2 * j!2 + 2 * j!2 * (2 * j!2))/2 = j!2+2*j!2*j!2")
                                      (("1" (assert) nil nil)
                                       ("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (rewrite "even_or_odd")
                                (("2" (expand "odd?")
                                  (("2" (skosimp)
                                    (("2" (replace -1)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (case-replace
                                           "(2 + 4 * (j!2 * j!2) + 6 * j!2)/2= 1+2*j!2*j!2+3*j!2")
                                          (("1" (assert) nil nil)
                                           ("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide-all-but 1)
                        (("2" (case "even?(M)")
                          (("1" (expand "even?")
                            (("1" (skosimp)
                              (("1" (replace -1)
                                (("1"
                                  (case-replace
                                   "(2 * j!2 + 2 * j!2 * (2 * j!2)) / 2 = j!2+2*j!2*j!2")
                                  (("1" (assert) nil nil)
                                   ("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (rewrite "even_or_odd")
                            (("2" (expand "odd?")
                              (("2" (skosimp)
                                (("2" (replace -1)
                                  (("2" (assert)
                                    (("2"
                                      (case-replace
                                       "(2 + 4 * (j!2 * j!2) + 6 * j!2)/2= 1+2*j!2*j!2+3*j!2")
                                      (("1" (assert) nil nil)
                                       ("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "double_index_n")
                  (("2" (expand "M") (("2" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((double_index_i const-decl "nat" code_product nil)
    (M skolem-const-decl "nonneg_int" code_product nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (even? const-decl "bool" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (even_plus_even_is_even application-judgement "even_int" integers nil)
    (int_times_even_is_even application-judgement "even_int" integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (odd? const-decl "bool" integers nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (rat_plus_rat_is_rat application-judgement "rat" rationals nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers nil)
    (odd_times_odd_is_odd application-judgement "odd_int" integers nil)
    (even_or_odd formula-decl nil naturalnumbers nil)
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (trich_lt formula-decl nil real_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nnrat_plus_nnrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sq const-decl "nonneg_real" sq reals)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (sq_le formula-decl nil sq reals)
    (M skolem-const-decl "nonneg_int" code_product nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (double_index_triangle const-decl "nat" code_product nil)
    (double_index_triangle_def formula-decl nil code_product nil)
    (double_index_n const-decl "nat" code_product nil)
    (double_index_j const-decl "nat" code_product nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (double_index_n_bijective 0
  (double_index_n_bijective-1 nil 3397620027
   ("" (expand "bijective?")
    (("" (split)
      (("1" (expand "injective?")
        (("1"
          (case "forall (i,j0,j1:nat): double_index_n(i,j0)=double_index_n(i,j1)=> j0=j1")
          (("1" (skosimp)
            (("1" (case "x1!1`1 = x2!1`1")
              (("1" (inst - "x1!1`1" "x1!1`2" "x2!1`2")
                (("1" (assert) (("1" (decompose-equality) nil nil)) nil)) nil)
               ("2" (hide -1)
                (("2"
                  (case "forall (i0,i1,j0,j1:nat): i0<i1 => double_index_n(i0, j0) /= double_index_n(i1, j1)")
                  (("1" (lemma "trich_lt" ("x" "x1!1`1" "y" "x2!1`1"))
                    (("1" (split -1)
                      (("1" (inst - "x1!1`1" "x2!1`1" "x1!1`2" "x2!1`2")
                        (("1" (assert) nil nil)) nil)
                       ("2" (propax) nil nil)
                       ("3" (inst - "x2!1`1" "x1!1`1" "x2!1`2" "x1!1`2")
                        (("3" (assert) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (hide 2 3 -1)
                    (("2" (skosimp)
                      (("2" (expand "double_index_n")
                        (("2"
                          (case "(i0!1 * i0!1 + i0!1 * j0!1 + i0!1 +
        (i0!1 * j0!1 + j0!1 * j0!1 + j0!1))
       + 2*j0!1
       =
       (i1!1 * i1!1 + i1!1 * j1!1 + i1!1 +
         (i1!1 * j1!1 + j1!1 * j1!1 + j1!1))
        + 2*j1!1")
                          (("1" (assert)
                            (("1" (hide -3)
                              (("1" (case "j0!1<=j1!1")
                                (("1"
                                  (lemma "sq_lt" ("nna" "i0!1" "nnb" "i1!1"))
                                  (("1"
                                    (lemma "sq_le"
                                     ("nna" "j0!1" "nnb" "j1!1"))
                                    (("1" (rewrite "sq_rew")
                                      (("1"
                                        (rewrite "sq_rew")
                                        (("1"
                                          (rewrite "sq_rew")
                                          (("1"
                                            (rewrite "sq_rew")
                                            (("1"
                                              (assert)
                                              (("1"
                                                (lemma
                                                 "le_times_le_pos"
                                                 ("nnx"
                                                  "2*i0!1"
                                                  "y"
                                                  "2*i1!1"
                                                  "nnz"
                                                  "j0!1"
                                                  "w"
                                                  "j1!1"))
                                                (("1" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (case "j0!1>j1!1")
                                  (("1" (hide 1)
                                    (("1" (name "DJ" "j0!1-j1!1")
                                      (("1"
                                        (case "DJ>=1")
                                        (("1"
                                          (name "DI" "i1!1-i0!1")
                                          (("1"
                                            (case "DI>=1")
                                            (("1"
                                              (case-replace "j0!1=DJ+j1!1")
                                              (("1"
                                                (case-replace "i1!1=DI+i0!1")
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (hide -1 -2 -4 -6 -7 -9)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (lemma
                                                         "trich_lt"
                                                         ("x" "DJ" "y" "DI"))
                                                        (("1"
                                                          (split -1)
                                                          (("1"
                                                            (name
                                                             "DD"
                                                             "DI-DJ")
                                                            (("1"
                                                              (case "DD>=1")
                                                              (("1"
                                                                (case-replace
                                                                 "DI=DJ+DD")
                                                                (("1"
                                                                  (assert)
                                                                  (("1"
                                                                    (hide
                                                                     -1
                                                                     -3
                                                                     -4)
                                                                    (("1"
                                                                      (assert)
                                                                      (("1"
                                                                        (case
                                                                         "3*DJ=DD+DJ+DD*DD+2*DD*(DJ+i0!1+j1!1)")
                                                                        (("1"
                                                                          (hide
                                                                           -5)
                                                                          (("1"
                                                                            (case
                                                                             "0=DD+DD*DD+2*DD*(DJ + i0!1 + j1!1)-2*DJ")
                                                                            (("1"
                                                                              (hide
                                                                               -2)
                                                                              (("1"
                                                                                (case
                                                                                 "2*DD*DJ>=2*DJ")
                                                                                (("1"
                                                                                  (case
                                                                                   "DD + DD * DD + 2 * DD * (i0!1 + j1!1)>0")
                                                                                  (("1"
                                                                                    (assert)
                                                                                    nil
                                                                                    nil)
                                                                                   ("2"
                                                                                    (hide
                                                                                     -1
                                                                                     -2)
                                                                                    (("2"
                                                                                      (lemma
                                                                                       "sq_le"
                                                                                       ("nna"
                                                                                        "1"
                                                                                        "nnb"
                                                                                        "DD"))
                                                                                      (("2"
                                                                                        (lemma
                                                                                         "both_sides_times_pos_le1"
                                                                                         ("pz"
                                                                                          "2*DD"
                                                                                          "x"
                                                                                          "0"
                                                                                          "y"
                                                                                          "i0!1+j1!1"))
                                                                                        (("2"
                                                                                          (expand
                                                                                           "sq")
                                                                                          (("2"
                                                                                            (assert)
                                                                                            nil
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil)
                                                                                 ("2"
                                                                                  (hide
                                                                                   -1)
                                                                                  (("2"
                                                                                    (lemma
                                                                                     "both_sides_times_pos_le1"
                                                                                     ("pz"
                                                                                      "2*DJ"
                                                                                      "x"
                                                                                      "1"
                                                                                      "y"
                                                                                      "DD"))
                                                                                    (("2"
                                                                                      (assert)
                                                                                      nil
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (assert)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (replace -1)
                                                            (("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("3"
                                                            (lemma
                                                             "sq_lt"
                                                             ("nna"
                                                              "DI"
                                                              "nnb"
                                                              "DJ"))
                                                            (("3"
                                                              (lemma
                                                               "both_sides_times_pos_lt1"
                                                               ("pz"
                                                                "1+2*(i0!1+j1!1)"
                                                                "x"
                                                                "DI"
                                                                "y"
                                                                "DJ"))
                                                              (("3"
                                                                (expand "sq")
                                                                (("3"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (assert) nil nil))
                                                nil)
                                               ("2" (assert) nil nil))
                                              nil)
                                             ("2" (assert) nil nil))
                                            nil))
                                          nil)
                                         ("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (hide 2)
            (("2" (skosimp)
              (("2" (expand "double_index_n")
                (("2"
                  (case "(i!1 * i!1 + i!1 * j0!1 + i!1 + (i!1 * j0!1 + j0!1 * j0!1 + j0!1))
       + 2*j0!1
       =
       (i!1 * i!1 + i!1 * j1!1 + i!1 + (i!1 * j1!1 + j1!1 * j1!1 + j1!1))
        + 2*j1!1")
                  (("1" (hide -2)
                    (("1" (assert)
                      (("1" (lemma "trich_lt" ("x" "j0!1" "y" "j1!1"))
                        (("1" (split -1)
                          (("1" (lemma "sq_lt" ("nna" "j0!1" "nnb" "j1!1"))
                            (("1" (expand "sq")
                              (("1" (case-replace "i!1=0")
                                (("1" (assert) nil nil)
                                 ("2"
                                  (lemma "both_sides_times_pos_lt1"
                                   ("pz" "i!1" "x" "j0!1" "y" "j1!1"))
                                  (("1" (assert) nil nil)
                                   ("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (propax) nil nil)
                           ("3" (lemma "sq_lt" ("nna" "j1!1" "nnb" "j0!1"))
                            (("3" (expand "sq")
                              (("3" (assert)
                                (("3" (case-replace "i!1=0")
                                  (("1" (assert) nil nil)
                                   ("2"
                                    (lemma "both_sides_times_pos_lt1"
                                     ("pz" "i!1" "x" "j1!1" "y" "j0!1"))
                                    (("2" (assert) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "surjective?")
        (("2" (skolem + ("n"))
          (("2" (case "exists i,j: double_index_n(i,j)=n")
            (("1" (propax) nil nil)
             ("2" (hide 2)
              (("2" (inst + "double_index_i(n)" "double_index_j(n)")
                (("2" (rewrite "double_index_n_ij") nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((double_index_n const-decl "nat" code_product nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (< const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (trich_lt formula-decl nil real_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (> const-decl "bool" reals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (sq const-decl "nonneg_real" sq reals)
    (int_times_even_is_even application-judgement "even_int" integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (both_sides_times_pos_le1 formula-decl nil real_props nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (both_sides_times_pos_lt1 formula-decl nil real_props nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (sq_lt formula-decl nil sq reals)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (sq_rew formula-decl nil sq reals)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (le_times_le_pos formula-decl nil real_props nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (sq_le formula-decl nil sq reals) (<= const-decl "bool" reals nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (nnrat_plus_nnrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (injective? const-decl "bool" functions nil)
    (double_index_n_ij formula-decl nil code_product nil)
    (double_index_i const-decl "nat" code_product nil)
    (double_index_j const-decl "nat" code_product nil)
    (surjective? const-decl "bool" functions nil)
    (bijective? const-decl "bool" functions nil))
   shostak)))

