(partitions_scaf
 (gen_seq_lem_TCC1 0
  (gen_seq_lem_TCC1-1 nil 3280594050 ("" (grind) nil nil)
   ((|#| const-decl "finite_sequence[T]" partitions_scaf nil)) shostak
   (gen_seq_lem subtype "0" "below[length( #(x))]")))
 (gen_seq_lem 0
  (gen_seq_lem-1 nil 3280833619
   ("" (skosimp*)
    (("" (assert) (("" (expand "#") (("" (propax) nil nil)) nil)) nil)) nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)
    (|#| const-decl "finite_sequence[T]" partitions_scaf nil))
   shostak))
 (part2set_prep_TCC1 0
  (part2set_prep_TCC1-2 "" 3790090705
   ("" (lemma "connected_domain") (("" (skosimp*) nil nil)) nil) nil shostak
   (part2set_prep assuming "integral_def[T].integral_def"
    "connected_domain: ASSUMPTION deriv_domain_def[T].connected?"))
  (part2set_prep_TCC1-1 nil 3281096981
   ("" (lemma "connected_domain")
    (("" (skosimp*) (("" (expand "connected?") (("" (propax) nil nil)) nil))
      nil))
    nil)
   ((connected_domain formula-decl nil partitions_scaf nil)) shostak
   (part2set_prep assuming "integral_def[T].integral_def"
    "connected_domain: ASSUMPTION deriv_domain_def[T].connected?")))
 (part2set_prep_TCC2 0
  (part2set_prep_TCC2-2 "" 3790090705
   ("" (skosimp*) (("" (lemma "not_one_element") (("" (propax) nil nil)) nil))
    nil)
   nil shostak
   (part2set_prep assuming "integral_def[T].integral_def"
    "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?"))
  (part2set_prep_TCC2-1 nil 3281096981
   ("" (skosimp*)
    (("" (lemma "not_one_element")
      (("" (expand "not_one_element?") (("" (propax) nil nil)) nil)) nil))
    nil)
   ((not_one_element formula-decl nil partitions_scaf nil)) shostak
   (part2set_prep assuming "integral_def[T].integral_def"
    "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?")))
 (part2set_prep 0
  (part2set_prep-1 nil 3281096964
   ("" (skosimp*)
    (("" (lemma "is_finite_surj[T]")
      (("" (inst?)
        (("" (assert)
          (("" (hide 2)
            (("" (inst + "length(P!1)" "seq(P!1)")
              (("1" (expand "surjective?")
                (("1" (skosimp*)
                  (("1" (typepred "y!1") (("1" (propax) nil nil)) nil)) nil))
                nil)
               ("2" (skosimp*) (("2" (inst?) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (is_finite_surj formula-decl nil finite_sets nil)
    (P!1 skolem-const-decl "partition[T](a!1, b!1)" partitions_scaf nil)
    (b!1 skolem-const-decl "{x: T | a!1 < x}" partitions_scaf nil)
    (a!1 skolem-const-decl "T" partitions_scaf nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (surjective? const-decl "bool" functions nil)
    (partition type-eq-decl nil integral_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   nil))
 (part2set_TCC1 0
  (part2set_TCC1-1 nil 3281096981
   ("" (skosimp*)
    (("" (lemma "is_finite_surj[T]")
      (("" (inst?)
        (("" (assert)
          (("" (hide 2)
            (("" (inst + "length(P!1)" "seq(P!1)")
              (("1" (expand "surjective?")
                (("1" (skosimp*)
                  (("1" (typepred "y!1") (("1" (propax) nil nil)) nil)) nil))
                nil)
               ("2" (skosimp*) (("2" (inst?) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (is_finite_surj formula-decl nil finite_sets nil)
    (P!1 skolem-const-decl "partition[T](a!1, b!1)" partitions_scaf nil)
    (b!1 skolem-const-decl "{x: T | a!1 < x}" partitions_scaf nil)
    (a!1 skolem-const-decl "T" partitions_scaf nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (surjective? const-decl "bool" functions nil)
    (partition type-eq-decl nil integral_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   shostak
   (part2set subtype
    "{s: partitions_scaf.T | EXISTS (kk: naturalnumbers.below(length(partitions_scaf.P))): seq(partitions_scaf.P)(kk) = s}"
    "finite_set[T]")))
 (part2set_lem 0
  (part2set_lem-1 nil 3281181911
   ("" (skosimp*)
    (("" (expand "part2set")
      (("" (assert)
        (("" (prop)
          (("1" (inst + "0") (("1" (assert) nil nil)) nil)
           ("2" (inst + "length(P!1)-1") (("2" (assert) nil nil)) nil)
           ("3" (skosimp*) (("3" (inst?) nil nil)) nil)
           ("4" (skosimp*)
            (("4" (typepred "x!1")
              (("4" (expand "part2set")
                (("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((part2set const-decl "finite_set[T]" partitions_scaf nil)
    (partition type-eq-decl nil integral_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil))
   shostak))
 (card_part2set 0
  (card_part2set-1 nil 3281117875
   ("" (skosimp*)
    (("" (expand "part2set")
      (("" (typepred "P!1")
        (("" (lemma "card_subset[T]")
          (("" (inst - "add(a!1,singleton[T](b!1))" "_")
            (("" (inst?)
              (("1" (assert)
                (("1" (split -1)
                  (("1" (case-replace "card(add(a!1,singleton[T](b!1))) = 2")
                    (("1" (assert) nil nil)
                     ("2" (hide 2)
                      (("2" (rewrite "card_add")
                        (("2" (rewrite "card_singleton")
                          (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 2)
                    (("2" (expand "subset?")
                      (("2" (skosimp*)
                        (("2" (assert)
                          (("2" (typepred "x!1")
                            (("2" (expand "add")
                              (("2" (expand "member")
                                (("2" (expand "singleton")
                                  (("2" (split -2)
                                    (("1" (inst + "0")
                                      (("1" (assert) nil nil)) nil)
                                     ("2" (inst + "length(P!1)-1")
                                      (("2" (assert) nil nil)) nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 2)
                (("2" (lemma "part2set_prep")
                  (("2" (assert) (("2" (inst?) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((part2set const-decl "finite_set[T]" partitions_scaf nil)
    (card_subset formula-decl nil finite_sets nil)
    (a!1 skolem-const-decl "T" partitions_scaf nil)
    (b!1 skolem-const-decl "{x: T | a!1 < x}" partitions_scaf nil)
    (P!1 skolem-const-decl "partition[T](a!1, b!1)" partitions_scaf nil)
    (card_singleton formula-decl nil finite_sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (card_add formula-decl nil finite_sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (part2set_prep formula-decl nil partitions_scaf nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nonempty? const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_singleton_finite application-judgement "non_empty_finite_set[T]"
     partitions_scaf nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[real]" integral_def nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set[T]"
     partitions_scaf nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set[real]"
     integral_def nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def nil))
   nil))
 (minmax_part2set_TCC1 0
  (minmax_part2set_TCC1-1 nil 3281118218
   ("" (skosimp*)
    (("" (lemma "card_part2set")
      (("" (inst?)
        (("" (lemma "card_empty?[T]")
          (("" (inst?) (("" (ground) (("" (assert) nil nil)) nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((card_part2set formula-decl nil partitions_scaf nil)
    (card_empty? formula-decl nil finite_sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (part2set const-decl "finite_set[T]" partitions_scaf nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (partition type-eq-decl nil integral_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak
   (minmax_part2set subtype
    "partitions_scaf.part2set(partitions_scaf.a, partitions_scaf.b, partitions_scaf.P)"
    "non_empty_finite_set[T]")))
 (minmax_part2set 0
  (minmax_part2set-2 "" 3790090707
   ("" (skosimp*)
    (("" (prop)
      (("1" (lemma "min_lem[T,<=]")
        (("1" (inst?)
          (("1" (assert)
            (("1" (hide 2)
              (("1" (expand "part2set")
                (("1" (prop)
                  (("1" (inst + "0") (("1" (assert) nil nil)) nil)
                   ("2" (skosimp*)
                    (("2" (typepred "x!1")
                      (("2" (expand "part2set")
                        (("2" (skosimp*)
                          (("2" (lemma "parts_order[T]")
                            (("2" (inst - "a!1" "b!1" "P!1" "0" "kk!1")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (lemma "max_lem[T,<=]")
        (("2" (inst?)
          (("2" (assert)
            (("2" (hide 2)
              (("2" (expand "part2set")
                (("2" (prop)
                  (("1" (inst + "length(P!1)-1") (("1" (assert) nil nil)) nil)
                   ("2" (skosimp*)
                    (("2" (typepred "x!1")
                      (("2" (expand "part2set")
                        (("2" (skosimp*)
                          (("2" (lemma "parts_order[T]")
                            (("2"
                              (inst - "a!1" "b!1" "P!1" "kk!1"
                               "length(P!1)-1")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (minmax_part2set-1 nil 3281118004
   ("" (skosimp*)
    (("" (prop)
      (("1" (lemma "min_lem[T,<=]")
        (("1" (inst?)
          (("1" (assert)
            (("1" (hide 2)
              (("1" (expand "part2set")
                (("1" (prop)
                  (("1" (inst + "0") (("1" (assert) nil nil)) nil)
                   ("2" (skosimp*)
                    (("2" (typepred "x!1")
                      (("2" (expand "part2set")
                        (("2" (skosimp*)
                          (("2" (lemma "parts_order[T]")
                            (("2" (inst - "a!1" "b!1" "P!1" "0" "kk!1")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (assert)
            (("2" (lemma "card_empty?[T]")
              (("2" (inst?)
                (("2" (assert)
                  (("2" (lemma "card_part2set")
                    (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (lemma "max_lem[T,<=]")
        (("2" (inst?)
          (("1" (assert)
            (("1" (hide 2)
              (("1" (expand "part2set")
                (("1" (prop)
                  (("1" (inst + "length(P!1)-1") (("1" (assert) nil nil)) nil)
                   ("2" (skosimp*)
                    (("2" (typepred "x!1")
                      (("2" (expand "part2set")
                        (("2" (skosimp*)
                          (("2" (lemma "parts_order[T]")
                            (("2"
                              (inst - "a!1" "b!1" "P!1" "kk!1"
                               "length(P!1)-1")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (lemma "card_empty?[T]")
            (("2" (inst?)
              (("2" (assert)
                (("2" (lemma "card_part2set")
                  (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (empty? const-decl "bool" sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (> const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def nil)
    (part2set const-decl "finite_set[T]" partitions_scaf nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (parts_order formula-decl nil integral_def nil)
    (min_lem formula-decl nil finite_sets_minmax finite_sets)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (restrict const-decl "R" restrict nil) (<= const-decl "bool" reals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (max_lem formula-decl nil finite_sets_minmax finite_sets))
   nil))
 (part2set_TCC2 0
  (part2set_TCC2-1 nil 3281096981
   ("" (skosimp*)
    (("" (lemma "card_part2set") (("" (assert) (("" (inst?) nil nil)) nil))
      nil))
    nil)
   ((card_part2set formula-decl nil partitions_scaf nil)
    (partition type-eq-decl nil integral_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak
   (part2set_ subtype
    "partitions_scaf.part2set(partitions_scaf.a, partitions_scaf.b, partitions_scaf.P)"
    "{s: finite_sets[T].finite_set | reals.>(finite_sets[T].card(s), 1)}")))
 (set2seq_TCC1 0
  (set2seq_TCC1-1 nil 3280842302
   ("" (skosimp*) (("" (expand "nonempty?") (("" (propax) nil nil)) nil)) nil)
   ((nonempty? const-decl "bool" sets nil)) shostak
   (set2seq subtype "partitions_scaf.S" "(sets[T].nonempty?)")))
 (set2seq_TCC2 0
  (set2seq_TCC2-1 nil 3280842320
   ("" (skosimp*) (("" (rewrite "card_rest[T]") (("" (assert) nil nil)) nil))
    nil)
   ((card_rest formula-decl nil finite_sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak
   (set2seq termination
    "partitions_scaf.set2seq(sets[T].rest(partitions_scaf.S))" "nil")))
 (set2seq_length 0
  (set2seq_length-1 nil 3281098906
   ("" (induct "S" 1 "finite_set_induction_rest[T]")
    (("1" (expand "set2seq")
      (("1" (expand "#")
        (("1" (expand "o ")
          (("1" (ground)
            (("1" (case "empty?[T](emptyset[T])")
              (("1" (assert)
                (("1" (rewrite "card_emptyset[T]")
                  (("1" (assert)
                    (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 2) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skosimp*)
      (("2" (expand "set2seq" 1)
        (("2" (expand "o ")
          (("2" (expand "#")
            (("2" (assert)
              (("2" (rewrite "card_rest") (("2" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (finite_rest application-judgement "finite_set[T]" partitions_scaf nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (card_rest formula-decl nil finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" partitions_scaf nil)
    (O const-decl "finseq" finite_sequences nil)
    (empty? const-decl "bool" sets nil) (emptyset const-decl "set" sets nil)
    (card_emptyset formula-decl nil finite_sets nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (member const-decl "bool" sets nil)
    (|#| const-decl "finite_sequence[T]" partitions_scaf nil)
    (finite_set_induction_rest formula-decl nil finite_sets_inductions
     finite_sets)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (set2seq def-decl "finite_sequence[T]" partitions_scaf nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   shostak))
 (set2seq_lem 0
  (set2seq_lem-2 "" 3790090708
   ("" (induct "S" 1 "finite_set_induction_rest[T]")
    (("1" (assert) nil nil)
     ("2" (skosimp*)
      (("2" (expand "set2seq")
        (("2" (case "empty?[T](emptyset[T])")
          (("1" (assert)
            (("1" (typepred "ii!1")
              (("1" (expand "set2seq")
                (("1" (expand "empty_seq") (("1" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (assert) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("3" (skosimp*)
      (("3" (expand "set2seq" 1)
        (("3" (expand "o ")
          (("3" (assert)
            (("3" (expand "#")
              (("3" (ground)
                (("3" (inst?)
                  (("3" (assert)
                    (("3" (lemma "rest_member[T]")
                      (("3" (expand "member")
                        (("3" (inst?) (("3" (assert) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (set2seq_lem-1 nil 3280846807
   ("" (induct "S" 1 "finite_set_induction_rest[T]")
    (("1" (assert) nil nil)
     ("2" (skosimp*)
      (("2" (expand "set2seq")
        (("2" (case "empty?[T](emptyset[T])")
          (("1" (assert)
            (("1" (typepred "ii!1")
              (("1" (expand "set2seq")
                (("1" (expand "empty_seq") (("1" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (assert) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("3" (skosimp*)
      (("3" (expand "set2seq" 1)
        (("3" (expand "o ")
          (("3" (assert)
            (("3" (expand "#")
              (("3" (ground)
                (("3" (inst?)
                  (("1" (assert)
                    (("1" (lemma "rest_member[T]")
                      (("1" (expand "member")
                        (("1" (inst?)
                          (("1" (assert) nil nil)
                           ("2" (assert)
                            (("2" (hide 3)
                              (("2" (typepred "ii!1")
                                (("2" (assert)
                                  (("2" (expand "set2seq")
                                    (("2" (expand "o ")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (expand "#")
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 3)
                    (("2" (typepred "ii!1")
                      (("2" (expand "set2seq")
                        (("2" (expand "#")
                          (("2" (expand "o")
                            (("2" (assert)
                              (("2" (lift-if)
                                (("2" (ground)
                                  (("1" (expand "set2seq")
                                    (("1" (assert) nil nil)) nil)
                                   ("2" (expand "set2seq")
                                    (("2" (assert)
                                      (("2"
                                        (expand "o")
                                        (("2"
                                          (expand "#")
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((O const-decl "finseq" finite_sequences nil)
    (|#| const-decl "finite_sequence[T]" partitions_scaf nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (rest const-decl "set" sets nil)
    (rest_member formula-decl nil sets_lemmas nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (empty? const-decl "bool" sets nil) (emptyset const-decl "set" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (member const-decl "bool" sets nil)
    (finite_rest application-judgement "finite_set[T]" partitions_scaf nil)
    (finite_emptyset name-judgement "finite_set[T]" partitions_scaf nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_set_induction_rest formula-decl nil finite_sets_inductions
     finite_sets)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (set2seq def-decl "finite_sequence[T]" partitions_scaf nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   shostak))
 (set2seq_exists 0
  (set2seq_exists-1 nil 3281099741
   ("" (induct "S" 1 "finite_set_induction_rest[T]")
    (("1" (skosimp*) (("1" (assert) (("1" (inst?) nil nil)) nil)) nil)
     ("2" (skosimp*)
      (("2" (typepred "x!1")
        (("2" (expand "emptyset") (("2" (propax) nil nil)) nil)) nil))
      nil)
     ("3" (skosimp*)
      (("3" (expand "set2seq" 1)
        (("3" (expand "o " 1)
          (("3" (expand "#")
            (("3" (assert)
              (("3" (inst?)
                (("3" (assert)
                  (("3" (lemma "choose_rest_or[T]")
                    (("3" (inst?)
                      (("3" (inst?)
                        (("3" (expand "member")
                          (("3" (split -1)
                            (("1" (assert)
                              (("1" (skosimp*)
                                (("1" (typepred "ii!1")
                                  (("1" (inst + "ii!1+1")
                                    (("1" (assert) nil nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (inst + "0")
                              (("1" (assert) nil nil)
                               ("2" (expand "set2seq") (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((O const-decl "finseq" finite_sequences nil)
    (finite_rest application-judgement "finite_set[T]" partitions_scaf nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil)
    (rest const-decl "set" sets nil) (/= const-decl "boolean" notequal nil)
    (remove const-decl "set" sets nil)
    (finite_remove application-judgement "finite_set[T]" partitions_scaf nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (ii!1 skolem-const-decl "below(length(set2seq(rest(SS!1))))"
     partitions_scaf nil)
    (SS!1 skolem-const-decl "non_empty_finite_set[T]" partitions_scaf nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (choose_rest_or formula-decl nil sets_lemmas nil)
    (|#| const-decl "finite_sequence[T]" partitions_scaf nil)
    (emptyset const-decl "set" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_set_induction_rest formula-decl nil finite_sets_inductions
     finite_sets)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (set2seq def-decl "finite_sequence[T]" partitions_scaf nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   shostak))
 (minmax_set2seq_TCC1 0
  (minmax_set2seq_TCC1-1 nil 3281118238
   ("" (skosimp*) (("" (assert) nil nil)) nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (set2seq_length formula-decl nil partitions_scaf nil))
   shostak
   (minmax_set2seq subtype "partitions_scaf.set2seq(partitions_scaf.S)"
    "ne_seqs[T]")))
 (minmax_set2seq_TCC2 0
  (minmax_set2seq_TCC2-1 nil 3281118238
   ("" (skosimp*)
    (("" (lemma "card_empty?[T]")
      (("" (inst?) (("" (assert) (("" (ground) nil nil)) nil)) nil)) nil))
    nil)
   ((T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (card_empty? formula-decl nil finite_sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   shostak
   (minmax_set2seq subtype "partitions_scaf.S" "non_empty_finite_set[T]")))
 (minmax_set2seq 0
  (minmax_set2seq-2 "" 3790090710
   ("" (skosimp*)
    (("" (prop)
      (("1" (typepred "min(set2seq(S!1))")
        (("1" (skosimp*)
          (("1" (replace -3 * rl)
            (("1"
              (typepred
               "min[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
              (("1" (lemma "set2seq_lem")
                (("1" (inst?)
                  (("1" (assert)
                    (("1" (inst - "jj!1")
                      (("1" (inst -4 "set2seq(S!1)`seq(jj!1)")
                        (("1" (assert)
                          (("1" (lemma "set2seq_exists")
                            (("1"
                              (inst - "S!1"
                               "min[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
                              (("1" (assert)
                                (("1" (skosimp*)
                                  (("1" (replace -1 * rl)
                                    (("1" (inst -7 "ii!1")
                                      (("1" (assert) nil nil)) nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (typepred "max(set2seq(S!1))")
        (("2" (skosimp*)
          (("2" (replace -3 * rl)
            (("2"
              (typepred
               "max[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
              (("2" (lemma "set2seq_lem")
                (("2" (inst?)
                  (("2" (assert)
                    (("2" (inst - "jj!1")
                      (("2" (inst -4 "set2seq(S!1)`seq(jj!1)")
                        (("2" (assert)
                          (("2" (lemma "set2seq_exists")
                            (("2"
                              (inst - "S!1"
                               "max[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
                              (("2" (assert)
                                (("2" (skosimp*)
                                  (("2" (replace -1 * rl)
                                    (("2" (inst -7 "ii!1")
                                      (("2" (assert) nil nil)) nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (minmax_set2seq-1 nil 3281118135
   ("" (skosimp*)
    (("" (prop)
      (("1" (typepred "min(set2seq(S!1))")
        (("1" (skosimp*)
          (("1" (replace -3 * rl)
            (("1"
              (typepred
               "min[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
              (("1" (lemma "set2seq_lem")
                (("1" (inst?)
                  (("1" (assert)
                    (("1" (inst - "jj!1")
                      (("1" (inst -4 "set2seq(S!1)`seq(jj!1)")
                        (("1" (assert)
                          (("1" (lemma "set2seq_exists")
                            (("1"
                              (inst - "S!1"
                               "min[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
                              (("1" (assert)
                                (("1" (skosimp*)
                                  (("1" (replace -1 * rl)
                                    (("1" (inst -7 "ii!1")
                                      (("1" (assert) nil nil)) nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (assert)
                                (("2" (lemma "card_empty?[T]")
                                  (("2" (inst?) (("2" (assert) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (lemma "card_empty?[T]")
                (("2" (inst?) (("2" (assert) (("2" (ground) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (propax) nil nil))
        nil)
       ("2" (typepred "max(set2seq(S!1))")
        (("1" (skosimp*)
          (("1" (replace -3 * rl)
            (("1"
              (typepred
               "max[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
              (("1" (lemma "set2seq_lem")
                (("1" (inst?)
                  (("1" (assert)
                    (("1" (inst - "jj!1")
                      (("1" (inst -4 "set2seq(S!1)`seq(jj!1)")
                        (("1" (assert)
                          (("1" (lemma "set2seq_exists")
                            (("1"
                              (inst - "S!1"
                               "max[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
                              (("1" (assert)
                                (("1" (skosimp*)
                                  (("1" (replace -1 * rl)
                                    (("1" (inst -7 "ii!1")
                                      (("1" (assert) nil nil)) nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (assert)
                                (("2" (lemma "card_empty?[T]")
                                  (("2" (inst?) (("2" (assert) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (lemma "card_empty?[T]")
                (("2" (inst?) (("2" (assert) (("2" (ground) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (propax) nil nil))
        nil))
      nil))
    nil)
   ((non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (min const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES a <= x)}"
         finite_sets_minmax finite_sets)
    (below type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (set2seq_exists formula-decl nil partitions_scaf nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (set2seq_lem formula-decl nil partitions_scaf nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (ne_seqs type-eq-decl nil seqs structures)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (> const-decl "bool" reals nil) (restrict const-decl "R" restrict nil)
    (<= const-decl "bool" reals nil) (dom type-eq-decl nil min_seq structures)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (min const-decl "{t: T |
   (FORALL (ii: dom(s)): t <= seq(s)(ii)) AND
    (EXISTS (jj: dom(s)): seq(s)(jj) = t)}" min_seq structures)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (set2seq def-decl "finite_sequence[T]" partitions_scaf nil)
    (max const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES x <= a)}"
         finite_sets_minmax finite_sets)
    (dom type-eq-decl nil max_seq structures)
    (max const-decl "{t: T |
   (FORALL (ii: dom(s)): seq(s)(ii) <= t) AND
    (EXISTS (jj: dom(s)): seq(s)(jj) = t)}" max_seq structures))
   nil))
 (set2seq_neq_TCC1 0
  (set2seq_neq_TCC1-1 nil 3281092893
   ("" (skosimp*)
    (("" (assert) (("" (typepred "ii!1") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sort_length formula-decl nil sort_seq structures)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (restrict const-decl "R" restrict nil) (<= const-decl "bool" reals nil)
    (seqs type-eq-decl nil sort_seq structures)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (permutation? const-decl "bool" permutations_seq structures)
    (increasing? const-decl "bool" sort_seq structures)
    (sort const-decl
          "{ss: seqs | permutation?[T, <=](s, ss) AND increasing?(ss)}"
      sort_seq structures)
    (below type-eq-decl nil naturalnumbers nil))
   shostak (set2seq_neq subtype "partitions_scaf.ii" "below[SP`length]")))
 (set2seq_neq_TCC2 0
  (set2seq_neq_TCC2-1 nil 3281094287
   ("" (skosimp*)
    (("" (assert) (("" (typepred "jj!1") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sort_length formula-decl nil sort_seq structures)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (restrict const-decl "R" restrict nil) (<= const-decl "bool" reals nil)
    (seqs type-eq-decl nil sort_seq structures)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (permutation? const-decl "bool" permutations_seq structures)
    (increasing? const-decl "bool" sort_seq structures)
    (sort const-decl
          "{ss: seqs | permutation?[T, <=](s, ss) AND increasing?(ss)}"
      sort_seq structures)
    (below type-eq-decl nil naturalnumbers nil))
   shostak (set2seq_neq subtype "partitions_scaf.jj" "below[SP`length]")))
 (set2seq_neq 0
  (set2seq_neq-1 nil 3281100425
   ("" (induct "S" 1 "finite_set_induction_rest[T]")
    (("1" (assert) nil nil)
     ("2" (skosimp*)
      (("2" (typepred "ii!1")
        (("2" (typepred "jj!1")
          (("2" (assert)
            (("2" (rewrite "card_emptyset") (("2" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skosimp*)
      (("3" (typepred "ii!1")
        (("3" (typepred "jj!1")
          (("3" (assert)
            (("3" (expand "set2seq" -4)
              (("3" (expand "#")
                (("3" (expand "o")
                  (("3" (case "ii!1 < 1")
                    (("1" (assert)
                      (("1" (lemma "set2seq_lem")
                        (("1" (inst?)
                          (("1" (assert)
                            (("1" (inst - "jj!1-1")
                              (("1" (assert)
                                (("1" (lemma "choose_not_member[T]")
                                  (("1" (inst?) (("1" (assert) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (case "jj!1 < 1")
                      (("1" (assert)
                        (("1" (lemma "set2seq_lem")
                          (("1" (inst?)
                            (("1" (assert)
                              (("1" (inst - "ii!1-1")
                                (("1" (lemma "choose_not_member[T]")
                                  (("1" (inst?) (("1" (assert) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert)
                        (("2" (inst -3 "ii!1-1" "jj!1-1")
                          (("1" (assert) nil nil)
                           ("2" (rewrite "card_rest") (("2" (assert) nil nil))
                            nil)
                           ("3" (rewrite "card_rest") (("3" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skosimp*)
      (("4" (assert)
        (("4" (skosimp*)
          (("4" (hide 2)
            (("4" (typepred "ii!1")
              (("4" (typepred "jj!1") (("4" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skosimp*)
      (("5" (assert)
        (("5" (skosimp*)
          (("5" (assert)
            (("5" (typepred "ii!1")
              (("5" (typepred "jj!1") (("5" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((O const-decl "finseq" finite_sequences nil)
    (SS!1 skolem-const-decl "non_empty_finite_set[T]" partitions_scaf nil)
    (ii!1 skolem-const-decl "below(length(sort(set2seq(SS!1))))"
     partitions_scaf nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (jj!1 skolem-const-decl "below(length(sort(set2seq(SS!1))))"
     partitions_scaf nil)
    (card_rest formula-decl nil finite_sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_rest application-judgement "finite_set[T]" partitions_scaf nil)
    (rest const-decl "set" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (choose_not_member formula-decl nil sets_lemmas nil)
    (member const-decl "bool" sets nil)
    (set2seq_lem formula-decl nil partitions_scaf nil)
    (|#| const-decl "finite_sequence[T]" partitions_scaf nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (card_emptyset formula-decl nil finite_sets nil)
    (sort_length formula-decl nil sort_seq structures)
    (set2seq_length formula-decl nil partitions_scaf nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" partitions_scaf nil)
    (emptyset const-decl "set" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_set_induction_rest formula-decl nil finite_sets_inductions
     finite_sets)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set2seq def-decl "finite_sequence[T]" partitions_scaf nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil) (<= const-decl "bool" reals nil)
    (seqs type-eq-decl nil sort_seq structures)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (permutation? const-decl "bool" permutations_seq structures)
    (increasing? const-decl "bool" sort_seq structures)
    (sort const-decl
          "{ss: seqs | permutation?[T, <=](s, ss) AND increasing?(ss)}"
      sort_seq structures)
    (below type-eq-decl nil naturalnumbers nil)
    (/= const-decl "boolean" notequal nil))
   shostak))
 (sort_set2seq_lem 0
  (sort_set2seq_lem-1 nil 3281101427
   ("" (skosimp*)
    (("" (assert)
      (("" (skosimp*)
        (("" (lemma "sort_seq_in")
          (("" (inst?)
            (("1" (expand "in?")
              (("1" (skosimp*)
                (("1" (replace -1)
                  (("1" (hide -1)
                    (("1" (lemma "set2seq_lem")
                      (("1" (inst?)
                        (("1" (assert) (("1" (inst?) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (typepred "ii!1") (("2" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (sort_seq_in formula-decl nil sort_seq structures)
    (sort_length formula-decl nil sort_seq structures)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (in? const-decl "bool" seqs structures)
    (set2seq_lem formula-decl nil partitions_scaf nil)
    (set2seq_length formula-decl nil partitions_scaf nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (seqs type-eq-decl nil sort_seq structures)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (permutation? const-decl "bool" permutations_seq structures)
    (increasing? const-decl "bool" sort_seq structures)
    (sort const-decl
          "{ss: seqs | permutation?[T, <=](s, ss) AND increasing?(ss)}"
      sort_seq structures)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (set2seq def-decl "finite_sequence[T]" partitions_scaf nil)
    (S!1 skolem-const-decl "finite_set[T]" partitions_scaf nil)
    (below type-eq-decl nil naturalnumbers nil)
    (ii!1 skolem-const-decl "below(length(sort(set2seq(S!1))))"
     partitions_scaf nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (set2part_prep_TCC1 0
  (set2part_prep_TCC1-1 nil 3280844789
   ("" (skosimp*)
    (("" (assert)
      (("" (typepred "S!1")
        (("" (lemma "card_empty?[T]")
          (("" (inst?) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((card_empty? formula-decl nil finite_sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil))
   shostak
   (set2part_prep subtype "partitions_scaf.S" "non_empty_finite_set[T]")))
 (set2part_prep 0
  (set2part_prep-2 "" 3790090712
   ("" (skosimp*)
    (("" (typepred "S!1")
      ((""
        (typepred "min[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
        ((""
          (typepred
           "max[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
          (("" (assert)
            ((""
              (name-replace "MINS"
               "min[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
              ((""
                (name-replace "MAXS"
                 "max[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
                ((""
                  (case "EXISTS (xx,yy: T): S!1(xx) AND S!1(yy) and xx /= yy")
                  (("1" (skosimp*)
                    (("1" (inst-cp -5 "xx!1")
                      (("1" (inst-cp -5 "yy!1")
                        (("1" (inst-cp -10 "yy!1")
                          (("1" (inst-cp -10 "xx!1") (("1" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide -1 -2 -3 -4 -5 -6 2)
                    (("2" (case "card(S!1) = 0")
                      (("1" (assert) nil nil)
                       ("2" (lemma "card_empty?[T]")
                        (("2" (inst?)
                          (("2" (assert)
                            (("2" (expand "empty?")
                              (("2" (skosimp*)
                                (("2" (expand "member")
                                  (("2" (case "card(remove(x!1,S!1)) = 0")
                                    (("1" (rewrite "card_remove")
                                      (("1" (assert) nil nil)) nil)
                                     ("2" (lemma "card_empty?[T]")
                                      (("2"
                                        (inst?)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (ground)
                                            (("2"
                                              (expand "empty?")
                                              (("2"
                                                (skosimp*)
                                                (("2"
                                                  (expand "member")
                                                  (("2"
                                                    (expand "remove")
                                                    (("2"
                                                      (expand "member")
                                                      (("2"
                                                        (flatten)
                                                        (("2"
                                                          (inst + "x!1" "x!2")
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (set2part_prep-1 nil 3280844160
   ("" (skosimp*)
    (("" (typepred "S!1")
      ((""
        (typepred "min[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
        (("1"
          (typepred
           "max[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
          (("1" (assert)
            (("1"
              (name-replace "MINS"
               "min[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
              (("1"
                (name-replace "MAXS"
                 "max[T, restrict[[real, real], [T, T], boolean](<=)](S!1)")
                (("1"
                  (case "EXISTS (xx,yy: T): S!1(xx) AND S!1(yy) and xx /= yy")
                  (("1" (skosimp*)
                    (("1" (inst-cp -5 "xx!1")
                      (("1" (inst-cp -5 "yy!1")
                        (("1" (inst-cp -10 "yy!1")
                          (("1" (inst-cp -10 "xx!1") (("1" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide -1 -2 -3 -4 -5 -6 2)
                    (("2" (case "card(S!1) = 0")
                      (("1" (assert) nil nil)
                       ("2" (lemma "card_empty?[T]")
                        (("2" (inst?)
                          (("2" (assert)
                            (("2" (expand "empty?")
                              (("2" (skosimp*)
                                (("2" (expand "member")
                                  (("2" (case "card(remove(x!1,S!1)) = 0")
                                    (("1" (rewrite "card_remove")
                                      (("1" (assert) nil nil)) nil)
                                     ("2" (lemma "card_empty?[T]")
                                      (("2"
                                        (inst?)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (ground)
                                            (("2"
                                              (expand "empty?")
                                              (("2"
                                                (skosimp*)
                                                (("2"
                                                  (expand "member")
                                                  (("2"
                                                    (expand "remove")
                                                    (("2"
                                                      (expand "member")
                                                      (("2"
                                                        (flatten)
                                                        (("2"
                                                          (inst + "x!1" "x!2")
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (lemma "card_empty?[T]")
          (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (max const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES x <= a)}"
         finite_sets_minmax finite_sets)
    (/= const-decl "boolean" notequal nil) (member const-decl "bool" sets nil)
    (card_remove formula-decl nil finite_sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (remove const-decl "set" sets nil)
    (finite_remove application-judgement "finite_set[T]" partitions_scaf nil)
    (card_empty? formula-decl nil finite_sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (empty? const-decl "bool" sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil)
    (min const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES a <= x)}"
         finite_sets_minmax finite_sets))
   shostak))
 (sort_set2seq_neq_TCC1 0
  (sort_set2seq_neq_TCC1-1 nil 3281094366
   ("" (skosimp*) (("" (typepred "ii!1") (("" (assert) nil nil)) nil)) nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (set2seq def-decl "finite_sequence[T]" partitions_scaf nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (sort const-decl
          "{ss: seqs | permutation?[T, <=](s, ss) AND increasing?(ss)}"
      sort_seq structures)
    (increasing? const-decl "bool" sort_seq structures)
    (permutation? const-decl "bool" permutations_seq structures)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (seqs type-eq-decl nil sort_seq structures)
    (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sort_length formula-decl nil sort_seq structures))
   shostak
   (sort_set2seq_neq subtype "partitions_scaf.ii" "below[SP`length]")))
 (sort_set2seq_neq_TCC2 0
  (sort_set2seq_neq_TCC2-1 nil 3281094380
   ("" (skosimp*) (("" (typepred "jj!1") (("" (assert) nil nil)) nil)) nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (set2seq def-decl "finite_sequence[T]" partitions_scaf nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (sort const-decl
          "{ss: seqs | permutation?[T, <=](s, ss) AND increasing?(ss)}"
      sort_seq structures)
    (increasing? const-decl "bool" sort_seq structures)
    (permutation? const-decl "bool" permutations_seq structures)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (seqs type-eq-decl nil sort_seq structures)
    (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sort_length formula-decl nil sort_seq structures))
   shostak
   (sort_set2seq_neq subtype "partitions_scaf.jj" "below[SP`length]")))
 (sort_set2seq_neq 0
  (sort_set2seq_neq-1 nil 3281106057
   ("" (skosimp*)
    (("" (assert)
      (("" (skosimp*)
        (("" (typepred "sort(set2seq(S!1))")
          (("" (hide -2)
            (("" (lemma "perm_symmetric[T,<=]")
              (("" (inst - "set2seq(S!1)" "sort(set2seq(S!1))")
                (("" (assert)
                  (("" (hide -2)
                    (("" (expand "permutation?")
                      (("" (skosimp*)
                        (("" (typepred "ii!1")
                          (("" (typepred "jj!1")
                            (("" (inst-cp - "ii!1")
                              (("" (inst - "jj!1")
                                (("" (replace -4)
                                  (("" (hide -4)
                                    (("" (replace -4)
                                      ((""
                                        (hide -4)
                                        ((""
                                          (lemma "set2seq_neq")
                                          ((""
                                            (inst?)
                                            ((""
                                              (assert)
                                              ((""
                                                (inst
                                                 -
                                                 "f!1(ii!1)"
                                                 "f!1(jj!1)")
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (expand "bijective?")
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (expand
                                                           "injective?")
                                                          (("1"
                                                            (inst
                                                             -
                                                             "ii!1"
                                                             "jj!1")
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (typepred "f!1(jj!1)")
                                                  (("2" (assert) nil nil))
                                                  nil)
                                                 ("3"
                                                  (typepred "f!1(ii!1)")
                                                  (("3" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sort const-decl
          "{ss: seqs | permutation?[T, <=](s, ss) AND increasing?(ss)}"
      sort_seq structures)
    (increasing? const-decl "bool" sort_seq structures)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (seqs type-eq-decl nil sort_seq structures)
    (set2seq def-decl "finite_sequence[T]" partitions_scaf nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (permutation? const-decl "bool" permutations_seq structures)
    (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (perm_symmetric formula-decl nil permutations_seq structures)
    (below type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (set2seq_neq formula-decl nil partitions_scaf nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (set2seq_length formula-decl nil partitions_scaf nil)
    (sort_length formula-decl nil sort_seq structures)
    (bijective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (jj!1 skolem-const-decl "below(length(sort(sort(set2seq(S!1)))))"
     partitions_scaf nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ii!1 skolem-const-decl "below(length(sort(sort(set2seq(S!1)))))"
     partitions_scaf nil)
    (f!1 skolem-const-decl
     "[below(length(sort(set2seq(S!1)))) -> below(length(set2seq(S!1)))]"
     partitions_scaf nil)
    (S!1 skolem-const-decl "finite_set[T]" partitions_scaf nil))
   shostak))
 (set2part_TCC1 0
  (set2part_TCC1-1 nil 3280842341
   ("" (skosimp*) (("" (rewrite "set2part_prep") nil nil)) nil)
   ((set2part_prep formula-decl nil partitions_scaf nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil))
   shostak
   (set2part subtype
    "finite_sets_minmax[T, restrict[[real, real], [T, T], booleans.bool].restrict(reals.<=)].max(partitions_scaf.S)"
    "{x: partitions_scaf.T | reals.<(finite_sets_minmax[T, restrict[[real, real], [T, T], booleans.bool].restrict(reals.<=)].min(partitions_scaf.S), x)}")))
 (set2part_TCC2 0
  (set2part_TCC2-2 "" 3790090714
   ("" (skosimp*)
    (("" (prop)
      (("1" (skosimp*)
        (("1" (lemma "min_lem[T,<=]")
          (("1" (inst?)
            (("1" (inst - "min(S!1)")
              (("1" (assert)
                (("1" (inst?)
                  (("1" (assert)
                    (("1" (hide -1)
                      (("1" (lemma "max_lem[T,<=]")
                        (("1" (inst?)
                          (("1" (inst - "max(S!1)")
                            (("1" (assert)
                              (("1" (inst?)
                                (("1" (hide 2)
                                  (("1" (lemma "sort_set2seq_lem")
                                    (("1" (assert) (("1" (inst?) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 2)
                    (("2" (lemma "sort_set2seq_lem")
                      (("2" (inst?)
                        (("2" (assert) (("2" (inst?) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (lemma "card_empty?[T]")
                (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
              nil)
             ("2" (lemma "card_empty?[T]")
              (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil)
       ("2" (assert) nil nil)
       ("3" (assert)
        (("3" (rewrite "sort_seq_min")
          (("3" (typepred "min(set2seq(S!1))")
            (("3" (lemma "minmax_set2seq")
              (("3" (inst?) (("3" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil)
       ("4" (typepred "S!1")
        (("4" (lemma "sort_seq_max")
          (("4" (inst?)
            (("4" (assert)
              (("4" (lemma "minmax_set2seq")
                (("4" (inst?) (("4" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("5" (skosimp*)
        (("5" (lemma "sort_seq_lem")
          (("5" (inst?)
            (("5" (flatten)
              (("5" (hide -1)
                (("5" (expand "increasing?")
                  (("5" (inst - "ii!1" "ii!1+1")
                    (("5" (assert)
                      (("5" (typepred "ii!1")
                        (("5" (assert)
                          (("5" (lemma "sort_set2seq_neq")
                            (("5" (inst?)
                              (("5" (assert)
                                (("5" (inst - "ii!1" "ii!1+1")
                                  (("5" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak
   (set2part subtype
    "sort_seq[T, restrict[[real, real], [T, T], booleans.bool].restrict(reals.<=)].sort(partitions_scaf.set2seq(partitions_scaf.S))"
    "integral_def[T].partition(finite_sets_minmax[T, restrict[[real, real], [T, T], booleans.bool].restrict(reals.<=)].min(partitions_scaf.S), finite_sets_minmax[T, restrict[[real, real], [T, T], booleans.bool].restrict(reals.<=)].max(partitions_scaf.S))"))
  (set2part_TCC2-1 nil 3280842717
   ("" (skosimp*)
    (("" (prop)
      (("1" (skosimp*)
        (("1" (lemma "min_lem[T,<=]")
          (("1" (inst?)
            (("1" (inst - "min(S!1)")
              (("1" (assert)
                (("1" (inst?)
                  (("1" (assert)
                    (("1" (hide -1)
                      (("1" (lemma "max_lem[T,<=]")
                        (("1" (inst?)
                          (("1" (inst - "max(S!1)")
                            (("1" (assert)
                              (("1" (inst?)
                                (("1" (hide 2)
                                  (("1" (lemma "sort_set2seq_lem")
                                    (("1" (assert) (("1" (inst?) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (typepred "S!1")
                              (("2" (lemma "card_empty?[T]")
                                (("2" (inst?) (("2" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil)
                           ("2" (lemma "card_empty?[T]")
                            (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 2)
                    (("2" (lemma "sort_set2seq_lem")
                      (("2" (inst?)
                        (("2" (assert) (("2" (inst?) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (lemma "card_empty?[T]")
                (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
              nil)
             ("2" (lemma "card_empty?[T]")
              (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil)
       ("2" (assert) nil nil)
       ("3" (assert)
        (("3" (rewrite "sort_seq_min")
          (("3" (typepred "min(set2seq(S!1))")
            (("3" (lemma "minmax_set2seq")
              (("3" (inst?) (("3" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil)
       ("4" (typepred "S!1")
        (("4" (lemma "sort_seq_max")
          (("4" (inst?)
            (("4" (assert)
              (("4" (lemma "minmax_set2seq")
                (("4" (inst?) (("4" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("5" (skosimp*)
        (("5" (lemma "sort_seq_lem")
          (("5" (inst?)
            (("5" (flatten)
              (("5" (hide -1)
                (("5" (expand "increasing?")
                  (("5" (inst - "ii!1" "ii!1+1")
                    (("5" (assert)
                      (("5" (typepred "ii!1")
                        (("5" (assert)
                          (("5" (lemma "sort_set2seq_neq")
                            (("5" (inst?)
                              (("5" (assert)
                                (("5" (inst - "ii!1" "ii!1+1")
                                  (("5" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (min_lem formula-decl nil finite_sets_minmax finite_sets)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (min const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES a <= x)}"
         finite_sets_minmax finite_sets)
    (x1!1 skolem-const-decl "below[sort(set2seq(S!1))`length]" partitions_scaf
     nil)
    (< const-decl "bool" reals nil)
    (set2seq def-decl "finite_sequence[T]" partitions_scaf nil)
    (sort const-decl
          "{ss: seqs | permutation?[T, <=](s, ss) AND increasing?(ss)}"
      sort_seq structures)
    (increasing? const-decl "bool" sort_seq structures)
    (permutation? const-decl "bool" permutations_seq structures)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (seqs type-eq-decl nil sort_seq structures)
    (below type-eq-decl nil naturalnumbers nil)
    (sort_set2seq_lem formula-decl nil partitions_scaf nil)
    (max const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES x <= a)}"
         finite_sets_minmax finite_sets)
    (max_lem formula-decl nil finite_sets_minmax finite_sets)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (card_empty? formula-decl nil finite_sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil) (empty? const-decl "bool" sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (S!1 skolem-const-decl "{s: finite_set[T] | card[T](s) > 1}"
     partitions_scaf nil)
    (set2seq_length formula-decl nil partitions_scaf nil)
    (sort_length formula-decl nil sort_seq structures)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sort_seq_min formula-decl nil sort_seq_lems structures)
    (ne_seqs type-eq-decl nil seqs structures)
    (minmax_set2seq formula-decl nil partitions_scaf nil)
    (dom type-eq-decl nil min_seq structures)
    (min const-decl "{t: T |
   (FORALL (ii: dom(s)): t <= seq(s)(ii)) AND
    (EXISTS (jj: dom(s)): seq(s)(jj) = t)}" min_seq structures)
    (sort_seq_max formula-decl nil sort_seq_lems structures)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (sort_seq_lem formula-decl nil sort_seq structures)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sort_set2seq_neq formula-decl nil partitions_scaf nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil))
   shostak
   (set2part subtype
    "sort_seq[T, restrict[[real, real], [T, T], booleans.bool].restrict(reals.<=)].sort(partitions_scaf.set2seq(partitions_scaf.S))"
    "integral_def[T].partition(finite_sets_minmax[T, restrict[[real, real], [T, T], booleans.bool].restrict(reals.<=)].min(partitions_scaf.S), finite_sets_minmax[T, restrict[[real, real], [T, T], booleans.bool].restrict(reals.<=)].max(partitions_scaf.S))")))
 (set2part_length 0
  (set2part_length-1 nil 3281119415
   ("" (skosimp*)
    (("" (assert) (("" (expand "set2part") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sort_length formula-decl nil sort_seq structures)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (restrict const-decl "R" restrict nil) (<= const-decl "bool" reals nil)
    (set2seq_length formula-decl nil partitions_scaf nil)
    (set2part const-decl
     "partition[T](min[T, restrict[[real, real], [T, T], bool](<=)](S),
             max[T, restrict[[real, real], [T, T], bool](<=)](S))"
     partitions_scaf nil))
   shostak))
 (set2part_lem 0
  (set2part_lem-2 "" 3790090714
   ("" (skosimp*)
    (("" (expand "set2part")
      (("" (lemma "sort_set2seq_lem")
        (("" (inst?)
          (("" (assert)
            (("" (inst?) (("" (typepred "ii!1") (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (set2part_lem-1 nil 3281118998
   ("" (skosimp*)
    (("" (expand "set2part")
      (("" (lemma "sort_set2seq_lem")
        (("" (inst?)
          (("" (assert)
            (("" (inst?)
              (("" (typepred "ii!1")
                (("" (assert)
                  (("" (expand "set2part") (("" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((set2part const-decl
     "partition[T](min[T, restrict[[real, real], [T, T], bool](<=)](S),
             max[T, restrict[[real, real], [T, T], bool](<=)](S))"
     partitions_scaf nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sort_length formula-decl nil sort_seq structures)
    (set2seq_length formula-decl nil partitions_scaf nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil)
    (<= const-decl "bool" reals nil)
    (seqs type-eq-decl nil sort_seq structures)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (permutation? const-decl "bool" permutations_seq structures)
    (increasing? const-decl "bool" sort_seq structures)
    (sort const-decl
          "{ss: seqs | permutation?[T, <=](s, ss) AND increasing?(ss)}"
      sort_seq structures)
    (set2seq def-decl "finite_sequence[T]" partitions_scaf nil)
    (below type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (empty? const-decl "bool" sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (min const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES a <= x)}"
         finite_sets_minmax finite_sets)
    (max const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES x <= a)}"
         finite_sets_minmax finite_sets)
    (closed_interval type-eq-decl nil intervals_real reals)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def nil)
    (ii!1 skolem-const-decl "below(length(set2part(S!1)))" partitions_scaf
     nil)
    (S!1 skolem-const-decl "finite_set[T]" partitions_scaf nil)
    (set2part_length formula-decl nil partitions_scaf nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sort_set2seq_lem formula-decl nil partitions_scaf nil))
   shostak))
 (set2part_ix 0
  (set2part_ix-1 nil 3281207584
   ("" (skosimp*)
    (("" (expand "set2part")
      (("" (lemma "set2seq_exists")
        (("" (inst?)
          (("" (assert)
            (("" (assert)
              (("" (skosimp*)
                (("" (lemma "sort_seq_in?")
                  (("" (inst?)
                    (("" (inst -1 "x!1")
                      (("" (flatten)
                        (("" (hide -2)
                          (("" (split -1)
                            (("1" (expand "in?")
                              (("1" (skosimp*)
                                (("1" (inst?)
                                  (("1" (assert)
                                    (("1" (typepred "ii!2")
                                      (("1" (assert) nil nil)) nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (expand "in?")
                              (("2" (hide 2)
                                (("2" (inst?) (("2" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((set2part const-decl
     "partition[T](min[T, restrict[[real, real], [T, T], bool](<=)](S),
             max[T, restrict[[real, real], [T, T], bool](<=)](S))"
     partitions_scaf nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (sort_seq_in? formula-decl nil sort_seq structures)
    (restrict const-decl "R" restrict nil) (<= const-decl "bool" reals nil)
    (in? const-decl "bool" seqs structures)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (set2part_length formula-decl nil partitions_scaf nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (> const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (empty? const-decl "bool" sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (min const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES a <= x)}"
         finite_sets_minmax finite_sets)
    (max const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES x <= a)}"
         finite_sets_minmax finite_sets)
    (closed_interval type-eq-decl nil intervals_real reals)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def nil)
    (permutation? const-decl "bool" permutations_seq structures)
    (increasing? const-decl "bool" sort_seq structures)
    (sort const-decl
          "{ss: seqs | permutation?[T, <=](s, ss) AND increasing?(ss)}"
      sort_seq structures)
    (ii!2 skolem-const-decl "below(length(sort(set2seq(S!1))))"
     partitions_scaf nil)
    (S!1 skolem-const-decl "finite_set[T]" partitions_scaf nil)
    (sort_length formula-decl nil sort_seq structures)
    (set2seq_length formula-decl nil partitions_scaf nil)
    (set2seq def-decl "finite_sequence[T]" partitions_scaf nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (seqs type-eq-decl nil sort_seq structures)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (set2seq_exists formula-decl nil partitions_scaf nil))
   shostak))
 (insert_TCC1 0
  (insert_TCC1-2 "" 3790090715
   ("" (skosimp*)
    (("" (rewrite "card_add[T]")
      (("" (assert)
        (("" (lemma "card_part2set")
          (("" (inst?) (("" (lift-if) (("" (ground) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak
   (insert subtype
    "sets[T].add(partitions_scaf.xx, partitions_scaf.part2set(partitions_scaf.a, partitions_scaf.b, partitions_scaf.P))"
    "{s: finite_sets[T].finite_set | reals.>(finite_sets[T].card(s), 1)}"))
  (insert_TCC1-1 nil 3281116766
   ("" (skosimp*)
    (("" (rewrite "card_add[T]")
      (("" (assert)
        (("" (lemma "card_part2set")
          (("" (inst?)
            (("" (assert) (("" (lift-if) (("" (ground) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((card_add formula-decl nil finite_sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (> const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def nil)
    (part2set const-decl "finite_set[T]" partitions_scaf nil)
    (open_interval type-eq-decl nil intervals_real reals)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (nil application-judgement "{s: finite_set[T] | card(s) > 1}"
     partitions_scaf nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (card_part2set formula-decl nil partitions_scaf nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak
   (insert subtype
    "sets[T].add(partitions_scaf.xx, partitions_scaf.part2set(partitions_scaf.a, partitions_scaf.b, partitions_scaf.P))"
    "{s: finite_sets[T].finite_set | reals.>(finite_sets[T].card(s), 1)}")))
 (insert_TCC2 0
  (insert_TCC2-2 "" 3790090718
   ("" (skosimp*)
    (("" (case "card(add[T](xx!1, part2set(a!1, b!1, P!1))) > 1")
      (("1" (prop)
        (("1" (skosimp*)
          (("1" (assert)
            (("1" (lemma "minmax_part2set")
              (("1" (inst?)
                (("1" (flatten)
                  (("1" (case "NOT empty?[T](part2set(a!1, b!1, P!1))")
                    (("1" (auto-rewrite-theory "sets[T]")
                      (("1" (prop)
                        (("1" (lemma "min_lem[T,<=]")
                          (("1" (inst?)
                            (("1" (assert)
                              (("1" (lemma "set2part_lem")
                                (("1" (inst?)
                                  (("1" (assert) (("1" (inst?) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (hide -1)
                          (("2" (lemma "max_lem[T,<=]")
                            (("2" (inst?)
                              (("2" (assert)
                                (("2" (lemma "set2part_lem")
                                  (("2" (inst?)
                                    (("2" (assert)
                                      (("2"
                                        (skosimp*)
                                        (("2" (inst?) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide-all-but -1)
                      (("2" (lemma "card_empty?[T]")
                        (("2" (inst?)
                          (("2" (lemma "card_part2set")
                            (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (assert) nil nil)
         ("3" (assert)
          (("3" (typepred "set2part(add[T](xx!1, part2set(a!1, b!1, P!1)))")
            (("3" (assert)
              (("3" (replace -2)
                (("3" (hide -)
                  (("3" (lemma "min_lem[T,<=]")
                    (("3" (inst?)
                      (("3" (assert)
                        (("3" (hide 2)
                          (("3" (expand "add")
                            (("3" (expand "member")
                              (("3" (lemma "part2set_lem")
                                (("3" (inst?)
                                  (("3" (flatten)
                                    (("3" (assert)
                                      (("3"
                                        (skosimp*)
                                        (("3"
                                          (typepred "x!1")
                                          (("3"
                                            (expand "add")
                                            (("3"
                                              (assert)
                                              (("3"
                                                (expand "part2set")
                                                (("3"
                                                  (skosimp*)
                                                  (("3"
                                                    (lemma "parts_order[T]")
                                                    (("3"
                                                      (inst
                                                       -
                                                       "a!1"
                                                       "b!1"
                                                       "P!1"
                                                       "0"
                                                       "kk!1")
                                                      (("3" (assert) nil nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("4" (assert)
          (("4" (typepred "set2part(add[T](xx!1, part2set(a!1, b!1, P!1)))")
            (("4" (assert)
              (("4" (replace -3)
                (("4" (hide -)
                  (("4" (lemma "max_lem[T,<=]")
                    (("4" (inst?)
                      (("4" (assert)
                        (("4" (hide 2)
                          (("4" (expand "add")
                            (("4" (expand "member")
                              (("4" (lemma "part2set_lem")
                                (("4" (inst?)
                                  (("4" (flatten)
                                    (("4" (assert)
                                      (("4"
                                        (skosimp*)
                                        (("4"
                                          (hide -3)
                                          (("4"
                                            (typepred "x!1")
                                            (("4"
                                              (expand "add")
                                              (("4"
                                                (assert)
                                                (("4"
                                                  (inst?)
                                                  (("4" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("5" (skosimp*)
          (("5" (typepred "set2part(add[T](xx!1, part2set(a!1, b!1, P!1)))")
            (("5" (hide -1 -2 -3) (("5" (inst?) nil nil)) nil)) nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (rewrite "card_add")
          (("2" (lemma "card_part2set")
            (("2" (inst?) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak
   (insert subtype
    "partitions_scaf.set2part(sets[T].add(partitions_scaf.xx, partitions_scaf.part2set(partitions_scaf.a, partitions_scaf.b, partitions_scaf.P)))"
    "integral_def[T].partition(partitions_scaf.a, partitions_scaf.b)"))
  (insert_TCC2-1 nil 3281116767
   ("" (skosimp*)
    (("" (case "card(add[T](xx!1, part2set(a!1, b!1, P!1))) > 1")
      (("1" (prop)
        (("1" (skosimp*)
          (("1" (assert)
            (("1" (lemma "minmax_part2set")
              (("1" (inst?)
                (("1" (flatten)
                  (("1" (case "NOT empty?[T](part2set(a!1, b!1, P!1))")
                    (("1" (auto-rewrite-theory "sets[T]")
                      (("1" (prop)
                        (("1" (lemma "min_lem[T,<=]")
                          (("1" (inst?)
                            (("1" (assert)
                              (("1" (lemma "set2part_lem")
                                (("1" (inst?)
                                  (("1" (assert) (("1" (inst?) nil nil)) nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (expand "empty?")
                              (("2" (skosimp*)
                                (("2" (assert) (("2" (inst?) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (hide -1)
                          (("2" (lemma "max_lem[T,<=]")
                            (("2" (inst?)
                              (("1" (assert)
                                (("1" (lemma "set2part_lem")
                                  (("1" (inst?)
                                    (("1" (assert)
                                      (("1"
                                        (skosimp*)
                                        (("1" (inst?) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (expand "empty?")
                                (("2" (skosimp*)
                                  (("2" (assert) (("2" (inst?) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide-all-but -1)
                      (("2" (lemma "card_empty?[T]")
                        (("2" (inst?)
                          (("2" (lemma "card_part2set")
                            (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (assert) nil nil)
         ("3" (assert)
          (("3" (typepred "set2part(add[T](xx!1, part2set(a!1, b!1, P!1)))")
            (("3" (assert)
              (("3" (replace -2)
                (("3" (hide -)
                  (("3" (lemma "min_lem[T,<=]")
                    (("3" (inst?)
                      (("3" (assert)
                        (("3" (hide 2)
                          (("3" (expand "add")
                            (("3" (expand "member")
                              (("3" (lemma "part2set_lem")
                                (("3" (inst?)
                                  (("3" (flatten)
                                    (("3" (assert)
                                      (("3"
                                        (skosimp*)
                                        (("3"
                                          (typepred "x!1")
                                          (("3"
                                            (expand "add")
                                            (("3"
                                              (assert)
                                              (("3"
                                                (expand "part2set")
                                                (("3"
                                                  (skosimp*)
                                                  (("3"
                                                    (lemma "parts_order[T]")
                                                    (("3"
                                                      (inst
                                                       -
                                                       "a!1"
                                                       "b!1"
                                                       "P!1"
                                                       "0"
                                                       "kk!1")
                                                      (("3" (assert) nil nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("4" (assert)
          (("4" (typepred "set2part(add[T](xx!1, part2set(a!1, b!1, P!1)))")
            (("4" (assert)
              (("4" (replace -3)
                (("4" (hide -)
                  (("4" (lemma "max_lem[T,<=]")
                    (("4" (inst?)
                      (("4" (assert)
                        (("4" (hide 2)
                          (("4" (expand "add")
                            (("4" (expand "member")
                              (("4" (lemma "part2set_lem")
                                (("4" (inst?)
                                  (("4" (flatten)
                                    (("4" (assert)
                                      (("4"
                                        (skosimp*)
                                        (("4"
                                          (hide -3)
                                          (("4"
                                            (typepred "x!1")
                                            (("4"
                                              (expand "add")
                                              (("4"
                                                (assert)
                                                (("4"
                                                  (inst?)
                                                  (("4" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("5" (skosimp*)
          (("5" (typepred "set2part(add[T](xx!1, part2set(a!1, b!1, P!1)))")
            (("1" (hide -1 -2 -3) (("1" (inst?) nil nil)) nil)
             ("2" (propax) nil nil))
            nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (rewrite "card_add")
          (("2" (lemma "card_part2set")
            (("2" (inst?) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((part2set const-decl "finite_set[T]" partitions_scaf nil)
    (partition type-eq-decl nil integral_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (<= const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil)
    (open_interval type-eq-decl nil intervals_real reals)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (T formal-nonempty-subtype-decl nil partitions_scaf nil)
    (T_pred const-decl "[real -> boolean]" partitions_scaf nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set[T]"
     partitions_scaf nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (set2part_length formula-decl nil partitions_scaf nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (parts_order formula-decl nil integral_def nil)
    (part2set_lem formula-decl nil partitions_scaf nil)
    (minmax_part2set formula-decl nil partitions_scaf nil)
    (card_part2set formula-decl nil partitions_scaf nil)
    (card_empty? formula-decl nil finite_sets nil)
    (max_lem formula-decl nil finite_sets_minmax finite_sets)
    (min_lem formula-decl nil finite_sets_minmax finite_sets)
    (restrict const-decl "R" restrict nil) (member const-decl "bool" sets nil)
    (set2part const-decl
     "partition[T](min[T, restrict[[real, real], [T, T], bool](<=)](S),
             max[T, restrict[[real, real], [T, T], bool](<=)](S))"
     partitions_scaf nil)
    (max const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES x <= a)}"
         finite_sets_minmax finite_sets)
    (min const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES a <= x)}"
         finite_sets_minmax finite_sets)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set2part_lem formula-decl nil partitions_scaf nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nil application-judgement "{s: finite_set[T] | card(s) > 1}"
     partitions_scaf nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (card_add formula-decl nil finite_sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil))
   shostak
   (insert subtype
    "partitions_scaf.set2part(sets[T].add(partitions_scaf.xx, partitions_scaf.part2set(partitions_scaf.a, partitions_scaf.b, partitions_scaf.P)))"
    "integral_def[T].partition(partitions_scaf.a, partitions_scaf.b)"))))

