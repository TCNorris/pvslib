(integral_cont_scaf
 (IMP_integral_prep_TCC1 0
  (IMP_integral_prep_TCC1-2 "" 3790090281
   ("" (lemma "connected_domain") (("" (propax) nil nil)) nil)
   ((connected_domain formula-decl nil integral_cont_scaf nil)) shostak
   (IMP_integral_prep assuming "integral_prep[T].integral_prep"
    "connected_domain: ASSUMPTION deriv_domain_def[T].connected?"))
  (IMP_integral_prep_TCC1-1 nil 3253546854
   ("" (skosimp*)
    (("" (lemma "connected_domain")
      (("" (inst?) (("" (inst -1 "y!1") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   nil nil
   (IMP_integral_prep assuming "integral_prep[T].integral_prep"
    "connected_domain: ASSUMPTION deriv_domain_def[T].connected?")))
 (IMP_integral_prep_TCC2 0
  (IMP_integral_prep_TCC2-2 "" 3790090281
   ("" (lemma "not_one_element") (("" (propax) nil nil)) nil)
   ((not_one_element formula-decl nil integral_cont_scaf nil)) shostak
   (IMP_integral_prep assuming "integral_prep[T].integral_prep"
    "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?"))
  (IMP_integral_prep_TCC2-1 nil 3253546854
   ("" (skosimp*) (("" (lemma "not_one_element") (("" (inst?) nil nil)) nil))
    nil)
   nil nil
   (IMP_integral_prep assuming "integral_prep[T].integral_prep"
    "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?")))
 (adh_lem 0
  (adh_lem-2 nil 3477662882
   ("" (skosimp*)
    (("" (expand "adh")
      (("" (skosimp*)
        (("" (expand "fullset")
          (("" (case "x!1+e!1/2 <= b!1")
            (("1" (inst + "x!1+e!1/2")
              (("1" (expand "abs") (("1" (assert) nil nil)) nil)
               ("2" (assert)
                (("2" (lemma "connected_domain")
                  (("2" (expand "connected?")
                    (("2" (inst -1 "a!1" "b!1" "e!1/2 + x!1")
                      (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (inst + "b!1")
              (("1" (expand "abs") (("1" (ground) nil nil)) nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_minus_real_is_real application-judgement "real" reals nil)
    (adh const-decl "setof[real]" convergence_functions nil)
    (fullset const-decl "set" sets nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (T formal-subtype-decl nil integral_cont_scaf nil)
    (T_pred const-decl "[real -> boolean]" integral_cont_scaf nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (e!1 skolem-const-decl "posreal" integral_cont_scaf nil)
    (x!1 skolem-const-decl "T" integral_cont_scaf nil)
    (a!1 skolem-const-decl "T" integral_cont_scaf nil)
    (b!1 skolem-const-decl "T" integral_cont_scaf nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (connected_domain formula-decl nil integral_cont_scaf nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (minus_real_is_real application-judgement "real" reals nil))
   nil)
  (adh_lem-1 nil 3253546854
   ("" (skosimp*)
    (("" (expand "adh")
      (("" (skosimp*)
        (("" (expand "fullset")
          (("" (case "x!1+e!1/2 <= b!1")
            (("1" (inst + "x!1+e!1/2")
              (("1" (expand "abs") (("1" (assert) nil nil)) nil)
               ("2" (assert)
                (("2" (lemma "connected_domain")
                  (("2" (inst -1 "a!1" "b!1" "e!1/2 + x!1")
                    (("2" (assert) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (inst + "b!1")
              (("1" (expand "abs") (("1" (ground) nil nil)) nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((adh const-decl "setof[real]" convergence_functions nil)
    (closed_interval type-eq-decl nil intervals_real reals))
   nil))
 (cont_restrict 0
  (cont_restrict-1 nil 3253546854
   ("" (skosimp*)
    (("" (typepred "x!1")
      (("" (expand "continuous?")
        (("" (skosimp*)
          (("" (inst - "epsilon!1")
            (("" (skosimp*)
              (("" (inst + "delta!1")
                (("" (skosimp*)
                  (("" (expand "restrict")
                    (("" (inst - "x!2") (("" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((closed_interval type-eq-decl nil intervals_real reals)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-subtype-decl nil integral_cont_scaf nil)
    (T_pred const-decl "[real -> boolean]" integral_cont_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (restrict const-decl "R" restrict nil) (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (continuous? const-decl "bool" continuous_functions nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (cont_interv_TCC1 0
  (cont_interv_TCC1-1 nil 3374402964
   ("" (skosimp*) (("" (typepred "ii!1") (("" (assert) nil nil)) nil)) nil)
   ((partition type-eq-decl nil integral_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-subtype-decl nil integral_cont_scaf nil)
    (T_pred const-decl "[real -> boolean]" integral_cont_scaf nil)
    (below type-eq-decl nil nat_types nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (cont_interv subtype "integral_cont_scaf.ii"
    "naturalnumbers.below(length(integral_cont_scaf.P))")))
 (cont_interv_TCC2 0
  (cont_interv_TCC2-1 nil 3374402964
   ("" (skosimp*) (("" (typepred "ii!1") (("" (assert) nil nil)) nil)) nil)
   ((partition type-eq-decl nil integral_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-subtype-decl nil integral_cont_scaf nil)
    (T_pred const-decl "[real -> boolean]" integral_cont_scaf nil)
    (below type-eq-decl nil nat_types nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil))
   nil
   (cont_interv subtype "(number_fields.+)(1, integral_cont_scaf.ii)"
    "naturalnumbers.below(length(integral_cont_scaf.P))")))
 (cont_interv 0
  (cont_interv-3 nil 3477662850
   ("" (skosimp*)
    (("" (expand "continuous?")
      (("" (skosimp*)
        (("" (expand "restrict")
          (("" (inst?)
            (("1" (assert)
              (("1" (rewrite "continuity_def")
                (("1" (rewrite "continuity_def")
                  (("1" (expand "convergence")
                    (("1" (expand "convergence")
                      (("1" (prop)
                        (("1" (hide -2)
                          (("1" (assert)
                            (("1" (expand "adh")
                              (("1" (skosimp*)
                                (("1" (inst -1 "e!1")
                                  (("1" (skosimp*)
                                    (("1" (typepred "x0!1")
                                      (("1"
                                        (typepred "x!1")
                                        (("1"
                                          (case "x0!1 = seq(P!1)(ii!1)")
                                          (("1"
                                            (case
                                             "e!1 <= seq(P!1)(1 + ii!1) - x0!1")
                                            (("1"
                                              (inst + "x0!1+e!1/2")
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (expand "fullset")
                                                  (("1"
                                                    (expand "abs" 1)
                                                    (("1" (assert) nil nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (assert)
                                                (("2"
                                                  (lemma "connected_domain")
                                                  (("2"
                                                    (expand "connected?")
                                                    (("2"
                                                      (inst
                                                       -1
                                                       "x0!1"
                                                       "seq(P!1)(1 + ii!1)"
                                                       "(e!1 / 2 + x0!1)")
                                                      (("2" (assert) nil nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (inst
                                               +
                                               "(seq(P!1)(1 + ii!1) + x0!1)/2")
                                              (("1"
                                                (expand "fullset")
                                                (("1"
                                                  (expand "abs" 2)
                                                  (("1" (assert) nil nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (lemma "connected_domain")
                                                (("2"
                                                  (expand "connected?")
                                                  (("2"
                                                    (inst
                                                     -1
                                                     "x0!1"
                                                     "seq(P!1)(1 + ii!1)"
                                                     "(seq(P!1)(1 + ii!1) + x0!1) / 2")
                                                    (("2" (assert) nil nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (case
                                             "e!1 <= x0!1 - seq(P!1)(ii!1)")
                                            (("1"
                                              (inst + "x0!1 - e!1/2")
                                              (("1"
                                                (expand "fullset")
                                                (("1"
                                                  (expand "abs" 2)
                                                  (("1" (assert) nil nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (assert)
                                                (("2"
                                                  (lemma "connected_domain")
                                                  (("2"
                                                    (expand "connected?")
                                                    (("2"
                                                      (inst
                                                       -1
                                                       "seq(P!1)(ii!1)"
                                                       "x0!1"
                                                       "(x0!1 - e!1 / 2)")
                                                      (("2" (assert) nil nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (inst
                                               +
                                               "(x0!1 + seq(P!1)(ii!1))/2")
                                              (("1"
                                                (expand "fullset")
                                                (("1"
                                                  (expand "abs")
                                                  (("1"
                                                    (lift-if)
                                                    (("1" (ground) nil nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (lemma "connected_domain")
                                                (("2"
                                                  (expand "connected?")
                                                  (("2"
                                                    (inst
                                                     -1
                                                     "seq(P!1)(ii!1)"
                                                     "x0!1"
                                                     "(seq(P!1)(ii!1) + x0!1) / 2")
                                                    (("2" (assert) nil nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (hide -1)
                          (("2" (skosimp*)
                            (("2" (inst -1 "epsilon!1")
                              (("2" (skosimp*)
                                (("2" (inst + "delta!1")
                                  (("2" (skosimp*)
                                    (("2" (inst?)
                                      (("1" (assert) nil nil)
                                       ("2"
                                        (typepred "x!1")
                                        (("2"
                                          (hide -1 -4 -5 -6 2)
                                          (("2"
                                            (typepred "P!1")
                                            (("2"
                                              (lemma "parts_order")
                                              (("2"
                                                (inst-cp
                                                 -1
                                                 "a!1"
                                                 "b!1"
                                                 "P!1"
                                                 "0"
                                                 "ii!1")
                                                (("2"
                                                  (inst
                                                   -1
                                                   "a!1"
                                                   "b!1"
                                                   "P!1"
                                                   "ii!1+1"
                                                   "length(P!1)-1")
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (split -1)
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (split -2)
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (assert)
                                                        (("2"
                                                          (typepred "ii!1")
                                                          (("2"
                                                            (case
                                                             "ii!1 = length(P!1) - 2")
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (hide 2)
                (("2" (typepred "x0!1")
                  (("2" (lemma "parts_order")
                    (("2" (inst-cp -1 "a!1" "b!1" "P!1" "0" "ii!1")
                      (("2"
                        (inst -1 "a!1" "b!1" "P!1" "ii!1+1" "length(P!1)-1")
                        (("2" (assert)
                          (("2" (split -1)
                            (("1" (split -2)
                              (("1" (assert) nil nil) ("2" (assert) nil nil))
                              nil)
                             ("2" (assert)
                              (("2" (split -1)
                                (("1" (assert) nil nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((continuous? const-decl "bool" continuous_functions nil)
    (restrict const-decl "R" restrict nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (x0!1 skolem-const-decl "closed_interval[T](xx!1(ii!1), xx!1(1 + ii!1))"
     integral_cont_scaf nil)
    (ii!1 skolem-const-decl "below(length(P!1) - 1)" integral_cont_scaf nil)
    (xx!1 skolem-const-decl "[below(length(P!1)) -> T]" integral_cont_scaf
     nil)
    (P!1 skolem-const-decl "partition[T](a!1, b!1)" integral_cont_scaf nil)
    (partition type-eq-decl nil integral_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (b!1 skolem-const-decl "T" integral_cont_scaf nil)
    (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (a!1 skolem-const-decl "T" integral_cont_scaf nil)
    (T formal-subtype-decl nil integral_cont_scaf nil)
    (T_pred const-decl "[real -> boolean]" integral_cont_scaf nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (continuity_def formula-decl nil continuous_functions nil)
    (convergence const-decl "bool" lim_of_functions nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (parts_order formula-decl nil integral_def nil)
    (x!1 skolem-const-decl "closed_interval[T](xx!1(ii!1), xx!1(1 + ii!1))"
     integral_cont_scaf nil)
    (adh const-decl "setof[real]" convergence_functions nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (connected_domain formula-decl nil integral_cont_scaf nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (fullset const-decl "set" sets nil)
    (e!1 skolem-const-decl "posreal" integral_cont_scaf nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (convergence const-decl "bool" convergence_functions nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   nil)
  (cont_interv-2 nil 3477662725
   (";;; Proof cont_interv-1 for formula integral_cont_scaf.cont_interv"
    (skosimp*)
    ((";;; Proof cont_interv-1 for formula integral_cont_scaf.cont_interv"
      (expand "continuous?")
      ((";;; Proof cont_interv-1 for formula integral_cont_scaf.cont_interv"
        (skosimp*)
        ((";;; Proof cont_interv-1 for formula integral_cont_scaf.cont_interv"
          (expand "restrict")
          ((";;; Proof cont_interv-1 for formula integral_cont_scaf.cont_interv"
            (inst?)
            (("1" (assert)
              (("1" (rewrite "continuity_def")
                (("1" (rewrite "continuity_def")
                  (("1" (expand "convergence")
                    (("1" (expand "convergence")
                      (("1" (prop)
                        (("1" (hide -2)
                          (("1" (assert)
                            (("1" (expand "adh")
                              (("1" (skosimp*)
                                (("1" (inst -1 "e!1")
                                  (("1" (skosimp*)
                                    (("1" (typepred "x0!1")
                                      (("1"
                                        (typepred "x!1")
                                        (("1"
                                          (case "x0!1 = seq(P!1)(ii!1)")
                                          (("1"
                                            (case
                                             "e!1 <= seq(P!1)(1 + ii!1) - x0!1")
                                            (("1"
                                              (inst + "x0!1+e!1/2")
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (expand "fullset")
                                                  (("1"
                                                    (expand "abs" 1)
                                                    (("1" (assert) nil)))))))
                                               ("2"
                                                (assert)
                                                (("2"
                                                  (lemma "connected_domain")
                                                  (("2"
                                                    ("expand "
                                                     connected?
                                                     ")
           (inst -1 "
                                                     x0!1
                                                     " "
                                                     seq
                                                     (P!1)
                                                     (1 + ii!1)
                                                     " "
                                                     (e!1 / 2 + x0!1)
                                                     ")
           (assert))))
        ("
                                                     2
                                                     "
         (inst + "
                                                     (seq
                                                      (P!1)
                                                      (1 + ii!1)
                                                      +
                                                      x0!1)
                                                     /2
                                                     ")
         (("
                                                     1
                                                     " (expand "
                                                     fullset
                                                     ") (expand "
                                                     abs
                                                     " 2) (assert))
          ("
                                                     2
                                                     "
           (lemma "
                                                     connected_domain
                                                     ") ("
                                                     expand
                                                     "connected?")
                                                    (("2"
                                                      (inst
                                                       -1
                                                       "x0!1"
                                                       "seq(P!1)(1 + ii!1)"
                                                       "(seq(P!1)(1 + ii!1) + x0!1) / 2")
                                                      (("2"
                                                        (assert)
                                                        nil)))))))))))))
                                           ("2"
                                            (case
                                             "e!1 <= x0!1 - seq(P!1)(ii!1)")
                                            (("1"
                                              (inst + "x0!1 - e!1/2")
                                              (("1"
                                                (expand "fullset")
                                                (("1"
                                                  (expand "abs" 2)
                                                  (("1" (assert) nil)))))
                                               ("2"
                                                (assert)
                                                (("2"
                                                  (lemma "connected_domain")
                                                  (("2"
                                                    ("expand "
                                                     connected?
                                                     ")
           (inst -1 "
                                                     seq
                                                     (P!1)
                                                     (ii!1)
                                                     " "
                                                     x0!1
                                                     " "
                                                     (x0!1 - e!1 / 2)
                                                     ")
           (assert))))
        ("
                                                     2
                                                     "
         (inst + "
                                                     (x0!1 + seq (P!1) (ii!1))
                                                     /2
                                                     ")
         (("
                                                     1
                                                     " (expand "
                                                     fullset
                                                     ") (expand "
                                                     abs
                                                     ") (lift-if) (ground))
          ("
                                                     2
                                                     "
           (lemma "
                                                     connected_domain
                                                     ") ("
                                                     expand
                                                     "connected?")
                                                    (("2"
                                                      (inst
                                                       -1
                                                       "seq(P!1)(ii!1)"
                                                       "x0!1"
                                                       "(seq(P!1)(ii!1) + x0!1) / 2")
                                                      (("2"
                                                        (assert)
                                                        nil)))))))))))))))))))))))))))))))
                         ("2" (hide -1)
                          (("2" (skosimp*)
                            (("2" (inst -1 "epsilon!1")
                              (("2" (skosimp*)
                                (("2" (inst + "delta!1")
                                  (("2" (skosimp*)
                                    (("2" (inst?)
                                      (("1" (assert) nil)
                                       ("2"
                                        (typepred "x!1")
                                        (("2"
                                          (hide -1 -4 -5 -6 2)
                                          (("2"
                                            (typepred "P!1")
                                            (("2"
                                              (lemma "parts_order")
                                              (("2"
                                                (inst-cp
                                                 -1
                                                 "a!1"
                                                 "b!1"
                                                 "P!1"
                                                 "0"
                                                 "ii!1")
                                                (("2"
                                                  (inst
                                                   -1
                                                   "a!1"
                                                   "b!1"
                                                   "P!1"
                                                   "ii!1+1"
                                                   "length(P!1)-1")
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (split -1)
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (split -2)
                                                          (("1" (assert) nil)
                                                           ("2"
                                                            (assert)
                                                            nil)))))
                                                       ("2"
                                                        (assert)
                                                        (("2"
                                                          (typepred "ii!1")
                                                          (("2"
                                                            (case
                                                             "ii!1 = length(P!1) - 2")
                                                            (("1"
                                                              (assert)
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              nil)))))))))))))))))))))))))))))))))))))))))))))))))
             ("2" (assert)
              (("2" (hide 2)
                (("2" (typepred "x0!1")
                  (("2" (lemma "parts_order")
                    (("2" (inst-cp -1 "a!1" "b!1" "P!1" "0" "ii!1")
                      (("2"
                        (inst -1 "a!1" "b!1" "P!1" "ii!1+1" "length(P!1)-1")
                        (("2" (assert)
                          (("2" (split -1)
                            (("1" (split -2)
                              (("1" (assert) nil) ("2" (assert) nil)))
                             ("2" (assert)
                              (("2" (split -1)
                                (("1" (assert) nil)
                                 ("2" (assert)
                                  nil))))))))))))))))))))))))))))))
    ";;; developed with shostak decision procedures")
   nil nil)
  (cont_interv-1 nil 3253546854
   ("" (skosimp*)
    (("" (expand "continuous?")
      (("" (skosimp*)
        (("" (expand "restrict")
          (("" (inst?)
            (("1" (assert)
              (("1" (rewrite "continuity_def")
                (("1" (rewrite "continuity_def")
                  (("1" (expand "convergence")
                    (("1" (expand "convergence")
                      (("1" (prop)
                        (("1" (hide -2)
                          (("1" (assert)
                            (("1" (expand "adh")
                              (("1" (skosimp*)
                                (("1" (inst -1 "e!1")
                                  (("1" (skosimp*)
                                    (("1" (typepred "x0!1")
                                      (("1"
                                        (typepred "x!1")
                                        (("1"
                                          (case "x0!1 = seq(P!1)(ii!1)")
                                          (("1"
                                            (case
                                             "e!1 <= seq(P!1)(1 + ii!1) - x0!1")
                                            (("1"
                                              (inst + "x0!1+e!1/2")
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (expand "fullset")
                                                  (("1"
                                                    (expand "abs" 1)
                                                    (("1" (assert) nil nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (assert)
                                                (("2"
                                                  (lemma "connected_domain")
                                                  (("2"
                                                    (inst
                                                     -1
                                                     "x0!1"
                                                     "seq(P!1)(1 + ii!1)"
                                                     "(e!1 / 2 + x0!1)")
                                                    (("2" (assert) nil nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (inst
                                               +
                                               "(seq(P!1)(1 + ii!1) + x0!1)/2")
                                              (("1"
                                                (expand "fullset")
                                                (("1"
                                                  (expand "abs" 2)
                                                  (("1" (assert) nil nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (lemma "connected_domain")
                                                (("2"
                                                  (inst
                                                   -1
                                                   "x0!1"
                                                   "seq(P!1)(1 + ii!1)"
                                                   "(seq(P!1)(1 + ii!1) + x0!1) / 2")
                                                  (("2" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (case
                                             "e!1 <= x0!1 - seq(P!1)(ii!1)")
                                            (("1"
                                              (inst + "x0!1 - e!1/2")
                                              (("1"
                                                (expand "fullset")
                                                (("1"
                                                  (expand "abs" 2)
                                                  (("1" (assert) nil nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (assert)
                                                (("2"
                                                  (lemma "connected_domain")
                                                  (("2"
                                                    (inst
                                                     -1
                                                     "seq(P!1)(ii!1)"
                                                     "x0!1"
                                                     "(x0!1 - e!1 / 2)")
                                                    (("2" (assert) nil nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (inst
                                               +
                                               "(x0!1 + seq(P!1)(ii!1))/2")
                                              (("1"
                                                (expand "fullset")
                                                (("1"
                                                  (expand "abs")
                                                  (("1"
                                                    (lift-if)
                                                    (("1" (ground) nil nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (lemma "connected_domain")
                                                (("2"
                                                  (inst
                                                   -1
                                                   "seq(P!1)(ii!1)"
                                                   "x0!1"
                                                   "(seq(P!1)(ii!1) + x0!1) / 2")
                                                  (("2" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (hide -1)
                          (("2" (skosimp*)
                            (("2" (inst -1 "epsilon!1")
                              (("2" (skosimp*)
                                (("2" (inst + "delta!1")
                                  (("2" (skosimp*)
                                    (("2" (inst?)
                                      (("1" (assert) nil nil)
                                       ("2"
                                        (typepred "x!1")
                                        (("2"
                                          (hide -1 -4 -5 -6 2)
                                          (("2"
                                            (typepred "P!1")
                                            (("2"
                                              (lemma "parts_order")
                                              (("2"
                                                (inst-cp
                                                 -1
                                                 "a!1"
                                                 "b!1"
                                                 "P!1"
                                                 "0"
                                                 "ii!1")
                                                (("2"
                                                  (inst
                                                   -1
                                                   "a!1"
                                                   "b!1"
                                                   "P!1"
                                                   "ii!1+1"
                                                   "length(P!1)-1")
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (split -1)
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (split -2)
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (assert)
                                                        (("2"
                                                          (typepred "ii!1")
                                                          (("2"
                                                            (case
                                                             "ii!1 = length(P!1) - 2")
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (hide 2)
                (("2" (typepred "x0!1")
                  (("2" (lemma "parts_order")
                    (("2" (inst-cp -1 "a!1" "b!1" "P!1" "0" "ii!1")
                      (("2"
                        (inst -1 "a!1" "b!1" "P!1" "ii!1+1" "length(P!1)-1")
                        (("2" (assert)
                          (("2" (split -1)
                            (("1" (split -2)
                              (("1" (assert) nil nil) ("2" (assert) nil nil))
                              nil)
                             ("2" (assert)
                              (("2" (split -1)
                                (("1" (assert) nil nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((convergence const-decl "bool" convergence_functions nil)
    (parts_order formula-decl nil integral_def nil)
    (adh const-decl "setof[real]" convergence_functions nil)
    (convergence const-decl "bool" lim_of_functions nil)
    (continuity_def formula-decl nil continuous_functions nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (partition type-eq-decl nil integral_def nil))
   nil))
 (fmin_nonempty_TCC1 0
  (fmin_nonempty_TCC1-1 nil 3253546854 ("" (subtype-tcc) nil nil)
   ((real_minus_real_is_real application-judgement "real" reals nil)) nil
   (fmin_nonempty subtype "integral_cont_scaf.ii" "below[P`length]")))
 (fmin_nonempty_TCC2 0
  (fmin_nonempty_TCC2-1 nil 3253546854 ("" (subtype-tcc) nil nil)
   ((real_minus_real_is_real application-judgement "real" reals nil)) nil
   (fmin_nonempty subtype "(number_fields.+)(1, integral_cont_scaf.ii)"
    "below[P`length]")))
 (fmin_nonempty_TCC3 0
  (fmin_nonempty_TCC3-1 nil 3253546854 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" integral_cont_scaf nil)
    (T formal-subtype-decl nil integral_cont_scaf nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def nil)
    (continuous? const-decl "bool" continuous_functions nil)
    (restrict const-decl "R" restrict nil)
    (fun_cont_on type-eq-decl nil integral_cont_scaf nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil
   (fmin_nonempty subtype
    "seq(integral_cont_scaf.P)((number_fields.+)(1, integral_cont_scaf.ii))"
    "{x: integral_cont_scaf.T | reals.<(seq(integral_cont_scaf.P)(integral_cont_scaf.ii), x)}")))
 (fmin_nonempty_TCC4 0
  (fmin_nonempty_TCC4-1 nil 3253546854
   ("" (skosimp*)
    (("" (lemma "cont_interv")
      (("" (inst -1 "a!1" "b!1" "f!1" "P!1" "seq(P!1)")
        (("" (assert)
          (("" (split -1)
            (("1" (inst?)
              (("1" (expand "continuous?" -1) (("1" (inst?) nil nil)) nil))
              nil)
             ("2" (hide 2)
              (("2" (expand "continuous?")
                (("2" (typepred "f!1") (("2" (propax) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cont_interv formula-decl nil integral_cont_scaf nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (continuous? const-decl "bool" continuous_functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (partition type-eq-decl nil integral_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (fun_cont_on type-eq-decl nil integral_cont_scaf nil)
    (restrict const-decl "R" restrict nil)
    (continuous? const-decl "bool" continuous_functions nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (T formal-subtype-decl nil integral_cont_scaf nil)
    (T_pred const-decl "[real -> boolean]" integral_cont_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil
   (fmin_nonempty subtype "integral_cont_scaf.f"
    "interval_minmax[T].fun_cont_on(seq(integral_cont_scaf.P)(integral_cont_scaf.ii), seq(integral_cont_scaf.P)((number_fields.+)(1, integral_cont_scaf.ii)))")))
 (fmin_nonempty_TCC5 0
  (fmin_nonempty_TCC5-1 nil 3253546854 ("" (subtype-tcc) nil nil)
   ((real_minus_real_is_real application-judgement "real" reals nil)) nil
   (fmin_nonempty subtype "(number_fields.+)(1, integral_cont_scaf.ii)"
    "below[P`length]")))
 (fmin_nonempty 0
  (fmin_nonempty-2 "" 3790090285
   ("" (skosimp*)
    (("" (expand "nonempty?")
      (("" (expand "empty?")
        (("" (expand "member")
          (("" (inst-cp -1 "f!1(x!1)")
            (("" (skosimp*)
              (("" (ground)
                ((""
                  (inst -
                   "f!1(min_x(seq(P!1)(ii!1), seq(P!1)(1 + ii!1), f!1))")
                  (("" (skosimp*)
                    (("" (ground)
                      (("1" (case "ii!2 = ii!1")
                        (("1" (assert) nil nil)
                         ("2" (hide 2 3)
                          (("2" (lemma "parts_disjoint")
                            (("2" (inst?)
                              (("2" (inst?) (("2" (assert) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide 2)
                        (("2" (hide 1)
                          (("2" (lemma "parts_order")
                            (("2" (case "ii!1 = ii!2")
                              (("1" (assert) nil nil)
                               ("2" (case "ii!1 < ii!2")
                                (("1"
                                  (inst - "a!1" "b!1" "P!1" "ii!1+1" "ii!2")
                                  (("1" (assert) nil nil)) nil)
                                 ("2" (inst - "a!1" "b!1" "P!1" "ii!2" "ii!1")
                                  (("2" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (hide 1 2)
                        (("3" (lemma "parts_order")
                          (("3" (case "ii!1 = ii!2")
                            (("1" (assert) nil nil)
                             ("2" (case "ii!1 < ii!2")
                              (("1"
                                (inst - "a!1" "b!1" "P!1" "ii!1+1" "ii!2+1")
                                (("1" (assert) nil nil)) nil)
                               ("2" (inst - "a!1" "b!1" "P!1" "ii!2+1" "ii!1")
                                (("2" (assert) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nonempty? const-decl "bool" sets nil) (member const-decl "bool" sets nil)
    (< const-decl "bool" reals nil)
    (fun_cont_on type-eq-decl nil interval_minmax nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (min_x const-decl "{mx: T |
   a <= mx AND
    mx <= b AND (FORALL (x: T): a <= x AND x <= b IMPLIES f(mx) <= f(x))}"
     interval_minmax nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (> const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def nil)
    (parts_order formula-decl nil integral_def nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (parts_disjoint formula-decl nil integral_def nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (fun_cont_on type-eq-decl nil integral_cont_scaf nil)
    (restrict const-decl "R" restrict nil)
    (continuous? const-decl "bool" continuous_functions nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (T formal-subtype-decl nil integral_cont_scaf nil)
    (T_pred const-decl "[real -> boolean]" integral_cont_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (empty? const-decl "bool" sets nil))
   shostak)
  (fmin_nonempty-1 nil 3253546854
   ("" (skosimp*)
    (("" (expand "nonempty?")
      (("" (expand "empty?")
        (("" (expand "member")
          (("" (inst-cp -1 "f!1(x!1)")
            (("" (skosimp*)
              (("" (ground)
                ((""
                  (inst -
                   "f!1(min_x(seq(P!1)(ii!1), seq(P!1)(1 + ii!1), f!1))")
                  (("1" (skosimp*)
                    (("1" (ground)
                      (("1" (case "ii!2 = ii!1")
                        (("1" (assert) nil nil)
                         ("2" (hide 2 3)
                          (("2" (lemma "parts_disjoint")
                            (("2" (inst?)
                              (("2" (inst?) (("2" (assert) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide 2)
                        (("2" (hide 1)
                          (("2" (lemma "parts_order")
                            (("2" (case "ii!1 = ii!2")
                              (("1" (assert) nil nil)
                               ("2" (case "ii!1 < ii!2")
                                (("1"
                                  (inst - "a!1" "b!1" "P!1" "ii!1+1" "ii!2")
                                  (("1" (assert) nil nil)) nil)
                                 ("2" (inst - "a!1" "b!1" "P!1" "ii!2" "ii!1")
                                  (("2" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (hide 1 2)
                        (("3" (lemma "parts_order")
                          (("3" (case "ii!1 = ii!2")
                            (("1" (assert) nil nil)
                             ("2" (case "ii!1 < ii!2")
                              (("1"
                                (inst - "a!1" "b!1" "P!1" "ii!1+1" "ii!2+1")
                                (("1" (assert) nil nil)) nil)
                               ("2" (inst - "a!1" "b!1" "P!1" "ii!2+1" "ii!1")
                                (("2" (assert) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (skosimp*)
                    (("2" (hide 2)
                      (("2" (typepred "f!1")
                        (("2" (lemma "cont_interv")
                          (("2" (inst -1 "a!1" "b!1" "f!1" "P!1" "seq(P!1)")
                            (("2" (assert)
                              (("2" (split -1)
                                (("1" (assert)
                                  (("1" (inst?)
                                    (("1" (assert)
                                      (("1"
                                        (expand "continuous?" -1)
                                        (("1" (inst?) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (hide 2)
                                  (("2" (expand "continuous?" 1)
                                    (("2" (propax) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((fun_cont_on type-eq-decl nil interval_minmax nil)
    (min_x const-decl "{mx: T |
   a <= mx AND
    mx <= b AND (FORALL (x: T): a <= x AND x <= b IMPLIES f(mx) <= f(x))}"
     interval_minmax nil)
    (partition type-eq-decl nil integral_def nil)
    (parts_disjoint formula-decl nil integral_def nil)
    (parts_order formula-decl nil integral_def nil)
    (closed_interval type-eq-decl nil intervals_real reals))
   nil))
 (fmax_nonempty_TCC1 0
  (fmax_nonempty_TCC1-1 nil 3253546854 ("" (subtype-tcc) nil nil)
   ((real_minus_real_is_real application-judgement "real" reals nil)) nil
   (fmax_nonempty subtype "(number_fields.+)(1, integral_cont_scaf.ii)"
    "below[P`length]")))
 (fmax_nonempty 0
  (fmax_nonempty-2 "" 3790090286
   ("" (skosimp*)
    (("" (expand "nonempty?")
      (("" (expand "empty?")
        (("" (expand "member")
          (("" (inst-cp -1 "f!1(x!1)")
            (("" (skosimp*)
              (("" (ground)
                ((""
                  (inst -
                   "f!1(max_x(seq(P!1)(ii!1), seq(P!1)(1 + ii!1), f!1))")
                  (("" (skosimp*)
                    (("" (ground)
                      (("1" (case "ii!2 = ii!1")
                        (("1" (assert) nil nil)
                         ("2" (hide 2 3)
                          (("2" (lemma "parts_disjoint")
                            (("2" (inst?)
                              (("2" (inst?) (("2" (assert) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide 2)
                        (("2" (hide 1)
                          (("2" (lemma "parts_order")
                            (("2" (case "ii!1 = ii!2")
                              (("1" (assert) nil nil)
                               ("2" (case "ii!1 < ii!2")
                                (("1"
                                  (inst - "a!1" "b!1" "P!1" "ii!1+1" "ii!2")
                                  (("1" (assert) nil nil)) nil)
                                 ("2" (inst - "a!1" "b!1" "P!1" "ii!2" "ii!1")
                                  (("2" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (hide 1 2)
                        (("3" (lemma "parts_order")
                          (("3" (case "ii!1 = ii!2")
                            (("1" (assert) nil nil)
                             ("2" (case "ii!1 < ii!2")
                              (("1"
                                (inst - "a!1" "b!1" "P!1" "ii!1+1" "ii!2+1")
                                (("1" (assert) nil nil)) nil)
                               ("2" (inst - "a!1" "b!1" "P!1" "ii!2+1" "ii!1")
                                (("2" (assert) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nonempty? const-decl "bool" sets nil) (member const-decl "bool" sets nil)
    (< const-decl "bool" reals nil)
    (fun_cont_on type-eq-decl nil interval_minmax nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (max_x const-decl "{mx: T |
   a <= mx AND
    mx <= b AND (FORALL (x: T): a <= x AND x <= b IMPLIES f(mx) >= f(x))}"
     interval_minmax nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (> const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def nil)
    (parts_order formula-decl nil integral_def nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (parts_disjoint formula-decl nil integral_def nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (fun_cont_on type-eq-decl nil integral_cont_scaf nil)
    (restrict const-decl "R" restrict nil)
    (continuous? const-decl "bool" continuous_functions nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (T formal-subtype-decl nil integral_cont_scaf nil)
    (T_pred const-decl "[real -> boolean]" integral_cont_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (empty? const-decl "bool" sets nil))
   shostak)
  (fmax_nonempty-1 nil 3253546854
   ("" (skosimp*)
    (("" (expand "nonempty?")
      (("" (expand "empty?")
        (("" (expand "member")
          (("" (inst-cp -1 "f!1(x!1)")
            (("" (skosimp*)
              (("" (ground)
                ((""
                  (inst -
                   "f!1(max_x(seq(P!1)(ii!1), seq(P!1)(1 + ii!1), f!1))")
                  (("1" (skosimp*)
                    (("1" (ground)
                      (("1" (case "ii!2 = ii!1")
                        (("1" (assert) nil nil)
                         ("2" (hide 2 3)
                          (("2" (lemma "parts_disjoint")
                            (("2" (inst?)
                              (("2" (inst?) (("2" (assert) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide 2)
                        (("2" (hide 1)
                          (("2" (lemma "parts_order")
                            (("2" (case "ii!1 = ii!2")
                              (("1" (assert) nil nil)
                               ("2" (case "ii!1 < ii!2")
                                (("1"
                                  (inst - "a!1" "b!1" "P!1" "ii!1+1" "ii!2")
                                  (("1" (assert) nil nil)) nil)
                                 ("2" (inst - "a!1" "b!1" "P!1" "ii!2" "ii!1")
                                  (("2" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (hide 1 2)
                        (("3" (lemma "parts_order")
                          (("3" (case "ii!1 = ii!2")
                            (("1" (assert) nil nil)
                             ("2" (case "ii!1 < ii!2")
                              (("1"
                                (inst - "a!1" "b!1" "P!1" "ii!1+1" "ii!2+1")
                                (("1" (assert) nil nil)) nil)
                               ("2" (inst - "a!1" "b!1" "P!1" "ii!2+1" "ii!1")
                                (("2" (assert) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (skosimp*)
                    (("2" (hide 2)
                      (("2" (typepred "f!1")
                        (("2" (lemma "cont_interv")
                          (("2" (inst -1 "a!1" "b!1" "f!1" "P!1" "seq(P!1)")
                            (("2" (assert)
                              (("2" (split -1)
                                (("1" (assert)
                                  (("1" (inst?)
                                    (("1" (assert)
                                      (("1"
                                        (expand "continuous?" -1)
                                        (("1" (inst?) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (hide 2)
                                  (("2" (expand "continuous?" 1)
                                    (("2" (propax) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((fun_cont_on type-eq-decl nil interval_minmax nil)
    (max_x const-decl "{mx: T |
   a <= mx AND
    mx <= b AND (FORALL (x: T): a <= x AND x <= b IMPLIES f(mx) >= f(x))}"
     interval_minmax nil)
    (partition type-eq-decl nil integral_def nil)
    (parts_disjoint formula-decl nil integral_def nil)
    (parts_order formula-decl nil integral_def nil)
    (closed_interval type-eq-decl nil intervals_real reals))
   nil))
 (fmin_TCC1 0
  (fmin_TCC1-1 nil 3253546854 ("" (subtype-tcc) nil nil) nil nil
   (fmin subtype "integral_cont_scaf.ii" "below[P`length]")))
 (fmin_TCC2 0
  (fmin_TCC2-1 nil 3253546854 ("" (subtype-tcc) nil nil) nil nil
   (fmin subtype "(number_fields.+)(integral_cont_scaf.ii, 1)"
    "below[P`length]")))
 (fmin_TCC3 0
  (fmin_TCC3-1 nil 3253546854 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" integral_cont_scaf nil)
    (T formal-subtype-decl nil integral_cont_scaf nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil))
   nil
   (fmin subtype
    "integral_cont_scaf.xx((number_fields.+)(integral_cont_scaf.ii, 1))"
    "{x: integral_cont_scaf.T | reals.<(integral_cont_scaf.xx(integral_cont_scaf.ii), x)}")))
 (fmin_TCC4 0
  (fmin_TCC4-2 "" 3790090287
   ("" (skosimp*)
    (("" (typepred "f!1")
      (("" (lemma "cont_interv")
        (("" (inst?)
          (("" (inst?)
            (("" (expand "continuous?" -1)
              (("" (split -1)
                (("1" (inst?) nil nil) ("2" (propax) nil nil)
                 ("3" (propax) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((fun_cont_on type-eq-decl nil integral_cont_scaf nil)
    (restrict const-decl "R" restrict nil)
    (continuous? const-decl "bool" continuous_functions nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-subtype-decl nil integral_cont_scaf nil)
    (T_pred const-decl "[real -> boolean]" integral_cont_scaf nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (> const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def nil)
    (continuous? const-decl "bool" continuous_functions nil)
    (cont_interv formula-decl nil integral_cont_scaf nil))
   shostak
   (fmin subtype "integral_cont_scaf.f"
    "interval_minmax[T].fun_cont_on(integral_cont_scaf.xx(integral_cont_scaf.ii), integral_cont_scaf.xx((number_fields.+)(1, integral_cont_scaf.ii)))"))
  (fmin_TCC4-1 nil 3253546854
   ("" (skosimp*)
    (("" (typepred "f!1")
      (("" (lemma "cont_interv")
        (("" (inst?)
          (("" (inst?)
            (("" (inst -1 "xx!1")
              (("" (expand "continuous?" -1)
                (("" (split -1)
                  (("1" (inst?) nil nil) ("2" (propax) nil nil)
                   ("3" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((closed_interval type-eq-decl nil intervals_real reals)
    (partition type-eq-decl nil integral_def nil))
   nil
   (fmin subtype "integral_cont_scaf.f"
    "interval_minmax[T].fun_cont_on(integral_cont_scaf.xx(integral_cont_scaf.ii), integral_cont_scaf.xx((number_fields.+)(1, integral_cont_scaf.ii)))")))
 (fmin_TCC5 0
  (fmin_TCC5-1 nil 3253546854 ("" (subtype-tcc) nil nil)
   ((real_minus_real_is_real application-judgement "real" reals nil)) nil
   (fmin subtype "(number_fields.+)(integral_cont_scaf.ii, 1)"
    "below[P`length]")))
 (fmin_TCC6 0
  (fmin_TCC6-1 nil 3253546854
   (""
    (inst +
     "(LAMBDA  (a: T, b: {x: T | a < x}, P: partition(a, b),                        f: fun_cont_on(a, b)):            (LAMBDA (x:T): choose({ fv: real  |                   FORALL (ii : below(length(P)-1)):                       (seq(P)(ii) < x AND x < seq(P)(ii+1) IMPLIES                                fv = f(min_x(seq(P)(ii),seq(P)(ii+1),f))) AND                             ((seq(P)(ii) = x OR x = seq(P)(ii+1)) IMPLIES                                fv = f(x))})))")
    (("1" (skosimp*)
      (("1"
        (typepred
         "choose[real]             ({fv: real |                 FORALL (ii: below(length(P!1) - 1)):                   (seq(P!1)(ii) < x!1 AND x!1 < seq(P!1)(1 + ii) IMPLIES                     fv = f!1(min_x(seq(P!1)(ii), seq(P!1)(1 + ii), f!1)))                    AND                    ((seq(P!1)(ii) = x!1 OR x!1 = seq(P!1)(1 + ii)) IMPLIES                      fv = f!1(x!1))})")
        (("1" (inst?) nil nil)
         ("2" (hide 2) (("2" (rewrite "fmin_nonempty") nil nil)) nil)
         ("3" (skosimp*)
          (("3" (lemma "cont_interv")
            (("3" (inst -1 "a!1" "b!1" "f!1" "P!1" "seq(P!1)")
              (("3" (assert)
                (("3" (split -1)
                  (("1" (inst?)
                    (("1" (expand "continuous?" -1) (("1" (inst?) nil nil))
                      nil))
                    nil)
                   ("2" (hide 2)
                    (("2" (typepred "f!1")
                      (("2" (expand "continuous?" 1) (("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("4" (skosimp*) (("4" (assert) nil nil)) nil))
        nil))
      nil)
     ("2" (skosimp*) (("2" (rewrite "fmin_nonempty") nil nil)) nil)
     ("3" (skosimp*)
      (("3" (lemma "cont_interv")
        (("3" (inst -1 "a!1" "b!1" "f!1" "P!1" "seq(P!1)")
          (("3" (assert)
            (("3" (split -1)
              (("1" (inst?)
                (("1" (expand "continuous?" -1) (("1" (inst?) nil nil)) nil))
                nil)
               ("2" (hide 2)
                (("2" (typepred "f!1")
                  (("2" (expand "continuous?" 1) (("2" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skosimp*) (("4" (assert) nil nil)) nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (T formal-subtype-decl nil integral_cont_scaf nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" integral_cont_scaf nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (> const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def nil)
    (continuous? const-decl "bool" continuous_functions nil)
    (restrict const-decl "R" restrict nil)
    (fun_cont_on type-eq-decl nil integral_cont_scaf nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fun_cont_on type-eq-decl nil interval_minmax nil)
    (min_x const-decl "{mx: T |
   a <= mx AND
    mx <= b AND (FORALL (x: T): a <= x AND x <= b IMPLIES f(mx) <= f(x))}"
     interval_minmax nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (continuous? const-decl "bool" continuous_functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cont_interv formula-decl nil integral_cont_scaf nil)
    (fmin_nonempty formula-decl nil integral_cont_scaf nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil))
   nil
   (fmin existence ""
    "[d: [a: integral_cont_scaf.T, b: {x: integral_cont_scaf.T | reals.<(a, x)}, integral_def[T].partition(a, b), integral_cont_scaf.fun_cont_on(a, b)] -> {ff: [integral_cont_scaf.T -> reals.real] | FORALL (ii: naturalnumbers.below((number_fields.-)(length(d`3), 1))): FORALL (x: integral_cont_scaf.T): booleans.AND((booleans.IMPLIES(booleans.AND(reals.<(seq(d`3)(ii), x), reals.<(x, seq(d`3)((number_fields.+)(1, ii)))), ff(x) = d`4(interval_minmax[T].min_x(seq(d`3)(ii), seq(d`3)((number_fields.+)(1, ii)), d`4)))), (booleans.IMPLIES((booleans.OR(seq(d`3)(ii) = x, x = seq(d`3)((number_fields.+)(1, ii)))), ff(x) = d`4(x))))}]")))
 (fmax_TCC1 0
  (fmax_TCC1-1 nil 3253546854 ("" (existence-tcc) nil nil)
   ((real_minus_real_is_real application-judgement "real" reals nil)) nil
   (fmax subtype "(number_fields.+)(integral_cont_scaf.ii, 1)"
    "below[P`length]")))
 (fmax_TCC2 0
  (fmax_TCC2-1 nil 3253546854
   (""
    (inst + "(LAMBDA  (a: T, b: {x: T | a < x}, P: partition(a, b),
                              f: fun_cont_on(a, b)):
                (LAMBDA (x:T): choose({ fv: real  |
                        FORALL (ii : below(length(P)-1)):
                            (seq(P)(ii) < x AND x < seq(P)(ii+1) IMPLIES
                                      fv = f(max_x(seq(P)(ii),seq(P)(ii+1),f))) AND
                                   ((seq(P)(ii) = x OR x = seq(P)(ii+1)) IMPLIES
                                      fv = f(x))})))")
    (("1" (skosimp*)
      (("1"
        (typepred "choose[real]
                         ({fv: real |
                             FORALL (ii: below(length(P!1) - 1)):
                               (seq(P!1)(ii) < x!1 AND x!1 < seq(P!1)(1 + ii) IMPLIES
                                 fv = f!1(max_x(seq(P!1)(ii), seq(P!1)(1 + ii), f!1)))
                                AND
                                ((seq(P!1)(ii) = x!1 OR x!1 = seq(P!1)(1 + ii)) IMPLIES
                                  fv = f!1(x!1))})")
        (("1" (inst?) nil nil)
         ("2" (hide 2) (("2" (rewrite "fmax_nonempty") nil nil)) nil)
         ("3" (skosimp*)
          (("3" (hide 2)
            (("3" (lemma "cont_interv")
              (("3" (inst -1 "a!1" "b!1" "f!1" "P!1" "seq(P!1)")
                (("3" (assert)
                  (("3" (split -1)
                    (("1" (inst?)
                      (("1" (expand "continuous?" -1) (("1" (inst?) nil nil))
                        nil))
                      nil)
                     ("2" (hide 2)
                      (("2" (typepred "f!1")
                        (("2" (expand "continuous?" 1)
                          (("2" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("4" (skosimp*) (("4" (assert) nil nil)) nil))
        nil))
      nil)
     ("2" (skosimp*) (("2" (rewrite "fmax_nonempty") nil nil)) nil)
     ("3" (skosimp*)
      (("3" (lemma "cont_interv")
        (("3" (inst -1 "a!1" "b!1" "f!1" "P!1" "seq(P!1)")
          (("3" (assert)
            (("3" (split -1)
              (("1" (inst?)
                (("1" (expand "continuous?" -1) (("1" (inst?) nil nil)) nil))
                nil)
               ("2" (hide 2)
                (("2" (typepred "f!1")
                  (("2" (expand "continuous?" 1) (("2" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skosimp*) (("4" (assert) nil nil)) nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (T formal-subtype-decl nil integral_cont_scaf nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" integral_cont_scaf nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (> const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def nil)
    (continuous? const-decl "bool" continuous_functions nil)
    (restrict const-decl "R" restrict nil)
    (fun_cont_on type-eq-decl nil integral_cont_scaf nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fun_cont_on type-eq-decl nil interval_minmax nil)
    (max_x const-decl "{mx: T |
   a <= mx AND
    mx <= b AND (FORALL (x: T): a <= x AND x <= b IMPLIES f(mx) >= f(x))}"
     interval_minmax nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (cont_interv formula-decl nil integral_cont_scaf nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (continuous? const-decl "bool" continuous_functions nil)
    (fmax_nonempty formula-decl nil integral_cont_scaf nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil))
   nil
   (fmax existence ""
    "[d: [a: integral_cont_scaf.T, b: {x: integral_cont_scaf.T | reals.<(a, x)}, integral_def[T].partition(a, b), integral_cont_scaf.fun_cont_on(a, b)] -> {ff: [integral_cont_scaf.T -> reals.real] | FORALL (ii: naturalnumbers.below((number_fields.-)(length(d`3), 1))): FORALL (x: integral_cont_scaf.T): booleans.AND((booleans.IMPLIES(booleans.AND(reals.<(seq(d`3)(ii), x), reals.<(x, seq(d`3)((number_fields.+)(1, ii)))), ff(x) = d`4(interval_minmax[T].max_x(seq(d`3)(ii), seq(d`3)((number_fields.+)(1, ii)), d`4)))), (booleans.IMPLIES((booleans.OR(seq(d`3)(ii) = x, x = seq(d`3)((number_fields.+)(1, ii)))), ff(x) = d`4(x))))}]")))
 (fmax_step 0
  (fmax_step-3 "" 3790090294
   ("" (skosimp*)
    (("" (expand "step_function?")
      (("" (expand "step_function_on?")
        (("" (inst + "PP!1")
          (("" (skosimp*)
            ((""
              (inst + "f!1(max_x(seq(PP!1)(ii!1), seq(PP!1)(1 + ii!1), f!1))")
              (("1" (skosimp*)
                (("1" (typepred "fmax(a!1, b!1, PP!1, f!1)")
                  (("1" (inst?) (("1" (assert) nil nil)) nil)) nil))
                nil)
               ("2" (skosimp*)
                (("2" (typepred "f!1")
                  (("2" (lemma "cont_interv")
                    (("2" (inst?)
                      (("2" (inst -1 "PP!1" "seq(PP!1)")
                        (("2" (assert)
                          (("2" (split -1)
                            (("1" (hide -2)
                              (("1" (inst?)
                                (("1" (expand "continuous?" -1)
                                  (("1" (inst?) nil nil)) nil))
                                nil))
                              nil)
                             ("2" (hide 2)
                              (("2" (expand "continuous?" 1)
                                (("2" (propax) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (typepred "PP!1") (("3" (inst?) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((step_function? const-decl "bool" step_fun_def nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" integral_cont_scaf nil)
    (T formal-subtype-decl nil integral_cont_scaf nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (> const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def nil)
    (cont_interv formula-decl nil integral_cont_scaf nil)
    (continuous? const-decl "bool" continuous_functions nil)
    (open_interval type-eq-decl nil intervals_real reals)
    (fmax const-decl "{ff: [T -> real] |
   LET xx = seq(P) IN
     FORALL (ii: below(length(P) - 1)):
       FORALL (x: T):
         (xx(ii) < x AND x < xx(ii + 1) IMPLIES
           ff(x) = f(max_x(xx(ii), xx(ii + 1), f)))
          AND ((xx(ii) = x OR x = xx(ii + 1)) IMPLIES ff(x) = f(x))}"
     integral_cont_scaf nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (max_x const-decl "{mx: T |
   a <= mx AND
    mx <= b AND (FORALL (x: T): a <= x AND x <= b IMPLIES f(mx) >= f(x))}"
     interval_minmax nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fun_cont_on type-eq-decl nil interval_minmax nil)
    (continuous? const-decl "bool" continuous_functions nil)
    (restrict const-decl "R" restrict nil)
    (fun_cont_on type-eq-decl nil integral_cont_scaf nil)
    (f!1 skolem-const-decl "fun_cont_on(a!1, b!1)" integral_cont_scaf nil)
    (a!1 skolem-const-decl "T" integral_cont_scaf nil)
    (b!1 skolem-const-decl "T" integral_cont_scaf nil)
    (PP!1 skolem-const-decl "partition[T](a!1, b!1)" integral_cont_scaf nil)
    (ii!1 skolem-const-decl "below(PP!1`length - 1)" integral_cont_scaf nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (step_function_on? const-decl "bool" step_fun_def nil))
   shostak)
  (fmax_step-2 nil 3306065842
   ("" (skosimp*)
    (("" (expand "step_function?")
      (("" (expand "step_function_on?")
        (("" (inst + "PP!1")
          (("" (skosimp*)
            ((""
              (inst + "f!1(max_x(seq(PP!1)(ii!1), seq(PP!1)(1 + ii!1), f!1))")
              (("1" (skosimp*)
                (("1" (typepred "fmax(a!1, b!1, PP!1, f!1)")
                  (("1" (inst?) (("1" (assert) nil nil)) nil)
                   ("2" (propax) nil nil))
                  nil))
                nil)
               ("2" (skosimp*)
                (("2" (typepred "f!1")
                  (("2" (lemma "cont_interv")
                    (("2" (inst?)
                      (("2" (inst -1 "PP!1" "seq(PP!1)")
                        (("2" (assert)
                          (("2" (split -1)
                            (("1" (hide -2)
                              (("1" (inst?)
                                (("1" (expand "continuous?" -1)
                                  (("1" (inst?) nil nil)) nil))
                                nil))
                              nil)
                             ("2" (hide 2)
                              (("2" (expand "continuous?" 1)
                                (("2" (propax) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (typepred "PP!1") (("3" (inst?) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((step_function? const-decl "bool" step_fun_def nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (partition type-eq-decl nil integral_def nil)
    (fun_cont_on type-eq-decl nil interval_minmax nil)
    (max_x const-decl "{mx: T |
   a <= mx AND
    mx <= b AND (FORALL (x: T): a <= x AND x <= b IMPLIES f(mx) >= f(x))}"
     interval_minmax nil)
    (open_interval type-eq-decl nil intervals_real reals)
    (step_function_on? const-decl "bool" step_fun_def nil))
   nil)
  (fmax_step-1 nil 3292321780
   ("" (skosimp*)
    (("" (expand "step_function?")
      (("" (expand "step_function_on?")
        (("" (inst + "PP!1")
          (("" (skosimp*)
            ((""
              (inst +
               "f!1(max_x[T](seq(PP!1)(ii!1), seq(PP!1)(1 + ii!1), f!1))")
              (("1" (skosimp*)
                (("1" (typepred "fmax(a!1, b!1, PP!1, f!1)")
                  (("1" (inst?) (("1" (assert) nil nil)) nil)
                   ("2" (propax) nil nil))
                  nil))
                nil)
               ("2" (skosimp*)
                (("2" (typepred "f!1")
                  (("2" (lemma "cont_interv")
                    (("2" (inst?)
                      (("2" (inst -1 "PP!1" "seq(PP!1)")
                        (("2" (assert)
                          (("2" (split -1)
                            (("1" (hide -2)
                              (("1" (inst?)
                                (("1" (expand "continuous?" -1)
                                  (("1" (inst?) nil nil)) nil))
                                nil))
                              nil)
                             ("2" (hide 2)
                              (("2" (expand "continuous?" 1)
                                (("2" (propax) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (typepred "PP!1") (("3" (inst?) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((step_function_on? const-decl "bool" step_fun_def nil)
    (partition type-eq-decl nil integral_def nil)
    (step_function? const-decl "bool" step_fun_def nil))
   nil))
 (fmin_step 0
  (fmin_step-3 "" 3790090295
   ("" (skosimp*)
    (("" (expand "step_function?")
      (("" (expand "step_function_on?")
        (("" (inst + "PP!1")
          (("" (skosimp*)
            ((""
              (inst + "f!1(min_x(seq(PP!1)(ii!1), seq(PP!1)(1 + ii!1), f!1))")
              (("1" (skosimp*)
                (("1" (typepred "fmin(a!1, b!1, PP!1, f!1)")
                  (("1" (inst?) (("1" (assert) nil nil)) nil)) nil))
                nil)
               ("2" (skosimp*)
                (("2" (typepred "f!1")
                  (("2" (lemma "cont_interv")
                    (("2" (inst?)
                      (("2" (inst -1 "PP!1" "seq(PP!1)")
                        (("2" (assert)
                          (("2" (split -1)
                            (("1" (inst?)
                              (("1" (expand "continuous?" -1)
                                (("1" (inst?) nil nil)) nil))
                              nil)
                             ("2" (hide 2)
                              (("2" (expand "continuous?" 1)
                                (("2" (propax) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (typepred "PP!1") (("3" (inst?) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((step_function? const-decl "bool" step_fun_def nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" integral_cont_scaf nil)
    (T formal-subtype-decl nil integral_cont_scaf nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (> const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (partition type-eq-decl nil integral_def nil)
    (cont_interv formula-decl nil integral_cont_scaf nil)
    (continuous? const-decl "bool" continuous_functions nil)
    (open_interval type-eq-decl nil intervals_real reals)
    (fmin const-decl "{ff: [T -> real] |
   LET xx = seq(P) IN
     FORALL (ii: below(length(P) - 1)):
       FORALL (x: T):
         (xx(ii) < x AND x < xx(ii + 1) IMPLIES
           ff(x) = f(min_x(xx(ii), xx(ii + 1), f)))
          AND ((xx(ii) = x OR x = xx(ii + 1)) IMPLIES ff(x) = f(x))}"
     integral_cont_scaf nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (min_x const-decl "{mx: T |
   a <= mx AND
    mx <= b AND (FORALL (x: T): a <= x AND x <= b IMPLIES f(mx) <= f(x))}"
     interval_minmax nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fun_cont_on type-eq-decl nil interval_minmax nil)
    (continuous? const-decl "bool" continuous_functions nil)
    (restrict const-decl "R" restrict nil)
    (fun_cont_on type-eq-decl nil integral_cont_scaf nil)
    (f!1 skolem-const-decl "fun_cont_on(a!1, b!1)" integral_cont_scaf nil)
    (a!1 skolem-const-decl "T" integral_cont_scaf nil)
    (b!1 skolem-const-decl "T" integral_cont_scaf nil)
    (PP!1 skolem-const-decl "partition[T](a!1, b!1)" integral_cont_scaf nil)
    (ii!1 skolem-const-decl "below(PP!1`length - 1)" integral_cont_scaf nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (step_function_on? const-decl "bool" step_fun_def nil))
   shostak)
  (fmin_step-2 nil 3306065856
   ("" (skosimp*)
    (("" (expand "step_function?")
      (("" (expand "step_function_on?")
        (("" (inst + "PP!1")
          (("" (skosimp*)
            ((""
              (inst + "f!1(min_x(seq(PP!1)(ii!1), seq(PP!1)(1 + ii!1), f!1))")
              (("1" (skosimp*)
                (("1" (typepred "fmin(a!1, b!1, PP!1, f!1)")
                  (("1" (inst?) (("1" (assert) nil nil)) nil)
                   ("2" (propax) nil nil))
                  nil))
                nil)
               ("2" (skosimp*)
                (("2" (typepred "f!1")
                  (("2" (lemma "cont_interv")
                    (("2" (inst?)
                      (("2" (inst -1 "PP!1" "seq(PP!1)")
                        (("2" (assert)
                          (("2" (split -1)
                            (("1" (inst?)
                              (("1" (expand "continuous?" -1)
                                (("1" (inst?) nil nil)) nil))
                              nil)
                             ("2" (hide 2)
                              (("2" (expand "continuous?" 1)
                                (("2" (propax) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (typepred "PP!1") (("3" (inst?) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((step_function? const-decl "bool" step_fun_def nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (partition type-eq-decl nil integral_def nil)
    (fun_cont_on type-eq-decl nil interval_minmax nil)
    (min_x const-decl "{mx: T |
   a <= mx AND
    mx <= b AND (FORALL (x: T): a <= x AND x <= b IMPLIES f(mx) <= f(x))}"
     interval_minmax nil)
    (open_interval type-eq-decl nil intervals_real reals)
    (step_function_on? const-decl "bool" step_fun_def nil))
   nil)
  (fmin_step-1 nil 3292321808
   ("" (skosimp*)
    (("" (expand "step_function?")
      (("" (expand "step_function_on?")
        (("" (inst + "PP!1")
          (("" (skosimp*)
            ((""
              (inst +
               "f!1(min_x[T](seq(PP!1)(ii!1), seq(PP!1)(1 + ii!1), f!1))")
              (("1" (skosimp*)
                (("1" (typepred "fmin(a!1, b!1, PP!1, f!1)")
                  (("1" (inst?) (("1" (assert) nil nil)) nil)
                   ("2" (propax) nil nil))
                  nil))
                nil)
               ("2" (skosimp*)
                (("2" (typepred "f!1")
                  (("2" (lemma "cont_interv")
                    (("2" (inst?)
                      (("2" (inst -1 "PP!1" "seq(PP!1)")
                        (("2" (assert)
                          (("2" (split -1)
                            (("1" (inst?)
                              (("1" (expand "continuous?" -1)
                                (("1" (inst?) nil nil)) nil))
                              nil)
                             ("2" (hide 2)
                              (("2" (expand "continuous?" 1)
                                (("2" (propax) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (typepred "PP!1") (("3" (inst?) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((step_function_on? const-decl "bool" step_fun_def nil)
    (partition type-eq-decl nil integral_def nil)
    (step_function? const-decl "bool" step_fun_def nil))
   nil))
 (fmax_ge 0
  (fmax_ge-2 "" 3790090296
   ("" (skosimp*)
    (("" (typepred "fmax(a!1, b!1, PP!1, f!1)")
      (("" (typepred "fmin(a!1, b!1, PP!1, f!1)")
        (("" (lemma "part_induction")
          ((""
            (inst -
             "(LAMBDA (x:T): fmax(a!1, b!1, PP!1, f!1)(x) - fmin(a!1, b!1, PP!1, f!1)(x) >= 0)"
             "a!1" "b!1" "PP!1" "x!1")
            (("" (assert)
              (("" (assert)
                (("" (skosimp*)
                  (("" (inst -3 "ii!1")
                    (("" (inst -4 "ii!1")
                      (("" (inst - "x!1")
                        (("" (inst - "x!1")
                          (("" (case-replace "seq(PP!1)(ii!1) = x!1")
                            (("1" (assert) nil nil)
                             ("2" (case-replace "seq(PP!1)(1+ii!1) = x!1")
                              (("1" (assert) nil nil)
                               ("2" (assert)
                                (("2" (replace -3)
                                  (("2" (hide -3)
                                    (("2" (replace -3)
                                      (("2"
                                        (hide -3)
                                        (("2"
                                          (typepred
                                           "max_x(seq(PP!1)(ii!1), seq(PP!1)(1 + ii!1), f!1)")
                                          (("2"
                                            (hide -1 -2 -3)
                                            (("2"
                                              (inst
                                               -1
                                               "min_x(seq(PP!1)(ii!1), seq(PP!1)(1 + ii!1), f!1)")
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((fmax const-decl "{ff: [T -> real] |
   LET xx = seq(P) IN
     FORALL (ii: below(length(P) - 1)):
       FORALL (x: T):
         (xx(ii) < x AND x < xx(ii + 1) IMPLIES
           ff(x) = f(max_x(xx(ii), xx(ii + 1), f)))
          AND ((xx(ii) = x OR x = xx(ii + 1)) IMPLIES ff(x) = f(x))}"
     integral_cont_scaf nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (max_x const-decl "{mx: T |
   a <= mx AND
    mx <= b AND (FORALL (x: T): a <= x AND x <= b IMPLIES f(mx) >= f(x))}"
     interval_minmax nil)
    (fun_cont_on type-eq-decl nil interval_minmax nil)
    (fun_cont_on type-eq-decl nil integral_cont_scaf nil)
    (restrict const-decl "R" restrict nil)
    (continuous? const-decl "bool" continuous_functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (partition type-eq-decl nil integral_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (finite_sequence type-eq-decl nil finite_sequences nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-subtype-decl nil integral_cont_scaf nil)
    (T_pred const-decl "[real -> boolean]" integral_cont_scaf nil)
    (below type-eq-decl nil nat_types nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (part_induction formula-decl nil integral_def nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (min_x const-decl "{mx: T |
   a <= mx AND
    mx <= b AND (FORALL (x: T): a <= x AND x <= b IMPLIES f(mx) <= f(x))}"
     interval_minmax nil)
    (fmin const-decl "{ff: [T -> real] |
   LET xx = seq(P) IN
     FORALL (ii: below(length(P) - 1)):
       FORALL (x: T):
         (xx(ii) < x AND x < xx(ii + 1) IMPLIES
           ff(x) = f(min_x(xx(ii), xx(ii + 1), f)))
          AND ((xx(ii) = x OR x = xx(ii + 1)) IMPLIES ff(x) = f(x))}"
     integral_cont_scaf nil))
   shostak)
  (fmax_ge-1 nil 3292321887
   ("" (skosimp*)
    (("" (typepred "fmax(a!1, b!1, PP!1, f!1)")
      (("1" (typepred "fmin(a!1, b!1, PP!1, f!1)")
        (("1" (lemma "part_induction")
          (("1"
            (inst -
             "(LAMBDA (x:T): fmax(a!1, b!1, PP!1, f!1)(x) - fmin(a!1, b!1, PP!1, f!1)(x) >= 0)"
             "a!1" "b!1" "PP!1" "x!1")
            (("1" (assert)
              (("1" (assert)
                (("1" (skosimp*)
                  (("1" (inst -3 "ii!1")
                    (("1" (inst -4 "ii!1")
                      (("1" (inst - "x!1")
                        (("1" (inst - "x!1")
                          (("1" (case-replace "seq(PP!1)(ii!1) = x!1")
                            (("1" (assert) nil nil)
                             ("2" (case-replace "seq(PP!1)(1+ii!1) = x!1")
                              (("1" (assert) nil nil)
                               ("2" (assert)
                                (("2" (replace -3)
                                  (("2" (hide -3)
                                    (("2" (replace -3)
                                      (("2"
                                        (hide -3)
                                        (("2"
                                          (typepred
                                           "max_x(seq(PP!1)(ii!1), seq(PP!1)(1 + ii!1), f!1)")
                                          (("1"
                                            (hide -1 -2 -3)
                                            (("1"
                                              (inst
                                               -1
                                               "min_x(seq(PP!1)(ii!1), seq(PP!1)(1 + ii!1), f!1)")
                                              (("1" (assert) nil nil)
                                               ("2"
                                                (skosimp*)
                                                (("2"
                                                  (hide-all-but 1)
                                                  (("2"
                                                    (typepred "f!1")
                                                    (("2"
                                                      (inst?)
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (lemma
                                                           "cont_interv")
                                                          (("2"
                                                            (inst?)
                                                            (("2"
                                                              (inst
                                                               -1
                                                               "PP!1"
                                                               "seq(PP!1)")
                                                              (("2"
                                                                (split -1)
                                                                (("1"
                                                                  (inst?)
                                                                  (("1"
                                                                    (assert)
                                                                    (("1"
                                                                      (expand
                                                                       "continuous?"
                                                                       -1)
                                                                      (("1"
                                                                        (inst
                                                                         -1
                                                                         "x!2")
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (hide 2)
                                                                  (("2"
                                                                    (hide -1)
                                                                    (("2"
                                                                      (typepred
                                                                       "f!1")
                                                                      (("2"
                                                                        (expand
                                                                         "continuous?"
                                                                         1)
                                                                        (("2"
                                                                          (propax)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (skosimp*)
                                            (("2"
                                              (hide-all-but 1)
                                              (("2"
                                                (lemma "cont_interv")
                                                (("2"
                                                  (inst
                                                   -1
                                                   "a!1"
                                                   "b!1"
                                                   "f!1"
                                                   "PP!1"
                                                   "seq(PP!1)")
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (split -1)
                                                      (("1"
                                                        (inst?)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (expand
                                                             "continuous?"
                                                             -1)
                                                            (("1"
                                                              (inst?)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (hide 2)
                                                        (("2"
                                                          (typepred "f!1")
                                                          (("2"
                                                            (expand
                                                             "continuous?"
                                                             1)
                                                            (("2"
                                                              (propax)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert) (("2" (skosimp*) nil nil)) nil))
            nil))
          nil))
        nil)
       ("2" (propax) nil nil))
      nil))
    nil)
   ((max_x const-decl "{mx: T |
   a <= mx AND
    mx <= b AND (FORALL (x: T): a <= x AND x <= b IMPLIES f(mx) >= f(x))}"
     interval_minmax nil)
    (fun_cont_on type-eq-decl nil interval_minmax nil)
    (partition type-eq-decl nil integral_def nil)
    (closed_interval type-eq-decl nil intervals_real reals)
    (part_induction formula-decl nil integral_def nil)
    (min_x const-decl "{mx: T |
   a <= mx AND
    mx <= b AND (FORALL (x: T): a <= x AND x <= b IMPLIES f(mx) <= f(x))}"
     interval_minmax nil))
   nil)))

