(lim_of_composition
 (adherence_lemma 0
  (adherence_lemma-1 nil 3473169489
   (""
    (grind :exclude ("convergence" "abs") :rewrites
     ("adh[T1]" "adh[T2]" "convergence_def[T1]") :if-match nil)
    (("" (inst? -6)
      (("" (skolem!)
        (("" (inst -5 "delta!1")
          (("" (skolem!)
            (("" (inst?) (("" (inst?) (("" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (T2_pred const-decl "[real -> boolean]" lim_of_composition nil)
    (T2 formal-subtype-decl nil lim_of_composition nil)
    (convergence_def formula-decl nil lim_of_functions nil)
    (adh const-decl "setof[real]" convergence_functions nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T1_pred const-decl "[real -> boolean]" lim_of_composition nil)
    (T1 formal-subtype-decl nil lim_of_composition nil)
    (fullset const-decl "set" sets nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (adherence_lemma2 0
  (adherence_lemma2-1 nil 3473169489
   ("" (skosimp)
    (("" (use "lim_fun_lemma[T1]")
      (("" (forward-chain "adherence_lemma") nil nil)) nil))
    nil)
   ((lim_fun_lemma formula-decl nil lim_of_functions nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T1_pred const-decl "[real -> boolean]" lim_of_composition nil)
    (T1 formal-subtype-decl nil lim_of_composition nil)
    (convergent? const-decl "bool" lim_of_functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (T2 formal-subtype-decl nil lim_of_composition nil)
    (T2_pred const-decl "[real -> boolean]" lim_of_composition nil)
    (lim const-decl "{l: real | convergence(f, x0, l)}" lim_of_functions nil)
    (convergence const-decl "bool" lim_of_functions nil)
    (adherence_lemma formula-decl nil lim_of_composition nil))
   nil))
 (convergence_composition 0
  (convergence_composition-1 nil 3473169489
   (""
    (grind :exclude ("convergence" "abs" "adh") :rewrites
     ("convergence_def[T2]" "convergence_def[T1]") :if-match nil)
    (("" (delete -1 -2 -3 -4 -5 -6 -8)
      (("" (inst -2 "epsilon!1")
        (("" (skolem!)
          (("" (inst -1 "delta!1")
            (("" (skolem!)
              (("" (inst 1 "delta!2")
                (("" (skosimp)
                  (("" (inst?) (("" (inst?) (("" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (O const-decl "T3" function_props nil)
    (T2_pred const-decl "[real -> boolean]" lim_of_composition nil)
    (T2 formal-subtype-decl nil lim_of_composition nil)
    (convergence_def formula-decl nil lim_of_functions nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T1_pred const-decl "[real -> boolean]" lim_of_composition nil)
    (T1 formal-subtype-decl nil lim_of_composition nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (convergent_composition 0
  (convergent_composition-2 "" 3790089909
   ("" (lemma "convergence_composition")
    (("" (grind :defs nil :rewrites ("convergent?[T1]" "convergent?[T2]"))
      (("" (rewrite "lim_fun_def[T1]" :dir rl) nil nil)) nil))
    nil)
   ((T1 formal-subtype-decl nil lim_of_composition nil)
    (T1_pred const-decl "[real -> boolean]" lim_of_composition nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (convergent? const-decl "bool" lim_of_functions nil)
    (T2 formal-subtype-decl nil lim_of_composition nil)
    (T2_pred const-decl "[real -> boolean]" lim_of_composition nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (lim_fun_def formula-decl nil lim_of_functions nil)
    (convergence_composition formula-decl nil lim_of_composition nil))
   shostak)
  (convergent_composition-1 nil 3473169489
   ("" (lemma "convergence_composition")
    (("" (grind :defs nil :rewrites ("convergent?[T1]" "convergent?[T2]"))
      (("" (rewrite "lim_fun_def[T1]" :dir rl) (("" (inst?) nil nil)) nil))
      nil))
    nil)
   ((convergent? const-decl "bool" lim_of_functions nil)
    (lim_fun_def formula-decl nil lim_of_functions nil))
   nil))
 (lim_composition_TCC1 0
  (lim_composition_TCC1-1 nil 3473169489
   ("" (skosimp) (("" (rewrite "convergent_composition") nil nil)) nil)
   ((convergent_composition formula-decl nil lim_of_composition nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T1_pred const-decl "[real -> boolean]" lim_of_composition nil)
    (T1 formal-subtype-decl nil lim_of_composition nil)
    (T2_pred const-decl "[real -> boolean]" lim_of_composition nil)
    (T2 formal-subtype-decl nil lim_of_composition nil))
   nil
   (lim_composition subtype "lim_of_composition.x"
    "{a | lim_of_functions[T1].convergent?(function_props[T1, T2, real].o(lim_of_composition.g, lim_of_composition.f), lim_of_functions.a)}")))
 (lim_composition 0
  (lim_composition-1 nil 3473169489
   ("" (skosimp)
    (("" (assert)
      (("" (auto-rewrite "adherence_lemma2" "convergent_composition")
        (("" (rewrite "lim_fun_def[T1]")
          (("" (use "lim_fun_lemma[T2]")
            (("" (use "lim_fun_lemma[T1]" ("f" "f!1"))
              (("" (forward-chain "convergence_composition") nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lim_fun_def formula-decl nil lim_of_functions nil)
    (T2_pred const-decl "[real -> boolean]" lim_of_composition nil)
    (T2 formal-subtype-decl nil lim_of_composition nil)
    (O const-decl "T3" function_props nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (convergent? const-decl "bool" lim_of_functions nil)
    (convergence const-decl "bool" lim_of_functions nil)
    (lim const-decl "{l: real | convergence(f, x0, l)}" lim_of_functions nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T1_pred const-decl "[real -> boolean]" lim_of_composition nil)
    (T1 formal-subtype-decl nil lim_of_composition nil)
    (convergence_composition formula-decl nil lim_of_composition nil)
    (lim_fun_lemma formula-decl nil lim_of_functions nil))
   nil))
 (convergence_comp_continuous 0
  (convergence_comp_continuous-1 nil 3473169489
   ("" (skosimp)
    (("" (rewrite continuity_def)
      (("" (forward-chain "convergence_composition") nil nil)) nil))
    nil)
   ((continuity_def formula-decl nil continuous_functions nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T2_pred const-decl "[real -> boolean]" lim_of_composition nil)
    (T2 formal-subtype-decl nil lim_of_composition nil)
    (T1 formal-subtype-decl nil lim_of_composition nil)
    (T1_pred const-decl "[real -> boolean]" lim_of_composition nil)
    (convergence_composition formula-decl nil lim_of_composition nil))
   nil))
 (convergent_comp_continuous 0
  (convergent_comp_continuous-1 nil 3473169489
   ("" (skosimp)
    (("" (assert)
      (("" (auto-rewrite "lim_fun_lemma[T1]")
        (("" (use "convergence_comp_continuous" ("z" "lim(f!1, x!1)"))
          (("" (assert)
            (("" (expand "convergent?" +) (("" (inst?) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((convergence_comp_continuous formula-decl nil lim_of_composition nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T2_pred const-decl "[real -> boolean]" lim_of_composition nil)
    (T2 formal-subtype-decl nil lim_of_composition nil)
    (T1_pred const-decl "[real -> boolean]" lim_of_composition nil)
    (T1 formal-subtype-decl nil lim_of_composition nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (convergent? const-decl "bool" lim_of_functions nil)
    (convergence const-decl "bool" lim_of_functions nil)
    (lim const-decl "{l: real | convergence(f, x0, l)}" lim_of_functions nil))
   nil))
 (lim_comp_continuous_TCC1 0
  (lim_comp_continuous_TCC1-1 nil 3473169489
   ("" (skosimp) (("" (rewrite "convergent_comp_continuous") nil nil)) nil)
   ((convergent_comp_continuous formula-decl nil lim_of_composition nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T1_pred const-decl "[real -> boolean]" lim_of_composition nil)
    (T1 formal-subtype-decl nil lim_of_composition nil)
    (T2_pred const-decl "[real -> boolean]" lim_of_composition nil)
    (T2 formal-subtype-decl nil lim_of_composition nil))
   nil
   (lim_comp_continuous subtype "lim_of_composition.x"
    "{a | lim_of_functions[T1].convergent?(function_props[T1, T2, real].o(lim_of_composition.g, lim_of_composition.f), lim_of_functions.a)}")))
 (lim_comp_continuous 0
  (lim_comp_continuous-1 nil 3473169489
   ("" (skosimp)
    (("" (assert)
      (("" (auto-rewrite "convergent_comp_continuous")
        (("" (rewrite "lim_fun_def[T1]")
          (("" (use "lim_fun_lemma[T1]")
            (("" (forward-chain "convergence_comp_continuous") nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((lim_fun_def formula-decl nil lim_of_functions nil)
    (T2_pred const-decl "[real -> boolean]" lim_of_composition nil)
    (T2 formal-subtype-decl nil lim_of_composition nil)
    (O const-decl "T3" function_props nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (convergent? const-decl "bool" lim_of_functions nil)
    (convergence const-decl "bool" lim_of_functions nil)
    (lim const-decl "{l: real | convergence(f, x0, l)}" lim_of_functions nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T1_pred const-decl "[real -> boolean]" lim_of_composition nil)
    (T1 formal-subtype-decl nil lim_of_composition nil)
    (convergence_comp_continuous formula-decl nil lim_of_composition nil)
    (lim_fun_lemma formula-decl nil lim_of_functions nil))
   nil)))

