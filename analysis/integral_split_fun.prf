(integral_split_fun
 (connected_domain 0
  (connected_domain-1 nil 3580211873 ("" (postpone) nil nil) nil shostak))
 (split_fun?_split_fun 0
  (split_fun?_split_fun-1 nil 3580207215
   ("" (skeep)
    (("" (expand "split_fun")
      (("" (expand "split_fun?") (("" (inst + "tSplit" "r1" "r2") nil nil))
        nil))
      nil))
    nil)
   ((split_fun const-decl "[T -> real]" integral_split_fun nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" integral_split_fun nil)
    (T formal-nonempty-subtype-decl nil integral_split_fun nil)
    (split_fun? const-decl "bool" integral_split_fun nil))
   shostak))
 (Integrable_Split_fun_TCC1 0
  (Integrable_Split_fun_TCC1-1 nil 3610803562
   ("" (skosimp*)
    (("" (lemma "connected_domain") (("" (propax) nil nil)) nil)) nil)
   ((connected_domain formula-decl nil integral_split_fun nil)) nil
   (Integrable_Split_fun assuming "integral_def[T].integral_def"
    "connected_domain: ASSUMPTION deriv_domain_def[T].connected?")))
 (Integrable_Split_fun_TCC2 0
  (Integrable_Split_fun_TCC2-1 nil 3610803562
   ("" (skosimp*) (("" (lemma "not_one_element") (("" (propax) nil nil)) nil))
    nil)
   ((not_one_element formula-decl nil integral_split_fun nil)) nil
   (Integrable_Split_fun assuming "integral_def[T].integral_def"
    "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?")))
 (split_fun_Integrable_TCC1 0
  (split_fun_Integrable_TCC1-1 nil 3601219687
   ("" (lemma "connected_domain") (("" (skeep) nil nil)) nil)
   ((connected_domain formula-decl nil integral_split_fun nil)) nil
   (split_fun_Integrable assuming "integral_def[T].integral_def"
    "connected_domain: ASSUMPTION deriv_domain_def[T].connected?")))
 (split_fun_Integrable_TCC2 0
  (split_fun_Integrable_TCC2-1 nil 3601219687
   ("" (skeep) (("" (lemma "not_one_element") (("" (propax) nil nil)) nil))
    nil)
   ((not_one_element formula-decl nil integral_split_fun nil)) nil
   (split_fun_Integrable assuming "integral_def[T].integral_def"
    "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?")))
 (split_fun_Integrable 0
  (split_fun_Integrable-3 nil 3611418980
   ("" (skeep)
    (("" (case-replace "t0 = t1")
      (("1" (rewrite "Integrable?_a_to_a[T]")
        (("1" (lemma "not_one_element") (("1" (propax) nil nil)) nil)
         ("2" (lemma "connected_domain") (("2" (propax) nil nil)) nil))
        nil)
       ("2" (lemma "Integral_split[T]")
        (("1" (inst - "t0" "tSplit" "t1" "split_fun(tSplit, r1, r2)")
          (("1" (assert)
            (("1" (hide 3)
              (("1" (lemma "Integral_restr_eq[T]")
                (("1" (split +)
                  (("1"
                    (inst - "t0" "tSplit" "r1" "split_fun(tSplit, r1, r2)")
                    (("1" (assert)
                      (("1" (skosimp*)
                        (("1" (case-replace "t0 = tSplit")
                          (("1" (rewrite "Integrable?_a_to_a[T]") nil nil)
                           ("2" (hide 2)
                            (("2" (expand "split_fun")
                              (("2" (assert)
                                (("2" (typepred "x!1")
                                  (("2" (assert)
                                    (("2" (lift-if) (("2" (ground) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2"
                    (inst - "tSplit" "t1" "r2" "split_fun(tSplit, r1, r2)")
                    (("2" (assert)
                      (("2" (hide 1)
                        (("2" (skosimp*)
                          (("2" (typepred "x!1")
                            (("2" (expand "split_fun")
                              (("2" (assert)
                                (("2" (lift-if) (("2" (ground) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
         ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" integral_split_fun nil)
    (T formal-nonempty-subtype-decl nil integral_split_fun nil)
    (connected_domain formula-decl nil integral_split_fun nil)
    (not_one_element formula-decl nil integral_split_fun nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (split_fun const-decl "[T -> real]" integral_split_fun nil)
    (Integrable?_a_to_a formula-decl nil integral nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (not_one_element? const-decl "bool" deriv_domain_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (Open_interval type-eq-decl nil intervals_real reals)
    (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Integral_restr_eq formula-decl nil integral nil)
    (Integral_split formula-decl nil integral nil))
   nil)
  (split_fun_Integrable-2 nil 3602589166
   ("" (skeep)
    (("" (case-replace "t0 = t1")
      (("1" (rewrite "Integrable?_a_to_a[T]")
        (("1" (lemma "not_one_element") (("1" (propax) nil nil)) nil)
         ("2" (lemma "connected_domain") (("2" (propax) nil nil)) nil))
        nil)
       ("2" (lemma "Integral_split_fun[T]")
        (("1" (inst - "t0" "tSplit" "t1" "split_fun(tSplit, r1, r2)")
          (("1" (assert)
            (("1" (hide 3)
              (("1" (lemma "Integral_restr_eq[T]")
                (("1" (split +)
                  (("1"
                    (inst - "t0" "tSplit" "r1" "split_fun(tSplit, r1, r2)")
                    (("1" (assert)
                      (("1" (skosimp*)
                        (("1" (case-replace "t0 = tSplit")
                          (("1" (rewrite "Integrable?_a_to_a[T]") nil nil)
                           ("2" (hide 2)
                            (("2" (expand "split_fun")
                              (("2" (assert)
                                (("2" (typepred "x!1")
                                  (("2" (assert)
                                    (("2" (lift-if) (("2" (ground) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2"
                    (inst - "tSplit" "t1" "r2" "split_fun(tSplit, r1, r2)")
                    (("2" (assert)
                      (("2" (hide 1)
                        (("2" (skosimp*)
                          (("2" (typepred "x!1")
                            (("2" (expand "split_fun")
                              (("2" (assert)
                                (("2" (lift-if) (("2" (ground) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
         ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil))
        nil))
      nil))
    nil)
   ((Integrable?_a_to_a formula-decl nil integral nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (not_one_element? const-decl "bool" deriv_domain_def nil)
    (Open_interval type-eq-decl nil intervals_real reals)
    (Integral_restr_eq formula-decl nil integral nil))
   nil)
  (split_fun_Integrable-1 nil 3580065368
   ("" (skeep)
    (("" (typepred "r1")
      (("" (typepred "r2")
        (("" (case "t0<tSplit")
          (("1" (case "t1<t0")
            (("1" (lemma "derivable_Integrable?[T]")
              (("1" (inst - "t1" "t0" "r1")
                (("1" (lemma "integral_restr_eq[T]")
                  (("1" (inst -1 "t1" "t0" "r1" "split_fun(tSplit, r1, r2)")
                    (("1" (assert)
                      (("1" (split)
                        (("1" (flatten)
                          (("1" (expand "Integrable?")
                            (("1" (propax) nil nil)) nil))
                          nil)
                         ("2" (hide 2)
                          (("2" (skeep)
                            (("2" (expand "split_fun")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil)
                         ("3" (hide 2)
                          (("3" (expand "Integrable?")
                            (("3" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
               ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil))
              nil)
             ("2" (case "t1>tSplit")
              (("1" (lemma "integral_split[T]")
                (("1" (inst - "t0" "tSplit" "t1" "split_fun(tSplit, r1, r2)")
                  (("1" (assert)
                    (("1" (split)
                      (("1" (flatten)
                        (("1" (hide -2)
                          (("1" (expand "Integrable?")
                            (("1" (propax) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (hide 2 3)
                        (("2" (lemma "derivable_Integrable?[T]")
                          (("2" (inst -1 "t0" "tSplit" "r1")
                            (("2" (assert)
                              (("2" (lemma "integral_restr_eq[T]")
                                (("2"
                                  (inst -1 "t0" "tSplit" "r1"
                                   "split_fun(tSplit, r1, r2)")
                                  (("2" (assert)
                                    (("2" (split)
                                      (("1"
                                        (skeep)
                                        (("1"
                                          (expand "split_fun")
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (expand "Integrable?")
                                        (("2" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (hide 2 3)
                        (("3" (lemma "derivable_Integrable?[T]")
                          (("3" (inst -1 "tSplit" "t1" "r1")
                            (("3" (assert)
                              (("3" (lemma "integral_restr_eq[T]")
                                (("3"
                                  (inst -1 "tSplit" "t1" "r2"
                                   "split_fun(tSplit, r1, r2)")
                                  (("3" (assert)
                                    (("3" (split)
                                      (("1"
                                        (skeep)
                                        (("1"
                                          (expand "split_fun")
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (expand "Integrable?")
                                        (("2"
                                          (lemma "derivable_Integrable?[T]")
                                          (("2"
                                            (inst -1 "tSplit" "t1" "r2")
                                            (("2"
                                              (assert)
                                              (("2"
                                                (expand "Integrable?")
                                                (("2" (propax) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
                 ("3" (lemma "connected_domain") (("3" (propax) nil nil))
                  nil))
                nil)
               ("2" (flip-ineq 1)
                (("2" (flip-ineq 1)
                  (("2" (lemma "derivable_Integrable?[T]")
                    (("1" (inst -1 "t0" "t1" "r1")
                      (("1" (assert)
                        (("1" (case "t0<t1")
                          (("1" (lemma "integral_restr_eq[T]")
                            (("1"
                              (inst -1 "t0" "t1" "r1"
                               "split_fun(tSplit, r1, r2)")
                              (("1" (assert)
                                (("1" (split)
                                  (("1" (flatten)
                                    (("1" (expand "Integrable?")
                                      (("1" (propax) nil nil)) nil))
                                    nil)
                                   ("2" (hide 2)
                                    (("2" (skeep)
                                      (("2"
                                        (expand "split_fun")
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3" (hide 2)
                                    (("3" (expand "Integrable?")
                                      (("3" (propax) nil nil)) nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flip-ineq 1)
                            (("2" (case "t0=t1")
                              (("1" (lemma "Integrable?_a_to_a[T]")
                                (("1"
                                  (inst -1 "t1" "split_fun(tSplit, r1, r2)")
                                  (("1" (replace -2) (("1" (propax) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (lemma "not_one_element") (("2" (propax) nil nil))
                      nil)
                     ("3" (lemma "connected_domain") (("3" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flip-ineq 1)
            (("2" (case "t0<t1")
              (("1" (lemma "derivable_Integrable?[T]")
                (("1" (inst -1 "t0" "t1" "r2")
                  (("1" (assert)
                    (("1" (lemma "integral_restr_eq[T]")
                      (("1"
                        (inst -1 "t0" "t1" "r2" "split_fun(tSplit, r1, r2)")
                        (("1" (assert)
                          (("1" (split)
                            (("1" (flatten)
                              (("1" (expand "Integrable?")
                                (("1" (propax) nil nil)) nil))
                              nil)
                             ("2" (hide 2)
                              (("2" (skeep)
                                (("2" (expand "split_fun")
                                  (("2" (assert) nil nil)) nil))
                                nil))
                              nil)
                             ("3" (hide 2)
                              (("3" (expand "Integrable?")
                                (("3" (propax) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
                 ("3" (lemma "connected_domain") (("3" (propax) nil nil))
                  nil))
                nil)
               ("2" (flip-ineq 1)
                (("2" (case "t0=t1")
                  (("1" (lemma "Integrable?_a_to_a[T]")
                    (("1" (inst -1 "t1" "split_fun(tSplit, r1, r2)")
                      (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil)
                     ("2" (lemma "not_one_element") (("2" (propax) nil nil))
                      nil)
                     ("3" (lemma "connected_domain") (("3" (propax) nil nil))
                      nil))
                    nil)
                   ("2" (case "tSplit<t1")
                    (("1" (expand "Integrable?")
                      (("1" (assert)
                        (("1" (lemma "derivable_Integrable?[T]")
                          (("1" (inst -1 "t1" "t0" "r2")
                            (("1" (assert)
                              (("1" (lemma "integral_restr_eq[T]")
                                (("1"
                                  (inst -1 "t1" "t0" "r2"
                                   "split_fun(tSplit, r1, r2)")
                                  (("1" (assert)
                                    (("1" (split)
                                      (("1"
                                        (skeep)
                                        (("1"
                                          (expand "split_fun" 1)
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (expand "Integrable?")
                                        (("2" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (lemma "not_one_element")
                            (("2" (propax) nil nil)) nil)
                           ("3" (lemma "connected_domain")
                            (("3" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flip-ineq 1)
                      (("2" (case "tSplit=t0")
                        (("1" (case "t1<tSplit")
                          (("1" (lemma "derivable_Integrable?[T]")
                            (("1" (inst -1 "t1" "tSplit" "r1")
                              (("1" (assert)
                                (("1" (lemma "integral_restr_eq[T]")
                                  (("1"
                                    (inst -1 "t1" "tSplit" "r1"
                                     "split_fun(tSplit, r1, r2)")
                                    (("1" (assert)
                                      (("1"
                                        (split)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (expand "Integrable?")
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (skeep)
                                          (("2"
                                            (expand "split_fun")
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil)
                                         ("3"
                                          (expand "Integrable?")
                                          (("3" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (lemma "not_one_element")
                              (("2" (propax) nil nil)) nil)
                             ("3" (lemma "connected_domain")
                              (("3" (propax) nil nil)) nil))
                            nil)
                           ("2" (flip-ineq 1)
                            (("2" (lemma "derivable_Integrable?[T]")
                              (("1" (inst -1 "t1" "t0" "r2")
                                (("1" (assert) nil nil)) nil)
                               ("2" (lemma "not_one_element")
                                (("2" (propax) nil nil)) nil)
                               ("3" (lemma "connected_domain")
                                (("3" (propax) nil nil)) nil))
                              nil))
                            nil))
                          nil)
                         ("2" (case "t1<tSplit")
                          (("1" (lemma "integral_split[T]")
                            (("1"
                              (inst -1 "t1" "tSplit" "t0"
                               "split_fun(tSplit, r1, r2)")
                              (("1" (assert)
                                (("1" (split)
                                  (("1" (flatten)
                                    (("1" (hide -2)
                                      (("1"
                                        (expand "Integrable?")
                                        (("1" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (lemma "derivable_Integrable?[T]")
                                    (("2" (inst -1 "t1" "tSplit" "r1")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (lemma "integral_restr_eq[T]")
                                          (("2"
                                            (inst
                                             -1
                                             "t1"
                                             "tSplit"
                                             "r1"
                                             "split_fun(tSplit, r1, r2)")
                                            (("2"
                                              (assert)
                                              (("2"
                                                (split)
                                                (("1"
                                                  (skeep)
                                                  (("1"
                                                    (expand "split_fun")
                                                    (("1" (assert) nil nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (expand "Integrable?")
                                                  (("2" (propax) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3" (lemma "derivable_Integrable?[T]")
                                    (("3" (inst -1 "tSplit" "t0" "r2")
                                      (("3"
                                        (assert)
                                        (("3"
                                          (lemma "integral_restr_eq[T]")
                                          (("3"
                                            (inst
                                             -1
                                             "tSplit"
                                             "t0"
                                             "r2"
                                             "split_fun(tSplit, r1, r2)")
                                            (("3"
                                              (assert)
                                              (("3"
                                                (split)
                                                (("1"
                                                  (skeep)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (expand "split_fun")
                                                      (("1" (propax) nil nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (expand "Integrable?")
                                                  (("2" (propax) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (lemma "not_one_element")
                              (("2" (propax) nil nil)) nil)
                             ("3" (lemma "connected_domain")
                              (("3" (propax) nil nil)) nil))
                            nil)
                           ("2" (flip-ineq 1)
                            (("2" (lemma "derivable_Integrable?[T]")
                              (("1" (inst -1 "t1" "t0" "r2")
                                (("1" (assert)
                                  (("1" (lemma "integral_restr_eq[T]")
                                    (("1"
                                      (inst
                                       -1
                                       "t1"
                                       "t0"
                                       "r2"
                                       "split_fun(tSplit, r1, r2)")
                                      (("1"
                                        (assert)
                                        (("1"
                                          (split)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (hide -2)
                                              (("1"
                                                (expand "Integrable?")
                                                (("1" (propax) nil nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (skeep)
                                            (("2"
                                              (expand "split_fun")
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil)
                                           ("3"
                                            (expand "Integrable?")
                                            (("3" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (lemma "not_one_element")
                                (("2" (propax) nil nil)) nil)
                               ("3" (lemma "connected_domain")
                                (("3" (propax) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((derivable? const-decl "bool" derivatives nil)
    (Integrable?_a_to_a formula-decl nil integral nil)
    (derivable_Integrable? formula-decl nil fundamental_theorem nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (not_one_element? const-decl "bool" deriv_domain_def nil)
    (Integrable? const-decl "bool" integral_def nil))
   shostak))
 (Integral_split_fun_TCC1 0
  (Integral_split_fun_TCC1-1 nil 3602604443
   ("" (skosimp*)
    (("" (lemma "Integrable?_inside[T]")
      (("1"
        (inst -1 "t0!1" "t1!1" "split_fun(tSplit!1, r1!1, r2!1)" "t0!1"
         "tt!1")
        (("1" (assert) nil nil)) nil)
       ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
       ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil))
      nil))
    nil)
   ((T formal-nonempty-subtype-decl nil integral_split_fun nil)
    (T_pred const-decl "[real -> boolean]" integral_split_fun nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Integrable?_inside formula-decl nil integral nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (not_one_element? const-decl "bool" deriv_domain_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (split_fun const-decl "[T -> real]" integral_split_fun nil)
    (not_one_element formula-decl nil integral_split_fun nil)
    (connected_domain formula-decl nil integral_split_fun nil))
   nil
   (Integral_split_fun subtype
    "integral_split_fun.split_fun(integral_split_fun.tSplit, integral_split_fun.r1, integral_split_fun.r2)"
    "integral_def[T].Integrable_funs(integral_split_fun.t0, integral_split_fun.tt)")))
 (Integral_split_fun_TCC2 0
  (Integral_split_fun_TCC2-1 nil 3602604443
   ("" (skosimp*)
    (("" (lemma "Integrable?_inside[T]")
      (("1" (inst -1 "t0!1" "tSplit!1" "r1!1" "t0!1" "tt!1")
        (("1" (assert) nil nil)) nil)
       ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
       ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil))
      nil))
    nil)
   ((T formal-nonempty-subtype-decl nil integral_split_fun nil)
    (T_pred const-decl "[real -> boolean]" integral_split_fun nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Integrable?_inside formula-decl nil integral nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (not_one_element? const-decl "bool" deriv_domain_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (not_one_element formula-decl nil integral_split_fun nil)
    (connected_domain formula-decl nil integral_split_fun nil))
   nil
   (Integral_split_fun subtype "integral_split_fun.r1"
    "integral_def[T].Integrable_funs(integral_split_fun.t0, integral_split_fun.tt)")))
 (Integral_split_fun_TCC3 0
  (Integral_split_fun_TCC3-1 nil 3602604443
   ("" (skosimp*)
    (("" (lemma "Integrable?_inside[T]")
      (("1" (inst -1 "tSplit!1" "t1!1" "r2!1" "tSplit!1" "tt!1")
        (("1" (assert) nil nil)) nil)
       ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
       ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil))
      nil))
    nil)
   ((T formal-nonempty-subtype-decl nil integral_split_fun nil)
    (T_pred const-decl "[real -> boolean]" integral_split_fun nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Integrable?_inside formula-decl nil integral nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (not_one_element? const-decl "bool" deriv_domain_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (not_one_element formula-decl nil integral_split_fun nil)
    (connected_domain formula-decl nil integral_split_fun nil))
   nil
   (Integral_split_fun subtype "integral_split_fun.r2"
    "integral_def[T].Integrable_funs(integral_split_fun.tSplit, integral_split_fun.tt)")))
 (Integral_split_fun 0
  (Integral_split_fun-2 nil 3611419189
   ("" (skeep)
    (("" (lemma "split_fun_Integrable")
      (("" (inst?)
        (("" (assert)
          (("" (case "tt < tSplit")
            (("1" (lemma "Integral_restr_eq[T]")
              (("1" (inst - "t0" "tt" "r1" "split_fun(tSplit, r1, r2)")
                (("1" (assert)
                  (("1" (split -1)
                    (("1" (flatten) nil nil)
                     ("2" (hide 2)
                      (("2" (skosimp*)
                        (("2" (expand "split_fun")
                          (("2" (typepred "x!1")
                            (("2" (assert)
                              (("2" (flatten)
                                (("2" (hide -4) (("2" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("3" (hide 2)
                      (("3" (lemma "Integrable?_inside[T]")
                        (("3" (inst - "t0" "tSplit" "r1" "t0" "tt")
                          (("3" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 2)
                (("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil))
                nil)
               ("3" (hide 2)
                (("3" (lemma "connected_domain") (("3" (propax) nil nil))
                  nil))
                nil))
              nil)
             ("2" (case-replace "tt = tSplit")
              (("1" (assert)
                (("1" (replace -1 :dir rl)
                  (("1" (expand "split_fun")
                    (("1" (lemma "Integral_restr_eq[T]")
                      (("1"
                        (inst - "t0" "tt" "r1"
                         "LAMBDA (t: T): IF (t <= tt) THEN r1(t) ELSE r2(t) ENDIF")
                        (("1" (assert)
                          (("1" (hide 3)
                            (("1" (skosimp*)
                              (("1" (lift-if)
                                (("1" (ground)
                                  (("1" (typepred "x!1")
                                    (("1" (ground) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (lemma "not_one_element") (("2" (propax) nil nil))
                        nil)
                       ("3" (lemma "connected_domain")
                        (("3" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand "split_fun")
                (("2" (assert)
                  (("2" (lemma "Integral_split[T]")
                    (("1"
                      (inst - "t0" "tSplit" "tt"
                       "LAMBDA (t: T): IF (t <= tSplit) THEN r1(t) ELSE r2(t) ENDIF")
                      (("1" (split -1)
                        (("1" (flatten)
                          (("1" (replace -2 :dir rl)
                            (("1" (hide -2)
                              (("1" (lemma "Integral_restr_eq[T]")
                                (("1" (assert)
                                  (("1"
                                    (inst - "t0" "tSplit" "r1"
                                     "LAMBDA (t: T): IF (t <= tSplit) THEN r1(t) ELSE r2(t) ENDIF")
                                    (("1" (assert)
                                      (("1"
                                        (split -1)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (replace -2)
                                            (("1"
                                              (lemma "Integral_restr_eq[T]")
                                              (("1"
                                                (inst
                                                 -
                                                 "tSplit"
                                                 "tt"
                                                 "r2"
                                                 "LAMBDA (t: T): IF (t <= tSplit) THEN r1(t) ELSE r2(t) ENDIF")
                                                (("1"
                                                  (split -1)
                                                  (("1" (assert) nil nil)
                                                   ("2"
                                                    (hide 4)
                                                    (("2"
                                                      (skosimp*)
                                                      (("2"
                                                        (typepred "x!1")
                                                        (("2"
                                                          (lift-if)
                                                          (("2"
                                                            (ground)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("3"
                                                    (hide -1 -2 -3 4)
                                                    (("3"
                                                      (lemma
                                                       "Integrable?_inside[T]")
                                                      (("3"
                                                        (inst
                                                         -
                                                         "tSplit"
                                                         "t1"
                                                         "r2"
                                                         "tSplit"
                                                         "tt")
                                                        (("3"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (hide 4)
                                          (("2"
                                            (skosimp*)
                                            (("2"
                                              (typepred "x!1")
                                              (("2"
                                                (assert)
                                                (("2" (ground) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (hide 4)
                          (("2" (lemma "Integral_restr_eq[T]")
                            (("2"
                              (inst - "t0" "tSplit" "r1"
                               "LAMBDA (t: T): IF (t <= tSplit) THEN r1(t) ELSE r2(t) ENDIF")
                              (("2" (assert)
                                (("2" (skosimp*)
                                  (("2" (typepred "x!1")
                                    (("2" (ground) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (lemma "Integral_restr_eq[T]")
                          (("3"
                            (inst - "tSplit" "tt" "r2"
                             "LAMBDA (t: T): IF (t <= tSplit) THEN r1(t) ELSE r2(t) ENDIF")
                            (("3" (assert)
                              (("3" (split +)
                                (("1" (skosimp*)
                                  (("1" (typepred "x!1")
                                    (("1" (ground) nil nil)) nil))
                                  nil)
                                 ("2" (hide 2 5)
                                  (("2" (lemma "Integrable?_inside[T]")
                                    (("2"
                                      (inst
                                       -
                                       "tSplit"
                                       "t1"
                                       "r2"
                                       "tSplit"
                                       "tt")
                                      (("2" (assert) nil nil)) nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (lemma "not_one_element") (("2" (propax) nil nil))
                      nil)
                     ("3" (lemma "connected_domain") (("3" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((split_fun_Integrable formula-decl nil integral_split_fun nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (Integral_split formula-decl nil integral nil)
    (Integral_restr_eq formula-decl nil integral nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (not_one_element? const-decl "bool" deriv_domain_def nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Integrable?_inside formula-decl nil integral nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (Open_interval type-eq-decl nil intervals_real reals)
    (split_fun const-decl "[T -> real]" integral_split_fun nil)
    (not_one_element formula-decl nil integral_split_fun nil)
    (connected_domain formula-decl nil integral_split_fun nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (< const-decl "bool" reals nil)
    (T formal-nonempty-subtype-decl nil integral_split_fun nil)
    (T_pred const-decl "[real -> boolean]" integral_split_fun nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil)
  (Integral_split_fun-1 nil 3602604451
   ("" (skeep)
    (("" (case "tt < tSplit")
      (("1" (lemma "Integral_restr_eq[T]")
        (("1" (inst - "t0" "tt" "r1" "split_fun(tSplit, r1, r2)")
          (("1" (assert)
            (("1" (split -1)
              (("1" (flatten) nil nil)
               ("2" (hide 2)
                (("2" (skosimp*)
                  (("2" (expand "split_fun")
                    (("2" (typepred "x!1")
                      (("2" (assert)
                        (("2" (flatten)
                          (("2" (hide -4) (("2" (assert) nil nil)) nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (hide 2)
                (("3" (lemma "Integrable?_inside[T]")
                  (("3" (inst - "t0" "tSplit" "r1" "t0" "tt")
                    (("3" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 2)
          (("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)) nil)
         ("3" (hide 2)
          (("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (case-replace "tt = tSplit")
        (("1" (assert)
          (("1" (replace -1 :dir rl)
            (("1" (expand "split_fun")
              (("1" (lemma "Integral_restr_eq[T]")
                (("1"
                  (inst - "t0" "tt" "r1"
                   "LAMBDA (t: T): IF (t <= tt) THEN r1(t) ELSE r2(t) ENDIF")
                  (("1" (assert)
                    (("1" (hide 3)
                      (("1" (skosimp*)
                        (("1" (lift-if)
                          (("1" (ground)
                            (("1" (typepred "x!1") (("1" (ground) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
                 ("3" (lemma "connected_domain") (("3" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "split_fun")
          (("2" (assert)
            (("2" (lemma "Integral_split_fun[T]")
              (("1"
                (inst - "t0" "tSplit" "tt"
                 "LAMBDA (t: T): IF (t <= tSplit) THEN r1(t) ELSE r2(t) ENDIF")
                (("1" (split -1)
                  (("1" (flatten)
                    (("1" (replace -2 :dir rl)
                      (("1" (hide -2)
                        (("1" (lemma "Integral_restr_eq[T]")
                          (("1" (assert)
                            (("1"
                              (inst - "t0" "tSplit" "r1"
                               "LAMBDA (t: T): IF (t <= tSplit) THEN r1(t) ELSE r2(t) ENDIF")
                              (("1" (assert)
                                (("1" (split -1)
                                  (("1" (flatten)
                                    (("1" (replace -2)
                                      (("1"
                                        (lemma "Integral_restr_eq[T]")
                                        (("1"
                                          (inst
                                           -
                                           "tSplit"
                                           "tt"
                                           "r2"
                                           "LAMBDA (t: T): IF (t <= tSplit) THEN r1(t) ELSE r2(t) ENDIF")
                                          (("1"
                                            (split -1)
                                            (("1" (assert) nil nil)
                                             ("2"
                                              (hide 4)
                                              (("2"
                                                (skosimp*)
                                                (("2"
                                                  (typepred "x!1")
                                                  (("2"
                                                    (lift-if)
                                                    (("2" (ground) nil nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("3"
                                              (hide -1 -2 -3 4)
                                              (("3"
                                                (lemma
                                                 "Integrable?_inside[T]")
                                                (("3"
                                                  (inst
                                                   -
                                                   "tSplit"
                                                   "t1"
                                                   "r2"
                                                   "tSplit"
                                                   "tt")
                                                  (("3" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (hide 4)
                                    (("2" (skosimp*)
                                      (("2"
                                        (typepred "x!1")
                                        (("2"
                                          (assert)
                                          (("2" (ground) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 4)
                    (("2" (lemma "Integral_restr_eq[T]")
                      (("2"
                        (inst - "t0" "tSplit" "r1"
                         "LAMBDA (t: T): IF (t <= tSplit) THEN r1(t) ELSE r2(t) ENDIF")
                        (("2" (assert)
                          (("2" (skosimp*)
                            (("2" (typepred "x!1") (("2" (ground) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (lemma "Integral_restr_eq[T]")
                    (("3"
                      (inst - "tSplit" "tt" "r2"
                       "LAMBDA (t: T): IF (t <= tSplit) THEN r1(t) ELSE r2(t) ENDIF")
                      (("3" (assert)
                        (("3" (split +)
                          (("1" (skosimp*)
                            (("1" (typepred "x!1") (("1" (ground) nil nil))
                              nil))
                            nil)
                           ("2" (hide 2 5)
                            (("2" (lemma "Integrable?_inside[T]")
                              (("2" (inst - "tSplit" "t1" "r2" "tSplit" "tt")
                                (("2" (assert) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
               ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Integral_restr_eq formula-decl nil integral nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (not_one_element? const-decl "bool" deriv_domain_def nil)
    (Integrable?_inside formula-decl nil integral nil)
    (Open_interval type-eq-decl nil intervals_real reals))
   shostak))
 (split_fun2?_split_fun2 0
  (split_fun2?_split_fun2-1 nil 3611571005
   ("" (skosimp*)
    (("" (expand "split_fun2?")
      (("" (expand "split_fun2") (("" (inst?) nil nil)) nil)) nil))
    nil)
   ((split_fun2? const-decl "bool" integral_split_fun nil)
    (T formal-nonempty-subtype-decl nil integral_split_fun nil)
    (T_pred const-decl "[real -> boolean]" integral_split_fun nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (split_fun2 const-decl "[T -> real]" integral_split_fun nil))
   shostak))
 (Integrable_Split_fun2_TCC1 0
  (Integrable_Split_fun2_TCC1-1 nil 3611570519
   ("" (lemma "connected_domain") (("" (skosimp*) nil nil)) nil)
   ((connected_domain formula-decl nil integral_split_fun nil)) nil
   (Integrable_Split_fun2 assuming "integral_def[T].integral_def"
    "connected_domain: ASSUMPTION deriv_domain_def[T].connected?")))
 (Integrable_Split_fun2_TCC2 0
  (Integrable_Split_fun2_TCC2-1 nil 3611570519
   ("" (skosimp*) (("" (lemma "not_one_element") (("" (propax) nil nil)) nil))
    nil)
   ((not_one_element formula-decl nil integral_split_fun nil)) nil
   (Integrable_Split_fun2 assuming "integral_def[T].integral_def"
    "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?")))
 (split_fun2_Integrable_TCC1 0
  (split_fun2_Integrable_TCC1-1 nil 3611570519
   ("" (skosimp*)
    (("" (lemma "connected_domain") (("" (propax) nil nil)) nil)) nil)
   ((connected_domain formula-decl nil integral_split_fun nil)) nil
   (split_fun2_Integrable assuming "integral_def[T].integral_def"
    "connected_domain: ASSUMPTION deriv_domain_def[T].connected?")))
 (split_fun2_Integrable_TCC2 0
  (split_fun2_Integrable_TCC2-1 nil 3611570519
   ("" (skosimp*) (("" (lemma "not_one_element") (("" (propax) nil nil)) nil))
    nil)
   ((not_one_element formula-decl nil integral_split_fun nil)) nil
   (split_fun2_Integrable assuming "integral_def[T].integral_def"
    "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?")))
 (split_fun2_Integrable 0
  (split_fun2_Integrable-1 nil 3611571190
   ("" (skosimp*)
    (("" (case-replace "t0!1=t1!1")
      (("1" (lemma "Integrable?_a_to_a[T]")
        (("1"
          (inst -1 "t1!1"
           "split_fun2(tSplit1!1, tSplit2!1, r1!1, r2!1, r3!1)")
          nil nil)
         ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
         ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil))
        nil)
       ("2" (lemma "Integral_split[T]")
        (("1"
          (inst -1 "t0!1" "tSplit1!1" "t1!1"
           "split_fun2(tSplit1!1, tSplit2!1, r1!1, r2!1, r3!1)")
          (("1" (lemma "Integral_split[T]")
            (("1"
              (inst -1 "tSplit1!1" "tSplit2!1" "t1!1"
               "split_fun2(tSplit1!1, tSplit2!1, r1!1, r2!1, r3!1)")
              (("1" (split -1)
                (("1" (flatten)
                  (("1" (hide -2)
                    (("1" (hide (-5 -6 1))
                      (("1" (split)
                        (("1" (flatten) nil nil)
                         ("2" (lemma "Integral_restr_eq[T]")
                          (("2" (hide (-2 2))
                            (("2"
                              (inst -1 "t0!1" "tSplit1!1" "r1!1"
                               "split_fun2(tSplit1!1, tSplit2!1, r1!1, r2!1, r3!1)")
                              (("2" (split -1)
                                (("1" (flatten) nil nil)
                                 ("2" (skosimp*)
                                  (("2" (expand "in_order?")
                                    (("2" (flatten)
                                      (("2"
                                        (case-replace "t0!1=tSplit1!1")
                                        (("1"
                                          (rewrite "Integrable?_a_to_a[T]")
                                          nil
                                          nil)
                                         ("2"
                                          (expand "split_fun2")
                                          (("2"
                                            (assert)
                                            (("2"
                                              (typepred "x!1")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (lift-if)
                                                  (("2" (ground) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("3" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (lemma "Integral_restr_eq[T]")
                  (("2"
                    (inst -1 "tSplit1!1" "tSplit2!1" "r2!1"
                     "split_fun2(tSplit1!1, tSplit2!1, r1!1, r2!1, r3!1)")
                    (("2" (split -1)
                      (("1" (flatten) nil nil)
                       ("2" (skosimp*)
                        (("2" (expand "in_order?")
                          (("2" (flatten)
                            (("2" (case-replace "tSplit1!1=tSplit2!1")
                              (("1" (rewrite "Integrable?_a_to_a[T]") nil nil)
                               ("2" (expand "split_fun2")
                                (("2" (assert)
                                  (("2" (typepred "x!1")
                                    (("2" (assert)
                                      (("2"
                                        (lift-if)
                                        (("2" (ground) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (propax) nil nil))
                      nil))
                    nil))
                  nil)
                 ("3" (hide (-1 -3 -4 2 3))
                  (("3" (lemma "Integral_restr_eq[T]")
                    (("3"
                      (inst -1 "tSplit2!1" "t1!1" "r3!1"
                       "split_fun2(tSplit1!1, tSplit2!1, r1!1, r2!1, r3!1)")
                      (("3" (split -1)
                        (("1" (flatten) nil nil)
                         ("2" (skosimp*)
                          (("2" (expand "in_order?")
                            (("2" (flatten)
                              (("2" (case-replace "tSplit2!1=t1!1")
                                (("1" (rewrite "Integrable?_a_to_a[T]") nil
                                  nil)
                                 ("2" (expand "split_fun2")
                                  (("2" (assert)
                                    (("2" (typepred "x!1")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (lift-if)
                                          (("2" (ground) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
         ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" integral_split_fun nil)
    (T formal-nonempty-subtype-decl nil integral_split_fun nil)
    (connected_domain formula-decl nil integral_split_fun nil)
    (not_one_element formula-decl nil integral_split_fun nil)
    (split_fun2 const-decl "[T -> real]" integral_split_fun nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (not_one_element? const-decl "bool" deriv_domain_def nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (Integrable?_a_to_a formula-decl nil integral nil)
    (Integral_restr_eq formula-decl nil integral nil)
    (Open_interval type-eq-decl nil intervals_real reals)
    (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (in_order? const-decl "bool" integral_split_fun nil)
    (Integral_split formula-decl nil integral nil))
   shostak))
 (Integral_split_fun2_TCC1 0
  (Integral_split_fun2_TCC1-1 nil 3611570519
   ("" (skosimp*)
    (("" (lemma "Integrable?_inside[T]")
      (("1"
        (inst -1 "t0!1" "t1!1"
         "split_fun2(tSplit1!1, tSplit2!1, r1!1, r2!1, r3!1)" "t0!1" "tt!1")
        (("1" (expand "in_order?") (("1" (ground) nil nil)) nil)) nil)
       ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
       ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil))
      nil))
    nil)
   ((T formal-nonempty-subtype-decl nil integral_split_fun nil)
    (T_pred const-decl "[real -> boolean]" integral_split_fun nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Integrable?_inside formula-decl nil integral nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (not_one_element? const-decl "bool" deriv_domain_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (in_order? const-decl "bool" integral_split_fun nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (split_fun2 const-decl "[T -> real]" integral_split_fun nil)
    (not_one_element formula-decl nil integral_split_fun nil)
    (connected_domain formula-decl nil integral_split_fun nil))
   nil
   (Integral_split_fun2 subtype
    "integral_split_fun.split_fun2(integral_split_fun.tSplit1, integral_split_fun.tSplit2, integral_split_fun.r1, integral_split_fun.r2, integral_split_fun.r3)"
    "integral_def[T].Integrable_funs(integral_split_fun.t0, integral_split_fun.tt)")))
 (Integral_split_fun2_TCC2 0
  (Integral_split_fun2_TCC2-1 nil 3611570519
   ("" (skosimp*)
    (("" (lemma "Integrable?_inside[T]")
      (("1" (inst -1 "t0!1" "tSplit1!1" "r1!1" "t0!1" "tt!1")
        (("1" (expand "in_order?") (("1" (assert) nil nil)) nil)) nil)
       ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
       ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil))
      nil))
    nil)
   ((T formal-nonempty-subtype-decl nil integral_split_fun nil)
    (T_pred const-decl "[real -> boolean]" integral_split_fun nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Integrable?_inside formula-decl nil integral nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (not_one_element? const-decl "bool" deriv_domain_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (in_order? const-decl "bool" integral_split_fun nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (not_one_element formula-decl nil integral_split_fun nil)
    (connected_domain formula-decl nil integral_split_fun nil))
   nil
   (Integral_split_fun2 subtype "integral_split_fun.r1"
    "integral_def[T].Integrable_funs(integral_split_fun.t0, integral_split_fun.tt)")))
 (Integral_split_fun2_TCC3 0
  (Integral_split_fun2_TCC3-1 nil 3611570519
   ("" (skosimp*)
    (("" (lemma "Integrable?_inside[T]")
      (("1" (inst -1 "tSplit1!1" "tSplit2!1" "r2!1" "tSplit1!1" "tt!1")
        (("1" (expand "in_order?") (("1" (assert) nil nil)) nil)) nil)
       ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
       ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil))
      nil))
    nil)
   ((T formal-nonempty-subtype-decl nil integral_split_fun nil)
    (T_pred const-decl "[real -> boolean]" integral_split_fun nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Integrable?_inside formula-decl nil integral nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (not_one_element? const-decl "bool" deriv_domain_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (in_order? const-decl "bool" integral_split_fun nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (not_one_element formula-decl nil integral_split_fun nil)
    (connected_domain formula-decl nil integral_split_fun nil))
   nil
   (Integral_split_fun2 subtype "integral_split_fun.r2"
    "integral_def[T].Integrable_funs(integral_split_fun.tSplit1, integral_split_fun.tt)")))
 (Integral_split_fun2_TCC4 0
  (Integral_split_fun2_TCC4-1 nil 3611570519
   ("" (skosimp*)
    (("" (lemma "Integrable?_inside[T]")
      (("1" (inst -1 "tSplit2!1" "t1!1" "r3!1" "tSplit2!1" "tt!1")
        (("1" (expand "in_order?") (("1" (assert) nil nil)) nil)) nil)
       ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
       ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil))
      nil))
    nil)
   ((T formal-nonempty-subtype-decl nil integral_split_fun nil)
    (T_pred const-decl "[real -> boolean]" integral_split_fun nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Integrable?_inside formula-decl nil integral nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (not_one_element? const-decl "bool" deriv_domain_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (in_order? const-decl "bool" integral_split_fun nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (not_one_element formula-decl nil integral_split_fun nil)
    (connected_domain formula-decl nil integral_split_fun nil))
   nil
   (Integral_split_fun2 subtype "integral_split_fun.r3"
    "integral_def[T].Integrable_funs(integral_split_fun.tSplit2, integral_split_fun.tt)")))
 (Integral_split_fun2 0
  (Integral_split_fun2-2 nil 3611576453
   ("" (skosimp*)
    (("" (lemma "split_fun2_Integrable")
      (("" (inst?)
        (("" (prop)
          (("" (case "tt!1<= tSplit1!1")
            (("1" (lemma "Integral_restr_eq[T]")
              (("1"
                (inst -1 "t0!1" "tt!1" "r1!1"
                 "split_fun2(tSplit1!1, tSplit2!1, r1!1, r2!1, r3!1)")
                (("1" (assert)
                  (("1" (split)
                    (("1" (flatten) nil nil)
                     ("2" (skosimp*)
                      (("2" (expand "split_fun2")
                        (("2" (typepred "x!1")
                          (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil))
                        nil))
                      nil)
                     ("3" (lemma "Integrable?_inside[T]")
                      (("3" (inst -1 "t0!1" "tSplit1!1" "r1!1" "t0!1" "tt!1")
                        (("3" (expand "in_order?")
                          (("3" (prop) (("3" (ground) nil nil)) nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
               ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil))
              nil)
             ("2" (case "tt!1<=tSplit2!1")
              (("1" (lemma "Integral_split[T]")
                (("1"
                  (inst -1 "t0!1" "tSplit1!1" "tt!1"
                   "split_fun2(tSplit1!1, tSplit2!1, r1!1, r2!1, r3!1)")
                  (("1" (split)
                    (("1" (flatten)
                      (("1" (replace -2 :dir rl)
                        (("1" (hide -2 -1)
                          (("1" (lemma "Integral_restr_eq[T]")
                            (("1"
                              (inst-cp -1 "t0!1" "tSplit1!1" "r1!1"
                               "split_fun2(tSplit1!1, tSplit2!1, r1!1, r2!1, r3!1)")
                              (("1"
                                (inst -1 "tSplit1!1" "tt!1" "r2!1"
                                 "split_fun2(tSplit1!1, tSplit2!1, r1!1, r2!1, r3!1)")
                                (("1" (split -1)
                                  (("1" (flatten)
                                    (("1" (replace -2)
                                      (("1"
                                        (hide (-1 -2))
                                        (("1"
                                          (split -1)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (replace -2)
                                              (("1"
                                                (lift-if)
                                                (("1" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (hide (-2 -6 -7 -8 3))
                                            (("2"
                                              (skosimp*)
                                              (("2"
                                                (typepred "x!1")
                                                (("2"
                                                  (expand "in_order?")
                                                  (("2"
                                                    (expand "split_fun2")
                                                    (("2"
                                                      (lift-if)
                                                      (("2" (ground) nil nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("3" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (skosimp*)
                                    (("2" (expand "in_order?")
                                      (("2"
                                        (flatten)
                                        (("2"
                                          (typepred "x!1")
                                          (("2"
                                            (expand "split_fun2")
                                            (("2"
                                              (lift-if)
                                              (("2" (ground) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3" (hide (-1 -3 -4 -5 -6 -7 -9 3))
                                    (("3" (lemma "Integrable?_inside[T]")
                                      (("3"
                                        (inst
                                         -1
                                         "tSplit1!1"
                                         "tSplit2!1"
                                         "r2!1"
                                         "tSplit1!1"
                                         "tt!1")
                                        (("3" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (lemma "Integrable?_inside[T]")
                      (("2"
                        (inst -1 "t0!1" "t1!1"
                         "split_fun2(tSplit1!1, tSplit2!1, r1!1, r2!1, r3!1)"
                         "t0!1" "tSplit1!1")
                        (("2" (expand "in_order?")
                          (("2" (flatten) (("2" (ground) nil nil)) nil)) nil))
                        nil))
                      nil)
                     ("3" (lemma "Integrable?_inside[T]")
                      (("3"
                        (inst -1 "t0!1" "t1!1"
                         "split_fun2(tSplit1!1, tSplit2!1, r1!1, r2!1, r3!1)"
                         "tSplit1!1" "tt!1")
                        (("3" (expand "in_order?")
                          (("3" (flatten) (("3" (ground) nil nil)) nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
                 ("3" (lemma "connected_domain") (("3" (propax) nil nil))
                  nil))
                nil)
               ("2" (lemma "Integral_split[T]")
                (("1"
                  (inst -1 "t0!1" "tSplit2!1" "tt!1"
                   "split_fun2(tSplit1!1, tSplit2!1, r1!1, r2!1, r3!1)")
                  (("1" (split)
                    (("1" (flatten)
                      (("1" (replace -2 :dir rl)
                        (("1" (hide (-2 -1))
                          (("1" (lemma "Integrable?_inside[T]")
                            (("1"
                              (inst -1 "tSplit2!1" "t1!1" "r3!1" "tSplit2!1"
                               "tt!1")
                              (("1" (prop)
                                (("1" (lemma "Integral_restr_eq[T]")
                                  (("1"
                                    (inst -1 "tSplit2!1" "tt!1" "r3!1"
                                     "split_fun2(tSplit1!1, tSplit2!1, r1!1, r2!1, r3!1)")
                                    (("1" (split)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (replace -2)
                                          (("1"
                                            (hide (-1 -2 -3 -10))
                                            (("1"
                                              (lemma "Integral_split[T]")
                                              (("1"
                                                (inst
                                                 -1
                                                 "t0!1"
                                                 "tSplit1!1"
                                                 "tSplit2!1"
                                                 "split_fun2(tSplit1!1, tSplit2!1, r1!1, r2!1, r3!1)")
                                                (("1"
                                                  (prop)
                                                  (("1"
                                                    (replace -2 :dir rl)
                                                    (("1"
                                                      (hide (-1 -2))
                                                      (("1"
                                                        (lemma
                                                         "Integral_restr_eq[T]")
                                                        (("1"
                                                          (inst-cp
                                                           -1
                                                           "t0!1"
                                                           "tSplit1!1"
                                                           "r1!1"
                                                           "split_fun2(tSplit1!1, tSplit2!1, r1!1, r2!1, r3!1)")
                                                          (("1"
                                                            (inst
                                                             -1
                                                             "tSplit1!1"
                                                             "tSplit2!1"
                                                             "r2!1"
                                                             "split_fun2(tSplit1!1, tSplit2!1, r1!1, r2!1, r3!1)")
                                                            (("1"
                                                              (split -1)
                                                              (("1"
                                                                (flatten)
                                                                (("1"
                                                                  (replace -2)
                                                                  (("1"
                                                                    (hide
                                                                     -1
                                                                     -2)
                                                                    (("1"
                                                                      (split)
                                                                      (("1"
                                                                        (flatten)
                                                                        (("1"
                                                                          (replace
                                                                           -2)
                                                                          (("1"
                                                                            (expand
                                                                             "in_order?")
                                                                            (("1"
                                                                              (ground)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (skosimp*)
                                                                        (("2"
                                                                          (expand
                                                                           "in_order?")
                                                                          (("2"
                                                                            (expand
                                                                             "split_fun2")
                                                                            (("2"
                                                                              (flatten)
                                                                              (("2"
                                                                                (lift-if)
                                                                                (("2"
                                                                                  (typepred
                                                                                   "x!1")
                                                                                  (("2"
                                                                                    (ground)
                                                                                    nil
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("3"
                                                                        (propax)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (skosimp*)
                                                                (("2"
                                                                  (expand
                                                                   "in_order?")
                                                                  (("2"
                                                                    (expand
                                                                     "split_fun2")
                                                                    (("2"
                                                                      (flatten)
                                                                      (("2"
                                                                        (lift-if)
                                                                        (("2"
                                                                          (typepred
                                                                           "x!1")
                                                                          (("2"
                                                                            (ground)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("3"
                                                                (propax)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (lemma
                                                     "Integral_restr_eq[T]")
                                                    (("2"
                                                      (inst
                                                       -1
                                                       "t0!1"
                                                       "tSplit1!1"
                                                       "r1!1"
                                                       "split_fun2(tSplit1!1, tSplit2!1, r1!1, r2!1, r3!1)")
                                                      (("2"
                                                        (split)
                                                        (("1"
                                                          (lemma
                                                           "Integrable?_inside[T]")
                                                          (("1"
                                                            (inst
                                                             -1
                                                             "t0!1"
                                                             "t1!1"
                                                             "split_fun2(tSplit1!1, tSplit2!1, r1!1, r2!1, r3!1)"
                                                             "t0!1"
                                                             "tSplit1!1")
                                                            (("1"
                                                              (expand
                                                               "in_order?")
                                                              (("1"
                                                                (flatten)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (skosimp*)
                                                          (("2"
                                                            (expand
                                                             "in_order?")
                                                            (("2"
                                                              (flatten)
                                                              (("2"
                                                                (expand
                                                                 "split_fun2")
                                                                (("2"
                                                                  (typepred
                                                                   "x!1")
                                                                  (("2"
                                                                    (lift-if)
                                                                    (("2"
                                                                      (ground)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("3"
                                                    (lemma
                                                     "Integrable?_inside[T]")
                                                    (("3"
                                                      (inst
                                                       -1
                                                       "t0!1"
                                                       "t1!1"
                                                       "split_fun2(tSplit1!1, tSplit2!1, r1!1, r2!1, r3!1)"
                                                       "tSplit1!1"
                                                       "tSplit2!1")
                                                      (("3"
                                                        (expand "in_order?")
                                                        (("3"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (skosimp*)
                                        (("2"
                                          (expand "in_order?")
                                          (("2"
                                            (flatten)
                                            (("2"
                                              (expand "split_fun2")
                                              (("2"
                                                (lift-if)
                                                (("2"
                                                  (typepred "x!1")
                                                  (("2" (ground) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("3" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (ground) nil nil)
                                 ("3" (ground) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (lemma "Integrable?_inside[T]")
                      (("2"
                        (inst - "t0!1" "t1!1"
                         "split_fun2(tSplit1!1, tSplit2!1, r1!1, r2!1, r3!1)"
                         "t0!1" "tSplit2!1")
                        (("2" (expand "in_order?")
                          (("2" (flatten) (("2" (ground) nil nil)) nil)) nil))
                        nil))
                      nil)
                     ("3" (lemma "Integrable?_inside[T]")
                      (("3"
                        (inst - "t0!1" "t1!1"
                         "split_fun2(tSplit1!1, tSplit2!1, r1!1, r2!1, r3!1)"
                         "tSplit2!1" "tt!1")
                        (("3" (expand "in_order?")
                          (("3" (flatten) (("3" (ground) nil nil)) nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
                 ("3" (lemma "connected_domain") (("3" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((split_fun2_Integrable formula-decl nil integral_split_fun nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (Integral_split formula-decl nil integral nil)
    (Integral_restr_eq formula-decl nil integral nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (not_one_element? const-decl "bool" deriv_domain_def nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (Integrable?_inside formula-decl nil integral nil)
    (in_order? const-decl "bool" integral_split_fun nil)
    (Open_interval type-eq-decl nil intervals_real reals)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (split_fun2 const-decl "[T -> real]" integral_split_fun nil)
    (not_one_element formula-decl nil integral_split_fun nil)
    (connected_domain formula-decl nil integral_split_fun nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (<= const-decl "bool" reals nil)
    (T formal-nonempty-subtype-decl nil integral_split_fun nil)
    (T_pred const-decl "[real -> boolean]" integral_split_fun nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil)
  (Integral_split_fun2-1 nil 3611575024
   ("" (skosimp*)
    (("" (lemma "split_fun2_Integrable")
      (("" (inst?)
        (("" (prop)
          (("" (case "tt!1< tSplit1!1")
            (("1" (lemma "Integral_restr_eq[T]")
              (("1"
                (inst -1 "t0!1" "tt!1" "r1!1"
                 "split_fun2(tSplit1!1, tSplit2!1, r1!1, r2!1, r3!1)")
                (("1" (assert)
                  (("1" (split)
                    (("1" (flatten) nil nil)
                     ("2" (skosimp*)
                      (("2" (expand "split_fun2")
                        (("2" (typepred "x!1")
                          (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil))
                        nil))
                      nil)
                     ("3" (lemma "Integrable?_inside[T]")
                      (("3" (inst -1 "t0!1" "tSplit1!1" "r1!1" "t0!1" "tt!1")
                        (("3" (expand "in_order?")
                          (("3" (prop)
                            (("1" (ground) nil nil) ("2" (ground) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
               ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil))
              nil)
             ("2" (case-replace "tSplit1!1=tt!1")
              (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (split_fun3?_split_fun3 0
  (split_fun3?_split_fun3-1 nil 3611663321
   ("" (skosimp*)
    (("" (expand "split_fun3?")
      ((""
        (inst 1 "tSplit1!1" " tSplit2!1" " tSplit3!1" " r1!1" " r2!1" " r3!1"
         " r4!1")
        (("" (grind) (("" (expand "split_fun3") (("" (propax) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((split_fun3? const-decl "bool" integral_split_fun nil)
    (split_fun3 const-decl "[T -> real]" integral_split_fun nil)
    (T formal-nonempty-subtype-decl nil integral_split_fun nil)
    (T_pred const-decl "[real -> boolean]" integral_split_fun nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (Integrable_Split_fun3_TCC1 0
  (Integrable_Split_fun3_TCC1-1 nil 3611662500
   ("" (skosimp*)
    (("" (lemma "connected_domain") (("" (propax) nil nil)) nil)) nil)
   ((connected_domain formula-decl nil integral_split_fun nil)) nil
   (Integrable_Split_fun3 assuming "integral_def[T].integral_def"
    "connected_domain: ASSUMPTION deriv_domain_def[T].connected?")))
 (Integrable_Split_fun3_TCC2 0
  (Integrable_Split_fun3_TCC2-1 nil 3611662500
   ("" (skosimp*) (("" (lemma "not_one_element") (("" (propax) nil nil)) nil))
    nil)
   ((not_one_element formula-decl nil integral_split_fun nil)) nil
   (Integrable_Split_fun3 assuming "integral_def[T].integral_def"
    "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?")))
 (split_middle_fun3 0
  (split_middle_fun3-1 nil 3611663629
   ("" (skosimp*)
    (("" (expand "split_fun3")
      (("" (expand "split_fun")
        (("" (grind) (("" (decompose-equality) (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((split_fun3 const-decl "[T -> real]" integral_split_fun nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" integral_split_fun nil)
    (T formal-nonempty-subtype-decl nil integral_split_fun nil)
    (<= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (split_fun const-decl "[T -> real]" integral_split_fun nil))
   shostak))
 (split_fun3_Integrable_TCC1 0
  (split_fun3_Integrable_TCC1-1 nil 3611662500
   ("" (skosimp*)
    (("" (lemma "connected_domain") (("" (propax) nil nil)) nil)) nil)
   ((connected_domain formula-decl nil integral_split_fun nil)) nil
   (split_fun3_Integrable assuming "integral_def[T].integral_def"
    "connected_domain: ASSUMPTION deriv_domain_def[T].connected?")))
 (split_fun3_Integrable_TCC2 0
  (split_fun3_Integrable_TCC2-1 nil 3611662500
   ("" (skosimp*) (("" (lemma "not_one_element") (("" (propax) nil nil)) nil))
    nil)
   ((not_one_element formula-decl nil integral_split_fun nil)) nil
   (split_fun3_Integrable assuming "integral_def[T].integral_def"
    "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?")))
 (split_fun3_Integrable 0
  (split_fun3_Integrable-1 nil 3611663730
   ("" (lemma "split_middle_fun3")
    (("" (skosimp*)
      (("" (inst?)
        (("" (expand "in_order?")
          (("" (flatten)
            (("" (prop)
              (("" (replace -1)
                (("" (lemma "split_fun_Integrable")
                  ((""
                    (inst-cp -1 "r1!1" "r2!1" "t0!1" "tSplit2!1" "tSplit1!1")
                    ((""
                      (inst-cp -1 "r3!1" "r4!1" "tSplit2!1" "t1!1"
                       "tSplit3!1")
                      ((""
                        (inst -1 " split_fun(tSplit1!1, r1!1, r2!1)"
                         "split_fun(tSplit3!1, r3!1, r4!1)" "t0!1" "t1!1"
                         "tSplit2!1")
                        (("" (prop)
                          (("1" (assert) nil nil) ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((in_order? const-decl "bool" integral_split_fun nil)
    (split_fun_Integrable formula-decl nil integral_split_fun nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (split_fun const-decl "[T -> real]" integral_split_fun nil)
    (T formal-nonempty-subtype-decl nil integral_split_fun nil)
    (T_pred const-decl "[real -> boolean]" integral_split_fun nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (split_middle_fun3 formula-decl nil integral_split_fun nil))
   shostak))
 (Integral_split_fun3_TCC1 0
  (Integral_split_fun3_TCC1-2 nil 3615814733
   ("" (skosimp*)
    (("" (lemma "Integrable?_inside[T]")
      (("1"
        (inst -1 "t0!1" "t1!1"
         "split_fun3(tSplit1!1, tSplit2!1, tSplit3!1, r1!1, r2!1, r3!1,
                          r4!1)" "t0!1" "tt!1")
        (("1" (grind) nil nil)) nil)
       ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
       ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil))
      nil))
    nil)
   ((T formal-nonempty-subtype-decl nil integral_split_fun nil)
    (T_pred const-decl "[real -> boolean]" integral_split_fun nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Integrable?_inside formula-decl nil integral nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (not_one_element? const-decl "bool" deriv_domain_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (split_fun3 const-decl "[T -> real]" integral_split_fun nil)
    (not_one_element formula-decl nil integral_split_fun nil)
    (connected_domain formula-decl nil integral_split_fun nil))
   nil
   (Integral_split_fun3 subtype
    "integral_split_fun.split_fun3(integral_split_fun.tSplit1, integral_split_fun.tSplit2, integral_split_fun.tSplit3, integral_split_fun.r1, integral_split_fun.r2, integral_split_fun.r3, integral_split_fun.r4)"
    "integral_def[T].Integrable_funs(integral_split_fun.t0, integral_split_fun.tt)"))
  (Integral_split_fun3_TCC1-1 nil 3611662500
   ("" (skosimp*)
    (("" (lemma "connected_domain") (("" (propax) nil nil)) nil)) nil)
   nil nil
   (Integral_split_fun3 subtype
    "integral_split_fun.split_fun3(integral_split_fun.tSplit1, integral_split_fun.tSplit2, integral_split_fun.tSplit3, integral_split_fun.r1, integral_split_fun.r2, integral_split_fun.r3, integral_split_fun.r4)"
    "integral_def[T].Integrable_funs(integral_split_fun.t0, integral_split_fun.tt)")))
 (Integral_split_fun3_TCC2 0
  (Integral_split_fun3_TCC2-2 nil 3615814819
   ("" (skosimp*)
    (("" (lemma "Integrable?_inside[T]")
      (("1" (inst -1 "t0!1" "tSplit1!1" " r1!1" "t0!1" "tt!1")
        (("1" (grind) nil nil)) nil)
       ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
       ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil))
      nil))
    nil)
   ((T formal-nonempty-subtype-decl nil integral_split_fun nil)
    (T_pred const-decl "[real -> boolean]" integral_split_fun nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Integrable?_inside formula-decl nil integral nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (not_one_element? const-decl "bool" deriv_domain_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (not_one_element formula-decl nil integral_split_fun nil)
    (connected_domain formula-decl nil integral_split_fun nil))
   nil
   (Integral_split_fun3 subtype "integral_split_fun.r1"
    "integral_def[T].Integrable_funs(integral_split_fun.t0, integral_split_fun.tt)"))
  (Integral_split_fun3_TCC2-1 nil 3611662500
   ("" (skosimp*) (("" (lemma "not_one_element") (("" (propax) nil nil)) nil))
    nil)
   nil nil
   (Integral_split_fun3 subtype "integral_split_fun.r1"
    "integral_def[T].Integrable_funs(integral_split_fun.t0, integral_split_fun.tt)")))
 (Integral_split_fun3_TCC3 0
  (Integral_split_fun3_TCC3-3 nil 3615815084
   ("" (skosimp*)
    (("" (lemma "Integrable?_inside[T]")
      (("1" (inst -1 "tSplit1!1" "tSplit2!1" " r2!1" "tSplit1!1" "tt!1")
        (("1" (grind) nil nil)) nil)
       ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
       ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil))
      nil))
    nil)
   ((T formal-nonempty-subtype-decl nil integral_split_fun nil)
    (T_pred const-decl "[real -> boolean]" integral_split_fun nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Integrable?_inside formula-decl nil integral nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (not_one_element? const-decl "bool" deriv_domain_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (Integrable? const-decl "bool" integral_def nil)
    (integrable? const-decl "bool" integral_def nil)
    (integral? const-decl "bool" integral_def nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (width const-decl "posreal" integral_def nil)
    (not_one_element formula-decl nil integral_split_fun nil)
    (connected_domain formula-decl nil integral_split_fun nil))
   nil
   (Integral_split_fun3 subtype "integral_split_fun.r2"
    "integral_def[T].Integrable_funs(integral_split_fun.tSplit1, integral_split_fun.tt)"))
  (Integral_split_fun3_TCC3-2 nil 3615814926
   ("" (skosimp*)
    (("" (lemma "Integrable?_inside[T]")
      (("1" (inst -1 "tSplit1!1" "tSplit2!1" " r2!1" "tSplit!1" "tt!1")
        (("1" (grind) nil)))
       ("2" (lemma "not_one_element") (("2" (propax) nil)))
       ("3" (lemma "connected_domain") (("3" (propax) nil))))))
    nil)
   nil nil
   (Integral_split_fun3 subtype "integral_split_fun.r2"
    "integral_def[T].Integrable_funs(integral_split_fun.tSplit1, integral_split_fun.tt)"))
  (Integral_split_fun3_TCC3-1 nil 3611662500
   ("" (skosimp*)
    (("" (lemma "Integrable?_inside[T]")
      (("1"
        (inst -1 "t0!1" "t1!1"
         "split_fun3(tSplit1!1, tSplit2!1, tSplit3!1, r1!1, r2!1, r3!1,
                      r4!1)" "t0!1" "tt!1")
        (("1" (grind) nil nil)) nil)
       ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
       ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil))
      nil))
    nil)
   ((Integrable?_inside formula-decl nil integral nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (not_one_element? const-decl "bool" deriv_domain_def nil))
   nil
   (Integral_split_fun3 subtype "integral_split_fun.r2"
    "integral_def[T].Integrable_funs(integral_split_fun.tSplit1, integral_split_fun.tt)")))
 (Integral_split_fun3_TCC4 0
  (Integral_split_fun3_TCC4-2 nil 3615815156
   ("" (skosimp*)
    (("" (lemma "Integrable?_inside[T]")
      (("1" (inst -1 "tSplit2!1" "tSplit3!1" " r3!1" "tSplit2!1" "tt!1")
        (("1" (grind) nil nil)) nil)
       ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
       ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil))
      nil))
    nil)
   ((T formal-nonempty-subtype-decl nil integral_split_fun nil)
    (T_pred const-decl "[real -> boolean]" integral_split_fun nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Integrable?_inside formula-decl nil integral nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (not_one_element? const-decl "bool" deriv_domain_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (Integrable? const-decl "bool" integral_def nil)
    (integrable? const-decl "bool" integral_def nil)
    (integral? const-decl "bool" integral_def nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (width const-decl "posreal" integral_def nil)
    (not_one_element formula-decl nil integral_split_fun nil)
    (connected_domain formula-decl nil integral_split_fun nil))
   nil
   (Integral_split_fun3 subtype "integral_split_fun.r3"
    "integral_def[T].Integrable_funs(integral_split_fun.tSplit2, integral_split_fun.tt)"))
  (Integral_split_fun3_TCC4-1 nil 3611662500
   ("" (skosimp*)
    (("" (lemma "Integrable?_inside[T]")
      (("1" (inst -1 "t0!1" "tSplit1!1" " r1!1" "t0!1" "tt!1")
        (("1" (grind) nil nil)) nil)
       ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
       ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil))
      nil))
    nil)
   ((Integrable?_inside formula-decl nil integral nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (not_one_element? const-decl "bool" deriv_domain_def nil))
   nil
   (Integral_split_fun3 subtype "integral_split_fun.r3"
    "integral_def[T].Integrable_funs(integral_split_fun.tSplit2, integral_split_fun.tt)")))
 (Integral_split_fun3_TCC5 0
  (Integral_split_fun3_TCC5-2 nil 3615815227
   ("" (skosimp*)
    (("" (lemma "Integrable?_inside[T]")
      (("1" (inst -1 "tSplit3!1" "t1!1" " r4!1" "tSplit3!1" "tt!1")
        (("1" (grind) nil nil)) nil)
       ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
       ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil))
      nil))
    nil)
   ((T formal-nonempty-subtype-decl nil integral_split_fun nil)
    (T_pred const-decl "[real -> boolean]" integral_split_fun nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Integrable?_inside formula-decl nil integral nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (not_one_element? const-decl "bool" deriv_domain_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (Integrable? const-decl "bool" integral_def nil)
    (integrable? const-decl "bool" integral_def nil)
    (integral? const-decl "bool" integral_def nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (width const-decl "posreal" integral_def nil)
    (not_one_element formula-decl nil integral_split_fun nil)
    (connected_domain formula-decl nil integral_split_fun nil))
   nil
   (Integral_split_fun3 subtype "integral_split_fun.r4"
    "integral_def[T].Integrable_funs(integral_split_fun.tSplit3, integral_split_fun.tt)"))
  (Integral_split_fun3_TCC5-1 nil 3611662500
   ("" (skosimp*)
    (("" (lemma "Integrable?_inside[T]")
      (("1" (inst -1 "tSplit1!1" "tSplit2!1" " r2!1" "tSplit1!1" "tt!1")
        (("1" (grind) nil nil)) nil)
       ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
       ("3" (lemma "connected_domain") (("3" (propax) nil nil)) nil))
      nil))
    nil)
   ((Integrable?_inside formula-decl nil integral nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (not_one_element? const-decl "bool" deriv_domain_def nil))
   nil
   (Integral_split_fun3 subtype "integral_split_fun.r4"
    "integral_def[T].Integrable_funs(integral_split_fun.tSplit3, integral_split_fun.tt)")))
 (Integral_split_fun3 0
  (Integral_split_fun3-1 nil 3611667504
   ("" (skosimp*)
    (("" (lemma "split_fun3_Integrable")
      ((""
        (inst -1 "r1!1" "r2!1" "r3!1" "r4!1" "t0!1" "t1!1" "tSplit1!1"
         "tSplit2!1" "tSplit3!1")
        (("" (prop)
          (("" (lemma "split_middle_fun3")
            ((""
              (inst -1 "r1!1" "r2!1" "r3!1" "r4!1" "tSplit1!1" "tSplit2!1"
               "tSplit3!1")
              (("" (expand "in_order?")
                (("" (flatten)
                  (("" (prop)
                    (("" (replace -1)
                      (("" (lemma "Integral_split_fun")
                        ((""
                          (inst -1 " split_fun(tSplit1!1, r1!1, r2!1)"
                           "split_fun(tSplit3!1, r3!1, r4!1)" "t0!1" "t1!1"
                           "tSplit2!1" "tt!1")
                          (("" (lemma "split_fun_Integrable")
                            ((""
                              (inst-cp -1 "r1!1" "r2!1" "t0!1" "tSplit2!1"
                               "tSplit1!1")
                              ((""
                                (inst -1 "r3!1" "r4!1" "tSplit2!1" "t1!1"
                                 "tSplit3!1")
                                (("" (prop)
                                  (("1" (replace -2)
                                    (("1" (case "tt!1<=tSplit2!1")
                                      (("1"
                                        (assert)
                                        (("1"
                                          (lemma "Integral_split_fun")
                                          (("1"
                                            (inst
                                             -1
                                             "r1!1"
                                             "r2!1"
                                             "t0!1"
                                             "tSplit2!1"
                                             "tSplit1!1"
                                             "tt!1")
                                            (("1" (prop) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (assert)
                                        (("2"
                                          (hide (-1 -2 -3 -4 -5 -6))
                                          (("2"
                                            (lemma "Integral_split_fun")
                                            (("2"
                                              (inst-cp
                                               -1
                                               "r1!1"
                                               "r2!1"
                                               "t0!1"
                                               "tSplit2!1"
                                               "tSplit1!1"
                                               "tSplit2!1")
                                              (("2"
                                                (inst
                                                 -1
                                                 "r3!1"
                                                 "r4!1"
                                                 "tSplit2!1"
                                                 "t1!1"
                                                 "tSplit3!1"
                                                 "tt!1")
                                                (("2"
                                                  (prop)
                                                  (("1"
                                                    (case
                                                     "Integral(t0!1, tSplit2!1, split_fun(tSplit1!1, r1!1, r2!1)) =
        Integral(t0!1, tSplit1!1, r1!1) +
             Integral(tSplit1!1, tSplit2!1, r2!1)")
                                                    (("1"
                                                      (replace -1)
                                                      (("1"
                                                        (replace -5)
                                                        (("1"
                                                          (lift-if 2)
                                                          (("1"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (case-replace
                                                       "tSplit2!1=tSplit1!1")
                                                      (("1"
                                                        (lemma
                                                         "Integral_a_to_a[T]")
                                                        (("1"
                                                          (inst
                                                           -1
                                                           "tSplit1!1"
                                                           "r2!1")
                                                          (("1"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2" (grind) nil nil))
                                                      nil)
                                                     ("3"
                                                      (lemma
                                                       "not_one_element")
                                                      (("3" (propax) nil nil))
                                                      nil)
                                                     ("4"
                                                      (lemma
                                                       "connected_domain")
                                                      (("4" (propax) nil nil))
                                                      nil))
                                                    nil)
                                                   ("2" (grind) nil nil)
                                                   ("3" (grind) nil nil)
                                                   ("4" (grind) nil nil)
                                                   ("5" (grind) nil nil)
                                                   ("6" (grind) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil)
                                   ("3" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((split_fun3_Integrable formula-decl nil integral_split_fun nil)
    (split_fun const-decl "[T -> real]" integral_split_fun nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (<= const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (connected_domain formula-decl nil integral_split_fun nil)
    (not_one_element formula-decl nil integral_split_fun nil)
    (Integral_a_to_a formula-decl nil integral nil)
    (width const-decl "posreal" integral_def nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (integral? const-decl "bool" integral_def nil)
    (integrable? const-decl "bool" integral_def nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (not_one_element? const-decl "bool" deriv_domain_def nil)
    (connected? const-decl "bool" deriv_domain_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (Integral const-decl "real" integral_def nil)
    (Integrable_funs type-eq-decl nil integral_def nil)
    (Integrable? const-decl "bool" integral_def nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (split_fun_Integrable formula-decl nil integral_split_fun nil)
    (Integral_split_fun formula-decl nil integral_split_fun nil)
    (in_order? const-decl "bool" integral_split_fun nil)
    (split_middle_fun3 formula-decl nil integral_split_fun nil)
    (T formal-nonempty-subtype-decl nil integral_split_fun nil)
    (T_pred const-decl "[real -> boolean]" integral_split_fun nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak)))

