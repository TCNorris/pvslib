(digraphs_
 (empty_digraph_TCC1 0
  (empty_digraph_TCC1-1 nil 3657104939 ("" (subtype-tcc) nil nil)
   ((emptyset const-decl "set" sets nil)) nil
   (empty_digraph subtype "sets[edgetype[T]].emptyset"
    "{e: (finite_sets[[digraphs_.T, digraphs_.T]].is_finite) | FORALL (x, y: digraphs_.T): booleans.IMPLIES(e(x, y), booleans.AND(sets[digraphs_.T].emptyset(x), sets[digraphs_.T].emptyset(y)))}")))
 (adjs_TCC1 0
  (adjs_TCC1-1 nil 3656665115
   ("" (skeep)
    (("" (use "concretedigraph_implements_abstractdigraph")
      (("" (expand "correct_implementation")
        (("" (expand "correct_implementation_")
          (("" (flatten)
            (("" (inst? -2)
              (("" (hide-all-but (-2 1))
                (("" (expand "is_finite")
                  (("" (skeep)
                    ((""
                      (inst 1 "N" "LAMBDA(s:({y | edges(G)(x, y)})): f(x, s)")
                      (("" (expand "injective?")
                        (("" (skeep)
                          (("" (inst?) (("" (assert) nil nil)) nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((concretedigraph_implements_abstractdigraph formula-decl nil digraphs_
     nil)
    (correct_implementation_ const-decl "bool" digraphs_abs nil)
    (ConcreteDigraph formal-type-decl nil digraphs_ nil)
    (is_finite const-decl "bool" finite_sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil digraphs_ nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]" digraphs_
     nil)
    (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil)
    (injective? const-decl "bool" functions nil)
    (correct_implementation const-decl "bool" digraphs_abs nil))
   nil
   (adjs subtype
    "{y | digraphs_.edges(digraphs_.G)(digraphs_.x, digraphs_.y)}"
    "finite_set[T]")))
 (edges_vert 0
  (edges_vert-1 nil 3507100927
   ("" (skosimp*)
    (("" (lemma "edges_in_verts")
      (("" (assert)
        (("" (inst -1 "G!1" "e!1`1" "e!1`2")
          (("" (split -1)
            (("1" (flatten)
              (("1" (expand "in?")
                (("1" (split -3)
                  (("1" (replace -1 :dir rl)
                    (("1" (inst + "PROJ_2(e!1)") nil nil)) nil)
                   ("2" (replace -1 :dir rl)
                    (("2" (inst + "PROJ_1(e!1)") nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (assert) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" digraphs_ nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" digraphs_ nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]" digraphs_
     nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" digraphs_ nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ConcreteDigraph formal-type-decl nil digraphs_ nil)
    (T formal-type-decl nil digraphs_ nil)
    (edges_in_verts formula-decl nil digraphs_abs nil)
    (edgetype type-eq-decl nil digraphs_utils nil)
    (in? const-decl "bool" pairs structures)
    (concretedigraph_implements_abstractdigraph formula-decl nil digraphs_
     nil))
   nil))
 (other_vert 0
  (other_vert-1 nil 3507100927
   ("" (skosimp*)
    (("" (lemma "edges_in_verts")
      (("" (assert)
        (("" (inst?)
          (("" (inst -1 "e!1`1" "e!1`2")
            (("" (split -1)
              (("1" (flatten)
                (("1" (expand "in?")
                  (("1" (split -3)
                    (("1" (inst + "PROJ_2(e!1)") (("1" (assert) nil nil)) nil)
                     ("2" (inst + "PROJ_1(e!1)") (("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" digraphs_ nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" digraphs_ nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]" digraphs_
     nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" digraphs_ nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ConcreteDigraph formal-type-decl nil digraphs_ nil)
    (T formal-type-decl nil digraphs_ nil)
    (edges_in_verts formula-decl nil digraphs_abs nil)
    (in? const-decl "bool" pairs structures)
    (edgetype type-eq-decl nil digraphs_utils nil)
    (concretedigraph_implements_abstractdigraph formula-decl nil digraphs_
     nil))
   nil))
 (edges_to_pair 0
  (edges_to_pair-2 "" 3790100574
   ("" (skosimp*)
    (("" (inst + "proj_1(e!1)" "proj_2(e!1)") (("" (assert) nil nil)) nil))
    nil)
   ((T formal-type-decl nil digraphs_ nil)
    (edgetype type-eq-decl nil digraphs_utils nil)
    (concretedigraph_implements_abstractdigraph formula-decl nil digraphs_
     nil)
    (make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" digraphs_ nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" digraphs_ nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]" digraphs_
     nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" digraphs_ nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ConcreteDigraph formal-type-decl nil digraphs_ nil)
    (edges_in_verts formula-decl nil digraphs_abs nil))
   shostak)
  (edges_to_pair-1 nil 3507100927
   ("" (skosimp*)
    (("" (inst + "proj_1(e!1)" "proj_2(e!1)")
      (("" (assert)
        (("" (case "e!1 = (proj_1(e!1),proj_2(e!1))")
          (("1" (replace -1 -)
            (("1" (assert)
              (("1" (use "edges_in_verts")
                (("1" (split -1)
                  (("1" (inst?) (("1" (assert) nil nil)) nil)
                   ("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((edgetype type-eq-decl nil digraphs_utils nil)
    (edges_in_verts formula-decl nil digraphs_abs nil))
   nil))
 (empty?_rew_TCC1 0
  (empty?_rew_TCC1-1 nil 3660743292 ("" (assert) nil nil)
   ((concretedigraph_implements_abstractdigraph formula-decl nil digraphs_
     nil)
    (make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" digraphs_ nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" digraphs_ nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]" digraphs_
     nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" digraphs_ nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ConcreteDigraph formal-type-decl nil digraphs_ nil)
    (T formal-type-decl nil digraphs_ nil)
    (vert_is_finite formula-decl nil digraphs_abs nil))
   nil (empty?_rew subtype "digraphs_.vert(digraphs_.G)" "finite_set[T]")))
 (empty?_rew 0
  (empty?_rew-1 nil 3507100927
   ("" (skosimp*)
    (("" (lemma " card_empty?[T]")
      (("" (inst?)
        (("" (expand "empty?" 1)
          (("" (replace -1) (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil digraphs_ nil)
    (card_empty? formula-decl nil finite_sets nil)
    (empty? const-decl "bool" digraphs_ nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" digraphs_ nil)
    (ConcreteDigraph formal-type-decl nil digraphs_ nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (empty_size 0
  (empty_size-1 nil 3559650566
   ("" (skeep)
    (("" (assert) (("" (rewrite "empty?_rew") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((size_def formula-decl nil digraphs_abs nil)
    (T formal-type-decl nil digraphs_ nil)
    (ConcreteDigraph formal-type-decl nil digraphs_ nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" digraphs_ nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]" digraphs_
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" digraphs_ nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" digraphs_ nil)
    (concretedigraph_implements_abstractdigraph formula-decl nil digraphs_
     nil)
    (empty?_rew formula-decl nil digraphs_ nil))
   shostak))
 (edges_of_empty 0
  (edges_of_empty-2 "" 3790100576
   ("" (skosimp*)
    (("" (expand "empty?")
      (("" (apply-extensionality 1 :hide? t)
        (("" (expand "emptyset")
          (("" (expand "empty?")
            (("" (expand "member")
              (("" (use "edges_in_verts")
                (("" (split -1)
                  (("1" (inst?) (("1" (assert) nil nil)) nil)
                   ("2" (assert) nil nil) ("3" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((empty? const-decl "bool" digraphs_ nil)
    (member const-decl "bool" sets nil)
    (concretedigraph_implements_abstractdigraph formula-decl nil digraphs_
     nil)
    (make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" digraphs_ nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" digraphs_ nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" digraphs_ nil)
    (edges_in_verts formula-decl nil digraphs_abs nil)
    (empty? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (ConcreteDigraph formal-type-decl nil digraphs_ nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]" digraphs_
     nil)
    (edgetype type-eq-decl nil digraphs_utils nil)
    (set type-eq-decl nil sets nil) (emptyset const-decl "set" sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil digraphs_ nil))
   shostak)
  (edges_of_empty-1 nil 3507100927
   ("" (skosimp*)
    (("" (expand "empty?")
      (("" (apply-extensionality 1 :hide? t)
        (("" (expand "emptyset")
          (("" (expand "empty?")
            (("" (expand "member")
              (("" (use "edges_in_verts")
                (("" (split -1)
                  (("1" (inst?)
                    (("1" (assert)
                      (("1" (inst?) (("1" (assert) nil nil)) nil)) nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((edges_in_verts formula-decl nil digraphs_abs nil)
    (edgetype type-eq-decl nil digraphs_utils nil))
   nil))
 (singleton_edges 0
  (singleton_edges-2 nil 3660747029
   ("" (skosimp*)
    (("" (expand "singleton?")
      (("" (assert)
        (("" (lemma "card_one[T]")
          (("" (inst?)
            (("" (assert)
              (("" (hide -2)
                (("" (skosimp*)
                  (("" (expand "empty?")
                    (("" (skosimp*)
                      (("" (expand "member")
                        (("" (lemma "edges_in_verts")
                          (("" (assert)
                            (("" (inst?)
                              (("" (inst -1 "x!2`1" "x!2`2")
                                (("" (split -1)
                                  (("1" (flatten)
                                    (("1" (replace -3)
                                      (("1"
                                        (hide -3)
                                        (("1"
                                          (expand "singleton")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (typepred "SG!1")
                                              (("1"
                                                (inst?)
                                                (("1" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((singleton? const-decl "bool" digraphs_ nil)
    (card_one formula-decl nil finite_sets nil)
    (edges_in_verts formula-decl nil digraphs_abs nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_singleton_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (edgetype type-eq-decl nil digraphs_utils nil)
    (/= const-decl "boolean" notequal nil)
    (simple_digraph type-eq-decl nil digraphs_ nil)
    (concretedigraph_implements_abstractdigraph formula-decl nil digraphs_
     nil)
    (make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" digraphs_ nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" digraphs_ nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]" digraphs_
     nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" digraphs_ nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ConcreteDigraph formal-type-decl nil digraphs_ nil)
    (T formal-type-decl nil digraphs_ nil)
    (size_def formula-decl nil digraphs_abs nil))
   nil)
  (singleton_edges-1 nil 3507100927
   ("" (skosimp*)
    (("" (expand "singleton?")
      (("" (expand "size")
        (("" (lemma "card_one[T]")
          (("" (inst?)
            (("" (assert)
              (("" (hide -2)
                (("" (skosimp*)
                  (("" (expand "empty?")
                    (("" (skosimp*)
                      (("" (expand "member")
                        (("" (lemma "edges_in_verts")
                          (("" (assert)
                            (("" (inst?)
                              (("" (inst -1 "x!2`1" "x!2`2")
                                (("" (split -1)
                                  (("1" (flatten)
                                    (("1" (replace -3)
                                      (("1"
                                        (hide -3)
                                        (("1"
                                          (expand "singleton")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (typepred "SG!1")
                                              (("1"
                                                (inst?)
                                                (("1" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((edges_in_verts formula-decl nil digraphs_abs nil)
    (edgetype type-eq-decl nil digraphs_utils nil))
   nil))
 (edge_in_card_gt_1_TCC1 0
  (edge_in_card_gt_1_TCC1-2 "" 3790100576 ("" (assert) nil nil)
   ((concretedigraph_implements_abstractdigraph formula-decl nil digraphs_
     nil)
    (make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" digraphs_ nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" digraphs_ nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]" digraphs_
     nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" digraphs_ nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ConcreteDigraph formal-type-decl nil digraphs_ nil)
    (T formal-type-decl nil digraphs_ nil)
    (vert_is_finite formula-decl nil digraphs_abs nil))
   shostak
   (edge_in_card_gt_1 subtype "digraphs_.vert(digraphs_.SG)" "finite_set[T]"))
  (edge_in_card_gt_1_TCC1-1 nil 3657643495
   ("" (assert)
    (("" (skeep)
      (("" (assert)
        (("" (lemma "vert_is_finite")
          (("" (split -1) (("1" (inst?) nil nil) ("2" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((vert_is_finite formula-decl nil digraphs_abs nil)) nil
   (edge_in_card_gt_1 subtype "digraphs_.vert(digraphs_.SG)"
    "finite_set[T]")))
 (edge_in_card_gt_1 0
  (edge_in_card_gt_1-1 nil 3507100927
   ("" (skosimp*)
    (("" (typepred "SG!1")
      (("" (lemma "edges_in_verts")
        (("" (assert)
          (("" (inst?)
            (("" (inst -1 "e!1`1" "e!1`2")
              (("" (inst?)
                (("" (split -1)
                  (("1" (assert)
                    (("1" (flatten)
                      (("1"
                        (case "subset?(add(PROJ_1(e!1),singleton(PROJ_2(e!1))),vert(SG!1))")
                        (("1" (lemma "card_subset[T]")
                          (("1" (inst?)
                            (("1" (assert)
                              (("1" (rewrite "card_add")
                                (("1" (rewrite "card_singleton")
                                  (("1" (hide -2)
                                    (("1" (expand "singleton")
                                      (("1" (assert) nil nil)) nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((simple_digraph type-eq-decl nil digraphs_ nil)
    (/= const-decl "boolean" notequal nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]" digraphs_
     nil)
    (ConcreteDigraph formal-type-decl nil digraphs_ nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (edgetype type-eq-decl nil digraphs_utils nil)
    (T formal-type-decl nil digraphs_ nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (concretedigraph_implements_abstractdigraph formula-decl nil digraphs_
     nil)
    (member const-decl "bool" sets nil)
    (card_subset formula-decl nil finite_sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (card_singleton formula-decl nil finite_sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (card_add formula-decl nil finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (singleton? const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (nonempty_singleton_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (edges_in_verts formula-decl nil digraphs_abs nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" digraphs_ nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" digraphs_ nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" digraphs_ nil))
   nil))
 (not_singleton_2_vert 0
  (not_singleton_2_vert-2 nil 3660747075
   ("" (skosimp*)
    (("" (expand "empty?")
      (("" (lemma "card_empty?[T]")
        (("" (inst?)
          (("" (iff)
            (("" (assert)
              (("" (expand "singleton?")
                (("" (assert)
                  (("" (lemma "card_2_has_2[T]")
                    (("" (inst -1 "vert(G!1)") (("" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((empty? const-decl "bool" digraphs_ nil)
    (vert_is_finite formula-decl nil digraphs_abs nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]" digraphs_
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" digraphs_ nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" digraphs_ nil)
    (concretedigraph_implements_abstractdigraph formula-decl nil digraphs_
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (ConcreteDigraph formal-type-decl nil digraphs_ nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" digraphs_ nil)
    (size_def formula-decl nil digraphs_abs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (card_2_has_2 formula-decl nil finite_sets nil)
    (singleton? const-decl "bool" digraphs_ nil)
    (card_empty? formula-decl nil finite_sets nil)
    (T formal-type-decl nil digraphs_ nil))
   nil)
  (not_singleton_2_vert-1 nil 3507100927
   ("" (skosimp*)
    (("" (expand "empty?")
      (("" (lemma "card_empty?[T]")
        (("" (inst?)
          (("1" (iff)
            (("1" (assert)
              (("1" (expand "singleton?")
                (("1" (expand "size")
                  (("1" (lemma "card_2_has_2[T]")
                    (("1" (inst -1 "vert(G!1)") (("1" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (assert)
            (("2" (use "vert_is_finite")
              (("2" (split -1) (("1" (inst?) nil nil) ("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((vert_is_finite formula-decl nil digraphs_abs nil)) nil))
 (proj_rew 0
  (proj_rew-2 "" 3790100578 ("" (skosimp*) (("" (assert) nil nil)) nil) nil
   shostak)
  (proj_rew-1 nil 3507100927
   ("" (skosimp*)
    (("" (assert) (("" (apply-extensionality 1 :hide? t) nil nil)) nil)) nil)
   nil nil))
 (singleton_digraph_TCC1 0
  (singleton_digraph_TCC1-1 nil 3507100927
   ("" (skosimp*) (("" (grind) nil nil)) nil)
   ((emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   nil
   (singleton_digraph subtype "sets[edgetype[T]].emptyset"
    "{e: (finite_sets[[digraphs_.T, digraphs_.T]].is_finite) | FORALL (x, y: digraphs_.T): booleans.IMPLIES(e(x, y), booleans.AND(sets[digraphs_.T].singleton(digraphs_.v)(x), sets[digraphs_.T].singleton(digraphs_.v)(y)))}")))
 (is_sing 0
  (is_sing-2 nil 3660747107
   ("" (expand "singleton_digraph")
    (("" (expand "singleton?")
      (("" (assert)
        (("" (skeep)
          (("" (use "make_ok")
            (("" (split -1)
              (("1" (flatten)
                (("1" (replace -1 :hide? t)
                  (("1" (rewrite "card_singleton") nil nil)) nil))
                nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((singleton? const-decl "bool" digraphs_ nil)
    (card_singleton formula-decl nil finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (edgetype type-eq-decl nil digraphs_utils nil)
    (edge_type type-eq-decl nil digraphs_abs nil)
    (singleton const-decl "(singleton?)" sets nil)
    (singleton? const-decl "bool" sets nil)
    (vert_type type-eq-decl nil digraphs_abs nil)
    (make_ok formula-decl nil digraphs_abs nil)
    (concretedigraph_implements_abstractdigraph formula-decl nil digraphs_
     nil)
    (make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" digraphs_ nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" digraphs_ nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]" digraphs_
     nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" digraphs_ nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ConcreteDigraph formal-type-decl nil digraphs_ nil)
    (T formal-type-decl nil digraphs_ nil)
    (size_def formula-decl nil digraphs_abs nil)
    (nonempty_singleton_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (singleton_digraph const-decl "ConcreteDigraph" digraphs_ nil))
   nil)
  (is_sing-1 nil 3507100927
   ("" (expand "singleton_digraph")
    (("" (expand "singleton?")
      (("" (expand "size")
        (("" (skeep)
          (("" (use "make_ok")
            (("" (split -1)
              (("1" (flatten)
                (("1" (replace -1 :hide? t)
                  (("1" (rewrite "card_singleton") nil nil)) nil))
                nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((vert_type type-eq-decl nil digraphs_abs nil)
    (edge_type type-eq-decl nil digraphs_abs nil)
    (edgetype type-eq-decl nil digraphs_utils nil)
    (make_ok formula-decl nil digraphs_abs nil))
   nil)))

