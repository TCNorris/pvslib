(di_subgraphs_
 (IMP_digraphs__TCC1 0
  (IMP_digraphs__TCC1-1 nil 3657646651
   ("" (use "concretedigraph_implements_abstractdigraph") nil nil)
   ((concretedigraph_implements_abstractdigraph formula-decl nil di_subgraphs_
     nil))
   nil
   (IMP_digraphs_ assuming
    "digraphs_[di_subgraphs_.T, di_subgraphs_.ConcreteDigraph, di_subgraphs_.vert, di_subgraphs_.edges, di_subgraphs_.size, di_subgraphs_.make].digraphs_"
    "concretedigraph_implements_abstractdigraph: ASSUMPTION digraphs_abs[digraphs_.T, digraphs_.ConcreteDigraph, digraphs_.vert, digraphs_.edges, digraphs_.size, digraphs_.make].correct_implementation")))
 (finite_vert_subset 0
  (finite_vert_subset-2 "" 3790100680
   ("" (skosimp*)
    (("" (lemma "finite_subset[T]")
      (("" (inst?)
        (("" (inst -1 "vert(G!1)")
          (("" (assert) (("" (hide 2) (("" (grind) nil nil)) nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil di_subgraphs_ nil)
    (finite_subset formula-decl nil finite_sets nil)
    (vert_is_finite formula-decl nil digraphs_abs nil)
    (concretedigraph_implements_abstractdigraph formula-decl nil digraphs_
     nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]"
     di_subgraphs_ nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" di_subgraphs_ nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" di_subgraphs_ nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" di_subgraphs_
     nil)
    (ConcreteDigraph formal-type-decl nil di_subgraphs_ nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak)
  (finite_vert_subset-1 nil 3253624236
   ("" (skosimp*)
    (("" (lemma "finite_subset[T]")
      (("" (inst?)
        (("" (inst -1 "vert(G!1)")
          (("1" (assert) (("1" (hide 2) (("1" (grind) nil nil)) nil)) nil)
           ("2" (typepred "vert") (("2" (inst?) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((vert_is_finite formula-decl nil digraphs_abs nil)
    (concretedigraph_implements_abstractdigraph formula-decl nil digraphs_
     nil))
   nil))
 (finite_edge_subset 0
  (finite_edge_subset-2 "" 3790100681
   ("" (skosimp*)
    (("" (lemma "finite_subset[edgetype]")
      (("" (inst?)
        (("" (inst - "edges(G!1)")
          (("" (assert) (("" (hide 2) (("" (grind) nil nil)) nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((edgetype type-eq-decl nil digraphs_utils nil)
    (T formal-type-decl nil di_subgraphs_ nil)
    (finite_subset formula-decl nil finite_sets nil)
    (edges_is_finite formula-decl nil digraphs_abs nil)
    (concretedigraph_implements_abstractdigraph formula-decl nil digraphs_
     nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" di_subgraphs_
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" di_subgraphs_ nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" di_subgraphs_ nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]"
     di_subgraphs_ nil)
    (ConcreteDigraph formal-type-decl nil di_subgraphs_ nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak)
  (finite_edge_subset-1 nil 3307706313
   ("" (skosimp*)
    (("" (lemma "finite_subset[edgetype]")
      (("" (inst?)
        (("" (inst - "edges(G!1)")
          (("1" (assert) (("1" (hide 2) (("1" (grind) nil nil)) nil)) nil)
           ("2" (typepred "edges")
            (("2" (inst?) (("2" (flatten) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((edgetype type-eq-decl nil digraphs_utils nil)
    (edges_is_finite formula-decl nil digraphs_abs nil)
    (concretedigraph_implements_abstractdigraph formula-decl nil digraphs_
     nil))
   nil))
 (di_subgraph_TCC1 0
  (di_subgraph_TCC1-1 nil 3253624236
   ("" (skosimp*) (("" (use "finite_vert_subset") nil nil)) nil)
   ((set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil di_subgraphs_ nil)
    (ConcreteDigraph formal-type-decl nil di_subgraphs_ nil)
    (finite_vert_subset formula-decl nil di_subgraphs_ nil))
   nil
   (di_subgraph subtype
    "{i | booleans.AND(di_subgraphs_.vert(di_subgraphs_.G)(di_subgraphs_.i), di_subgraphs_.V(di_subgraphs_.i))}"
    "(finite_sets[di_subgraphs_.T].is_finite)")))
 (di_subgraph_TCC2 0
  (di_subgraph_TCC2-2 "" 3790100681
   ("" (skosimp*)
    (("" (use "finite_edge_subset")
      (("" (assert) (("" (skeep) (("" (assert) nil nil)) nil)) nil)) nil))
    nil)
   ((finite_edge_subset formula-decl nil di_subgraphs_ nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil di_subgraphs_ nil)
    (ConcreteDigraph formal-type-decl nil di_subgraphs_ nil)
    (make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" di_subgraphs_ nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" di_subgraphs_ nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]"
     di_subgraphs_ nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" di_subgraphs_
     nil)
    (concretedigraph_implements_abstractdigraph formula-decl nil digraphs_
     nil)
    (edges_in_verts formula-decl nil digraphs_abs nil))
   shostak
   (di_subgraph subtype
    "{e | booleans.AND(di_subgraphs_.edges(di_subgraphs_.G)(di_subgraphs_.e), (LET (x, y) = di_subgraphs_.e IN booleans.AND(di_subgraphs_.V(di_subgraphs_.x), di_subgraphs_.V(di_subgraphs_.y))))}"
    "{e: (finite_sets[[di_subgraphs_.T, di_subgraphs_.T]].is_finite) | FORALL (x, y: di_subgraphs_.T): booleans.IMPLIES(e(x, y), booleans.AND(booleans.AND(di_subgraphs_.vert(di_subgraphs_.G)(x), di_subgraphs_.V(x)), booleans.AND(di_subgraphs_.vert(di_subgraphs_.G)(y), di_subgraphs_.V(y))))}"))
  (di_subgraph_TCC2-1 nil 3307703845
   ("" (skosimp*)
    (("" (use "finite_edge_subset")
      (("" (assert)
        (("" (skeep)
          (("" (assert)
            (("" (typepred "edges(G!1)")
              (("" (inst?) (("" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((concretedigraph_implements_abstractdigraph formula-decl nil digraphs_
     nil)
    (edges_in_verts formula-decl nil digraphs_abs nil))
   nil
   (di_subgraph subtype
    "{e | booleans.AND(di_subgraphs_.edges(di_subgraphs_.G)(di_subgraphs_.e), (LET (x, y) = di_subgraphs_.e IN booleans.AND(di_subgraphs_.V(di_subgraphs_.x), di_subgraphs_.V(di_subgraphs_.y))))}"
    "{e: (finite_sets[[di_subgraphs_.T, di_subgraphs_.T]].is_finite) | FORALL (x, y: di_subgraphs_.T): booleans.IMPLIES(e(x, y), booleans.AND(booleans.AND(di_subgraphs_.vert(di_subgraphs_.G)(x), di_subgraphs_.V(x)), booleans.AND(di_subgraphs_.vert(di_subgraphs_.G)(y), di_subgraphs_.V(y))))}")))
 (di_subgraph_TCC3 0
  (di_subgraph_TCC3-2 nil 3307706135
   ("" (skosimp*)
    (("" (expand "di_subgraph?")
      (("" (use "make_ok")
        (("1" (assert) (("1" (grind) nil nil)) nil)
         ("2" (hide 2)
          (("2" (use "finite_edge_subset")
            (("2" (assert) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil))
            nil))
          nil)
         ("3" (hide 2) (("3" (use "finite_vert_subset") nil nil)) nil))
        nil))
      nil))
    nil)
   ((di_subgraph? const-decl "bool" di_subgraphs_ nil)
    (make_ok formula-decl nil digraphs_abs nil)
    (T formal-type-decl nil di_subgraphs_ nil)
    (ConcreteDigraph formal-type-decl nil di_subgraphs_ nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" di_subgraphs_
     nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]"
     di_subgraphs_ nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" di_subgraphs_ nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" di_subgraphs_ nil)
    (edge_type type-eq-decl nil digraphs_abs nil)
    (vert_type type-eq-decl nil digraphs_abs nil)
    (edgetype type-eq-decl nil digraphs_utils nil)
    (V!1 skolem-const-decl "set[T]" di_subgraphs_ nil)
    (G!1 skolem-const-decl "ConcreteDigraph" di_subgraphs_ nil)
    (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)
    (make_ok_e formula-decl nil digraphs_abs nil)
    (make_ok_v formula-decl nil digraphs_abs nil)
    (concretedigraph_implements_abstractdigraph formula-decl nil digraphs_
     nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (finite_edge_subset formula-decl nil di_subgraphs_ nil)
    (edges_in_verts formula-decl nil digraphs_abs nil)
    (finite_vert_subset formula-decl nil di_subgraphs_ nil))
   nil
   (di_subgraph subtype
    "di_subgraphs_.make({i | booleans.AND(di_subgraphs_.vert(di_subgraphs_.G)(di_subgraphs_.i), di_subgraphs_.V(di_subgraphs_.i))}, {e | booleans.AND(di_subgraphs_.edges(di_subgraphs_.G)(di_subgraphs_.e), (LET (x, y) = di_subgraphs_.e IN booleans.AND(di_subgraphs_.V(di_subgraphs_.x), di_subgraphs_.V(di_subgraphs_.y))))})"
    "di_subgraphs_.di_subgraph(di_subgraphs_.G)"))
  (di_subgraph_TCC3-1 nil 3307703845 ("" (subtype-tcc) nil nil) nil nil
   (di_subgraph subtype
    "di_subgraphs_.make({i | booleans.AND(di_subgraphs_.vert(di_subgraphs_.G)(di_subgraphs_.i), di_subgraphs_.V(di_subgraphs_.i))}, {e | booleans.AND(di_subgraphs_.edges(di_subgraphs_.G)(di_subgraphs_.e), (LET (x, y) = di_subgraphs_.e IN booleans.AND(di_subgraphs_.V(di_subgraphs_.x), di_subgraphs_.V(di_subgraphs_.y))))})"
    "di_subgraphs_.di_subgraph(di_subgraphs_.G)")))
 (di_subgraph_vert_sub 0
  (di_subgraph_vert_sub-1 nil 3253624236
   ("" (skosimp*)
    (("" (expand "di_subgraph")
      (("" (use "make_ok")
        (("1" (split -1)
          (("1" (flatten)
            (("1" (replace -1 :hide? t)
              (("1" (hide -1)
                (("1" (apply-extensionality 1 :hide? t)
                  (("1" (expand "subset?")
                    (("1" (inst?)
                      (("1" (expand "member")
                        (("1" (iff 1) (("1" (ground) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (assert) nil nil))
          nil)
         ("2" (hide 2)
          (("2" (use "finite_edge_subset")
            (("2" (assert) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil))
            nil))
          nil)
         ("3" (use "finite_vert_subset") nil nil))
        nil))
      nil))
    nil)
   ((di_subgraph const-decl "di_subgraph(G)" di_subgraphs_ nil)
    (make_ok formula-decl nil digraphs_abs nil)
    (T formal-type-decl nil di_subgraphs_ nil)
    (ConcreteDigraph formal-type-decl nil di_subgraphs_ nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" di_subgraphs_
     nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]"
     di_subgraphs_ nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" di_subgraphs_ nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" di_subgraphs_ nil)
    (edge_type type-eq-decl nil digraphs_abs nil)
    (vert_type type-eq-decl nil digraphs_abs nil)
    (edgetype type-eq-decl nil digraphs_utils nil)
    (V!1 skolem-const-decl "set[T]" di_subgraphs_ nil)
    (G!1 skolem-const-decl "ConcreteDigraph" di_subgraphs_ nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil)
    (concretedigraph_implements_abstractdigraph formula-decl nil digraphs_
     nil)
    (finite_edge_subset formula-decl nil di_subgraphs_ nil)
    (edges_in_verts formula-decl nil digraphs_abs nil)
    (finite_vert_subset formula-decl nil di_subgraphs_ nil))
   nil))
 (di_subgraph_lem 0
  (di_subgraph_lem-1 nil 3253624236
   ("" (skosimp*) (("" (assert) nil nil)) nil) nil nil))
 (di_subgraph_smaller 0
  (di_subgraph_smaller-2 nil 3660748338
   ("" (skosimp*)
    (("" (assert)
      (("" (expand "di_subgraph?") (("" (rewrite "card_subset[T]") nil nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (size_def formula-decl nil digraphs_abs nil)
    (concretedigraph_implements_abstractdigraph formula-decl nil digraphs_
     nil)
    (T formal-type-decl nil di_subgraphs_ nil)
    (ConcreteDigraph formal-type-decl nil di_subgraphs_ nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" di_subgraphs_
     nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]"
     di_subgraphs_ nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" di_subgraphs_ nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" di_subgraphs_ nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (card_subset formula-decl nil finite_sets nil)
    (di_subgraph? const-decl "bool" di_subgraphs_ nil))
   nil)
  (di_subgraph_smaller-1 nil 3253624236
   ("" (skosimp*)
    (("" (expand "size")
      (("" (expand "di_subgraph?") (("" (rewrite "card_subset[T]") nil nil))
        nil))
      nil))
    nil)
   nil nil))
 (di_subgraph_vert 0
  (di_subgraph_vert-1 nil 3654873452
   ("" (skeep)
    (("" (expand "di_subgraph")
      (("" (expand "obs_eq")
        (("" (use "make_ok")
          (("1" (split -1)
            (("1" (flatten)
              (("1" (replace -1 :hide? t)
                (("1" (replace -1 :hide? t)
                  (("1" (split 1)
                    (("1" (apply-extensionality)
                      (("1" (hide 2) (("1" (grind) nil nil)) nil)) nil)
                     ("2" (expand "di_subgraph?")
                      (("2" (apply-extensionality)
                        (("2" (hide 2)
                          (("2" (flatten)
                            (("2" (iff)
                              (("2" (split 1)
                                (("1" (flatten)
                                  (("1" (inst -6 "x!1" "x!2")
                                    (("1" (assert)
                                      (("1"
                                        (expand "edge?")
                                        (("1" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (flatten)
                                  (("2" (assert)
                                    (("2" (expand "subset?" -3)
                                      (("2"
                                        (expand "member")
                                        (("2"
                                          (inst?)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert) nil nil))
            nil)
           ("2" (hide-all-but 1)
            (("2" (split 1)
              (("1" (use "vert_is_finite")
                (("1" (split -1)
                  (("1" (use "vert_is_finite" :subst ("G" "G2"))
                    (("1" (split -1)
                      (("1" (use "edges_is_finite")
                        (("1" (split -1)
                          (("1"
                            (lemma "is_finite_cross[(vert(G1)),(vert(G1))]")
                            (("1" (assert)
                              (("1" (split -1)
                                (("1"
                                  (lemma
                                   "finite_type_set[[(vert(G1)), (vert(G1))]]")
                                  (("1"
                                    (inst -1 "{e|vert(G1)(e`1) AND
                                vert(G1)(e`2) }")
                                    (("1" (assert)
                                      (("1"
                                        (expand "restrict")
                                        (("1"
                                          (hide-all-but (1 -1 -3))
                                          (("1"
                                            (lemma
                                             "finite_intersection[[T,T]]")
                                            (("1"
                                              (inst
                                               -1
                                               "edges(G2)"
                                               "{e | vert(G1)(e`1) AND vert(G1)(e`2)}")
                                              (("1"
                                                (expand "intersection")
                                                (("1"
                                                  (expand "member")
                                                  (("1" (propax) nil nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (assert)
                                                (("2"
                                                  (hide-all-but (-1 1))
                                                  (("2"
                                                    (expand "is_finite")
                                                    (("2"
                                                      (skeep)
                                                      (("2"
                                                        (inst 1 "N" "f")
                                                        (("2"
                                                          (expand "restrict")
                                                          (("2"
                                                            (expand
                                                             "injective?")
                                                            (("2"
                                                              (skeep)
                                                              (("2"
                                                                (inst?)
                                                                (("2"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (hide-all-but (-3 1))
                                  (("2" (expand "is_finite_type")
                                    (("2" (expand "is_finite")
                                      (("2" (propax) nil nil)) nil))
                                    nil))
                                  nil)
                                 ("3" (hide-all-but (-3 1))
                                  (("3" (expand "is_finite_type")
                                    (("3" (expand "is_finite")
                                      (("3" (propax) nil nil)) nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil))
                nil)
               ("2" (skeep) (("2" (assert) nil nil)) nil))
              nil))
            nil)
           ("3" (hide-all-but 1)
            (("3" (use "vert_is_finite")
              (("3" (split -1)
                (("1" (use "vert_is_finite" :subst ("G" "G1"))
                  (("1" (split -1)
                    (("1" (lemma "finite_intersection[T]")
                      (("1" (inst -1 "vert(G2)" "vert(G1)")
                        (("1" (expand "intersection")
                          (("1" (expand "member") (("1" (propax) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil)
                 ("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((di_subgraph const-decl "di_subgraph(G)" di_subgraphs_ nil)
    (is_finite_cross formula-decl nil finite_cross finite_sets)
    (is_finite_type const-decl "bool" finite_sets nil)
    (finite_type_set formula-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil)
    (injective? const-decl "bool" functions nil)
    (intersection const-decl "set" sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (finite_intersection formula-decl nil finite_sets nil)
    (restrict const-decl "R" restrict nil)
    (edges_is_finite formula-decl nil digraphs_abs nil)
    (vert_is_finite formula-decl nil digraphs_abs nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil)
    (di_subgraph? const-decl "bool" di_subgraphs_ nil)
    (edge? const-decl "bool" digraphs_ nil)
    (edges_in_verts formula-decl nil digraphs_abs nil)
    (x!2 skolem-const-decl "T" di_subgraphs_ nil)
    (x!1 skolem-const-decl "T" di_subgraphs_ nil)
    (G2 skolem-const-decl "ConcreteDigraph" di_subgraphs_ nil)
    (G1 skolem-const-decl "ConcreteDigraph" di_subgraphs_ nil)
    (edgetype type-eq-decl nil digraphs_utils nil)
    (vert_type type-eq-decl nil digraphs_abs nil)
    (edge_type type-eq-decl nil digraphs_abs nil)
    (make_ok formula-decl nil digraphs_abs nil)
    (concretedigraph_implements_abstractdigraph formula-decl nil digraphs_
     nil)
    (T formal-type-decl nil di_subgraphs_ nil)
    (ConcreteDigraph formal-type-decl nil di_subgraphs_ nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" di_subgraphs_
     nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]"
     di_subgraphs_ nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" di_subgraphs_ nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" di_subgraphs_ nil)
    (obs_eq const-decl "bool" digraphs_ nil))
   shostak)))

