(cycles_
 (IMP_circuits__TCC1 0
  (IMP_circuits__TCC1-1 nil 3656950460
   ("" (use "concretedigraph_implements_abstractdigraph") nil nil)
   ((concretedigraph_implements_abstractdigraph formula-decl nil cycles_ nil))
   nil
   (IMP_circuits_ assuming
    "circuits_[cycles_.T, cycles_.ConcreteDigraph, cycles_.vert, cycles_.edges, cycles_.size, cycles_.make].circuits_"
    "concretedigraph_implements_abstractdigraph: ASSUMPTION digraphs_abs[circuits_.T, circuits_.ConcreteDigraph, circuits_.vert, circuits_.edges, circuits_.size, circuits_.make].correct_implementation")))
 (cycle?_TCC1 0
  (cycle?_TCC1-1 nil 3559643154 ("" (subtype-tcc) nil nil)
   ((make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" cycles_ nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" cycles_ nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]" cycles_
     nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" cycles_ nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ConcreteDigraph formal-type-decl nil cycles_ nil)
    (T formal-type-decl nil cycles_ nil)
    (verts_in? const-decl "bool" walks_ nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)
    (edge? const-decl "bool" digraphs_ nil)
    (walk? const-decl "bool" walks_ nil)
    (pre_circuit? const-decl "bool" circuits_ nil)
    (circuit? const-decl "bool" circuits_ nil)
    (/= const-decl "boolean" notequal nil))
   nil (cycle? subtype "cycles_.i" "below[length(w)]")))
 (cycle?_TCC2 0
  (cycle?_TCC2-1 nil 3559643154 ("" (subtype-tcc) nil nil)
   ((make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" cycles_ nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" cycles_ nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]" cycles_
     nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" cycles_ nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ConcreteDigraph formal-type-decl nil cycles_ nil)
    (T formal-type-decl nil cycles_ nil)
    (verts_in? const-decl "bool" walks_ nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)
    (edge? const-decl "bool" digraphs_ nil)
    (walk? const-decl "bool" walks_ nil)
    (pre_circuit? const-decl "bool" circuits_ nil)
    (circuit? const-decl "bool" circuits_ nil)
    (/= const-decl "boolean" notequal nil))
   nil (cycle? subtype "cycles_.j" "below[length(w)]")))
 (cycle_at?_TCC1 0
  (cycle_at?_TCC1-1 nil 3659434186 ("" (subtype-tcc) nil nil)
   ((make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" cycles_ nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" cycles_ nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]" cycles_
     nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" cycles_ nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ConcreteDigraph formal-type-decl nil cycles_ nil)
    (T formal-type-decl nil cycles_ nil)
    (verts_in? const-decl "bool" walks_ nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)
    (edge? const-decl "bool" digraphs_ nil)
    (walk? const-decl "bool" walks_ nil)
    (pre_circuit? const-decl "bool" circuits_ nil)
    (circuit? const-decl "bool" circuits_ nil)
    (/= const-decl "boolean" notequal nil)
    (cycle? const-decl "bool" cycles_ nil))
   nil (cycle_at? subtype "0" "below[length(w)]")))
 (VCList_TCC1 0
  (VCList_TCC1-1 nil 3661515520 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil cycles_ nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (ConcreteDigraph formal-type-decl nil cycles_ nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" cycles_ nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]" cycles_
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" cycles_ nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" cycles_ nil)
    (vert? const-decl "bool" digraphs_ nil)
    (vert type-eq-decl nil digraphs_ nil)
    (vert_list const-decl "bool" digraphs_ nil)
    (VertList type-eq-decl nil digraphs_ nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (VertCycles type-eq-decl nil cycles_ nil)
    (CyclesAt type-eq-decl nil cycles_ nil) (< const-decl "bool" reals nil))
   nil
   (VCList subtype "cycles_.n"
    "below[length[vert[T, ConcreteDigraph, vert, edges, size, make](G)](VL)]")))
 (cycle_is_circuit 0
  (cycle_is_circuit-1 nil 3559643176
   ("" (skeep)
    (("" (expand "cycle?")
      (("" (expand "circuit?") (("" (flatten) (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((cycle? const-decl "bool" cycles_ nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (circuit? const-decl "bool" circuits_ nil))
   shostak))
 (circuit_subwalk_cycle_TCC1 0
  (circuit_subwalk_cycle_TCC1-1 nil 3564335113 ("" (subtype-tcc) nil nil)
   ((prewalk type-eq-decl nil walks_ nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil) (> const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" cycles_ nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" cycles_ nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]" cycles_
     nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" cycles_ nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ConcreteDigraph formal-type-decl nil cycles_ nil)
    (T formal-type-decl nil cycles_ nil)
    (verts_in? const-decl "bool" walks_ nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)
    (edge? const-decl "bool" digraphs_ nil)
    (walk? const-decl "bool" walks_ nil)
    (pre_circuit? const-decl "bool" circuits_ nil)
    (circuit? const-decl "bool" circuits_ nil))
   nil
   (circuit_subwalk_cycle subtype "cycles_.w"
    "walks_[cycles_.T, cycles_.ConcreteDigraph, cycles_.vert, cycles_.edges, cycles_.size, cycles_.make].Walk(cycles_.G)")))
 (circuit_subwalk_cycle 0
  (circuit_subwalk_cycle-1 nil 3564335167
   ("" (measure-induct+ "length(w)" "w")
    (("1" (skeep)
      (("1" (case "cycle?(G, x!1)")
        (("1" (hide -2)
          (("1" (inst 1 "x!1")
            (("1" (split)
              (("1" (expand "sub_walk?")
                (("1" (inst 1 "0" "length(x!1) - 1")
                  (("1" (decompose-equality)
                    (("1" (expand* "^" "min") nil nil)
                     ("2" (decompose-equality)
                      (("2" (expand* "^" "min") nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (propax) nil nil))
              nil))
            nil))
          nil)
         ("2" (expand "cycle?" 1)
          (("2" (prop)
            (("2" (skeep)
              (("2" (expand "finseq_appl")
                (("2" (case "i < j")
                  (("1" (inst -3 "x!1^(i, j)")
                    (("1" (inst -3 "G")
                      (("1" (expand "^" -3 1)
                        (("1" (expand* "empty_seq" "min")
                          (("1" (assert)
                            (("1" (split -3)
                              (("1" (skeep -1)
                                (("1" (inst 2 "w1")
                                  (("1" (assert)
                                    (("1" (expand "sub_walk?")
                                      (("1"
                                        (skosimp)
                                        (("1"
                                          (typepred "i" "j" "i!1" "j!1")
                                          (("1"
                                            (inst 2 "i + i!1" "i + j!1")
                                            (("1"
                                              (replace -5 2 rl)
                                              (("1"
                                                (hide -5)
                                                (("1"
                                                  (decompose-equality 2)
                                                  (("1"
                                                    (expand*
                                                     "^"
                                                     "min"
                                                     "empty_seq")
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (lift-if)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (decompose-equality)
                                                    (("2"
                                                      (expand "^" 1 3)
                                                      (("2"
                                                        (lift-if)
                                                        (("2"
                                                          (prop)
                                                          (("1"
                                                            (expand*
                                                             "^"
                                                             "min")
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (expand*
                                                             "^"
                                                             "min")
                                                            (("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (hide-all-but (-1 -4 1))
                                              (("2"
                                                (expand "^")
                                                (("2"
                                                  (expand "min")
                                                  (("2" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("3"
                                              (hide-all-but (-1 -3 1))
                                              (("3"
                                                (expand* "^" "min")
                                                (("3" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (hide 3)
                                (("2"
                                  (expand* "circuit?" "pre_circuit?"
                                   "finseq_appl")
                                  (("2" (rewrite "walk?_caret")
                                    (("2" (expand* "^" "min" "empty_seq") nil
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide -2 -3 3)
                      (("2" (expand* "^" "min" "empty_seq")
                        (("2" (assert) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (inst -2 "x!1^(j, i)")
                    (("1" (inst -2 "G")
                      (("1" (expand "^" -2 1)
                        (("1" (expand* "min" "empty_seq")
                          (("1" (assert)
                            (("1" (split -2)
                              (("1" (skeep -1)
                                (("1" (inst 3 "w1")
                                  (("1" (assert)
                                    (("1" (hide -2)
                                      (("1"
                                        (expand "sub_walk?")
                                        (("1"
                                          (skosimp)
                                          (("1"
                                            (typepred "i" "j" "i!1" "j!1")
                                            (("1"
                                              (inst 3 "j + i!1" "j + j!1")
                                              (("1"
                                                (replace -5 3 rl)
                                                (("1"
                                                  (hide -5)
                                                  (("1"
                                                    (decompose-equality 3)
                                                    (("1"
                                                      (expand*
                                                       "^"
                                                       "min"
                                                       "empty_seq")
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (lift-if)
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (decompose-equality 1)
                                                      (("2"
                                                        (expand "^" 1 3)
                                                        (("2"
                                                          (lift-if)
                                                          (("2"
                                                            (prop)
                                                            (("1"
                                                              (expand*
                                                               "^"
                                                               "min")
                                                              (("1"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (expand*
                                                               "^"
                                                               "min")
                                                              (("2"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (hide-all-but (-2 -4 +))
                                                (("2"
                                                  (expand* "^" "min")
                                                  (("2" (assert) nil nil))
                                                  nil))
                                                nil)
                                               ("3"
                                                (hide-all-but (-2 -3 +))
                                                (("3"
                                                  (expand* "^" "min")
                                                  (("3" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (hide 4)
                                (("2"
                                  (expand* "circuit?" "pre_circuit?"
                                   "finseq_appl")
                                  (("2" (rewrite "walk?_caret")
                                    (("2" (expand* "^" "min") nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand* "^" "min") (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (hide-all-but (-1 1))
      (("2" (skeep)
        (("2" (expand* "circuit?" "pre_circuit?" "finseq_appl")
          (("2" (assert) nil nil)) nil))
        nil))
      nil)
     ("3" (hide-all-but (-1 1))
      (("3" (skeep)
        (("3" (expand* "circuit?" "pre_circuit?" "finseq_appl")
          (("3" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (measure_induction formula-decl nil measure_induction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (T formal-type-decl nil cycles_ nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (ConcreteDigraph formal-type-decl nil cycles_ nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" cycles_ nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]" cycles_
     nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" cycles_ nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" cycles_ nil)
    (prewalk type-eq-decl nil walks_ nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (circuit? const-decl "bool" circuits_ nil)
    (walk? const-decl "bool" walks_ nil) (Walk type-eq-decl nil walks_ nil)
    (sub_walk? const-decl "bool" walks_ nil)
    (cycle? const-decl "bool" cycles_ nil)
    (i!1 skolem-const-decl "below(length(x!1 ^ (j, i)))" cycles_ nil)
    (j!1 skolem-const-decl "below(length(x!1 ^ (j, i)))" cycles_ nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (walk?_caret formula-decl nil walks_ nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (pre_circuit? const-decl "bool" circuits_ nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs
     nil)
    (j!1 skolem-const-decl "below(length(x!1 ^ (i, j)))" cycles_ nil)
    (i!1 skolem-const-decl "below(length(x!1 ^ (i, j)))" cycles_ nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (j skolem-const-decl "below(length(x!1) - 1)" cycles_ nil)
    (i skolem-const-decl "below(length(x!1) - 1)" cycles_ nil)
    (x!1 skolem-const-decl
     "prewalk[T, ConcreteDigraph, vert, edges, size, make]" cycles_ nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^ const-decl "finseq" finite_sequences nil)
    (below type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (cycle_prefix_TCC1 0
  (cycle_prefix_TCC1-1 nil 3579270878 ("" (subtype-tcc) nil nil)
   ((make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" cycles_ nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" cycles_ nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]" cycles_
     nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" cycles_ nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ConcreteDigraph formal-type-decl nil cycles_ nil)
    (T formal-type-decl nil cycles_ nil)
    (verts_in? const-decl "bool" walks_ nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)
    (edge? const-decl "bool" digraphs_ nil)
    (walk? const-decl "bool" walks_ nil)
    (pre_circuit? const-decl "bool" circuits_ nil)
    (circuit? const-decl "bool" circuits_ nil)
    (/= const-decl "boolean" notequal nil)
    (cycle? const-decl "bool" cycles_ nil)
    (O const-decl "finseq" finite_sequences nil))
   nil
   (cycle_prefix subtype
    "finite_sequences[cycles_.T].o(cycles_.w1, cycles_.w2)"
    "prewalk[T, ConcreteDigraph, vert, edges, size, make]")))
 (cycle_prefix 0
  (cycle_prefix-1 nil 3582385881
   ("" (auto-rewrite "finseq_appl")
    (("" (skeep)
      (("" (lemma "circuit_subwalk_cycle")
        (("" (inst -1 "G" "w")
          (("" (assert)
            (("" (skeep -1)
              (("" (expand "sub_walk?")
                (("" (skeep -1)
                  (("" (typepred "i" "j")
                    (("" (case "i = 0 AND j = length(w) - 1")
                      (("1" (flatten)
                        (("1" (replaces -1)
                          (("1" (replaces -1)
                            (("1" (hide-all-but (-3 -4 1))
                              (("1" (case-replace "w1 = w")
                                (("1" (hide -2 2)
                                  (("1" (replace -1 1 rl)
                                    (("1" (hide -1)
                                      (("1"
                                        (decompose-equality)
                                        (("1" (expand* "^" "min") nil nil)
                                         ("2"
                                          (decompose-equality)
                                          (("2"
                                            (typepred "x!1")
                                            (("2"
                                              (expand* "^" "min")
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (case "i > j")
                        (("1" (expand "^" -4)
                          (("1" (assert)
                            (("1" (hide-all-but (-4 -5))
                              (("1" (expand* "cycle?" "circuit?")
                                (("1" (flatten)
                                  (("1" (hide -2 -4)
                                    (("1" (expand "empty_seq")
                                      (("1" (assert) nil nil)) nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (case-replace "j = length(w) - 1")
                          (("1" (inst 4 "w1" "w^(1, i)")
                            (("1" (assert)
                              (("1" (replace -4 4 rl)
                                (("1" (rewrite "commuted_circuit_is_eq") nil
                                  nil))
                                nil))
                              nil)
                             ("2" (hide-all-but (1 3))
                              (("2" (expand* "^" "min")
                                (("2" (assert) nil nil)) nil))
                              nil))
                            nil)
                           ("2" (case-replace "i = 0")
                            (("1" (hide -1 -2 3 4)
                              (("1" (inst 3 "w1" "w^(j + 1, length(w) - 1)")
                                (("1" (assert)
                                  (("1"
                                    (case-replace
                                     "w1 o w ^ (1 + j, length(w) - 1) = w")
                                    (("1" (hide-all-but (-5 3))
                                      (("1"
                                        (rewrite "eq_circuit_reflexive")
                                        nil
                                        nil))
                                      nil)
                                     ("2" (replace -2 1 rl)
                                      (("2"
                                        (hide -2 -3 -4 3 4)
                                        (("2"
                                          (decompose-equality)
                                          (("1"
                                            (expand*
                                             "o"
                                             "^"
                                             "min"
                                             "empty_seq")
                                            nil
                                            nil)
                                           ("2"
                                            (decompose-equality)
                                            (("2"
                                              (typepred "x!1")
                                              (("2"
                                                (expand*
                                                 "o"
                                                 "^"
                                                 "min"
                                                 "empty_seq")
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (hide - 3)
                                  (("2" (expand* "^" "min")
                                    (("2" (assert) nil nil)) nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide -1 -5 4 5)
                              (("2"
                                (inst 4 "w1"
                                 "w^(j+1, length(w)-1) o w^(1, i)")
                                (("1" (assert)
                                  (("1" (rewrite "o_assoc")
                                    (("1" (replace -2 4 rl)
                                      (("1"
                                        (hide -2 -3)
                                        (("1"
                                          (case-replace
                                           "w^(i, j) o w^(1 + j, length(w) - 1) = w^(i, length(w) - 1)")
                                          (("1"
                                            (hide -1)
                                            (("1"
                                              (rewrite
                                               "commuted_circuit_is_eq")
                                              nil
                                              nil))
                                            nil)
                                           ("2"
                                            (hide 5)
                                            (("2"
                                              (decompose-equality)
                                              (("1"
                                                (expand*
                                                 "o"
                                                 "^"
                                                 "min"
                                                 "empty_seq")
                                                nil
                                                nil)
                                               ("2"
                                                (decompose-equality)
                                                (("2"
                                                  (typepred "x!1")
                                                  (("2"
                                                    (expand*
                                                     "o"
                                                     "^"
                                                     "min"
                                                     "empty_seq")
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (hide -2 -3)
                                  (("2" (expand* "o" "^" "min" "empty_seq")
                                    (("2" (assert) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ConcreteDigraph formal-type-decl nil cycles_ nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (T formal-type-decl nil cycles_ nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" cycles_ nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]" cycles_
     nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" cycles_ nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" cycles_ nil)
    (prewalk type-eq-decl nil walks_ nil)
    (o_assoc formula-decl nil finite_sequences nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (j skolem-const-decl "below(length(w))" cycles_ nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs
     nil)
    (eq_circuit_reflexive formula-decl nil circuits_ nil)
    (O const-decl "finseq" finite_sequences nil)
    (commuted_circuit_is_eq formula-decl nil circuits_ nil)
    (i skolem-const-decl "below(length(w))" cycles_ nil)
    (w skolem-const-decl
     "prewalk[T, ConcreteDigraph, vert, edges, size, make]" cycles_ nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (cycle? const-decl "bool" cycles_ nil)
    (circuit? const-decl "bool" circuits_ nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^ const-decl "finseq" finite_sequences nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (TRUE const-decl "bool" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (sub_walk? const-decl "bool" walks_ nil)
    (circuit_subwalk_cycle formula-decl nil cycles_ nil))
   shostak))
 (cycle_o_circuit_TCC1 0
  (cycle_o_circuit_TCC1-1 nil 3579270878 ("" (subtype-tcc) nil nil)
   ((prewalk type-eq-decl nil walks_ nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil) (> const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" cycles_ nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" cycles_ nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]" cycles_
     nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" cycles_ nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ConcreteDigraph formal-type-decl nil cycles_ nil)
    (T formal-type-decl nil cycles_ nil)
    (verts_in? const-decl "bool" walks_ nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)
    (edge? const-decl "bool" digraphs_ nil)
    (walk? const-decl "bool" walks_ nil)
    (pre_circuit? const-decl "bool" circuits_ nil)
    (circuit? const-decl "bool" circuits_ nil)
    (/= const-decl "boolean" notequal nil)
    (cycle? const-decl "bool" cycles_ nil)
    (rest const-decl "finseq" seq_extras structures)
    (O const-decl "finseq" finite_sequences nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil))
   nil
   (cycle_o_circuit subtype
    "finite_sequences[cycles_.T].o(cycles_.w1, seq_extras[cycles_.T].rest(cycles_.w2))"
    "prewalk[T, ConcreteDigraph, vert, edges, size, make]")))
 (cycle_o_circuit 0
  (cycle_o_circuit-1 nil 3582583306
   ("" (auto-rewrite "finseq_appl")
    (("" (skeep)
      (("" (lemma "cycle_prefix")
        (("" (inst -1 "G" "w")
          (("" (assert)
            (("" (skeep)
              (("" (inst 2 "w1" "add_first(last(w1), w2)")
                (("1" (rewrite "rest_add_first")
                  (("1" (assert)
                    (("1" (expand "eq_circuit?")
                      (("1" (flatten)
                        (("1" (hide -2 -4 1)
                          (("1" (expand* "circuit?" "pre_circuit?")
                            (("1" (assert)
                              (("1" (flatten)
                                (("1" (split)
                                  (("1"
                                    (case "add_first(last(w1), w2) = (w1 o w2) ^ (length(w1) - 1, length(w1 o w2) -1)")
                                    (("1" (replaces -1)
                                      (("1"
                                        (rewrite "walk?_caret")
                                        (("1"
                                          (expand "o" 1)
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (hide-all-but (-3 1))
                                      (("2"
                                        (decompose-equality)
                                        (("1"
                                          (expand*
                                           "add_first"
                                           "insert?"
                                           "o"
                                           "^"
                                           "min")
                                          nil
                                          nil)
                                         ("2"
                                          (decompose-equality)
                                          (("2"
                                            (typepred "x!1")
                                            (("2"
                                              (expand*
                                               "add_first"
                                               "insert?"
                                               "o"
                                               "^"
                                               "min")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (expand "last")
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (lift-if)
                                                      (("2" (ground) nil nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("3" (assert) nil nil))
                                    nil)
                                   ("2" (expand* "add_first" "insert?")
                                    (("2" (expand "last")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (expand "o" -2)
                                          (("2"
                                            (hide -1 -3)
                                            (("2"
                                              (expand*
                                               "cycle?"
                                               "circuit?"
                                               "pre_circuit?")
                                              (("2"
                                                (flatten)
                                                (("2"
                                                  (hide -2 -4 -5)
                                                  (("2" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3" (hide-all-but 1)
                                    (("3" (expand* "add_first" "insert?")
                                      (("3" (assert) nil nil)) nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide-all-but 1)
                  (("2" (expand* "add_first" "insert?")
                    (("2" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ConcreteDigraph formal-type-decl nil cycles_ nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (T formal-type-decl nil cycles_ nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" cycles_ nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]" cycles_
     nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" cycles_ nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" cycles_ nil)
    (prewalk type-eq-decl nil walks_ nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (w2 skolem-const-decl
     "prewalk[T, ConcreteDigraph, vert, edges, size, make]" cycles_ nil)
    (w1 skolem-const-decl
     "prewalk[T, ConcreteDigraph, vert, edges, size, make]" cycles_ nil)
    (last const-decl "T" seq_extras structures)
    (not_empty_seq type-eq-decl nil seq_extras structures)
    (/= const-decl "boolean" notequal nil)
    (add_first const-decl "finseq" seq_extras structures)
    (pre_circuit? const-decl "bool" circuits_ nil)
    (circuit? const-decl "bool" circuits_ nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (^ const-decl "finseq" finite_sequences nil)
    (O const-decl "finseq" finite_sequences nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (walk?_caret formula-decl nil walks_ nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (TRUE const-decl "bool" booleans nil) (< const-decl "bool" reals nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (insert? const-decl "finseq" seq_extras structures)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (cycle? const-decl "bool" cycles_ nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (eq_circuit? const-decl "bool" circuits_ nil)
    (rest_add_first formula-decl nil seq_extras structures)
    (cycle_prefix formula-decl nil cycles_ nil))
   shostak))
 (Pigeon_hole_TCC1 0
  (Pigeon_hole_TCC1-1 nil 3656950460 ("" (assert) nil nil)
   ((make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" cycles_ nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" cycles_ nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]" cycles_
     nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" cycles_ nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ConcreteDigraph formal-type-decl nil cycles_ nil)
    (T formal-type-decl nil cycles_ nil)
    (concretedigraph_implements_abstractdigraph formula-decl nil circuits_
     nil)
    (vert_is_finite formula-decl nil digraphs_abs nil))
   nil (Pigeon_hole subtype "cycles_.vert(cycles_.GF)" "finite_set[T]")))
 (Pigeon_hole 0
  (Pigeon_hole-2 "" 3790100655
   ("" (skosimp*)
    (("" (lemma "seq_pigeon_hole[T,(vert(GF!1))]")
      (("" (inst?)
        (("1" (assert) nil nil)
         ("2" (skosimp*)
          (("2" (hide 2)
            (("2" (typepred "x1!1")
              (("2" (typepred "w!1")
                (("2" (expand "walk?")
                  (("2" (flatten)
                    (("2" (expand "verts_in?") (("2" (inst?) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Digraph type-eq-decl nil digraphs_ nil)
    (make formal-const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" cycles_ nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (size formal-const-decl "[ConcreteDigraph -> nat]" cycles_ nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (edges formal-const-decl "[ConcreteDigraph -> [T, T -> bool]]" cycles_
     nil)
    (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (vert formal-const-decl "[ConcreteDigraph -> [T -> bool]]" cycles_ nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ConcreteDigraph formal-type-decl nil cycles_ nil)
    (T formal-type-decl nil cycles_ nil)
    (seq_pigeon_hole formula-decl nil seq_pigeon structures)
    (w!1 skolem-const-decl
     "Walk[T, ConcreteDigraph, vert, edges, size, make](GF!1)" cycles_ nil)
    (Walk type-eq-decl nil walks_ nil)
    (GF!1 skolem-const-decl
     "Digraph[T, ConcreteDigraph, vert, edges, size, make]" cycles_ nil)
    (walk? const-decl "bool" walks_ nil) (prewalk type-eq-decl nil walks_ nil)
    (> const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (verts_in? const-decl "bool" walks_ nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   shostak)
  (Pigeon_hole-1 nil 3507100929
   ("" (skosimp*)
    (("" (lemma "seq_pigeon_hole[T,(vert(GF!1))]")
      (("" (inst?)
        (("1" (assert)
          (("1" (skosimp*)
            (("1" (inst?)
              (("1" (inst 2 "j!1")
                (("1" (expand "finseq_appl") (("1" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skosimp*)
          (("2" (hide 2)
            (("2" (typepred "x1!1")
              (("2" (typepred "w!1")
                (("2" (expand "walk?")
                  (("2" (flatten)
                    (("2" (expand "verts_in?") (("2" (inst?) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Digraph type-eq-decl nil digraphs_ nil)
    (is_finite const-decl "bool" finite_sets nil)
    (seq_pigeon_hole formula-decl nil seq_pigeon structures)
    (verts_in? const-decl "bool" walks_ nil)
    (prewalk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil)
    (Walk type-eq-decl nil walks_ nil))
   nil)))

