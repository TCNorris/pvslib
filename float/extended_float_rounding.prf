(extended_float_rounding (rtod_on_ranged_pos_is_in_range 0 (rtod_on_ranged_pos_is_in_range-2 "" 3765539818 ("" (skeep :preds? t) (("" (lemma "bound_on_exp_of_rounded_erreal") (("" (inst -1 "max_pos_value") (("1" (case "Fexp(rnd_ucf(x)) <= Fexp(rnd_ucf(max_pos_value))") (("1" (split 1) (("1" (assert) nil nil) ("2" (assert) (("2" (expand "/=") (("2" (lemma "rnd_ucf_monotonic") (("2" (inst -1 "min_pos_value" "x") (("2" (split -1) (("1" (case "prj_ucf(rnd_ucf(min_pos_value)) = min_pos_value") (("1" (replace -1 :hide? t) (("1" (case "prj_ucf(rnd_ucf(x)) = 0") (("1" (replace -1 :hide? t) (("1" (hide-all-but -1) (("1" (expand "min_pos_value") (("1" (typepred "min_exp") (("1" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "prj_ucf") (("2" (expand "FtoR") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "dtor_rtod_on_er" 1 :dir rl) (("2" (rewrite "min_pos_value_is_er") nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "Lexico") (("2" (inst -1 "given_format") (("2" (split -1) (("1" (propax) nil nil) ("2" (use "EvenClosest_Monotone") (("2" (expand "Monotone?") (("2" (inst -1 "given_format") (("2" (inst -1 "x" "max_pos_value" "rnd_ucf(x)" "rnd_ucf(max_pos_value)") (("2" (split -1) (("1" (propax) nil nil) ("2" (typepred "rnd_ucf(max_pos_value)") (("2" (expand "currified_closest?_ucf") (("2" (expand "closest?_ucf") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (typepred "rnd_ucf(x)") (("3" (expand "currified_closest?_ucf") (("3" (expand "closest?_ucf") (("3" (propax) nil nil)) nil)) nil)) nil) ("4" (case "x=max_pos_value") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case "0 <= x") (("1" (use "rnc_ucf_increasing") (("1" (assert) (("1" (expand "<=" -1) (("1" (rewrite "FleCorrect") (("1" (case "FtoR(rnd_ucf(0)) = 0") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (case "Fnum(rnd_ucf(0)) = 0") (("1" (expand "FtoR") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (expand "rnd_ucf") (("2" (expand "RND_EClosest") (("2" (expand "RND_Min") (("2" (expand "RND_Max") (("2" (expand "RND_Min") (("2" (expand "RND_aux") (("2" (assert) (("2" (assert) (("2" (grind-reals) (("2" (expand "Fopp") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "er_ub_correspondent" :dir rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}" extended_float_rounding nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (precision formal-const-decl "above(1)" extended_float_rounding nil) (radix formal-const-decl "above(1)" extended_float_rounding nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bound_on_exp_of_rounded_erreal formula-decl nil extended_float_exactly_representable_reals nil) (er_ub_correspondent formula-decl nil extended_float_exactly_representable_reals nil) (rnd_ucf const-decl "{f: unb_canonic_float | currified_closest?_ucf(x1)(f)}" extended_float nil) (currified_closest?_ucf const-decl "bool" extended_float nil) (Fbounded? const-decl "bool" float nil) (unb_canonic_float type-eq-decl nil extended_float nil) (given_format const-decl "Format" extended_float nil) (Fcanonic? const-decl "bool" float nil) (Format type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (float type-eq-decl nil float nil) (<= const-decl "bool" reals nil) (rnd_ucf_monotonic formula-decl nil extended_float nil) (dtor_rtod_on_er formula-decl nil extended_float_exactly_representable_reals nil) (min_pos_value_is_er formula-decl nil extended_float_exactly_representable_reals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (FtoR const-decl "real" float nil) (posrat_exp application-judgement "posrat" exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (min_exp const-decl "negint" extended_float nil) (negint nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nonpos_int nonempty-type-eq-decl nil integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (prj_ucf const-decl "real" extended_float nil) (= const-decl "[T, T -> boolean]" equalities nil) (min_pos_value const-decl "posreal" extended_float nil) (/= const-decl "boolean" notequal nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (FleCorrect formula-decl nil float nil) (RND_EClosest const-decl "(Fcanonic?(b))" float nil) (RND_Max const-decl "(Fcanonic?(b))" float nil) (posint_exp application-judgement "posint" exponentiation nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (RND_aux const-decl "(Fcanonic?(b))" float nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (Fopp const-decl "float" float nil) (zero_times1 formula-decl nil real_props nil) (zero_is_neg_zero formula-decl nil real_props nil) (TRUE const-decl "bool" booleans nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (RND_Min const-decl "(Fcanonic?(b))" float nil) (<= const-decl "bool" float nil) (rnc_ucf_increasing formula-decl nil extended_float nil) (EvenClosest_Monotone formula-decl nil float nil) (closest?_ucf const-decl "bool" extended_float nil) (Monotone? const-decl "bool" float nil) (Lexico formula-decl nil float nil) (er_real nonempty-type-eq-decl nil ieee754_domain nil) (emax const-decl "above(1)" extended_float nil) (exactly_representable? const-decl "bool" ieee754_domain nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (max_pos_value const-decl "posreal" extended_float nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil)) shostak) (rtod_on_ranged_pos_is_in_range-1 nil 3764931722 ("" (skeep :preds? t) (("" (lemma "bound_on_exp_of_rounded_erreal") (("" (inst -1 "max_pos_value") (("1" (case "Fexp(rnd_ucf(x)) <= Fexp(rnd_ucf(max_pos_value))") (("1" (split 1) (("1" (assert) nil nil) ("2" (assert) (("2" (expand "/=") (("2" (lemma "rnd_ucf_monotonic") (("2" (inst -1 "min_pos_value" "x") (("2" (split -1) (("1" (case "prj_ucf(rnd_ucf(min_pos_value)) = min_pos_value") (("1" (replace -1 :hide? t) (("1" (case "prj_ucf(rnd_ucf(x)) = 0") (("1" (replace -1 :hide? t) (("1" (eval-formula -1) nil nil)) nil) ("2" (expand "prj_ucf") (("2" (expand "FtoR") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "dtor_rtod_on_er" 1 :dir rl) (("2" (rewrite "min_pos_value_is_er") nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "Lexico") (("2" (inst -1 "given_format") (("2" (split -1) (("1" (propax) nil nil) ("2" (use "EvenClosest_Monotone") (("2" (expand "Monotone?") (("2" (inst -1 "given_format") (("2" (inst -1 "x" "max_pos_value" "rnd_ucf(x)" "rnd_ucf(max_pos_value)") (("2" (split -1) (("1" (propax) nil nil) ("2" (typepred "rnd_ucf(max_pos_value)") (("2" (expand "currified_closest?_ucf") (("2" (expand "closest?_ucf") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (typepred "rnd_ucf(x)") (("3" (expand "currified_closest?_ucf") (("3" (expand "closest?_ucf") (("3" (propax) nil nil)) nil)) nil)) nil) ("4" (case "x=max_pos_value") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case "0 <= x") (("1" (use "rnc_ucf_increasing") (("1" (assert) (("1" (expand "<=" -1) (("1" (rewrite "FleCorrect") (("1" (eval-expr "FtoR(rnd_ucf(0))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "er_ub_correspondent" :dir rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((bound_on_exp_of_rounded_erreal formula-decl nil extended_float_exactly_representable_reals nil) (er_ub_correspondent formula-decl nil extended_float_exactly_representable_reals nil) (Fbounded? const-decl "bool" float nil) (Fcanonic? const-decl "bool" float nil) (Format type-eq-decl nil float nil) (float type-eq-decl nil float nil) (dtor_rtod_on_er formula-decl nil extended_float_exactly_representable_reals nil) (min_pos_value_is_er formula-decl nil extended_float_exactly_representable_reals nil) (FtoR const-decl "real" float nil) (min_pos_value const-decl "posreal" extended_float nil) (FleCorrect formula-decl nil float nil) (EvenClosest_Monotone formula-decl nil float nil) (Monotone? const-decl "bool" float nil) (Lexico formula-decl nil float nil) (er_real nonempty-type-eq-decl nil ieee754_domain nil) (exactly_representable? const-decl "bool" ieee754_domain nil) (max_pos_value const-decl "posreal" extended_float nil)) shostak)) (rtod_on_ranged_neg_is_in_range 0 (rtod_on_ranged_neg_is_in_range-1 nil 3764931764 ("" (skeep :preds? t) (("" (lemma "rtod_on_ranged_pos_is_in_range") (("" (inst -1 "x") (("" (split -1) (("1" (propax) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ((rtod_on_ranged_pos_is_in_range formula-decl nil extended_float_rounding nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (rnd_ef_well_defined 0 (rnd_ef_well_defined-1 nil 3765539256 ("" (skeep :preds? t) (("" (case "x <= max_pos_value AND
           min_pos_value <= x") (("1" (flatten) (("1" (use "rtod_on_ranged_pos_is_in_range") (("1" (assert) nil nil)) nil)) nil) ("2" (case "x <= -min_pos_value AND
             -max_pos_value <= x") (("1" (lemma "rtod_on_ranged_neg_is_in_range") (("1" (inst -1 "-x") (("1" (split -1) (("1" (flatten) (("1" (use "rnd_opp_ucf") (("1" (expand "Fopp") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((min_pos_value const-decl "posreal" extended_float nil) (max_pos_value const-decl "posreal" extended_float nil) (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}" extended_float_rounding nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (precision formal-const-decl "above(1)" extended_float_rounding nil) (radix formal-const-decl "above(1)" extended_float_rounding nil) (above nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (rtod_on_ranged_pos_is_in_range formula-decl nil extended_float_rounding nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rtod_on_ranged_neg_is_in_range formula-decl nil extended_float_rounding nil) (rnd_opp_ucf formula-decl nil extended_float nil) (minus_int_is_int application-judgement "int" integers nil) (Fopp const-decl "float" float nil) (minus_real_is_real application-judgement "real" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil)) nil)) (rnd_ef_TCC1 0 (rnd_ef_TCC1-3 "" 3804620391 ("" (lemma "rnd_ef_well_defined") (("" (skeep) (("" (inst?) (("" (ground) nil nil)) nil)) nil)) nil) nil shostak (rnd_ef subtype "extended_float[extended_float_rounding.radix, extended_float_rounding.precision, extended_float_rounding.dExp].rnd_ucf(extended_float_rounding.x)" "{v: extended_float[extended_float_rounding.radix, extended_float_rounding.precision, extended_float_rounding.dExp].unb_canonic_float | booleans.AND(reals.<=(Fexp(v), extended_float[extended_float_rounding.radix, extended_float_rounding.precision, extended_float_rounding.dExp].max_exp), Fnum(v) /= 0)}")) (rnd_ef_TCC1-2 "" 3764929250 ("" (use "rnd_ef_well_defined") nil nil) ((real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rnd_ef_well_defined formula-decl nil extended_float_rounding nil)) shostak (rnd_ef subtype "extended_float[extended_float_rounding.radix, extended_float_rounding.precision, extended_float_rounding.dExp].rnd_ucf(extended_float_rounding.x)" "{v: extended_float[extended_float_rounding.radix, extended_float_rounding.precision, extended_float_rounding.dExp].unb_canonic_float | booleans.AND(reals.<=(Fexp(v), extended_float[extended_float_rounding.radix, extended_float_rounding.precision, extended_float_rounding.dExp].max_exp), Fnum(v) /= 0)}")) (rnd_ef_TCC1-1 nil 3763829936 ("" (then (skeep :preds? t) (spread@ (case "x > 0") ((spread@ (case "x <= max_pos_value") ((then (lemma "bound_on_exp_of_rounded_erreal") (spread@ (inst -1 "max_pos_value") ((spread@ (case "Fexp(rnd_ucf(x)) <= Fexp(rnd_ucf(max_pos_value))") ((spread@ (split 5) ((assert) (then (assert) (hide 4) (expand "/=") (lemma "rnd_ucf_monotonic") (inst -1 "min_pos_value" "x") (spread@ (split -1) ((spread@ (case "prj_ucf(rnd_ucf(min_pos_value)) = min_pos_value") ((then (replace -1 :hide? t) (spread@ (case "prj_ucf(rnd_ucf(x)) = 0") ((then (replace -1 :hide? t) (eval-formula -1)) (then (expand "prj_ucf") (expand "FtoR") (assert))))) (spread@ (rewrite "dtor_rtod_on_er" 1 :dir rrl) ((rewrite "dtor_rtod_on_er" 1 :dir rl) (rewrite "min_pos_value_is_er"))))) (assert)))))) (then (use "Lexico") (inst -1 "given_format") (spread@ (split -1) ((propax) (then (use "EvenClosest_Monotone") (expand "Monotone?") (inst -1 "given_format") (inst -1 "x" "max_pos_value" "rnd_ucf(x)" "rnd_ucf(max_pos_value)") (spread@ (split -1) ((propax) (then (typepred "rnd_ucf(max_pos_value)") (expand "currified_closest?_ucf") (expand "closest?_ucf") (propax)) (then (typepred "rnd_ucf(x)") (expand "currified_closest?_ucf") (expand "closest?_ucf") (propax)) (spread@ (case "x=max_pos_value") ((assert) (assert)))))) (then (expand ">") (spread@ (case "0 <= x") ((then (use "rnc_ucf_increasing") (assert) (expand "<=" -1) (rewrite "FleCorrect") (eval-expr "FtoR(rnd_ucf(0))") (assert)) (assert)))) (then (typepred "rnd_ucf(max_pos_value)") (propax)) (then (typepred "rnd_ucf(x)") (propax))))))) (then (rewrite "er_ub_correspondent" :dir rl) (assert))))) (assert))) (spread@ (case "x < 0") ((then (hide 1) (name "y" "-x") (spread@ (case "-y = x") ((then (replace -1 :dir rl :hide? t) (hide -1) (rewrite "rnd_opp_ucf") (expand "Fopp") (spread@ (case "0 < y") ((spread@ (case "y <= max_pos_value") ((then (lemma "bound_on_exp_of_rounded_erreal") (spread@ (inst -1 "max_pos_value") ((spread@ (case "Fexp(rnd_ucf(y)) <= Fexp(rnd_ucf(max_pos_value))") ((spread@ (split 5) ((assert) (then (assert) (hide 2) (lemma "rnd_ucf_monotonic") (inst -1 "-y" "-min_pos_value") (spread@ (split -1) ((spread@ (case "prj_ucf(rnd_ucf(-min_pos_value)) = -min_pos_value") ((then (replace -1 :hide? t) (spread@ (case "prj_ucf(rnd_ucf(-y)) = 0") ((then (replace -1 :hide? t) (eval-formula -1)) (spread@ (case "Fnum(rnd_ucf(-y)) = 0") ((then (expand "prj_ucf") (expand "FtoR") (assert)) (then (hide-all-but (-2 1)) (lemma "rnd_opp_ucf") (inst -1 "-y") (spread@ (case "--y=y") ((then (replace -1 :hide? t) (replace -1 :hide? t) (expand "Fopp") (assert)) (assert))))))))) (then (rewrite "dtor_rtod_on_er" 1 :dir rl) (use "exactly_representable_symm_0") (assert) (rewrite "min_pos_value_is_er")))) (assert)))))) (then (use "Lexico") (inst -1 "given_format") (spread@ (split -1) ((propax) (then (use "EvenClosest_Monotone") (expand "Monotone?") (inst -1 "given_format") (inst -1 "y" "max_pos_value" "rnd_ucf(y)" "rnd_ucf(max_pos_value)") (spread@ (split -1) ((propax) (then (typepred "rnd_ucf(max_pos_value)") (expand "currified_closest?_ucf") (expand "closest?_ucf") (propax)) (then (typepred "rnd_ucf(y)") (expand "currified_closest?_ucf") (expand "closest?_ucf") (propax)) (spread@ (case "y=max_pos_value") ((assert) (assert)))))) (then (expand ">") (spread@ (case "0 <= y") ((then (use "rnc_ucf_increasing") (assert) (expand "<=" -1) (rewrite "FleCorrect") (eval-expr "FtoR(rnd_ucf(0))") (assert)) (assert)))) (then (typepred "rnd_ucf(max_pos_value)") (propax)) (then (typepred "rnd_ucf(y)") (propax))))))) (then (rewrite "er_ub_correspondent" :dir rl) (assert))))) (assert))) (assert)))) (assert)))) (assert)))))) nil nil) nil nil (rnd_ef subtype "extended_float[extended_float_rounding.radix, extended_float_rounding.precision, extended_float_rounding.dExp].rnd_ucf(extended_float_rounding.x)" "{v: extended_float[extended_float_rounding.radix, extended_float_rounding.precision, extended_float_rounding.dExp].unb_canonic_float | booleans.AND(reals.<=(Fexp(v), extended_float[extended_float_rounding.radix, extended_float_rounding.precision, extended_float_rounding.dExp].max_exp), Fnum(v) /= 0)}"))) (prj_ef_TCC1 0 (prj_ef_TCC1-1 nil 3763829936 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (efloat type-decl nil extended_float nil) (is_finite? const-decl "bool" extended_float nil) (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}" extended_float_rounding nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (precision formal-const-decl "above(1)" extended_float_rounding nil) (radix formal-const-decl "above(1)" extended_float_rounding nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (zero_inclusive formula-decl nil extended_float nil)) nil (prj_ef subtype "extended_float_rounding.f" "(extended_float[extended_float_rounding.radix, extended_float_rounding.precision, extended_float_rounding.dExp].nzfinite?)"))) (round_zero 0 (round_zero-1 nil 3763829985 ("" (expand "rnd_ef") (("" (lift-if 1) (("" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (propax) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (rnd_ef const-decl "efloat" extended_float_rounding nil)) nil)) (round_inverse_of_projection_on_nzfinite_TCC1 0 (round_inverse_of_projection_on_nzfinite_TCC1-1 nil 3763829981 ("" (subtype-tcc) nil nil) ((dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}" extended_float_rounding nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (precision formal-const-decl "above(1)" extended_float_rounding nil) (radix formal-const-decl "above(1)" extended_float_rounding nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (is_finite? const-decl "bool" extended_float nil)) nil (round_inverse_of_projection_on_nzfinite subtype "extended_float_rounding.f" "(extended_float[extended_float_rounding.radix, extended_float_rounding.precision, extended_float_rounding.dExp].is_finite?)"))) (round_inverse_of_projection_on_nzfinite 0 (round_inverse_of_projection_on_nzfinite-1 nil 3764610474 ("" (skeep :preds? t) (("" (expand "prj_ef") (("" (typepred "val(f)") (("" (case "rnd_ucf(prj_ucf(val(f))) = val(f)") (("1" (case "rnd_ef(prj_ucf(val(f))) = nzfinite(rnd_ucf(prj_ucf(val(f))))") (("1" (replace -1 :hide? t) (("1" (replace -1 :hide? t) (("1" (apply-extensionality 1) nil nil)) nil)) nil) ("2" (hide 2) (("2" (expand "rnd_ef") (("2" (lift-if 1) (("2" (case "(-max_pos_value <= prj_ucf(val(f)) AND prj_ucf(val(f)) <= -min_pos_value) OR (min_pos_value<= prj_ucf(val(f)) AND prj_ucf(val(f)) <= max_pos_value)") (("1" (split -1) (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "representability_limits_for_bounded_floats") (("2" (inst -1 "given_format" "max_exp" "val(f)") (("2" (skoletin -1 :hide? nil) (("2" (rewrite "min_pos_value__min_pos_unb_canonic_float__eq") (("2" (case "maximum_positive_bounded_value = max_pos_value") (("1" (replace -1 :hide? t :dir rl) (("1" (flatten) (("1" (expand "prj_ucf") (("1" (split -1) (("1" (propax) nil nil) ("2" (use "ftor_zero_fnum") (("2" (assert) nil nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "maximum_positive_bounded_value") (("2" (assert) (("2" (expand "vNum") (("2" (expand "given_format") (("2" (assert) (("2" (expand "prj_ucf") (("2" (expand "max_pos_value") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("2" (use "rnd_prj_ucf") nil nil)) nil)) nil)) nil)) nil) ((prj_ef const-decl "real" extended_float_rounding nil) (prj_ucf const-decl "real" extended_float nil) (rnd_ucf const-decl "{f: unb_canonic_float | currified_closest?_ucf(x1)(f)}" extended_float nil) (currified_closest?_ucf const-decl "bool" extended_float nil) (Fbounded? const-decl "bool" float nil) (= const-decl "[T, T -> boolean]" equalities nil) (f skolem-const-decl "(nzfinite?)" extended_float_rounding nil) (min_pos_value__min_pos_unb_canonic_float__eq formula-decl nil extended_float nil) (maximum_positive_bounded_value skolem-const-decl "int" extended_float_rounding nil) (ftor_zero_fnum formula-decl nil float nil) (minus_int_is_int application-judgement "int" integers nil) (minimum_positive_bounded_value const-decl "posreal" float nil) (FtoR const-decl "real" float nil) (posint_exp application-judgement "posint" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (^ const-decl "real" exponentiation nil) (vNum const-decl "posnat" float nil) (int_times_int_is_int application-judgement "int" integers nil) (representability_limits_for_bounded_floats formula-decl nil float nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posinf const-decl "efloat" extended_float nil) (poszero const-decl "efloat" extended_float nil) (negzero const-decl "efloat" extended_float nil) (neginf const-decl "efloat" extended_float nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (min_pos_value const-decl "posreal" extended_float nil) (max_pos_value const-decl "posreal" extended_float nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (- const-decl "[numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (efloat_nzfinite_extensionality formula-decl nil extended_float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nzfinite adt-constructor-decl "[{v: unb_canonic_float | Fexp(v) <= max_exp AND Fnum(v) /= 0} ->
   (nzfinite?)]" extended_float nil) (rnd_ef const-decl "efloat" extended_float_rounding nil) (rnd_prj_ucf formula-decl nil extended_float nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (radix formal-const-decl "above(1)" extended_float_rounding nil) (Format type-eq-decl nil float nil) (float type-eq-decl nil float nil) (Fcanonic? const-decl "bool" float nil) (precision formal-const-decl "above(1)" extended_float_rounding nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}" extended_float_rounding nil) (given_format const-decl "Format" extended_float nil) (efloat type-decl nil extended_float nil) (nzfinite? adt-recognizer-decl "[efloat -> boolean]" extended_float nil) (unb_canonic_float type-eq-decl nil extended_float nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (posint nonempty-type-eq-decl nil integers nil) (max_exp const-decl "posint" extended_float nil) (/= const-decl "boolean" notequal nil) (val adt-accessor-decl "[(nzfinite?) ->
   {v: unb_canonic_float | Fexp(v) <= max_exp AND Fnum(v) /= 0}]" extended_float nil)) shostak)) (rtoed_er_is_finite 0 (rtoed_er_is_finite-1 nil 3765793922 ("" (skeep :preds? t) (("" (use "er_lower_bound") (("" (lemma "er_upper_bound") (("" (inst -1 "x") (("" (rewrite "er_ub_correspondent") (("" (rewrite "er_lb_correspondent") (("" (expand "rnd_ef") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((er_lower_bound formula-decl nil ieee754_domain nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (radix formal-const-decl "above(1)" extended_float_rounding nil) (precision formal-const-decl "above(1)" extended_float_rounding nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}" extended_float_rounding nil) (emax const-decl "above(1)" extended_float nil) (exactly_representable? const-decl "bool" ieee754_domain nil) (er_real nonempty-type-eq-decl nil ieee754_domain nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (er_lb_correspondent formula-decl nil extended_float_exactly_representable_reals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (negzero const-decl "efloat" extended_float nil) (is_finite? const-decl "bool" extended_float nil) (poszero const-decl "efloat" extended_float nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rnd_ef const-decl "efloat" extended_float_rounding nil) (er_ub_correspondent formula-decl nil extended_float_exactly_representable_reals nil) (er_upper_bound formula-decl nil ieee754_domain nil)) nil)) (projection_on_nzfinite 0 (projection_on_nzfinite-1 nil 3765880309 ("" (skeep :preds? t) (("" (expand "prj_ef") (("" (typepred "val(f)") (("" (expand "/=") (("" (expand "prj_ucf") (("" (expand "FtoR") (("" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((prj_ef const-decl "real" extended_float_rounding nil) (FtoR const-decl "real" float nil) (nonzero_times3 formula-decl nil real_props nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (prj_ucf const-decl "real" extended_float nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (radix formal-const-decl "above(1)" extended_float_rounding nil) (Format type-eq-decl nil float nil) (float type-eq-decl nil float nil) (Fcanonic? const-decl "bool" float nil) (precision formal-const-decl "above(1)" extended_float_rounding nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}" extended_float_rounding nil) (given_format const-decl "Format" extended_float nil) (efloat type-decl nil extended_float nil) (nzfinite? adt-recognizer-decl "[efloat -> boolean]" extended_float nil) (unb_canonic_float type-eq-decl nil extended_float nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (posint nonempty-type-eq-decl nil integers nil) (max_exp const-decl "posint" extended_float nil) (/= const-decl "boolean" notequal nil) (val adt-accessor-decl "[(nzfinite?) ->
   {v: unb_canonic_float | Fexp(v) <= max_exp AND Fnum(v) /= 0}]" extended_float nil)) shostak)) (flip_sign_j 0 (flip_sign_j-2 nil 3765627806 ("" (skeep :preds? t) (("" (split 1) (("1" (lemma "FcanonicOpp") (("1" (inst -1 "given_format" "val(f)") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "Fopp") (("2" (typepred "val(f)") (("2" (propax) nil nil)) nil)) nil) ("3" (expand "Fopp") (("3" (assert) nil nil)) nil)) nil)) nil) ((posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Format type-eq-decl nil float nil) (precision formal-const-decl "above(1)" extended_float_rounding nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}" extended_float_rounding nil) (given_format const-decl "Format" extended_float nil) (float type-eq-decl nil float nil) (efloat type-decl nil extended_float nil) (nzfinite? adt-recognizer-decl "[efloat -> boolean]" extended_float nil) (Fcanonic? const-decl "bool" float nil) (unb_canonic_float type-eq-decl nil extended_float nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (posint nonempty-type-eq-decl nil integers nil) (max_exp const-decl "posint" extended_float nil) (/= const-decl "boolean" notequal nil) (val adt-accessor-decl "[(nzfinite?) ->
   {v: unb_canonic_float | Fexp(v) <= max_exp AND Fnum(v) /= 0}]" extended_float nil) (FcanonicOpp formula-decl nil float nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (radix formal-const-decl "above(1)" extended_float_rounding nil) (NOT const-decl "[bool -> bool]" booleans nil) (Fopp const-decl "float" float nil) (minus_int_is_int application-judgement "int" integers nil)) nil (flip_sign_j subtype "float[extended_float_rounding.radix].Fopp(extended_float[extended_float_rounding.radix, extended_float_rounding.precision, extended_float_rounding.dExp].val(extended_float_rounding.f))" "{v: extended_float[extended_float_rounding.radix, extended_float_rounding.precision, extended_float_rounding.dExp].unb_canonic_float | booleans.AND(reals.<=(Fexp(v), extended_float[extended_float_rounding.radix, extended_float_rounding.precision, extended_float_rounding.dExp].max_exp), Fnum(v) /= 0)}")) (flip_sign_j-1 nil 3765627775 ("" (judgement-tcc) nil nil) nil nil (flip_sign_j subtype "float[extended_float_rounding.radix].Fopp(extended_float[extended_float_rounding.radix, extended_float_rounding.precision, extended_float_rounding.dExp].val(extended_float_rounding.f))" "{v: extended_float[extended_float_rounding.radix, extended_float_rounding.precision, extended_float_rounding.dExp].unb_canonic_float | booleans.AND(reals.<=(Fexp(v), extended_float[extended_float_rounding.radix, extended_float_rounding.precision, extended_float_rounding.dExp].max_exp), Fnum(v) /= 0)}"))))
