(extended_float_exactly_representable_reals
 (er_rat_to_er_int__exponent__le_max_exp 0
  (er_rat_to_er_int__exponent__le_max_exp-1 nil 3763920022
   ("" (skeep :preds? t)
    (("" (expand "er_rat_to_er_int__exponent")
      (("" (expand "max_exp")
        (("" (assert)
          (("" (expand "emin")
            (("" (expand "min_exp") (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((er_rat_to_er_int__exponent const-decl "int"
     extended_float_exactly_representable_reals nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (emax const-decl "above(1)" extended_float nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (emin const-decl "negint" ieee754_domain nil)
    (max_exp const-decl "posint" extended_float nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil))
   shostak))
 (er_rat_to_er_int__exponent__ge_min_exp 0
  (er_rat_to_er_int__exponent__ge_min_exp-1 nil 3763920022
   ("" (expand "er_rat_to_er_int__exponent")
    (("" (skeep :preds? t)
      (("" (expand "min_exp") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (max_exp const-decl "posint" extended_float nil)
    (emax const-decl "above(1)" extended_float nil)
    (emin const-decl "negint" ieee754_domain nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (min_exp const-decl "negint" extended_float nil)
    (er_rat_to_er_int__exponent const-decl "int"
     extended_float_exactly_representable_reals nil)
    (int_plus_int_is_int application-judgement "int" integers nil))
   shostak))
 (er_rat_to_er_int__significand_TCC1 0
  (er_rat_to_er_int__significand_TCC2-1 nil 3763919900
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (emax const-decl "above(1)" extended_float nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (emin const-decl "negint" ieee754_domain nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (exponent type-eq-decl nil ieee754_domain nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (max_exp const-decl "posint" extended_float nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (/= const-decl "boolean" notequal nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil))
   shostak
   (er_rat_to_er_int__significand subtype
    "((number_fields.-)((number_fields.-)(extended_float_exactly_representable_reals.precision, 1), extended_float_exactly_representable_reals.i))"
    "{i: integers.int | booleans.OR(extended_float_exactly_representable_reals.radix /= 0, reals.>=(i, 0))}")))
 (er_rat_to_er_int__significand_TCC2 0
  (er_rat_to_er_int__significand_TCC1-1 nil 3763919900
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (emax const-decl "above(1)" extended_float nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (emin const-decl "negint" ieee754_domain nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (exponent type-eq-decl nil ieee754_domain nil)
    (nzreal_expt application-judgement "nzreal" exponentiation nil)
    (int_expt application-judgement "int" exponentiation nil)
    (int_exp application-judgement "int" exponentiation nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (max_exp const-decl "posint" extended_float nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (^ const-decl "real" exponentiation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (rat_exp application-judgement "rat" exponentiation nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (sigma_nat application-judgement "nat" sigma_nat "reals/")
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil))
   shostak
   (er_rat_to_er_int__significand subtype
    "number_fields.*(exponentiation.^(((number_fields.-)(1)), extended_float_exactly_representable_reals.s), sigma[nat].sigma(0, (number_fields.-)(extended_float_exactly_representable_reals.precision, 1), LAMBDA (i: naturalnumbers.nat): IF reals.<(i, extended_float_exactly_representable_reals.precision) THEN number_fields.*(extended_float_exactly_representable_reals.m(i), exponentiation.^(extended_float_exactly_representable_reals.radix, ((number_fields.-)((number_fields.-)(extended_float_exactly_representable_reals.precision, 1), i)))) ELSE 0 ENDIF))"
    "int")))
 (er_rat_to_er_int__significand__abs_lt_radix_pow_prec_TCC1 0
  (er_rat_to_er_int__significand__abs_lt_radix_pow_prec_TCC1-1 nil
   3765203177 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (emax const-decl "above(1)" extended_float nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (emin const-decl "negint" ieee754_domain nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (exponent type-eq-decl nil ieee754_domain nil)
    (max_exp const-decl "posint" extended_float nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (/= const-decl "boolean" notequal nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil))
   shostak
   (er_rat_to_er_int__significand__abs_lt_radix_pow_prec subtype
    "extended_float_exactly_representable_reals.precision"
    "{i: integers.int | booleans.OR(extended_float_exactly_representable_reals.radix /= 0, reals.>=(i, 0))}")))
 (er_rat_to_er_int__significand__abs_lt_radix_pow_prec 0
  (er_rat_to_er_int__significand__abs_lt_radix_pow_prec-2 "" 3765353041
   ("" (skeep :preds? t)
    (("" (expand "er_rat_to_er_int__significand")
      (("" (invoke (name-replace "significand_value" "%1") (! 1 1 1 2))
        (("1" (case "0 <= significand_value")
          (("1"
            (case "abs((-1) ^ s * significand_value) = significand_value")
            (("1" (replace -1 :hide? t)
              (("1" (expand "significand_value")
                (("1" (hide -1)
                  (("1"
                    (case "FORALL (j: nat): j < precision IMPLIES -1 - j + precision >= 0")
                    (("1" (assert)
                      (("1" (hide -1)
                        (("1"
                          (case "sigma[nat]
                                                                    (0, precision - 1,
                                                                     LAMBDA (i: nat):
                                                                       IF i < precision THEN m(i) * radix ^ (-1 - i + precision)
                                                                       ELSE 0
                                                                       ENDIF) = sigma[nat]
                                                                    (0, precision - 1,
                                                                     LAMBDA (j: nat):
                                                                       IF j < precision THEN m(precision-1-j) * radix ^ j
                                                                       ELSE 0
                                                                       ENDIF)")
                          (("1" (replace -1 :hide? t)
                            (("1" (lemma "sigma_le[nat]")
                              (("1"
                                (inst
                                 -1
                                 "LAMBDA(j:nat): IF j < precision THEN m(precision - 1 - j) * radix ^ j
                                                           ELSE 0
                                                           ENDIF"
                                 "LAMBDA(j:nat): (radix-1) * radix ^ j"
                                 "precision-1"
                                 "0")
                                (("1"
                                  (split -1)
                                  (("1"
                                    (use "sigma_scal[nat]")
                                    (("1"
                                      (replace -1 :hide? t)
                                      (("1"
                                        (use
                                         "sigma_nat.sigma_geometric")
                                        (("1"
                                          (split -1)
                                          (("1"
                                            (replace -1 :hide? t)
                                            (("1"
                                              (invoke
                                               (case "%1 < %2")
                                               (! -1 2)
                                               (! 1 2))
                                              (("1" (assert) nil nil)
                                               ("2"
                                                (hide-all-but 1)
                                                (("2"
                                                  (case
                                                   "(radix - 1) *
                                                         ((radix ^ 0 - radix ^ (precision - 1 + 1)) / (1 - radix)) = ((radix - 1)/ (1 - radix)) *
                                                         (radix ^ 0 - radix ^ (precision - 1 + 1))")
                                                  (("1"
                                                    (replace
                                                     -1
                                                     :hide?
                                                     t)
                                                    (("1"
                                                      (case
                                                       "((radix - 1) / (1 - radix)) *
                                                             (radix ^ 0 - radix ^ (precision - 1 + 1)) = radix ^ precision - 1")
                                                      (("1"
                                                        (replace
                                                         -1
                                                         :hide?
                                                         t)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (hide 2)
                                                        (("2"
                                                          (grind-reals)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (assert) nil nil)
                                           ("3" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (hide-all-but 1)
                                    (("2"
                                      (skeep :preds? t)
                                      (("2"
                                        (lift-if 1)
                                        (("2"
                                          (split 1)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (typepred
                                               "m(precision -1 - n)")
                                              (("1"
                                                (case
                                                 "m(precision - 1 - n) <= radix-1")
                                                (("1"
                                                  (hide -2)
                                                  (("1"
                                                    (mult-by
                                                     -1
                                                     "radix^n")
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide-all-but 1)
                            (("2" (lemma "sigma_downwards[nat]")
                              (("2"
                                (inst
                                 -1
                                 "LAMBDA (j: nat):
              IF j < precision THEN m(precision - 1 - j) * radix ^ j
              ELSE 0
              ENDIF"
                                 "precision-1"
                                 "0"
                                 "precision-1")
                                (("1"
                                  (assert)
                                  (("1"
                                    (replace -1 :hide? t)
                                    (("1"
                                      (use "sigma_eq[nat]")
                                      (("1"
                                        (split -1)
                                        (("1" (propax) nil nil)
                                         ("2" (assert) nil nil))
                                        nil)
                                       ("2"
                                        (hide 2)
                                        (("2"
                                          (skeep)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (skeep)
                                  (("2"
                                    (hide 2)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("3" (assert) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (assert)
                      (("2" (hide 2)
                        (("2" (skeep) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide-all-but (-1 1 -2))
              (("2" (expand "abs") (("2" (grind-reals) nil nil)) nil))
              nil))
            nil)
           ("2" (hide-all-but 1)
            (("2" (expand "significand_value")
              (("2" (use "sigma_nonneg[nat]")
                (("1" (expand ">=")
                  (("1" (assert)
                    (("1" (hide 2)
                      (("1" (skeep)
                        (("1" (lift-if 1)
                          (("1" (split 1)
                            (("1" (flatten) (("1" (assert) nil nil))
                              nil)
                             ("2" (flatten) (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (skeep) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((rat_exp application-judgement "rat" exponentiation nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (sigma_rat application-judgement "rational" sigma_nat "reals/")
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (er_rat_to_er_int__significand const-decl "int"
     extended_float_exactly_representable_reals nil)
    (expt_x1 formula-decl nil exponentiation nil)
    (minus_rat_is_rat application-judgement "rat" rationals nil)
    (neg_times_lt formula-decl nil real_props nil)
    (int_exp application-judgement "int" exponentiation nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma_nat application-judgement "nat" sigma_nat "reals/")
    (sigma_le formula-decl nil sigma "reals/")
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (times_div1 formula-decl nil real_props nil)
    (div_distributes_minus formula-decl nil real_props nil)
    (div_cancel3 formula-decl nil real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (sigma_geometric formula-decl nil sigma_nat "reals/")
    (sigma_scal formula-decl nil sigma "reals/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subrange type-eq-decl nil integers nil)
    (both_sides_times_pos_le1_imp formula-decl nil extra_real_props
     nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (sigma_downwards formula-decl nil sigma "reals/")
    (sigma_eq formula-decl nil sigma "reals/")
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (significand_value skolem-const-decl "rational"
     extended_float_exactly_representable_reals nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (rat_abs_is_nonneg application-judgement "{r: nonneg_rat | r >= q}"
     real_defs nil)
    (sigma_nonneg formula-decl nil sigma "reals/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (T_low type-eq-decl nil sigma "reals/")
    (T_high type-eq-decl nil sigma "reals/")
    (sigma def-decl "real" sigma "reals/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (< const-decl "bool" reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (emax const-decl "above(1)" extended_float nil)
    (significand type-eq-decl nil ieee754_domain nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil))
   shostak)
  (er_rat_to_er_int__significand__abs_lt_radix_pow_prec-1 nil
   3763919910
   ("" (skeep :preds? t)
    (("" (expand "er_rat_to_er_int__significand")
      ((""
        (case "sigma[below(53)] (0, 52, LAMBDA (i: below(53)): m(i) * 2 ^ (52 - i)) = sigma[below(53)] (0, 52, LAMBDA (i: below(53)): m(52 - i) * 2 ^ i)")
        (("1" (replace -1 :hide? t)
          (("1"
            (case "sigma[below(53)] (0, 52, LAMBDA (i: below(53)): m(52-i) * 2 ^ i) = sigma[nat] (0, 52, LAMBDA (i: nat): IF 52-i >= 0 AND 52-i < 53 THEN m(52-i) * 2 ^ i ELSE 0 ENDIF)")
            (("1" (replace -1 :hide? t)
              (("1"
                (name-replace "significand_value"
                 "sigma[nat] (0, 52, LAMBDA (i: nat): IF 52-i >= 0 AND 52-i < 53 THEN m(52-i) * 2 ^ i ELSE 0 ENDIF)")
                (("1" (case "0 <= significand_value")
                  (("1"
                    (case "abs((-1) ^ s * significand_value) = significand_value")
                    (("1" (replace -1 :hide? t)
                      (("1" (case "significand_value <= 2^53 - 1")
                        (("1" (assert) nil nil)
                         ("2" (hide 2)
                          (("2" (expand "significand_value")
                            (("2"
                              (case "sigma[nat](0, 52,  LAMBDA (i: nat): IF 52-i >= 0 THEN m(52-i) * 2 ^ i ELSE 0 ENDIF) <= sigma[nat](0, 52, LAMBDA (i: nat): 2 ^ i)")
                              (("1"
                                (use "sigma_nat.sigma_geometric")
                                (("1" (assert) nil nil))
                                nil)
                               ("2"
                                (hide 2)
                                (("2"
                                  (use "sigma_le[nat]")
                                  (("2"
                                    (assert)
                                    (("2"
                                      (hide 2)
                                      (("2"
                                        (skeep :preds? t)
                                        (("2"
                                          (typepred "m(52-n)")
                                          (("2" (grind-reals) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide-all-but (-1 1 -2))
                      (("2" (expand "abs")
                        (("2" (grind-reals) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (hide-all-but 1)
                    (("2" (expand "significand_value")
                      (("2" (use "sigma_nonneg[nat]")
                        (("2" (expand ">=") (("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide-all-but 1)
              (("2" (for 54 (expand "sigma")) nil nil)) nil))
            nil))
          nil)
         ("2" (hide-all-but 1)
          (("2"
            (for 52
             (then (rewrite "sigma_first_ge")
              (rewrite "sigma_last_ge" 1
               ("F" "LAMBDA (i: below(53)): m(52 - i) * 2 ^ i"))
              (assert)))
            (("2" (expand "sigma")
              (("2" (expand "sigma") (("2" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (significand type-eq-decl nil ieee754_domain nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (sigma def-decl "real" sigma "reals/")
    (T_high type-eq-decl nil sigma "reals/")
    (T_low type-eq-decl nil sigma "reals/")
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (sigma_nonneg formula-decl nil sigma "reals/")
    (rat_abs_is_nonneg application-judgement "{r: nonneg_rat | r >= q}"
     real_defs nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (subrange type-eq-decl nil integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (sigma_le formula-decl nil sigma "reals/")
    (sigma_geometric formula-decl nil sigma_nat "reals/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (int_exp application-judgement "int" exponentiation nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (neg_times_lt formula-decl nil real_props nil)
    (minus_rat_is_rat application-judgement "rat" rationals nil)
    (expt_x1 formula-decl nil exponentiation nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (nnrat_plus_nnrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (sigma_first_ge formula-decl nil sigma_below "reals/")
    (below type-eq-decl nil nat_types nil)
    (int_below type-eq-decl nil sigma_below "reals/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (sigma_last_ge formula-decl nil sigma_below "reals/")
    (odd_plus_odd_is_even application-judgement "even_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (er_rat_to_er_int__significand const-decl "int"
     extended_float_exactly_representable_reals nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (rat_exp application-judgement "rat" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil))
   shostak))
 (er_rat_to_er_int_value_TCC1 0
  (er_rat_to_er_int_value_TCC1-1 nil 3765203177
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (emax const-decl "above(1)" extended_float nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (emin const-decl "negint" ieee754_domain nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (exponent type-eq-decl nil ieee754_domain nil)
    (max_exp const-decl "posint" extended_float nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (er_rat_to_er_int__exponent const-decl "int"
     extended_float_exactly_representable_reals nil)
    (er_rat_to_er_int__significand const-decl "int"
     extended_float_exactly_representable_reals nil)
    (^ const-decl "real" exponentiation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (rat_exp application-judgement "rat" exponentiation nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (sigma_nat application-judgement "nat" sigma_nat "reals/")
    (int_plus_int_is_int application-judgement "int" integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil))
   shostak
   (er_rat_to_er_int_value subtype
    "extended_float_exactly_representable_reals.exponent"
    "{i: integers.int | booleans.OR(extended_float_exactly_representable_reals.radix /= 0, reals.>=(i, 0))}")))
 (er_rat_to_er_int_value 0
  (er_rat_to_er_int_value-1 nil 3763919910
   ("" (skeep :preds? t)
    (("" (beta)
      (("" (expand "er_rat_to_er_int__significand")
        (("" (expand "er_rat_to_er_int__exponent")
          (("" (expand "value")
            ((""
              (case "(radix ^ (e!1 - (precision-1))) * (-1) ^ s * sigma(0, (precision-1), LAMBDA (i: nat): IF i < precision THEN m(i) * radix ^ (-1 - i + precision)
               ELSE 0
               ENDIF) = radix ^ e!1 * (-1) ^ s * radix ^(-(precision-1)) * sigma(0, (precision-1), LAMBDA (i: nat): IF i < precision THEN  m(i) * radix ^ (precision-1) * radix ^(- i)ELSE 0
               ENDIF)")
              (("1" (replace -1 :hide? t)
                (("1"
                  (case "radix ^ (-(precision-1)) * sigma (0, (precision-1), LAMBDA (i: nat):
                IF i < precision
                  THEN m(i) * radix ^ (precision - 1) * radix ^ (-i)
                ELSE 0
                ENDIF) = sigma(0, (precision-1), LAMBDA (i: nat): IF i < precision
                  THEN m(i) * radix ^ (-i)ELSE 0
                ENDIF)")
                  (("1" (assert) nil nil)
                   ("2" (hide 2)
                    (("2" (lemma "sigma[nat].sigma_scal")
                      (("2" (inst? -1)
                        (("1" (replace -1 :hide? t :dir rl)
                          (("1" (rewrite "sigma[nat].sigma_eq")
                            (("1" (hide-all-but 1)
                              (("1"
                                (skeep :preds? t)
                                (("1"
                                  (swap
                                   "m(n)"
                                   "*"
                                   "radix ^ (precision-1) * radix ^ (-n)")
                                  (("1"
                                    (case
                                     "radix ^ (-(precision-1)) * ((radix ^ (precision-1) * radix ^ (-n)) * (m(n))) = (radix ^ (-(precision-1)) * radix ^ (precision-1)) * radix ^ (-n) * (m(n))")
                                    (("1"
                                      (replace -1 :hide? t)
                                      (("1"
                                        (rewrite "expt_plus" :dir rl)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skeep) (("2" (assert) nil nil)) nil)
                         ("3" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 2)
                (("2"
                  (case "(radix ^ (e!1 - (precision-1))) = radix ^ e!1 * radix ^ (- (precision-1))")
                  (("1" (replace -1 :hide? t)
                    (("1" (lemma "sigma[nat].sigma_eq")
                      (("1" (inst? -1 :where 1)
                        (("1"
                          (inst -1
                           "LAMBDA (i: nat): IF i < precision THEN m(i) * radix ^ (precision-1) * radix ^ (-i) ELSE 0 ENDIF")
                          (("1" (split -1)
                            (("1" (assert) nil nil)
                             ("2" (hide 2)
                              (("2"
                                (skeep :preds? t)
                                (("2"
                                  (lift-if 1)
                                  (("2"
                                    (split 1)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (case
                                         "(precision-1) - n = (precision-1) + -n")
                                        (("1"
                                          (replace -1 :hide? t)
                                          (("1"
                                            (rewrite "expt_plus")
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil)
                                         ("2" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert) nil nil)
                           ("3" (assert) nil nil))
                          nil)
                         ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 2)
                    (("2"
                      (case "e!1 - (precision-1) = e!1 + -(precision-1)")
                      (("1" (replace -1 :hide? t)
                        (("1" (rewrite "expt_plus") nil nil)) nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (assert) nil nil) ("4" (assert) nil nil)
               ("5" (assert) nil nil) ("6" (assert) nil nil)
               ("7" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (er_rat_to_er_int__exponent const-decl "int"
     extended_float_exactly_representable_reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (significand type-eq-decl nil ieee754_domain nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (sigma def-decl "real" sigma "reals/")
    (T_high type-eq-decl nil sigma "reals/")
    (T_low type-eq-decl nil sigma "reals/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (exponent type-eq-decl nil ieee754_domain nil)
    (emin const-decl "negint" ieee754_domain nil)
    (emax const-decl "above(1)" extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (^ const-decl "real" exponentiation nil)
    (>= const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real nonempty-type-from-decl nil reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigma_scal formula-decl nil sigma "reals/")
    (subrange type-eq-decl nil integers nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (expt_plus formula-decl nil exponentiation nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (sigma_eq formula-decl nil sigma "reals/")
    (sigma_rat application-judgement "rational" sigma_nat "reals/")
    (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (rat_exp application-judgement "rat" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (value const-decl "real" ieee754_domain nil)
    (er_rat_to_er_int__significand const-decl "int"
     extended_float_exactly_representable_reals nil))
   shostak))
 (er_ub_correspondent 0
  (er_ub_correspondent-1 nil 3763920022
   ("" (expand "max_pos_value")
    (("" (expand "er_ub")
      (("" (expand "value")
        (("" (expand "emax")
          (("" (expand "smax" :assert? none)
            ((""
              (case "((-1) ^ 0 * radix ^ (max_exp - 1 + precision)) *
              sigma(0, precision - 1,
                    LAMBDA (i: nat):
                      IF i < precision THEN (radix - 1) * radix ^ (-i)
                      ELSE 0
                      ENDIF) = radix ^ max_exp * (radix-1) * sigma(0, precision - 1,
                    LAMBDA (j: nat):
                      radix ^ j)")
              (("1" (replace -1 :hide? t)
                (("1" (use "sigma_nat.sigma_geometric")
                  (("1" (split -1)
                    (("1" (replace -1 :hide? t)
                      (("1" (grind-reals) nil nil)) nil)
                     ("2" (assert) nil nil) ("3" (assert) nil nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil))
                nil)
               ("2" (hide 2)
                (("2" (lemma "sigma[nat].sigma_eq")
                  (("2"
                    (inst -1 "LAMBDA (i: nat):
                   IF i < precision THEN (radix - 1) * radix ^ (-i)
                   ELSE 0
                   ENDIF" "LAMBDA (i: nat): (radix - 1) * radix ^ (-i)"
                     "precision-1" "0")
                    (("1" (split -1)
                      (("1" (replace -1 :hide? t)
                        (("1" (lemma "sigma[nat].sigma_scal")
                          (("1"
                            (inst -1 "LAMBDA (i: nat):radix ^ (-i)"
                             "(radix-1)" "precision-1" "0")
                            (("1" (replace -1 :hide? t)
                              (("1"
                                (case
                                 "radix ^ (max_exp - 1 + precision) = radix ^ max_exp * radix ^ ( - 1 + precision)")
                                (("1"
                                  (replace -1 :hide? t)
                                  (("1"
                                    (case
                                     "((-1) ^ 0 * (radix ^ max_exp * radix ^ (-1 + precision))) *
                        ((radix - 1) *
                          sigma(0, precision - 1, LAMBDA (i: nat): radix ^ (-i))) = (-1) ^ 0 * radix ^ max_exp  *
                        (radix - 1) * (radix ^ (-1 + precision) *
                          sigma(0, precision - 1, LAMBDA (i: nat): radix ^ (-i)))")
                                    (("1"
                                      (replace -1 :hide? t)
                                      (("1"
                                        (lemma "sigma[nat].sigma_scal")
                                        (("1"
                                          (inst
                                           -1
                                           "LAMBDA (i: nat): radix ^ (-i)"
                                           "radix ^ (-1 + precision)"
                                           "precision-1"
                                           "0")
                                          (("1"
                                            (replace
                                             -1
                                             :hide?
                                             rl
                                             :dir
                                             rl)
                                            (("1"
                                              (lemma
                                               "sigma[nat].sigma_eq")
                                              (("1"
                                                (inst
                                                 -1
                                                 "LAMBDA (i_1: nat): radix ^ (-1 + precision) * radix ^ (-i_1)"
                                                 "LAMBDA (i_1: nat): radix ^ (-1 + precision -i_1)"
                                                 "precision-1"
                                                 "0")
                                                (("1"
                                                  (split -1)
                                                  (("1"
                                                    (replace
                                                     -1
                                                     :hide?
                                                     t)
                                                    (("1"
                                                      (invoke
                                                       (case "%1 = %2")
                                                       (! 1 1 4)
                                                       (! 1 2 3))
                                                      (("1"
                                                        (assert)
                                                        nil
                                                        nil)
                                                       ("2"
                                                        (hide 2)
                                                        (("2"
                                                          (lemma
                                                           "sigma_downwards")
                                                          (("2"
                                                            (inst
                                                             -1
                                                             "LAMBDA (j: nat): radix ^ j"
                                                             "precision-1"
                                                             "0"
                                                             "precision-1")
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (replace
                                                                 -1
                                                                 :hide?
                                                                 t)
                                                                (("1"
                                                                  (lemma
                                                                   "sigma[nat].sigma_eq")
                                                                  (("1"
                                                                    (inst?
                                                                     -1)
                                                                    (("1"
                                                                      (split
                                                                       -1)
                                                                      (("1"
                                                                        (propax)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (hide
                                                                         2)
                                                                        (("2"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (hide
                                                                       2)
                                                                      (("2"
                                                                        (skeep)
                                                                        (("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("3"
                                                                      (hide
                                                                       2)
                                                                      (("3"
                                                                        (skeep)
                                                                        (("3"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("3"
                                                        (hide 2)
                                                        (("3"
                                                          (skeep)
                                                          (("3"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (hide-all-but 1)
                                                    (("2"
                                                      (skeep :preds? t)
                                                      (("2"
                                                        (lemma
                                                         "expt_plus")
                                                        (("2"
                                                          (inst
                                                           -1
                                                           "-1+precision"
                                                           "-n"
                                                           "radix")
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (assert) nil nil)
                                                 ("3" (assert) nil nil)
                                                 ("4"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (hide-all-but 1)
                                      (("2" (assert) nil nil))
                                      nil)
                                     ("3" (assert) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (hide-all-but 1)
                                  (("2"
                                    (lemma "expt_plus")
                                    (("2"
                                      (inst
                                       -1
                                       "max_exp"
                                       "-1+precision"
                                       "radix")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("3" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil)
                     ("2" (assert) nil nil) ("3" (assert) nil nil))
                    nil))
                  nil))
                nil)
               ("3" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((er_ub const-decl "er_real" ieee754_domain nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (emax const-decl "above(1)" extended_float nil)
    (< const-decl "bool" reals nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (sigma def-decl "real" sigma "reals/")
    (T_high type-eq-decl nil sigma "reals/")
    (T_low type-eq-decl nil sigma "reals/")
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (max_exp const-decl "posint" extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (>= const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real nonempty-type-from-decl nil reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sigma_geometric formula-decl nil sigma_nat "reals/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sigma_nat application-judgement "nat" sigma_nat "reals/")
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (div_cancel3 formula-decl nil real_props nil)
    (div_distributes_minus formula-decl nil real_props nil)
    (times_div2 formula-decl nil real_props nil)
    (times_div1 formula-decl nil real_props nil)
    (sigma_rat application-judgement "rational" sigma_nat "reals/")
    (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (int_exp application-judgement "int" exponentiation nil)
    (sigma_eq formula-decl nil sigma "reals/")
    (sigma_scal formula-decl nil sigma "reals/")
    (sigma_nnreal application-judgement "nnreal" sigma_nat "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma_downwards formula-decl nil sigma "reals/")
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (subrange type-eq-decl nil integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (expt_plus formula-decl nil exponentiation nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers
     nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (smax const-decl "significand" ieee754_domain nil)
    (value const-decl "real" ieee754_domain nil)
    (max_pos_value const-decl "posreal" extended_float nil)
    (posint_exp application-judgement "posint" exponentiation nil))
   shostak))
 (er_lb_correspondent 0
  (er_lb_correspondent-1 nil 3763920022
   ("" (expand "er_lb")
    (("" (use "er_ub_correspondent")
      (("" (expand "er_ub")
        (("" (replace -1 :hide? t :dir rl)
          (("" (expand "value") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((er_ub_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (expt_x1 formula-decl nil exponentiation nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (minus_rat_is_rat application-judgement "rat" rationals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (sigma_rat application-judgement "rational" sigma_nat "reals/")
    (posint_exp application-judgement "posint" exponentiation nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (int_exp application-judgement "int" exponentiation nil)
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers
     nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (value const-decl "real" ieee754_domain nil)
    (er_ub const-decl "er_real" ieee754_domain nil)
    (er_lb const-decl "er_real" ieee754_domain nil))
   shostak))
 (er_min_pos_correspondent 0
  (er_min_pos_correspondent-1 nil 3763920022
   ("" (expand "er_min_pos")
    (("" (expand "min_pos_value")
      (("" (case "emin = min_exp + precision - 1")
        (("1" (replace -1 :hide? t)
          (("1" (expand "smin")
            (("1" (expand "value")
              (("1"
                (case "sigma(0, precision - 1,
                    LAMBDA (i_1: nat):
                      IF i_1 < precision
                        THEN IF i_1 = precision - 1 THEN 1 ELSE 0 ENDIF *
                              radix ^ (-i_1)
                      ELSE 0
                      ENDIF) = radix ^ (-precision+1)")
                (("1" (replace -1 :hide? t)
                  (("1" (assert)
                    (("1" (lemma "expt_plus")
                      (("1"
                        (inst -1 "(1 + -precision)"
                         "(min_exp - 1 + precision)" "radix")
                        (("1" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide-all-but 1)
                  (("2" (lemma "sigma_with")
                    (("2"
                      (inst -1 "LAMBDA (i_1: nat):
                  IF i_1 < precision
                    THEN IF i_1 = precision - 1 THEN 1 ELSE 0 ENDIF *
                          radix ^ (-i_1)
                  ELSE 0
                  ENDIF" "LAMBDA(i:nat):0" "radix^(1-precision)"
                       "precision-1" "precision-1" "0")
                      (("1" (split -1)
                        (("1" (replace -1 :hide? t)
                          (("1" (rewrite "sigma_zero")
                            (("1" (assert) nil nil)) nil))
                          nil)
                         ("2" (assert) nil nil) ("3" (assert) nil nil)
                         ("4" (hide-all-but 1)
                          (("4" (apply-extensionality)
                            (("4" (hide 2) (("4" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil) ("3" (assert) nil nil)
                       ("4" (assert) nil nil))
                      nil))
                    nil))
                  nil)
                 ("3" (assert) nil nil) ("4" (assert) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 2)
          (("2" (expand "emin")
            (("2" (expand "emax")
              (("2" (expand "min_exp")
                (("2" (expand "max_exp") (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((min_pos_value const-decl "posreal" extended_float nil)
    (max_exp const-decl "posint" extended_float nil)
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers
     nil)
    (value const-decl "real" ieee754_domain nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (expt def-decl "real" exponentiation nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnrat_plus_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (sigma_nat application-judgement "nat" sigma_nat "reals/")
    (sigma_zero formula-decl nil sigma "reals/")
    (sigma_with formula-decl nil sigma "reals/")
    (int_exp application-judgement "int" exponentiation nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (expt_plus formula-decl nil exponentiation nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (sigma def-decl "real" sigma "reals/")
    (T_high type-eq-decl nil sigma "reals/")
    (T_low type-eq-decl nil sigma "reals/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (sigma_rat application-judgement "rational" sigma_nat "reals/")
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (smin const-decl "significand" ieee754_domain nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (emax const-decl "above(1)" extended_float nil)
    (emin const-decl "negint" ieee754_domain nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (min_exp const-decl "negint" extended_float nil)
    (er_min_pos const-decl "er_real" ieee754_domain nil))
   shostak))
 (er_max_neg_correspondent 0
  (er_max_neg_correspondent-1 nil 3763920022
   ("" (expand "er_max_neg")
    (("" (use "er_min_pos_correspondent")
      (("" (expand "er_min_pos")
        (("" (expand "value") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((er_min_pos_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (value const-decl "real" ieee754_domain nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (int_exp application-judgement "int" exponentiation nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (sigma_rat application-judgement "rational" sigma_nat "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (expt_x1 formula-decl nil exponentiation nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (er_min_pos const-decl "er_real" ieee754_domain nil)
    (er_max_neg const-decl "er_real" ieee754_domain nil))
   shostak))
 (min_pos_value_is_er 0
  (min_pos_value_is_er-1 nil 3764927692
   ("" (rewrite "er_min_pos_correspondent" :dir rl)
    (("" (assert) nil nil)) nil)
   ((er_min_pos_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil))
   shostak))
 (er_rat_er_int 0
  (er_rat_er_int-1 nil 3763919911
   ("" (skeep :preds? t)
    (("" (expand "exactly_representable?")
      (("" (skeep :preds? t)
        (("" (expand "exactly_representable_as_pair_of_integers?")
          (("" (use "er_rat_to_er_int_value")
            (("" (skoletin* -1)
              (("" (inst 1 "float_pair(signific,exponent)")
                (("1" (split 1)
                  (("1" (expand "FtoR")
                    (("1" (expand "float_pair")
                      (("1" (assert) nil nil)) nil))
                    nil)
                   ("2" (use "er_rat_to_er_int__exponent__le_max_exp")
                    (("2" (assert)
                      (("2" (expand "float_pair")
                        (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "Fbounded?")
                  (("2" (expand "float_pair")
                    (("2" (expand "given_format")
                      (("2" (expand "vNum")
                        (("2" (split 1)
                          (("1"
                            (use "er_rat_to_er_int__significand__abs_lt_radix_pow_prec")
                            (("1" (assert) nil nil)) nil)
                           ("2"
                            (use "er_rat_to_er_int__exponent__ge_min_exp")
                            (("2" (assert)
                              (("2"
                                (expand "min_exp")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((exactly_representable? const-decl "bool" ieee754_domain nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float_exactly_representable_reals nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (/= const-decl "boolean" notequal nil)
    (er_rat_to_er_int__exponent const-decl "int"
     extended_float_exactly_representable_reals nil)
    (er_rat_to_er_int__significand const-decl "int"
     extended_float_exactly_representable_reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (value const-decl "real" ieee754_domain nil)
    (^ const-decl "real" exponentiation nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (er_rat_to_er_int__significand__abs_lt_radix_pow_prec formula-decl
     nil extended_float_exactly_representable_reals nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (min_exp const-decl "negint" extended_float nil)
    (er_rat_to_er_int__exponent__ge_min_exp formula-decl nil
     extended_float_exactly_representable_reals nil)
    (vNum const-decl "posnat" float nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (FtoR const-decl "real" float nil)
    (er_rat_to_er_int__exponent__le_max_exp formula-decl nil
     extended_float_exactly_representable_reals nil)
    (exponent skolem-const-decl "int"
     extended_float_exactly_representable_reals nil)
    (signific skolem-const-decl "int"
     extended_float_exactly_representable_reals nil)
    (float_pair const-decl "float" float nil)
    (given_format const-decl "Format" extended_float nil)
    (Fbounded? const-decl "bool" float nil)
    (float type-eq-decl nil float nil)
    (Format type-eq-decl nil float nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (emax const-decl "above(1)" extended_float nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (emin const-decl "negint" ieee754_domain nil)
    (exponent type-eq-decl nil ieee754_domain nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (significand type-eq-decl nil ieee754_domain nil)
    (er_rat_to_er_int_value formula-decl nil
     extended_float_exactly_representable_reals nil))
   shostak))
 (er_bounded 0
  (er_bounded-1 nil 3763919911
   (""
    (then (use "er_rat_er_int")
     (expand "exactly_representable_as_pair_of_integers?") (skeep)
     (inst?) (skeep) (inst?))
    nil nil)
   ((er_rat_er_int formula-decl nil
     extended_float_exactly_representable_reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (float type-eq-decl nil float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float nil)
    (Fbounded? const-decl "bool" float nil)
    (given_format const-decl "Format" extended_float nil)
    (<= const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (max_exp const-decl "posint" extended_float nil)
    (f skolem-const-decl "(Fbounded?(given_format))"
     extended_float_exactly_representable_reals nil)
    (er_real nonempty-type-eq-decl nil ieee754_domain nil)
    (exactly_representable? const-decl "bool" ieee754_domain nil)
    (emax const-decl "above(1)" extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float_exactly_representable_reals nil))
   shostak))
 (er_canonic 0
  (er_canonic-1 nil 3764685365
   ("" (skeep)
    (("" (use "er_bounded")
      (("" (skeep)
        (("" (inst 1 "Fnormalize(given_format)(f)")
          (("1" (typepred "Fnormalize(given_format)(f)")
            (("1" (assert) nil nil)) nil)
           ("2" (typepred "Fnormalize(given_format)(f)")
            (("2" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((er_bounded formula-decl nil
     extended_float_exactly_representable_reals nil)
    (er_real nonempty-type-eq-decl nil ieee754_domain nil)
    (exactly_representable? const-decl "bool" ieee754_domain nil)
    (emax const-decl "above(1)" extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (f skolem-const-decl
     "{f: (Fbounded?(given_format)) | Fexp(f) <= max_exp}"
     extended_float_exactly_representable_reals nil)
    (max_exp const-decl "posint" extended_float nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (given_format const-decl "Format" extended_float nil)
    (Fnormalize def-decl
     "{x: (Fcanonic?(b)) | FtoR(x) = FtoR(f):: real AND Fexp(x) <= Fexp(f)}"
     float nil)
    (FtoR const-decl "real" float nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Fcanonic? const-decl "bool" float nil)
    (Fbounded? const-decl "bool" float nil)
    (float type-eq-decl nil float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float nil)
    (<= const-decl "bool" reals nil)
    (unb_canonic_float type-eq-decl nil extended_float nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   shostak))
 (dtor_rtod_on_er 0
  (dtor_rtod_on_er-1 nil 3763919911
   ("" (skeep :preds? t)
    (("" (typepred "rnd_ucf(x)")
      (("" (expand "currified_closest?_ucf")
        (("" (expand "closest?_ucf")
          (("" (expand "EvenClosest?")
            (("" (flatten)
              (("" (expand "Closest?" -2)
                (("" (use "er_bounded")
                  (("" (skeep -1 :preds? t)
                    (("" (inst -5 "f")
                      (("" (replace -3 :hide? t)
                        (("" (assert)
                          (("" (eval-expr "abs(0)")
                            (("" (replace -1 :hide? t)
                              ((""
                                (case "FtoR(rnd_ucf(x)) - x = 0")
                                (("1"
                                  (expand "prj_ucf")
                                  (("1" (assert) nil nil))
                                  nil)
                                 ("2"
                                  (expand "abs")
                                  (("2" (grind-reals) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((er_real nonempty-type-eq-decl nil ieee754_domain nil)
    (exactly_representable? const-decl "bool" ieee754_domain nil)
    (emax const-decl "above(1)" extended_float nil)
    (rnd_ucf const-decl
     "{f: unb_canonic_float | currified_closest?_ucf(x1)(f)}"
     extended_float nil)
    (currified_closest?_ucf const-decl "bool" extended_float nil)
    (Fbounded? const-decl "bool" float nil)
    (unb_canonic_float type-eq-decl nil extended_float nil)
    (given_format const-decl "Format" extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (Fcanonic? const-decl "bool" float nil)
    (float type-eq-decl nil float nil)
    (Format type-eq-decl nil float nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (> const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (above nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (closest?_ucf const-decl "bool" extended_float nil)
    (er_bounded formula-decl nil
     extended_float_exactly_representable_reals nil)
    (max_exp const-decl "posint" extended_float nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (abs_nat formula-decl nil abs_lems "reals/")
    (FtoR const-decl "real" float nil)
    (prj_ucf const-decl "real" extended_float nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (Closest? const-decl "bool" float nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (EvenClosest? const-decl "bool" float nil))
   shostak))
 (bound_on_exp_of_rounded_erreal 0
  (bound_on_exp_of_rounded_erreal-1 nil 3763919911
   ("" (skeep :preds? t)
    (("" (use "er_bounded")
      (("" (skeep :preds? t)
        (("" (lemma "CanonicLeastExp")
          (("" (inst -1 "given_format" "rnd_ucf(x)" "f")
            (("" (split -1)
              (("1" (assert) nil nil)
               ("2" (use "dtor_rtod_on_er")
                (("2" (expand "prj_ucf") (("2" (assert) nil nil)) nil))
                nil)
               ("3" (propax) nil nil) ("4" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((er_bounded formula-decl nil
     extended_float_exactly_representable_reals nil)
    (er_real nonempty-type-eq-decl nil ieee754_domain nil)
    (exactly_representable? const-decl "bool" ieee754_domain nil)
    (emax const-decl "above(1)" extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (CanonicLeastExp formula-decl nil float nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (prj_ucf const-decl "real" extended_float nil)
    (dtor_rtod_on_er formula-decl nil
     extended_float_exactly_representable_reals nil)
    (max_exp const-decl "posint" extended_float nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (rnd_ucf const-decl
     "{f: unb_canonic_float | currified_closest?_ucf(x1)(f)}"
     extended_float nil)
    (currified_closest?_ucf const-decl "bool" extended_float nil)
    (Fbounded? const-decl "bool" float nil)
    (unb_canonic_float type-eq-decl nil extended_float nil)
    (Fcanonic? const-decl "bool" float nil)
    (float type-eq-decl nil float nil)
    (given_format const-decl "Format" extended_float nil)
    (Format type-eq-decl nil float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   shostak)))

