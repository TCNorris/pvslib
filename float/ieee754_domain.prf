(ieee754_domain
 (emin_TCC1 0
  (emin_TCC1-1 nil 3790101901 ("" (subtype-tcc) nil nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil (emin subtype "(number_fields.-)(1, ieee754_domain.emax)" "negint")))
 (lesseqp_TCC1 0
  (lesseqp_TCC1-1 nil 3764935826 ("" (subtype-tcc) nil nil) nil nil
   (lesseqp subtype "ieee754_domain.j"
    "naturalnumbers.below(ieee754_domain.p)")))
 (significand_lt_first_discrepancy 0
  (significand_lt_first_discrepancy-1 nil 3764946996
   ("" (skeep)
    ((""
      (case "EXISTS(k: below(p)): (FORALL (j: below(k)): m1(j) = m2(j)) AND NOT m1(k) = m2(k)")
      (("1" (skeep :preds? t)
        (("1" (inst 3 "k")
          (("1" (split 3)
            (("1" (propax) nil nil)
             ("2" (expand "<=" -3)
              (("2" (inst -3 "k") (("2" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil)
       ("2" (hide 3)
        (("2" (hide -1)
          (("2" (inst 1 "min({k: below(p) | NOT m1(k) = m2(k)})")
            (("1" (split 1)
              (("1" (skeep :preds? t)
                (("1" (typepred "min({k: below(p) | NOT m1(k) = m2(k)})")
                  (("1" (inst -2 "j") (("1" (assert) nil nil)) nil)
                   ("2" (expand "nonempty?")
                    (("2" (expand "empty?")
                      (("2" (apply-extensionality 2)
                        (("2" (inst -1 "x!1")
                          (("2" (assert)
                            (("2" (expand "member") (("2" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (typepred "min({k: below(p) | NOT m1(k) = m2(k)})")
                (("1" (propax) nil nil)
                 ("2" (expand "nonempty?")
                  (("2" (expand "empty?")
                    (("2" (apply-extensionality) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (expand "nonempty?")
              (("2" (expand "empty?")
                (("2" (expand "member") (("2" (apply-extensionality) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil)
    (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat
         nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil)
    (<= const-decl "bool" ieee754_domain nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (k skolem-const-decl "below(p)" ieee754_domain nil)
    (m1 skolem-const-decl "significand" ieee754_domain nil)
    (m2 skolem-const-decl "significand" ieee754_domain nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (p formal-const-decl "above(1)" ieee754_domain nil)
    (below type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (b formal-const-decl "above(1)" ieee754_domain nil)
    (significand type-eq-decl nil ieee754_domain nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   shostak))
 (smax_TCC1 0
  (smax_TCC1-2 "" 3790102416 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (p formal-const-decl "above(1)" ieee754_domain nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak
   (smax subtype "(number_fields.-)(ieee754_domain.b, 1)"
    "naturalnumbers.below(ieee754_domain.b)"))
  (smax_TCC1-1 nil 3763809037 ("" (tcc)) nil nil
   (smax subtype "(number_fields.-)(ieee754_domain.b, 1)"
    "naturalnumbers.below(ieee754_domain.b)")))
 (smin_TCC1 0
  (smin_TCC1-1 nil 3764674754
   ("" (skeep :preds? t) (("" (typepred "b") (("" (assert) nil nil)) nil))
    nil)
   ((b formal-const-decl "above(1)" ieee754_domain nil)
    (above nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil (smin subtype "1" "naturalnumbers.below(ieee754_domain.b)")))
 (smin_TCC2 0
  (smin_TCC2-1 nil 3764674754 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (p formal-const-decl "above(1)" ieee754_domain nil)
    (below type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil (smin subtype "0" "naturalnumbers.below(ieee754_domain.b)")))
 (szero_TCC1 0
  (szero_TCC1-1 nil 3764936123 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (p formal-const-decl "above(1)" ieee754_domain nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil (szero subtype "0" "naturalnumbers.below(ieee754_domain.b)")))
 (smax_is_max 0
  (smax_is_max-1 nil 3764935833
   ("" (skeep :preds? t)
    (("" (expand "<=")
      (("" (skeep :preds? t)
        (("" (expand "smax") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((<= const-decl "bool" ieee754_domain nil)
    (smax const-decl "significand" ieee754_domain nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (smin_is_min 0
  (smin_is_min-1 nil 3764935889
   ("" (skeep :preds? t)
    (("" (case "EXISTS (k: below(p)): NOT m(k) = 0")
      (("1" (hide 1)
        (("1" (skeep -1 :preds? t)
          (("1" (expand "<=")
            (("1" (skeep 2 :preds? t)
              (("1" (expand "smin")
                (("1" (lift-if 2)
                  (("1" (split 2)
                    (("1" (flatten)
                      (("1" (case "k < i")
                        (("1" (inst -4 "k") (("1" (assert) nil nil)) nil)
                         ("2" (case "k=i")
                          (("1" (assert) nil nil) ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten) (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (apply-extensionality 2)
        (("2" (inst? 2)
          (("2" (assert) (("2" (expand "szero") (("2" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((<= const-decl "bool" ieee754_domain nil)
    (smin const-decl "significand" ieee754_domain nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (k skolem-const-decl "below(p)" ieee754_domain nil)
    (m skolem-const-decl "{m: significand | NOT m = szero}" ieee754_domain
     nil)
    (i skolem-const-decl
       "{i: below(p) | FORALL (j: below(i)): smin(j) = m(j)}" ieee754_domain
       nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (p formal-const-decl "above(1)" ieee754_domain nil)
    (below type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (b formal-const-decl "above(1)" ieee754_domain nil)
    (significand type-eq-decl nil ieee754_domain nil)
    (szero const-decl "significand" ieee754_domain nil))
   shostak))
 (IMP_sigma_TCC1 0
  (IMP_sigma_TCC1-1 nil 3765440807 ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (integer nonempty-type-from-decl nil integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (IMP_sigma assuming "reals@sigma[nat].sigma"
    "connected_domain: ASSUMPTION (FORALL (x, y: sigma.T), (z: integers.integer): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), sigma.T_pred(z)))")))
 (value_TCC1 0
  (value_TCC1-2 "" 3790102420 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (emin const-decl "negint" ieee754_domain nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (emax formal-const-decl "above(1)" ieee754_domain nil)
    (exponent type-eq-decl nil ieee754_domain nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (/= const-decl "boolean" notequal nil))
   shostak
   (value subtype "ieee754_domain.e"
    "{i: integers.int | booleans.OR(ieee754_domain.b /= 0, reals.>=(i, 0))}"))
  (value_TCC1-1 nil 3763809037 ("" (tcc)) nil nil
   (value subtype "ieee754_domain.e"
    "{i: integers.int | booleans.OR(ieee754_domain.b /= 0, reals.>=(i, 0))}")))
 (value_TCC2 0
  (value_TCC2-1 nil 3765440807 ("" (subtype-tcc) nil nil) nil nil
   (value subtype "0" "T_low[nat]")))
 (value_TCC3 0
  (value_TCC3-2 "" 3790102422 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (emin const-decl "negint" ieee754_domain nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (emax formal-const-decl "above(1)" ieee754_domain nil)
    (exponent type-eq-decl nil ieee754_domain nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   shostak
   (value subtype "(number_fields.-)(ieee754_domain.p, 1)" "T_high[nat]"))
  (value_TCC3-1 nil 3763809037 ("" (tcc)) nil nil
   (value subtype "(number_fields.-)(ieee754_domain.p, 1)" "T_high[nat]")))
 (value_TCC4 0
  (value_TCC4-2 "" 3790102422 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (emin const-decl "negint" ieee754_domain nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (emax formal-const-decl "above(1)" ieee754_domain nil)
    (exponent type-eq-decl nil ieee754_domain nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (/= const-decl "boolean" notequal nil))
   shostak
   (value subtype "((number_fields.-)(ieee754_domain.i))"
    "{i: integers.int | booleans.OR(ieee754_domain.b /= 0, reals.>=(i, 0))}"))
  (value_TCC4-1 nil 3763809037 ("" (tcc)) nil nil
   (value subtype "((number_fields.-)(ieee754_domain.i))"
    "{i: integers.int | booleans.OR(ieee754_domain.b /= 0, reals.>=(i, 0))}")))
 (significand_zero_value_zero 0
  (significand_zero_value_zero-1 nil 3764936883
   ("" (skeep :preds? t)
    (("" (expand "value")
      (("" (replace -4 :hide? t)
        ((""
          (case "sigma(0, p - 1, LAMBDA (i: nat): IF i<p THEN szero(i) * b ^ (-i) ELSE 0 ENDIF) = 0")
          (("1" (assert) nil nil)
           ("2" (hide 2)
            (("2" (use "sigma_zero")
              (("2" (lemma "sigma_eq")
                (("2"
                  (inst -1 "LAMBDA (i: nat): 0" "LAMBDA (i: nat):
              IF i < p THEN szero(i) * b ^ (-i) ELSE 0 ENDIF" "p-1" "0")
                  (("1" (assert)
                    (("1" (hide-all-but 1)
                      (("1" (skeep :preds? t)
                        (("1" (expand "szero") (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (skeep)
                    (("2" (typepred "b") (("2" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((value const-decl "real" ieee754_domain nil)
    (sigma_eq formula-decl nil sigma reals)
    (sigma_nat application-judgement "nat" ieee754_domain nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigma_zero formula-decl nil sigma reals)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (rat_exp application-judgement "rat" exponentiation nil)
    (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (sigma_rat application-judgement "rational" ieee754_domain nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil) (T_low type-eq-decl nil sigma reals)
    (T_high type-eq-decl nil sigma reals) (sigma def-decl "real" sigma reals)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (p formal-const-decl "above(1)" ieee754_domain nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (< const-decl "bool" reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (b formal-const-decl "above(1)" ieee754_domain nil)
    (significand type-eq-decl nil ieee754_domain nil)
    (szero const-decl "significand" ieee754_domain nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (- const-decl "[numfield -> numfield]" number_fields nil))
   shostak))
 (significand_le_value_le_TCC1 0
  (significand_le_value_le_TCC3-1 nil 3764944735 ("" (subtype-tcc) nil nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (<= const-decl "bool" ieee754_domain nil)
    (/= const-decl "boolean" notequal nil))
   nil
   (significand_le_value_le subtype "((number_fields.-)(ieee754_domain.i))"
    "{i: integers.int | booleans.OR(ieee754_domain.b /= 0, reals.>=(i, 0))}")))
 (significand_le_value_le 0
  (significand_le_value_le-2 "" 3790102429
   ("" (skeep)
    (("" (case "m1 = m2")
      (("1" (replace -1 :hide? t)
        (("1" (hide -1) (("1" (assert) nil nil)) nil)) nil)
       ("2" (use "significand_lt_first_discrepancy")
        (("2" (assert)
          (("2" (skeep :preds? t)
            (("2"
              (with-tccs
               (case "sigma(0, p - 1, LAMBDA (i: nat): IF i<p THEN m1(i) * b ^ (-i) ELSE 0 ENDIF) = sigma(0, k - 1, LAMBDA (i: nat): IF i<p THEN m1(i) * b ^ (-i) ELSE 0 ENDIF) + m1(k) * b^(-k) + sigma(k+1, p - 1, LAMBDA (i: nat): IF i<p THEN m1(i) * b ^ (-i) ELSE 0 ENDIF)"))
              (("1"
                (with-tccs
                 (case "sigma(0, p - 1, LAMBDA (i: nat): IF i<p THEN m2(i) * b ^ (-i) ELSE 0 ENDIF) =
                               sigma(0, k - 1, LAMBDA (i: nat): IF i<p THEN m2(i) * b ^ (-i) ELSE 0 ENDIF) +
                                m2(k) * b ^ (-k)
                                + sigma(k + 1, p - 1, LAMBDA (i: nat): IF i<p THEN m2(i) * b ^ (-i) ELSE 0 ENDIF)"))
                (("1" (replace -1 :hide? t)
                  (("1" (replace -1 :hide? t)
                    (("1"
                      (case "sigma(0, k - 1, LAMBDA (i: nat): IF i<p THEN m1(i) * b ^ (-i)  ELSE 0 ENDIF) = sigma(0, k - 1, LAMBDA (i: nat): IF i<p THEN m2(i) * b ^ (-i)  ELSE 0 ENDIF)")
                      (("1" (replace -1 :hide? t)
                        (("1"
                          (case "m1(k) * b ^ (-k)
                                     + sigma(k + 1, p - 1, LAMBDA (i: nat):  IF i<p THEN m1(i) * b ^ (-i) ELSE 0 ENDIF)
                                     <=
                                      m2(k) * b ^ (-k)
                                      + sigma(k + 1, p - 1, LAMBDA (i: nat): IF i<p THEN m2(i) * b ^ (-i) ELSE 0 ENDIF)")
                          (("1" (assert) nil nil)
                           ("2" (hide 3)
                            (("2"
                              (case "m1(k) * b ^ (-k) +
                                         sigma(k + 1, p - 1, LAMBDA (i: nat): IF i<p THEN m1(i) * b ^ (-i) ELSE 0 ENDIF) <= m1(k) * b ^ (-k) + (b-1) *
                                         sigma(k + 1, p - 1, LAMBDA (i: nat): b ^ (-i))")
                              (("1"
                                (case "m2(k) * b ^ (-k)  <= m2(k) * b ^ (-k) +
                                              sigma(k + 1, p - 1, LAMBDA (i: nat): IF i<p THEN m2(i) * b ^ (-i) ELSE 0 ENDIF)")
                                (("1"
                                  (case " m1(k) * b ^ (-k) +
                                                  (b - 1) * sigma(k + 1, p - 1, LAMBDA (i: nat): b ^ (-i)) <= m2(k) * b ^ (-k)")
                                  (("1" (assert) nil nil)
                                   ("2" (hide 2)
                                    (("2" (hide -1 -2)
                                      (("2"
                                        (case "k+1 > p-1")
                                        (("1"
                                          (expand "sigma")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (mult-by -4 "b ^ (-k)")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (lemma "sigma_geometric")
                                          (("2"
                                            (inst -1 "p-1" "k+1" "1/b")
                                            (("2"
                                              (split -1)
                                              (("1"
                                                (case
                                                 "sigma(k + 1, p - 1, LAMBDA (k: nat): (1 / b) ^ k) = sigma(k + 1, p - 1, LAMBDA (i: nat): b ^ (-i))")
                                                (("1"
                                                  (replace -1 :hide? t)
                                                  (("1"
                                                    (replace -1 :hide? t)
                                                    (("1"
                                                      (case
                                                       "(1 - 1 / b) = (b-1)/b")
                                                      (("1"
                                                        (replace -1 :hide? t)
                                                        (("1"
                                                          (case
                                                           "(b - 1) *
                                       (((1 / b) ^ (k + 1) - (1 / b) ^ (p - 1 + 1)) / ((b - 1) / b)) = b *
                                       (((1 / b) ^ (k + 1) - (1 / b) ^ (p - 1 + 1)))")
                                                          (("1"
                                                            (replace
                                                             -1
                                                             :hide?
                                                             t)
                                                            (("1"
                                                              (grind-reals)
                                                              (("1"
                                                                (case
                                                                 "((1 / b) ^ (1 + k)) * b = b ^ (-k)")
                                                                (("1"
                                                                  (replace
                                                                   -1
                                                                   :hide?
                                                                   t)
                                                                  (("1"
                                                                    (case
                                                                     "m1(k) * b ^ (-k) + b ^ (-k) = (m1(k)+1) * b ^ (-k)")
                                                                    (("1"
                                                                      (replace
                                                                       -1
                                                                       :hide?
                                                                       t)
                                                                      (("1"
                                                                        (case
                                                                         "m1(k)+1 <= m2(k)")
                                                                        (("1"
                                                                          (mult-by
                                                                           -1
                                                                           "b ^ (-k)")
                                                                          (("1"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (rewrite
                                                                   "div_expt"
                                                                   1)
                                                                  (("2"
                                                                    (assert)
                                                                    (("2"
                                                                      (rewrite
                                                                       "expt_plus"
                                                                       1
                                                                       :dir
                                                                       rl)
                                                                      (("2"
                                                                        (rewrite
                                                                         "expt_1i"
                                                                         1)
                                                                        (("2"
                                                                          (case
                                                                           "1 + (-k) + k = 1")
                                                                          (("1"
                                                                            (replace
                                                                             -1
                                                                             :hide?
                                                                             t)
                                                                            (("1"
                                                                              (use
                                                                               "expt_x1")
                                                                              (("1"
                                                                                (assert)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (name-replace
                                                             "bla"
                                                             "((1 / b) ^ (k + 1) - (1 / b) ^ (p - 1 + 1))")
                                                            (("2"
                                                              (name-replace
                                                               "ble"
                                                               "b-1")
                                                              (("2"
                                                                (grind-reals)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2" (assert) nil nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (case
                                                   "FORALL(n:nat,m:upfrom(n) | m < p) : sigma(n, m, LAMBDA (k: nat): (1 / b) ^ k) = sigma(n, m, LAMBDA (i: nat): b ^ (-i))")
                                                  (("1"
                                                    (inst? -1)
                                                    (("1" (assert) nil nil))
                                                    nil)
                                                   ("2"
                                                    (hide-all-but 1)
                                                    (("2"
                                                      (skeep :preds? t)
                                                      (("2"
                                                        (generalize
                                                         "m"
                                                         "m_"
                                                         "nat"
                                                         (1 -2 -3))
                                                        (("1"
                                                          (with-tccs
                                                           (induct "m_"))
                                                          (("1"
                                                            (flatten)
                                                            (("1"
                                                              (expand "sigma")
                                                              (("1"
                                                                (assert)
                                                                (("1"
                                                                  (expand
                                                                   "sigma")
                                                                  (("1"
                                                                    (assert)
                                                                    (("1"
                                                                      (use
                                                                       "expt_x0")
                                                                      (("1"
                                                                        (replace
                                                                         -1
                                                                         :hide?
                                                                         t)
                                                                        (("1"
                                                                          (use
                                                                           "expt_x0")
                                                                          (("1"
                                                                            (replace
                                                                             -1
                                                                             :hide?
                                                                             t)
                                                                            (("1"
                                                                              (propax)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (skeep)
                                                            (("2"
                                                              (expand
                                                               "sigma"
                                                               1)
                                                              (("2"
                                                                (lift-if 1)
                                                                (("2"
                                                                  (split 1)
                                                                  (("1"
                                                                    (propax)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (assert)
                                                                      (("2"
                                                                        (split
                                                                         -1)
                                                                        (("1"
                                                                          (replace
                                                                           -1
                                                                           :hide?
                                                                           t)
                                                                          (("1"
                                                                            (assert)
                                                                            (("1"
                                                                              (rewrite
                                                                               "expt_inverse")
                                                                              (("1"
                                                                                (rewrite
                                                                                 "div_expt"
                                                                                 2)
                                                                                (("1"
                                                                                  (rewrite
                                                                                   "expt_1i"
                                                                                   2)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (case
                                                                           "j=n-1")
                                                                          (("1"
                                                                            (replace
                                                                             -1
                                                                             :hide?
                                                                             t)
                                                                            (("1"
                                                                              (expand
                                                                               "sigma")
                                                                              (("1"
                                                                                (assert)
                                                                                (("1"
                                                                                  (rewrite
                                                                                   "expt_inverse")
                                                                                  (("1"
                                                                                    (rewrite
                                                                                     "div_expt"
                                                                                     3)
                                                                                    (("1"
                                                                                      (rewrite
                                                                                       "expt_1i"
                                                                                       3)
                                                                                      nil
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (typepred "b")
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (typepred "b")
                                                          (("3"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("3"
                                                    (typepred "b")
                                                    (("3" (assert) nil nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2" (assert) nil nil)
                                               ("3" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (hide -1 2)
                                  (("2"
                                    (case "0 <= sigma(k + 1, p - 1, LAMBDA (i: nat): IF i<p THEN m2(i) * b ^ (-i) ELSE 0 ENDIF)")
                                    (("1" (assert) nil nil)
                                     ("2" (use "sigma_Fnnr")
                                      (("1"
                                        (expand ">=")
                                        (("1" (assert) nil nil))
                                        nil)
                                       ("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (hide 2)
                                (("2"
                                  (case "sigma(k + 1, p - 1, LAMBDA (i: nat): IF i<p THEN m1(i) * b ^ (-i) ELSE 0 ENDIF) <= (b - 1) * sigma(k + 1, p - 1, LAMBDA (i: nat): b ^ (-i))")
                                  (("1" (assert) nil nil)
                                   ("2" (hide 2)
                                    (("2" (use "sigma_scal[nat]")
                                      (("1"
                                        (replace -1 :hide? t :dir rl)
                                        (("1"
                                          (with-tccs (use "sigma_le[nat]"))
                                          (("1"
                                            (assert)
                                            (("1"
                                              (hide 2)
                                              (("1"
                                                (skeep)
                                                (("1"
                                                  (case "m1(n) <= b-1")
                                                  (("1"
                                                    (mult-by -1 "b ^ (-n)")
                                                    (("1" (assert) nil nil))
                                                    nil)
                                                   ("2" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (typepred "b")
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("3" (typepred "b") (("3" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide 3)
                        (("2" (with-tccs (use "sigma_eq[nat]"))
                          (("2" (split -1)
                            (("1" (propax) nil nil)
                             ("2" (skeep 1)
                              (("2" (inst -2 "n") (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (typepred "b") (("3" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide 3)
                  (("2" (lemma "sigma_split[nat]")
                    (("2"
                      (inst -1
                       "LAMBDA (i: nat): IF i<p THEN m2(i) * b ^ (-i) ELSE 0 ENDIF"
                       "p-1" "0" "k-1")
                      (("1" (hide -2)
                        (("1" (assert)
                          (("1" (replace -1 :hide? t)
                            (("1" (assert)
                              (("1" (lemma "sigma_split[nat]")
                                (("1"
                                  (inst -1
                                   "LAMBDA (i: nat): IF i<p THEN m2(i) * b ^ (-i) ELSE 0 ENDIF"
                                   "p-1" "k" "k")
                                  (("1" (assert)
                                    (("1" (replace -1 :hide? t)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (expand "sigma")
                                          (("1"
                                            (expand "sigma")
                                            (("1" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (typepred "b") (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 3)
                (("2" (lemma "sigma_split[nat]")
                  (("2"
                    (inst -1
                     "LAMBDA (i: nat): IF i<p THEN m1(i) * b ^ (-i) ELSE 0 ENDIF"
                     "p-1" "0" "k-1")
                    (("1" (assert)
                      (("1" (replace -1 :hide? t)
                        (("1" (assert)
                          (("1" (lemma "sigma_split[nat]")
                            (("1"
                              (inst -1
                               "LAMBDA (i: nat): IF i<p THEN m1(i) * b ^ (-i) ELSE 0 ENDIF"
                               "p-1" "k" "k")
                              (("1" (assert)
                                (("1" (replace -1 :hide? t)
                                  (("1" (assert)
                                    (("1" (expand "sigma")
                                      (("1"
                                        (expand "sigma")
                                        (("1" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (typepred "b") (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((significand_lt_first_discrepancy formula-decl nil ieee754_domain nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sigma def-decl "real" sigma reals) (T_high type-eq-decl nil sigma reals)
    (T_low type-eq-decl nil sigma reals) (<= const-decl "bool" reals nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (rat_plus_rat_is_rat application-judgement "rat" rationals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (sigma_nnreal application-judgement "nnreal" ieee754_domain nil)
    (nnrat_plus_nnrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (both_sides_times_pos_lt1 formula-decl nil real_props nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (div_expt formula-decl nil exponentiation nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (expt_plus formula-decl nil exponentiation nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers nil)
    (expt_x1 formula-decl nil exponentiation nil)
    (expt_1i formula-decl nil exponentiation nil)
    (div_cancel3 formula-decl nil real_props nil)
    (times_div2 formula-decl nil real_props nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil)
    (posrat_plus_nnrat_is_posrat application-judgement "posrat" rationals nil)
    (nnrat_plus_posrat_is_posrat application-judgement "posrat" rationals nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat" rationals
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (k skolem-const-decl "below(p)" ieee754_domain nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (n skolem-const-decl "nat" ieee754_domain nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (expt_inverse formula-decl nil exponentiation nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (sigma_geometric formula-decl nil sigma_nat reals)
    (sigma_Fnnr formula-decl nil sigma reals)
    (sigma_scal formula-decl nil sigma reals)
    (sigma_le formula-decl nil sigma reals)
    (subrange type-eq-decl nil integers nil)
    (sigma_eq formula-decl nil sigma reals)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (sigma_split formula-decl nil sigma reals)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (sigma_rat application-judgement "rational" ieee754_domain nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (p formal-const-decl "above(1)" ieee754_domain nil)
    (below type-eq-decl nil naturalnumbers nil)
    (b formal-const-decl "above(1)" ieee754_domain nil)
    (significand type-eq-decl nil ieee754_domain nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   shostak)
  (significand_le_value_le-1 nil 3764945183
   ("" (skeep)
    (("" (case "m1 = m2")
      (("1" (replace -1 :hide? t)
        (("1" (hide -1) (("1" (assert) nil nil)) nil)) nil)
       ("2" (use "significand_lt_first_discrepancy")
        (("2" (assert)
          (("2" (skeep :preds? t)
            (("2"
              (with-tccs
               (case "sigma(0, p - 1, LAMBDA (i: nat): IF i<p THEN m1(i) * b ^ (-i) ELSE 0 ENDIF) = sigma(0, k - 1, LAMBDA (i: nat): IF i<p THEN m1(i) * b ^ (-i) ELSE 0 ENDIF) + m1(k) * b^(-k) + sigma(k+1, p - 1, LAMBDA (i: nat): IF i<p THEN m1(i) * b ^ (-i) ELSE 0 ENDIF)"))
              (("1"
                (with-tccs
                 (case "sigma(0, p - 1, LAMBDA (i: nat): IF i<p THEN m2(i) * b ^ (-i) ELSE 0 ENDIF) =
                               sigma(0, k - 1, LAMBDA (i: nat): IF i<p THEN m2(i) * b ^ (-i) ELSE 0 ENDIF) +
                                m2(k) * b ^ (-k)
                                + sigma(k + 1, p - 1, LAMBDA (i: nat): IF i<p THEN m2(i) * b ^ (-i) ELSE 0 ENDIF)"))
                (("1" (replace -1 :hide? t)
                  (("1" (replace -1 :hide? t)
                    (("1"
                      (case "sigma(0, k - 1, LAMBDA (i: nat): IF i<p THEN m1(i) * b ^ (-i)  ELSE 0 ENDIF) = sigma(0, k - 1, LAMBDA (i: nat): IF i<p THEN m2(i) * b ^ (-i)  ELSE 0 ENDIF)")
                      (("1" (replace -1 :hide? t)
                        (("1"
                          (case "m1(k) * b ^ (-k)
                                     + sigma(k + 1, p - 1, LAMBDA (i: nat):  IF i<p THEN m1(i) * b ^ (-i) ELSE 0 ENDIF)
                                     <=
                                      m2(k) * b ^ (-k)
                                      + sigma(k + 1, p - 1, LAMBDA (i: nat): IF i<p THEN m2(i) * b ^ (-i) ELSE 0 ENDIF)")
                          (("1" (assert) nil nil)
                           ("2" (hide 3)
                            (("2"
                              (case "m1(k) * b ^ (-k) +
                                         sigma(k + 1, p - 1, LAMBDA (i: nat): IF i<p THEN m1(i) * b ^ (-i) ELSE 0 ENDIF) <= m1(k) * b ^ (-k) + (b-1) *
                                         sigma(k + 1, p - 1, LAMBDA (i: nat): b ^ (-i))")
                              (("1"
                                (case "m2(k) * b ^ (-k)  <= m2(k) * b ^ (-k) +
                                              sigma(k + 1, p - 1, LAMBDA (i: nat): IF i<p THEN m2(i) * b ^ (-i) ELSE 0 ENDIF)")
                                (("1"
                                  (case " m1(k) * b ^ (-k) +
                                                  (b - 1) * sigma(k + 1, p - 1, LAMBDA (i: nat): b ^ (-i)) <= m2(k) * b ^ (-k)")
                                  (("1" (assert) nil nil)
                                   ("2" (hide 2)
                                    (("2" (hide -1 -2)
                                      (("2"
                                        (case "k+1 > p-1")
                                        (("1"
                                          (expand "sigma")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (mult-by -4 "b ^ (-k)")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (lemma "sigma_geometric")
                                          (("2"
                                            (inst -1 "p-1" "k+1" "1/b")
                                            (("2"
                                              (split -1)
                                              (("1"
                                                (case
                                                 "sigma(k + 1, p - 1, LAMBDA (k: nat): (1 / b) ^ k) = sigma(k + 1, p - 1, LAMBDA (i: nat): b ^ (-i))")
                                                (("1"
                                                  (replace -1 :hide? t)
                                                  (("1"
                                                    (replace -1 :hide? t)
                                                    (("1"
                                                      (case
                                                       "(1 - 1 / b) = (b-1)/b")
                                                      (("1"
                                                        (replace -1 :hide? t)
                                                        (("1"
                                                          (case
                                                           "(b - 1) *
                                       (((1 / b) ^ (k + 1) - (1 / b) ^ (p - 1 + 1)) / ((b - 1) / b)) = b *
                                       (((1 / b) ^ (k + 1) - (1 / b) ^ (p - 1 + 1)))")
                                                          (("1"
                                                            (replace
                                                             -1
                                                             :hide?
                                                             t)
                                                            (("1"
                                                              (grind-reals)
                                                              (("1"
                                                                (case
                                                                 "((1 / b) ^ (1 + k)) * b = b ^ (-k)")
                                                                (("1"
                                                                  (replace
                                                                   -1
                                                                   :hide?
                                                                   t)
                                                                  (("1"
                                                                    (case
                                                                     "m1(k) * b ^ (-k) + b ^ (-k) = (m1(k)+1) * b ^ (-k)")
                                                                    (("1"
                                                                      (replace
                                                                       -1
                                                                       :hide?
                                                                       t)
                                                                      (("1"
                                                                        (case
                                                                         "m1(k)+1 <= m2(k)")
                                                                        (("1"
                                                                          (mult-by
                                                                           -1
                                                                           "b ^ (-k)")
                                                                          (("1"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (rewrite
                                                                   "div_expt"
                                                                   1)
                                                                  (("2"
                                                                    (assert)
                                                                    (("2"
                                                                      (rewrite
                                                                       "expt_plus"
                                                                       1
                                                                       :dir
                                                                       rl)
                                                                      (("2"
                                                                        (rewrite
                                                                         "expt_1i"
                                                                         1)
                                                                        (("2"
                                                                          (case
                                                                           "1 + (-k) + k = 1")
                                                                          (("1"
                                                                            (replace
                                                                             -1
                                                                             :hide?
                                                                             t)
                                                                            (("1"
                                                                              (use
                                                                               "expt_x1")
                                                                              (("1"
                                                                                (assert)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (name-replace
                                                             "bla"
                                                             "((1 / b) ^ (k + 1) - (1 / b) ^ (p - 1 + 1))")
                                                            (("2"
                                                              (name-replace
                                                               "ble"
                                                               "b-1")
                                                              (("2"
                                                                (grind-reals)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2" (assert) nil nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (case
                                                   "FORALL(n:nat,m:upfrom(n) | m < p) : sigma(n, m, LAMBDA (k: nat): (1 / b) ^ k) = sigma(n, m, LAMBDA (i: nat): b ^ (-i))")
                                                  (("1"
                                                    (inst? -1)
                                                    (("1" (assert) nil nil))
                                                    nil)
                                                   ("2"
                                                    (hide-all-but 1)
                                                    (("2"
                                                      (skeep :preds? t)
                                                      (("2"
                                                        (generalize
                                                         "m"
                                                         "m_"
                                                         "nat"
                                                         (1 -2 -3))
                                                        (("1"
                                                          (with-tccs
                                                           (induct "m_"))
                                                          (("1"
                                                            (flatten)
                                                            (("1"
                                                              (expand "sigma")
                                                              (("1"
                                                                (assert)
                                                                (("1"
                                                                  (expand
                                                                   "sigma")
                                                                  (("1"
                                                                    (assert)
                                                                    (("1"
                                                                      (use
                                                                       "expt_x0")
                                                                      (("1"
                                                                        (replace
                                                                         -1
                                                                         :hide?
                                                                         t)
                                                                        (("1"
                                                                          (use
                                                                           "expt_x0")
                                                                          (("1"
                                                                            (replace
                                                                             -1
                                                                             :hide?
                                                                             t)
                                                                            (("1"
                                                                              (propax)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (skeep)
                                                            (("2"
                                                              (expand
                                                               "sigma"
                                                               1)
                                                              (("2"
                                                                (lift-if 1)
                                                                (("2"
                                                                  (split 1)
                                                                  (("1"
                                                                    (propax)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (assert)
                                                                      (("2"
                                                                        (split
                                                                         -1)
                                                                        (("1"
                                                                          (replace
                                                                           -1
                                                                           :hide?
                                                                           t)
                                                                          (("1"
                                                                            (assert)
                                                                            (("1"
                                                                              (rewrite
                                                                               "expt_inverse")
                                                                              (("1"
                                                                                (rewrite
                                                                                 "div_expt"
                                                                                 2)
                                                                                (("1"
                                                                                  (rewrite
                                                                                   "expt_1i"
                                                                                   2)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (case
                                                                           "j=n-1")
                                                                          (("1"
                                                                            (replace
                                                                             -1
                                                                             :hide?
                                                                             t)
                                                                            (("1"
                                                                              (expand
                                                                               "sigma")
                                                                              (("1"
                                                                                (assert)
                                                                                (("1"
                                                                                  (rewrite
                                                                                   "expt_inverse")
                                                                                  (("1"
                                                                                    (rewrite
                                                                                     "div_expt"
                                                                                     3)
                                                                                    (("1"
                                                                                      (rewrite
                                                                                       "expt_1i"
                                                                                       3)
                                                                                      nil
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (typepred "b")
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (typepred "b")
                                                          (("3"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("3"
                                                    (typepred "b")
                                                    (("3" (assert) nil nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2" (assert) nil nil)
                                               ("3" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (hide -1 2)
                                  (("2"
                                    (case "0 <= sigma(k + 1, p - 1, LAMBDA (i: nat): IF i<p THEN m2(i) * b ^ (-i) ELSE 0 ENDIF)")
                                    (("1" (assert) nil nil)
                                     ("2" (use "sigma_Fnnr")
                                      (("1"
                                        (expand ">=")
                                        (("1" (assert) nil nil))
                                        nil)
                                       ("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (hide 2)
                                (("2"
                                  (case "sigma(k + 1, p - 1, LAMBDA (i: nat): IF i<p THEN m1(i) * b ^ (-i) ELSE 0 ENDIF) <= (b - 1) * sigma(k + 1, p - 1, LAMBDA (i: nat): b ^ (-i))")
                                  (("1" (assert) nil nil)
                                   ("2" (hide 2)
                                    (("2" (use "sigma_scal[nat]")
                                      (("1"
                                        (replace -1 :hide? t :dir rl)
                                        (("1"
                                          (with-tccs (use "sigma_le[nat]"))
                                          (("1"
                                            (assert)
                                            (("1"
                                              (hide 2)
                                              (("1"
                                                (skeep)
                                                (("1"
                                                  (case "m1(n) <= b-1")
                                                  (("1"
                                                    (mult-by -1 "b ^ (-n)")
                                                    (("1" (assert) nil nil))
                                                    nil)
                                                   ("2" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (typepred "b")
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("3" (typepred "b") (("3" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide 3)
                        (("2" (with-tccs (use "sigma_eq[nat]"))
                          (("2" (split -1)
                            (("1" (propax) nil nil)
                             ("2" (skeep 1)
                              (("2" (inst -2 "n") (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (typepred "b") (("3" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide 3)
                  (("2" (lemma "sigma_split[nat]")
                    (("2"
                      (inst -1
                       "LAMBDA (i: nat): IF i<p THEN m2(i) * b ^ (-i) ELSE 0 ENDIF"
                       "p-1" "0" "k-1")
                      (("1" (hide -2)
                        (("1" (assert)
                          (("1" (replace -1 :hide? t)
                            (("1" (assert)
                              (("1" (lemma "sigma_split[nat]")
                                (("1"
                                  (inst -1
                                   "LAMBDA (i: nat): IF i<p THEN m2(i) * b ^ (-i) ELSE 0 ENDIF"
                                   "p-1" "k" "k")
                                  (("1" (assert)
                                    (("1" (replace -1 :hide? t)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (expand "sigma")
                                          (("1"
                                            (expand "sigma")
                                            (("1" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (typepred "b") (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 3)
                (("2" (lemma "sigma_split[nat]")
                  (("2"
                    (inst -1
                     "LAMBDA (i: nat): IF i<p THEN m1(i) * b ^ (-i) ELSE 0 ENDIF"
                     "p-1" "0" "k-1")
                    (("1" (assert)
                      (("1" (replace -1 :hide? t)
                        (("1" (assert)
                          (("1" (lemma "sigma_split[nat]")
                            (("1"
                              (inst -1
                               "LAMBDA (i: nat): IF i<p THEN m1(i) * b ^ (-i) ELSE 0 ENDIF"
                               "p-1" "k" "k")
                              (("1" (assert)
                                (("1" (replace -1 :hide? t)
                                  (("1" (assert)
                                    (("1" (expand "sigma")
                                      (("1"
                                        (expand "sigma")
                                        (("1" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (typepred "b") (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("3" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sigma def-decl "real" sigma reals) (T_high type-eq-decl nil sigma reals)
    (T_low type-eq-decl nil sigma reals)
    (sigma_split formula-decl nil sigma reals)
    (sigma_Fnnr formula-decl nil sigma reals)
    (sigma_geometric formula-decl nil sigma_nat reals)
    (sigma_scal formula-decl nil sigma reals)
    (sigma_le formula-decl nil sigma reals)
    (sigma_eq formula-decl nil sigma reals))
   shostak))
 (value_monotonicity 0
  (value_monotonicity-1 nil 3764941524
   ("" (skeep :preds? t)
    (("" (split -7)
      (("1" (expand "value")
        (("1" (grind-reals)
          (("1" (case "(-1) ^ 0 = 1")
            (("1" (replace -1 :hide? t)
              (("1" (case "(-1) ^ 1 = -1")
                (("1" (replace -1 :hide? t)
                  (("1" (assert)
                    (("1" (invoke (name-replace "a__" "%1") (!! 1 1 2))
                      (("1" (invoke (name-replace "b__" "%1") (! 1 2))
                        (("1" (case "0<=a__")
                          (("1" (case "0<=b__")
                            (("1" (assert) nil nil)
                             ("2" (expand "b__")
                              (("2" (use "sigma_Fnnr")
                                (("2" (assert) nil nil)) nil))
                              nil))
                            nil)
                           ("2" (expand "a__")
                            (("2" (use "sigma_Fnnr") (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (eval-formula) nil nil))
                nil))
              nil)
             ("2" (eval-formula) nil nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (replace -1 :hide? t)
          (("2" (replace -1 :hide? t :dir rl)
            (("2" (expand "value")
              (("2" (case "(-1) ^ 0 = 1")
                (("1" (replace -1 :hide? t)
                  (("1" (assert)
                    (("1" (invoke (name-replace "a__" "%1") (! 1 1 1))
                      (("1" (invoke (name-replace "b__" "%1") (! 1 1 2))
                        (("1" (invoke (name-replace "c__" "%1") (! 1 2 1))
                          (("1" (invoke (name-replace "d__" "%1") (! 1 2 2))
                            (("1" (case "a__ <= c__")
                              (("1" (case "b__ <= d__")
                                (("1" (case "a__ * b__ <= c__* b__ ")
                                  (("1" (case "c__* b__ <= c__ * d__")
                                    (("1" (assert) nil nil)
                                     ("2" (grind-reals) nil nil))
                                    nil)
                                   ("2" (hide-all-but (1 -2))
                                    (("2" (use "both_sides_times_pos_le1_imp")
                                      (("1" (assert) nil nil)
                                       ("2"
                                        (expand "b__")
                                        (("2"
                                          (hide-all-but 1)
                                          (("2"
                                            (expand ">=")
                                            (("2"
                                              (use "sigma_Fnnr")
                                              (("2"
                                                (expand ">=")
                                                (("2" (propax) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (hide 2)
                                  (("2" (expand "b__")
                                    (("2" (expand "d__")
                                      (("2"
                                        (use "significand_le_value_le")
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (hide 2)
                                (("2" (expand "a__")
                                  (("2" (expand "c__")
                                    (("2" (rewrite "both_sides_expt_gt1_le")
                                      nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (eval-formula) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (flatten)
        (("3" (replace -2 :hide? t)
          (("3" (replace -1 :hide? t)
            (("3" (expand "value")
              (("3" (case "(-1) ^ 1 = -1")
                (("1" (replace -1 :hide? t)
                  (("1" (assert)
                    (("1" (mult-by 1 "-1" "-")
                      (("1" (split 1)
                        (("1" (flatten) (("1" (assert) nil nil)) nil)
                         ("2" (flatten)
                          (("2" (assert)
                            (("2" (invoke (name-replace "a__" "%1") (! 2 1 1))
                              (("2"
                                (invoke (name-replace "b__" "%1") (! 2 1 2))
                                (("2"
                                  (invoke (name-replace "c__" "%1") (! 2 2 1))
                                  (("2"
                                    (invoke (name-replace "d__" "%1")
                                     (! 2 2 2))
                                    (("2" (case "a__ <= c__")
                                      (("1"
                                        (case "b__ <= d__")
                                        (("1"
                                          (case "a__ * b__ <= c__* b__ ")
                                          (("1"
                                            (case "c__* b__ <= c__ * d__")
                                            (("1" (assert) nil nil)
                                             ("2" (grind-reals) nil nil))
                                            nil)
                                           ("2"
                                            (hide-all-but (1 -2))
                                            (("2"
                                              (use
                                               "both_sides_times_pos_le1_imp")
                                              (("1" (assert) nil nil)
                                               ("2"
                                                (expand "b__")
                                                (("2"
                                                  (use "sigma_Fnnr")
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (hide 2 3)
                                          (("2"
                                            (expand "b__")
                                            (("2"
                                              (expand "d__")
                                              (("2"
                                                (use
                                                 "significand_le_value_le")
                                                (("2" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (expand "a__")
                                        (("2"
                                          (expand "c__")
                                          (("2"
                                            (rewrite "both_sides_expt_gt1_le")
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide-all-but 1)
                  (("2" (expand "^")
                    (("2" (expand "expt")
                      (("2" (expand "expt") (("2" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((expt def-decl "real" exponentiation nil)
    (both_sides_times_pos_neg_le1 formula-decl nil extra_real_props nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (b__ skolem-const-decl "rational" ieee754_domain nil)
    (d__ skolem-const-decl "rational" ieee754_domain nil)
    (c__ skolem-const-decl "posrat" ieee754_domain nil)
    (a__ skolem-const-decl "posrat" ieee754_domain nil)
    (nonneg_rat nonempty-type-eq-decl nil rationals nil)
    (posrat nonempty-type-eq-decl nil rationals nil)
    (c__ skolem-const-decl "posrat" ieee754_domain nil)
    (both_sides_expt_gt1_le formula-decl nil exponentiation nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (a__ skolem-const-decl "posrat" ieee754_domain nil)
    (d__ skolem-const-decl "rational" ieee754_domain nil)
    (significand_le_value_le formula-decl nil ieee754_domain nil)
    (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil)
    (b__ skolem-const-decl "rational" ieee754_domain nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (both_sides_times_pos_le2 formula-decl nil real_props nil)
    (value const-decl "real" ieee754_domain nil)
    (sigma_Fnnr formula-decl nil sigma reals)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (pos_times_le formula-decl nil real_props nil)
    (b__ skolem-const-decl "rat" ieee754_domain nil)
    (a__ skolem-const-decl "rat" ieee754_domain nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (b formal-const-decl "above(1)" ieee754_domain nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (emin const-decl "negint" ieee754_domain nil)
    (emax formal-const-decl "above(1)" ieee754_domain nil)
    (exponent type-eq-decl nil ieee754_domain nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals)
    (sigma def-decl "real" sigma reals)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (p formal-const-decl "above(1)" ieee754_domain nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (below type-eq-decl nil naturalnumbers nil)
    (significand type-eq-decl nil ieee754_domain nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat" rationals
     nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real nonempty-type-from-decl nil reals nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil)
    (^ const-decl "real" exponentiation nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (int_exp application-judgement "int" exponentiation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (sigma_rat application-judgement "rational" ieee754_domain nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (rat_exp application-judgement "rat" exponentiation nil)
    (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (exactly_representable_symm_0 0
  (exactly_representable_symm_0-1 nil 3764933125
   ("" (skeep)
    (("" (expand "exactly_representable?")
      (("" (iff)
        (("" (split 1)
          (("1" (flatten)
            (("1" (skeep :preds? t)
              (("1" (split -1)
                (("1" (inst 1 "1" "e" "m")
                  (("1" (expand "value")
                    (("1" (replace -1 :hide? t)
                      (("1" (case "(-1) ^ 0 = 1")
                        (("1" (replace -1 :hide? t)
                          (("1" (case "(-1) ^ 1 = -1")
                            (("1" (replace -1 :hide? t)
                              (("1" (assert) nil nil)) nil)
                             ("2" (eval-formula) nil nil))
                            nil))
                          nil)
                         ("2" (eval-formula) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (inst 1 "0" "e" "m")
                  (("2" (expand "value")
                    (("2" (replace -1 :hide? t)
                      (("2" (case "(-1) ^ 0 = 1")
                        (("1" (case "(-1) ^ 1 = -1")
                          (("1" (replace -1 :hide? t)
                            (("1" (replace -1 :hide? t)
                              (("1" (assert) nil nil)) nil))
                            nil)
                           ("2" (eval-formula) nil nil))
                          nil)
                         ("2" (eval-formula) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (skeep :preds? t)
              (("2" (split -1)
                (("1" (replace -1 :hide? t)
                  (("1" (inst 1 "1" "e" "m")
                    (("1" (expand "value")
                      (("1" (case "(-1) ^ 1 = -1")
                        (("1" (case "(-1) ^ 0 = 1")
                          (("1" (replace -1 :hide? t)
                            (("1" (replace -1 :hide? t)
                              (("1" (assert) nil nil)) nil))
                            nil)
                           ("2" (eval-formula) nil nil))
                          nil)
                         ("2" (eval-formula) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (replace -1 :hide? t)
                  (("2" (inst 1 "0" "e" "m")
                    (("2" (expand "value")
                      (("2" (case "(-1) ^ 1 = -1")
                        (("1" (case "(-1) ^ 0 = 1")
                          (("1" (replace -1 :hide? t)
                            (("1" (replace -1 :hide? t)
                              (("1" (assert) nil nil)) nil))
                            nil)
                           ("2" (eval-formula) nil nil))
                          nil)
                         ("2" (eval-formula) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((exactly_representable? const-decl "bool" ieee754_domain nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (emin const-decl "negint" ieee754_domain nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (emax formal-const-decl "above(1)" ieee754_domain nil)
    (exponent type-eq-decl nil ieee754_domain nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (p formal-const-decl "above(1)" ieee754_domain nil)
    (below type-eq-decl nil naturalnumbers nil)
    (b formal-const-decl "above(1)" ieee754_domain nil)
    (significand type-eq-decl nil ieee754_domain nil)
    (rat_exp application-judgement "rat" exponentiation nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (sigma_rat application-judgement "rational" ieee754_domain nil)
    (int_exp application-judgement "int" exponentiation nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat" rationals
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (value const-decl "real" ieee754_domain nil))
   shostak))
 (er_real_value 0
  (er_real_value-1 nil 3763809763
   ("" (skeep)
    (("" (expand "exactly_representable?") (("" (inst?) nil nil)) nil)) nil)
   ((exactly_representable? const-decl "bool" ieee754_domain nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (emin const-decl "negint" ieee754_domain nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (emax formal-const-decl "above(1)" ieee754_domain nil)
    (exponent type-eq-decl nil ieee754_domain nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (p formal-const-decl "above(1)" ieee754_domain nil)
    (below type-eq-decl nil naturalnumbers nil)
    (b formal-const-decl "above(1)" ieee754_domain nil)
    (significand type-eq-decl nil ieee754_domain nil))
   shostak))
 (zero_is_er 0
  (zero_is_er-1 nil 3763809141
   ("" (case "0 < b")
    (("1" (expand "exactly_representable?")
      (("1" (inst 1 "0" "1" "LAMBDA(i:below(p)): 0")
        (("1" (expand "value")
          (("1"
            (case "(LAMBDA (i_1: nat): IF i_1 < p THEN 0 * b ^ (-i_1) ELSE 0 ENDIF) = LAMBDA (i_1: nat): 0 ")
            (("1" (replace -1 :hide? t)
              (("1" (rewrite "sigma_zero") (("1" (grind-reals) nil nil)) nil))
              nil)
             ("2" (hide 2)
              (("2" (apply-extensionality)
                (("2" (lift-if)
                  (("2" (split 1)
                    (("1" (flatten) (("1" (assert) nil nil)) nil)
                     ("2" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (assert) nil nil))
            nil))
          nil)
         ("2" (typepred "b")
          (("2" (typepred "p") (("2" (assert) nil nil)) nil)) nil)
         ("3" (typepred "b")
          (("3" (typepred "p")
            (("3" (typepred "emax") (("3" (ground) nil nil)) nil)) nil))
          nil))
        nil))
      nil)
     ("2" (assert) nil nil))
    nil)
   ((b formal-const-decl "above(1)" ieee754_domain nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (value const-decl "real" ieee754_domain nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (T_low type-eq-decl nil sigma reals)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (T_high type-eq-decl nil sigma reals)
    (sigma_zero formula-decl nil sigma reals)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_exp application-judgement "int" exponentiation nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil)
    (sigma_nat application-judgement "nat" ieee754_domain nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_times_even_is_even application-judgement "even_int" integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (sigma_rat application-judgement "rational" ieee754_domain nil)
    (significand type-eq-decl nil ieee754_domain nil)
    (exponent type-eq-decl nil ieee754_domain nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (p formal-const-decl "above(1)" ieee754_domain nil)
    (below type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (emin const-decl "negint" ieee754_domain nil)
    (emax formal-const-decl "above(1)" ieee754_domain nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (exactly_representable? const-decl "bool" ieee754_domain nil))
   nil))
 (er_real_TCC1 0
  (er_real_TCC1-2 nil 3763809197 ("" (assert) nil nil)
   ((zero_is_er formula-decl nil ieee754_domain nil)) shostak
   (er_real subtype "0" "er_real"))
  (er_real_TCC1-1 nil 3763809037 ("" (subtype-tcc) nil nil) nil nil
   (er_real subtype "0" "er_real")))
 (er_lb_TCC1 0
  (er_lb_TCC1-1 "" 3790102436 ("" (tcc) nil nil)
   ((emin const-decl "negint" ieee754_domain nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   shostak (er_lb subtype "ieee754_domain.emax" "exponent"))
  (er_lb_TCC2-1 nil 3763809037 ("" (tcc)) nil nil
   (er_lb subtype "ieee754_domain.emax" "exponent")))
 (er_lb_TCC2 0
  (er_lb_TCC1-1 nil 3763809037 ("" (assert) nil nil)
   ((er_real_value formula-decl nil ieee754_domain nil)) shostak
   (er_lb subtype
    "ieee754_domain.value(1, ieee754_domain.emax, ieee754_domain.smax)"
    "er_real")))
 (er_lower_bound 0
  (er_lower_bound-1 nil 3764934156
   ("" (skeep :preds? t)
    (("" (expand "exactly_representable?")
      (("" (skeep :preds? t)
        (("" (replace -4 :hide? t :dir rl)
          (("" (expand "er_lb")
            (("" (use "value_monotonicity")
              (("" (assert)
                (("" (flatten)
                  (("" (split -1)
                    (("1" (assert) nil nil)
                     ("2" (replace -1 :hide? t) (("2" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((exactly_representable? const-decl "bool" ieee754_domain nil)
    (value_monotonicity formula-decl nil ieee754_domain nil)
    (smax const-decl "significand" ieee754_domain nil)
    (significand type-eq-decl nil ieee754_domain nil)
    (b formal-const-decl "above(1)" ieee754_domain nil)
    (below type-eq-decl nil naturalnumbers nil)
    (p formal-const-decl "above(1)" ieee754_domain nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (exponent type-eq-decl nil ieee754_domain nil)
    (emax formal-const-decl "above(1)" ieee754_domain nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (emin const-decl "negint" ieee754_domain nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (smax_is_max formula-decl nil ieee754_domain nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (er_lb const-decl "er_real" ieee754_domain nil))
   shostak))
 (er_ub_TCC1 0
  (er_ub_TCC1-1 nil 3763809037 ("" (assert) nil nil)
   ((er_real_value formula-decl nil ieee754_domain nil)) shostak
   (er_ub subtype
    "ieee754_domain.value(0, ieee754_domain.emax, ieee754_domain.smax)"
    "er_real")))
 (er_upper_bound 0
  (er_upper_bound-1 nil 3764934933
   ("" (skeep :preds? t)
    (("" (expand "exactly_representable?")
      (("" (skeep :preds? t)
        (("" (replace -4 :hide? t :dir rl)
          (("" (expand "er_ub")
            (("" (use "value_monotonicity")
              (("" (assert)
                (("" (flatten)
                  (("" (split -1)
                    (("1" (replace -1 :hide? t) (("1" (propax) nil nil)) nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((exactly_representable? const-decl "bool" ieee754_domain nil)
    (value_monotonicity formula-decl nil ieee754_domain nil)
    (smax const-decl "significand" ieee754_domain nil)
    (significand type-eq-decl nil ieee754_domain nil)
    (b formal-const-decl "above(1)" ieee754_domain nil)
    (below type-eq-decl nil naturalnumbers nil)
    (p formal-const-decl "above(1)" ieee754_domain nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (exponent type-eq-decl nil ieee754_domain nil)
    (emax formal-const-decl "above(1)" ieee754_domain nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (emin const-decl "negint" ieee754_domain nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (smax_is_max formula-decl nil ieee754_domain nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (er_ub const-decl "er_real" ieee754_domain nil))
   shostak))
 (er_min_pos_TCC1 0
  (er_min_pos_TCC1-1 nil 3764932924 ("" (subtype-tcc) nil nil)
   ((emin const-decl "negint" ieee754_domain nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil (er_min_pos subtype "ieee754_domain.emin" "exponent")))
 (er_min_pos_TCC2 0
  (er_min_pos_TCC2-1 nil 3764932924 ("" (assert) nil nil)
   ((er_real_value formula-decl nil ieee754_domain nil)) nil
   (er_min_pos subtype
    "ieee754_domain.value(0, ieee754_domain.emin, ieee754_domain.smin)"
    "er_real")))
 (er_min_pos_prop 0
  (er_min_pos_prop-1 nil 3764935147
   ("" (skeep :preds? t)
    (("" (expand "exactly_representable?")
      (("" (skeep :preds? t)
        (("" (replace -4 :hide? t :dir rl)
          (("" (expand "er_min_pos")
            (("" (use "value_monotonicity")
              (("" (assert)
                (("" (split -1)
                  (("1" (assert)
                    (("1" (use "smin_is_min")
                      (("1" (use "significand_zero_value_zero")
                        (("1" (assert) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (replace -1 :hide? t)
                    (("2" (expand "value" -)
                      (("2" (case "(-1) ^ 1 = -1")
                        (("1" (replace -1 :hide? t)
                          (("1"
                            (case "0<= b ^ e *
        sigma(0, p - 1,
              LAMBDA (i: nat): IF i < p THEN m(i) * b ^ (-i) ELSE 0 ENDIF)")
                            (("1" (assert) nil nil)
                             ("2" (hide-all-but 1)
                              (("2" (case "0<=b^e")
                                (("1" (use "sigma_Fnnr")
                                  (("1" (expand ">=")
                                    (("1" (assert)
                                      (("1" (grind-reals) nil nil)) nil))
                                    nil)
                                   ("2" (typepred "b")
                                    (("2" (assert) nil nil)) nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil)
                             ("3" (typepred "b") (("3" (assert) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand "^")
                          (("2" (expand "expt")
                            (("2" (expand "expt") (("2" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((exactly_representable? const-decl "bool" ieee754_domain nil)
    (value_monotonicity formula-decl nil ieee754_domain nil)
    (smin const-decl "significand" ieee754_domain nil)
    (significand type-eq-decl nil ieee754_domain nil)
    (b formal-const-decl "above(1)" ieee754_domain nil)
    (below type-eq-decl nil naturalnumbers nil)
    (p formal-const-decl "above(1)" ieee754_domain nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (exponent type-eq-decl nil ieee754_domain nil)
    (emax formal-const-decl "above(1)" ieee754_domain nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (emin const-decl "negint" ieee754_domain nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (nzreal_expt application-judgement "nzreal" exponentiation nil)
    (int_expt application-judgement "int" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (sigma_rat application-judgement "rational" ieee754_domain nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals)
    (sigma def-decl "real" sigma reals)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pos_times_le formula-decl nil real_props nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (sigma_Fnnr formula-decl nil sigma reals)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (int_exp application-judgement "int" exponentiation nil)
    (value const-decl "real" ieee754_domain nil)
    (significand_zero_value_zero formula-decl nil ieee754_domain nil)
    (szero const-decl "significand" ieee754_domain nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (m skolem-const-decl "significand" ieee754_domain nil)
    (smin_is_min formula-decl nil ieee754_domain nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (er_min_pos const-decl "er_real" ieee754_domain nil))
   shostak))
 (er_max_neg_TCC1 0
  (er_max_neg_TCC1-1 nil 3764932924 ("" (assert) nil nil)
   ((er_real_value formula-decl nil ieee754_domain nil)) nil
   (er_max_neg subtype
    "ieee754_domain.value(1, ieee754_domain.emin, ieee754_domain.smin)"
    "er_real")))
 (er_max_neg_prop 0
  (er_max_neg_prop-1 nil 3764935333
   ("" (skeep :preds? t)
    (("" (expand "exactly_representable?")
      (("" (skeep :preds? t)
        (("" (replace -4 :hide? t :dir rl)
          (("" (expand "er_max_neg")
            (("" (use "value_monotonicity")
              (("" (assert)
                (("" (split -1)
                  (("1" (replace -1 :hide? t)
                    (("1" (expand "value" -)
                      (("1" (case "(-1) ^ 0 = 1")
                        (("1" (replace -1 :hide? t)
                          (("1" (hide-all-but -3)
                            (("1" (assert)
                              (("1" (use "sigma_Fnnr")
                                (("1" (grind-reals) nil nil)) nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand "^")
                          (("2" (expand "expt") (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert)
                    (("2" (use "smin_is_min")
                      (("2" (use "significand_zero_value_zero")
                        (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((exactly_representable? const-decl "bool" ieee754_domain nil)
    (value_monotonicity formula-decl nil ieee754_domain nil)
    (smin const-decl "significand" ieee754_domain nil)
    (significand type-eq-decl nil ieee754_domain nil)
    (b formal-const-decl "above(1)" ieee754_domain nil)
    (below type-eq-decl nil naturalnumbers nil)
    (p formal-const-decl "above(1)" ieee754_domain nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (exponent type-eq-decl nil ieee754_domain nil)
    (emax formal-const-decl "above(1)" ieee754_domain nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (emin const-decl "negint" ieee754_domain nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (significand_zero_value_zero formula-decl nil ieee754_domain nil)
    (szero const-decl "significand" ieee754_domain nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (m skolem-const-decl "significand" ieee754_domain nil)
    (smin_is_min formula-decl nil ieee754_domain nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (sigma_rat application-judgement "rational" ieee754_domain nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat" rationals
     nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (neg_times_lt formula-decl nil real_props nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (T_low type-eq-decl nil sigma reals)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (T_high type-eq-decl nil sigma reals)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (sigma_Fnnr formula-decl nil sigma reals)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (int_exp application-judgement "int" exponentiation nil)
    (value const-decl "real" ieee754_domain nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (er_max_neg const-decl "er_real" ieee754_domain nil))
   shostak)))

