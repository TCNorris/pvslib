(trig_fp_bounds
 (IMP_derivative_props_TCC1 0
  (IMP_derivative_props_TCC1-2 nil 3699628916
   ("" (ground) (("" (expand "connected?") (("" (propax) nil nil)) nil)) nil)
   ((connected? const-decl "bool" deriv_domain_def analysis)) nil
   (IMP_derivative_props assuming
    "analysis@derivative_props[real].derivative_props"
    "connected_domain: ASSUMPTION deriv_domain_def[T].connected?"))
  (IMP_derivative_props_TCC1-1 nil 3699628843 ("" (assuming-tcc) nil nil) nil
   nil
   (IMP_derivative_props assuming
    "analysis@derivative_props[real].derivative_props"
    "connected_domain: ASSUMPTION deriv_domain_def[T].connected?")))
 (IMP_derivative_props_TCC2 0
  (IMP_derivative_props_TCC2-2 nil 3699628932
   ("" (expand "not_one_element?")
    (("" (skeep) (("" (inst 1 "x+1") (("" (assert) nil nil)) nil)) nil)) nil)
   ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (not_one_element? const-decl "bool" deriv_domain_def analysis))
   nil
   (IMP_derivative_props assuming
    "analysis@derivative_props[real].derivative_props"
    "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?"))
  (IMP_derivative_props_TCC2-1 nil 3699628843 ("" (assuming-tcc) nil nil) nil
   nil
   (IMP_derivative_props assuming
    "analysis@derivative_props[real].derivative_props"
    "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?")))
 (sin_error_prep 0
  (sin_error_prep-1 nil 3680957043
   (""
    (case "FORALL (x: real, eps:nnreal): abs(sin(x + eps) - sin(x)) <= 2*abs(sin(eps/2))")
    (("1" (skeep)
      (("1" (case "eps >=0")
        (("1" (inst?)
          (("1" (assert)
            (("1" (case "abs(eps/2) = eps/2")
              (("1" (assert) nil nil)
               ("2" (rewrite "abs_div")
                (("2" (assert)
                  (("2" (expand "abs" 1) (("2" (propax) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (lemma "sin_neg")
          (("2" (inst -1 "-(x+eps)")
            (("2" (simplify -1)
              (("2" (case "NOT --(x+eps)= x+eps")
                (("1" (assert) nil nil)
                 ("2" (replaces -1)
                  (("2" (replaces -1)
                    (("2" (lemma "sin_neg")
                      (("2" (inst -1 "-x")
                        (("2" (case "NOT --x = x")
                          (("1" (assert) nil nil)
                           ("2" (replaces -1)
                            (("2" (replaces -1)
                              (("2" (lemma "abs_neg")
                                (("2" (inst -1 " sin(-x - eps) -sin(-x)")
                                  (("2" (replaces -1)
                                    (("2" (inst -1 "-x" "-eps")
                                      (("1"
                                        (case "not abs(eps/2)  = -eps/2")
                                        (("1"
                                          (rewrite "abs_div")
                                          (("1"
                                            (expand "abs" 1)
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (replaces -1)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (hide 2)
      (("2" (skeep)
        (("2" (rewrite " sin_diff")
          (("2" (rewrite "abs_mult")
            (("2" (rewrite "abs_mult")
              (("2" (expand "abs" 1 1)
                (("2" (cancel-by 1 "2")
                  (("2" (hide (-1 1))
                    (("2" (cancel-by 1 "abs(sin(eps/2))")
                      (("2" (hide (-1 1))
                        (("2" (expand "abs")
                          (("2" (lift-if 1)
                            (("2" (split 1)
                              (("1" (assert) nil nil)
                               ("2" (flatten) (("2" (assert) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sin const-decl "real" sincos_def trig)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (<= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (sin_range application-judgement "real_abs_le1" sincos trig)
    (sin_neg formula-decl nil sincos_def trig)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (abs_neg formula-decl nil abs_lems reals)
    (TRUE const-decl "bool" booleans nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (eps skolem-const-decl "real" trig_fp_bounds nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (abs_div formula-decl nil real_props nil)
    (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (cos const-decl "real" sincos_def trig)
    (abs_mult formula-decl nil real_props nil)
    (pos_div_gt formula-decl nil real_props nil)
    (div_mult_pos_ge1 formula-decl nil real_props nil)
    (zero_times1 formula-decl nil real_props nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (div_108 skolem-const-decl
     "{n: nonneg_real | n >= sin(eps / 2) AND n >= -sin(eps / 2)}"
     trig_fp_bounds nil)
    (eps skolem-const-decl "nnreal" trig_fp_bounds nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (both_sides_times_pos_le1 formula-decl nil real_props nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (even? const-decl "bool" integers nil)
    (even_posnat nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (cos_range application-judgement "real_abs_le1" sincos trig)
    (sin_diff formula-decl nil trig_extra trig))
   shostak))
 (cos_error_prep 0
  (cos_error_prep-1 nil 3680958608
   ("" (lemma "cos_shift")
    (("" (skeep)
      (("" (inst-cp -1 "pi/2-x-eps")
        (("" (simplify -2)
          (("" (inst -1 "pi/2-x")
            (("" (simplify -1)
              (("" (replaces -1)
                (("" (replaces -1)
                  (("" (lemma "sin_error_prep")
                    (("" (inst -1 "pi/2-x" "-eps")
                      (("" (case "NOT abs(-eps / 2) = abs(eps / 2)")
                        (("1" (hide-all-but 1)
                          (("1" (ground)
                            (("1" (expand "abs")
                              (("1" (ground)
                                (("1" (lift-if 1)
                                  (("1" (split 1)
                                    (("1" (flatten) (("1" (assert) nil nil))
                                      nil)
                                     ("2" (flatten) (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (replaces -1) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sin_range application-judgement "real_abs_le1" sincos trig)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (cos_range application-judgement "real_abs_le1" sincos trig)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (sin_error_prep formula-decl nil trig_fp_bounds nil)
    (TRUE const-decl "bool" booleans nil)
    (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def
     trig)
    (cos const-decl "real" sincos_def trig)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (pi_bound name-judgement "{r: posreal | pi_lb < r AND r < pi_ub}"
     atan_approx trig)
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig)
    (cos_shift formula-decl nil sincos trig))
   shostak))
 (sin_bound_TCC1 0
  (sin_bound_TCC1-1 nil 3680961614 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (sin_bound subtype "3"
    "{i: integers.int | booleans.OR(trig_fp_bounds.eps /= 0, reals.>=(i, 0))}")))
 (sin_bound_TCC2 0
  (sin_bound_TCC2-1 nil 3680961614 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (sin_bound subtype "5"
    "{i: integers.int | booleans.OR(trig_fp_bounds.eps /= 0, reals.>=(i, 0))}")))
 (sin_bound_TCC3 0
  (sin_bound_TCC3-1 nil 3680961614 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (sin_bound subtype "7"
    "{i: integers.int | booleans.OR(trig_fp_bounds.eps /= 0, reals.>=(i, 0))}")))
 (sin_bound_TCC4 0
  (sin_bound_TCC4-1 nil 3680961614 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (sin_bound subtype "9"
    "{i: integers.int | booleans.OR(trig_fp_bounds.eps /= 0, reals.>=(i, 0))}")))
 (sin_bound 0
  (sin_bound-1 nil 3680961614
   ("" (skeep)
    (("" (lemma "sin_lb_gt0")
      (("" (case "eps = 0")
        (("1" (replaces -1)
          (("1" (simplify 1)
            (("1" (rewrite "sin_0")
              (("1" (expand "abs") (("1" (eval-formula 1) nil nil)) nil))
              nil))
            nil))
          nil)
         ("2" (inst -1 "2" "eps/2")
          (("1" (split -1)
            (("1" (lemma "trig_approx.sin_lb")
              (("1" (inst -1 "2" "eps/2")
                (("1" (case "NOT abs(sin(eps/2)) = sin(eps/2)")
                  (("1" (expand "abs") (("1" (assert) nil nil)) nil)
                   ("2" (replaces -1)
                    (("2" (lemma "trig_approx.sin_ub")
                      (("2" (inst-cp -1 "0" "eps/2")
                        (("1" (expand "sin_ub" -2)
                          (("1" (expand "sin_approx")
                            (("1" (expand "sigma")
                              (("1" (expand "sigma")
                                (("1" (expand "sin_term")
                                  (("1" (expand "factorial")
                                    (("1" (expand "factorial")
                                      (("1"
                                        (expand "^" -2)
                                        (("1"
                                          (expand "expt")
                                          (("1"
                                            (expand "expt")
                                            (("1"
                                              (simplify -2)
                                              (("1"
                                                (cross-mult -2)
                                                (("1"
                                                  (inst -1 "2" "eps/2")
                                                  (("1"
                                                    (expand "sin_ub")
                                                    (("1"
                                                      (expand "sin_approx")
                                                      (("1"
                                                        (expand "sigma")
                                                        (("1"
                                                          (expand "sigma")
                                                          (("1"
                                                            (expand "sigma")
                                                            (("1"
                                                              (expand "sigma")
                                                              (("1"
                                                                (expand
                                                                 "sigma")
                                                                (("1"
                                                                  (expand
                                                                   "sigma")
                                                                  (("1"
                                                                    (expand
                                                                     "sin_term")
                                                                    (("1"
                                                                      (case
                                                                       "NOT 2*((-1) ^ 0 * (eps / 2) ^ (1) / factorial(1) +
        (-1) ^ 1 * (eps / 2) ^ (3) / factorial(3)
        + (-1) ^ 2 * (eps / 2) ^ (5) / factorial(5)
        + (-1) ^ 3 * (eps / 2) ^ (7) / factorial(7)
        + (-1) ^ 4 * (eps / 2) ^ (9) / factorial(9)) = eps - eps ^ 3 / 24 + eps ^ 5 / 1920 - eps ^ 7 / 322560 +
            eps ^ 9 / 92897280")
                                                                      (("1"
                                                                        (hide-all-but
                                                                         1)
                                                                        (("1"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (both-sides
                                                                         "*"
                                                                         "2"
                                                                         -2)
                                                                        (("1"
                                                                          (replaces
                                                                           -1)
                                                                          (("1"
                                                                            (expand
                                                                             "min")
                                                                            (("1"
                                                                              (lift-if
                                                                               2)
                                                                              (("1"
                                                                                (split
                                                                                 2)
                                                                                (("1"
                                                                                  (flatten)
                                                                                  (("1"
                                                                                    (assert)
                                                                                    nil
                                                                                    nil))
                                                                                  nil)
                                                                                 ("2"
                                                                                  (flatten)
                                                                                  (("2"
                                                                                    (assert)
                                                                                    nil
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert) nil nil))
                nil))
              nil)
             ("2" (cross-mult 1)
              (("2" (mult-ineq -1 -1) (("2" (assert) nil nil)) nil)) nil))
            nil)
           ("2" (cross-mult 1) (("2" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((sin_lb_gt0 formula-decl nil trig_approx trig)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (rat_min application-judgement "{s: rat | s <= q AND s <= r}" real_defs
     nil)
    (rat_plus_rat_is_rat application-judgement "rat" rationals nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (int_times_even_is_even application-judgement "even_int" integers nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (sin_0 formula-decl nil sincos_def trig)
    (TRUE const-decl "bool" booleans nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (nat_exp application-judgement "nat" exponentiation nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (nnrat_plus_nnrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (> const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (eps skolem-const-decl "nnreal" trig_fp_bounds nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (sin_ub const-decl "real" trig_approx trig)
    (sigma def-decl "real" sigma reals)
    (sin_term const-decl "real" trig_approx trig)
    (expt def-decl "real" exponentiation nil)
    (int_exp application-judgement "int" exponentiation nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (nnreal_expt application-judgement "nnreal" exponentiation nil)
    (nzreal_expt application-judgement "nzreal" exponentiation nil)
    (int_expt application-judgement "int" exponentiation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (< const-decl "bool" reals nil) (even? const-decl "bool" integers nil)
    (times_div2 formula-decl nil real_props nil)
    (neg_times_lt formula-decl nil real_props nil)
    (pos_times_lt formula-decl nil real_props nil)
    (neg_times_le formula-decl nil real_props nil)
    (pos_times_le formula-decl nil real_props nil)
    (add_div formula-decl nil real_props nil)
    (div_div2 formula-decl nil real_props nil)
    (factorial_1 formula-decl nil factorial ints)
    (expt_x1 formula-decl nil exponentiation nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (div_mult_pos_lt2 formula-decl nil real_props nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (times_div1 formula-decl nil real_props nil)
    (^ const-decl "real" exponentiation nil)
    (factorial def-decl "posnat" factorial ints)
    (sin_approx const-decl "real" trig_approx trig)
    (sin_ub formula-decl nil trig_approx trig)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sin const-decl "real" sincos_def trig)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (sin_lb formula-decl nil trig_approx trig)
    (<= const-decl "bool" reals nil)
    (le_times_le_any1 formula-decl nil extra_real_props nil)
    (div_mult_pos_lt1 formula-decl nil real_props nil)
    (div_mult_pos_gt1 formula-decl nil extra_real_props nil)
    (sin_range application-judgement "real_abs_le1" sincos trig)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   shostak))
 (sin_error_bound_TCC1 0
  (sin_error_bound_TCC1-1 nil 3680963345 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (sin_error_bound subtype "3"
    "{i: integers.int | booleans.OR(trig_fp_bounds.peps /= 0, reals.>=(i, 0))}")))
 (sin_error_bound_TCC2 0
  (sin_error_bound_TCC2-1 nil 3680963345 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (sin_error_bound subtype "5"
    "{i: integers.int | booleans.OR(trig_fp_bounds.peps /= 0, reals.>=(i, 0))}")))
 (sin_error_bound_TCC3 0
  (sin_error_bound_TCC3-1 nil 3680963345 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (sin_error_bound subtype "7"
    "{i: integers.int | booleans.OR(trig_fp_bounds.peps /= 0, reals.>=(i, 0))}")))
 (sin_error_bound_TCC4 0
  (sin_error_bound_TCC4-1 nil 3680963345 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (sin_error_bound subtype "9"
    "{i: integers.int | booleans.OR(trig_fp_bounds.peps /= 0, reals.>=(i, 0))}")))
 (sin_error_bound 0
  (sin_error_bound-1 nil 3680963347
   ("" (skeep)
    (("" (skoletin)
      (("" (lemma "sin_error_prep")
        (("" (inst?)
          (("" (lemma "sin_bound")
            (("" (inst -1 "peps")
              (("" (typepred (eps))
                (("" (assert)
                  (("" (case " NOT abs(eps/2) = peps/2")
                    (("1" (rewrite "abs_div" 1)
                      (("1" (expand "abs" 1 2) (("1" (assert) nil nil)) nil))
                      nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_plus_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sin const-decl "real" sincos_def trig)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (^ const-decl "real" exponentiation nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs
     nil)
    (abs_div formula-decl nil real_props nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (sin_bound formula-decl nil trig_fp_bounds nil)
    (sin_error_prep formula-decl nil trig_fp_bounds nil)
    (sin_range application-judgement "real_abs_le1" sincos trig)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil))
   shostak))
 (cos_error_bound 0
  (cos_error_bound-1 nil 3680964690
   ("" (skeep)
    (("" (skoletin)
      (("" (lemma "cos_error_prep")
        (("" (inst?)
          (("" (lemma "sin_bound")
            (("" (inst -1 "peps")
              (("" (typepred (eps))
                (("" (assert)
                  (("" (case " NOT abs(eps/2) = peps/2")
                    (("1" (rewrite "abs_div" 1)
                      (("1" (expand "abs" 1 2) (("1" (assert) nil nil)) nil))
                      nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_plus_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (cos const-decl "real" sincos_def trig)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (^ const-decl "real" exponentiation nil)
    (sin_range application-judgement "real_abs_le1" sincos trig)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs
     nil)
    (abs_div formula-decl nil real_props nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (sin_bound formula-decl nil trig_fp_bounds nil)
    (cos_error_prep formula-decl nil trig_fp_bounds nil)
    (cos_range application-judgement "real_abs_le1" sincos trig)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil))
   shostak))
 (sin_bnd_simple 0
  (sin_bnd_simple-1 nil 3696756078
   ("" (skeep)
    (("" (case "abs(eps)<=2")
      (("1" (lemma "sin_error_bound")
        (("1" (inst?)
          (("1" (assert)
            (("1" (expand "min" 1)
              (("1" (assert) (("1" (lift-if 1) (("1" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (assert) nil nil))
          nil))
        nil)
       ("2" (expand "min" 2)
        (("2" (lift-if 2)
          (("2" (assert)
            (("2" (typepred "sin(x)")
              (("2" (typepred "sin(x+eps)")
                (("2" (assert)
                  (("2" (expand "abs" 2)
                    (("2" (assert)
                      (("2" (lift-if 2)
                        (("2" (split)
                          (("1" (flatten) (("1" (assert) nil nil)) nil)
                           ("2" (flatten) (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sin const-decl "real" sincos_def trig)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (sin_error_bound formula-decl nil trig_fp_bounds nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (eps skolem-const-decl "real" trig_fp_bounds nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (nonneg_real_min application-judgement
     "{z: nonneg_real | z <= x AND z <= y}" real_defs nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (sin_range application-judgement "real_abs_le1" sincos trig)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (cos_bnd_simple 0
  (cos_bnd_simple-1 nil 3696756109
   ("" (skeep)
    (("" (lemma "sin_shift")
      (("" (inst-cp -1 "x+eps")
        (("" (inst -1 "x")
          (("" (replaces -1 :dir rl)
            (("" (replaces -1 :dir rl)
              (("" (lemma "sin_bnd_simple")
                (("" (inst -1 "pi/2-x" "-eps")
                  (("" (lemma "abs_neg")
                    (("" (inst -1 "eps")
                      (("" (replaces -1) (("" (assert) nil nil)) nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sin_shift formula-decl nil sincos trig)
    (minus_real_is_real application-judgement "real" reals nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def
     trig)
    (cos const-decl "real" sincos_def trig)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_real_min application-judgement
     "{z: nonneg_real | z <= x AND z <= y}" real_defs nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (abs_neg formula-decl nil abs_lems reals)
    (sin_bnd_simple formula-decl nil trig_fp_bounds nil)
    (TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pi_bound name-judgement "{r: posreal | pi_lb < r AND r < pi_ub}"
     atan_approx trig)
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (sin_range application-judgement "real_abs_le1" sincos trig)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (cos_range application-judgement "real_abs_le1" sincos trig)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (sin_error_eps 0
  (sin_error_eps-1 nil 3696756144
   ("" (skeep)
    (("" (lemma "sin_bnd_simple")
      (("" (inst -1 "x" "ep")
        (("" (assert)
          (("" (expand "min" -1)
            (("" (lift-if -1)
              (("" (expand "min")
                (("" (lift-if 1) (("" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sin_bnd_simple formula-decl nil trig_fp_bounds nil)
    (nonneg_real_min application-judgement
     "{z: nonneg_real | z <= x AND z <= y}" real_defs nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (sin_range application-judgement "real_abs_le1" sincos trig)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (cos_error_eps 0
  (cos_error_eps-1 nil 3696756178
   ("" (skeep)
    (("" (lemma "cos_bnd_simple")
      (("" (inst -1 "x" "ep")
        (("" (expand "min")
          (("" (ground) (("" (lift-if) (("" (ground) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((cos_bnd_simple formula-decl nil trig_fp_bounds nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (cos_range application-judgement "real_abs_le1" sincos trig)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (atan_error_eps_TCC1 0
  (atan_error_eps_TCC1-1 nil 3696756045 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (atan_error_eps subtype "2"
    "{i: integers.int | booleans.OR(((number_fields.-)(trig_fp_bounds.x, trig_fp_bounds.eps)) /= 0, reals.>=(i, 0))}")))
 (atan_error_eps_TCC2 0
  (atan_error_eps_TCC2-1 nil 3696756045 ("" (subtype-tcc) nil nil) nil nil
   (atan_error_eps subtype "2"
    "{i: integers.int | booleans.OR((booleans.NOT)((number_fields.+)(trig_fp_bounds.eps, trig_fp_bounds.x) = 0), reals.>=(i, 0))}")))
 (atan_error_eps_TCC3 0
  (atan_error_eps_TCC3-1 nil 3696756045
   ("" (skeep)
    (("" (lift-if -2)
      (("" (split -2)
        (("1" (assert) nil nil)
         ("2" (flatten)
          (("2" (expand "min")
            (("2" (lift-if -1)
              (("2" (split -1)
                (("1" (flatten)
                  (("1" (case "(x+eps)^2 = sq(x+eps)")
                    (("1" (assert) nil nil) ("2" (grind) nil nil)) nil))
                  nil)
                 ("2" (flatten)
                  (("2" (case "(x-eps)^2 = sq(x-eps)")
                    (("1" (assert) nil nil) ("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sq const-decl "nonneg_real" sq reals)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nnreal type-eq-decl nil real_types nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (^ const-decl "real" exponentiation nil) (>= const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (real nonempty-type-from-decl nil reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (expt def-decl "real" exponentiation nil))
   nil
   (atan_error_eps subtype
    "((number_fields.+)(1, IF reals.<=(real_defs.abs(trig_fp_bounds.x), trig_fp_bounds.eps) THEN 0 ELSE real_defs.min(exponentiation.^(((number_fields.-)(trig_fp_bounds.x, trig_fp_bounds.eps)), 2), exponentiation.^(((number_fields.+)(trig_fp_bounds.x, trig_fp_bounds.eps)), 2)) ENDIF))"
    "nznum")))
 (atan_error_eps 0
  (atan_error_eps-1 nil 3696756215
   ("" (skeep)
    (("" (lemma "mean_value_abs")
      (("" (inst -1 "x" "x+ep" "atan")
        (("" (lemma "deriv_atan_fun")
          (("" (flatten)
            (("" (assert)
              (("" (case "0=ep")
                (("1" (replaces -1 :dir rl)
                  (("1" (assert)
                    (("1" (expand "abs" 1 1)
                      (("1"
                        (case "NOT (1 +
                   IF abs(x) <= eps THEN 0
                   ELSE min((x - eps) ^ 2, (eps + x) ^ 2)
                   ENDIF)>= 1")
                        (("1" (hide 2)
                          (("1" (lift-if 1)
                            (("1" (split 1)
                              (("1" (assert) nil nil)
                               ("2" (flatten)
                                (("2" (lemma "abs_sq")
                                  (("2" (inst-cp -1 "x-eps")
                                    (("2" (inst -1 "x+eps")
                                      (("2"
                                        (expand "^")
                                        (("2"
                                          (expand "expt")
                                          (("2"
                                            (expand "expt")
                                            (("2"
                                              (expand "expt")
                                              (("2"
                                                (expand "sq" -1 2)
                                                (("2"
                                                  (expand "sq" -2 2)
                                                  (("2"
                                                    (replaces -1 :dir rl)
                                                    (("2"
                                                      (replaces -1 :dir rl)
                                                      (("2" (assert) nil nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (cross-mult 1)
                          (("2" (assert)
                            (("2" (lift-if 1)
                              (("2" (assert)
                                (("2" (split 1)
                                  (("1" (propax) nil nil)
                                   ("2" (flatten)
                                    (("2" (assert)
                                      (("2"
                                        (split 2)
                                        (("1" (propax) nil nil)
                                         ("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert)
                  (("2" (skeep)
                    (("2" (replaces -5 :dir rl)
                      (("2" (expand "deriv" -2)
                        (("2" (decompose-equality -2)
                          (("1" (inst -1 "c")
                            (("1" (replaces -1)
                              (("1" (case "NOT abs(1/(1+c*c)) = 1/(1+c*c)")
                                (("1" (hide 3)
                                  (("1" (expand "abs")
                                    (("1" (lift-if 1)
                                      (("1"
                                        (split 1)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (lemma "abs_sq")
                                            (("1"
                                              (inst -1 "c")
                                              (("1"
                                                (expand "sq")
                                                (("1"
                                                  (replaces -1 :dir rl)
                                                  (("1" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (replaces -1)
                                  (("2"
                                    (case "NOT 1/(1+c*c)*abs(ep)<= eps/(1+c*c)")
                                    (("1" (assert)
                                      (("1"
                                        (case
                                         "NOT  eps / (1 + c * c) =  1 / (1 + c * c)*eps")
                                        (("1" (assert) nil nil)
                                         ("2"
                                          (replaces -1)
                                          (("2"
                                            (cancel-by 1 "1 / (1 + c * c)")
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (case
                                       "eps / (1 + c * c) <= eps /
                       (1 +
                         IF abs(x) <= eps THEN 0
                         ELSE min((x - eps) ^ 2, (eps + x) ^ 2)
                         ENDIF)")
                                      (("1"
                                        (assert)
                                        (("1"
                                          (case
                                           "FORALL (j,k,l:real): j<=k and k<=l IMPLIES j<=l")
                                          (("1"
                                            (inst
                                             -1
                                             "1 / (1 + c * c) * abs(ep)"
                                             "eps / (1 + c * c) "
                                             "       eps /
                      (1 +
                        IF abs(x) <= eps THEN 0
                        ELSE min((x - eps) ^ 2, (eps + x) ^ 2)
                        ENDIF)")
                                            (("1"
                                              (assert)
                                              (("1" (ground) nil nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (hide-all-but 1)
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (hide 3)
                                        (("2"
                                          (cancel-by 1 "eps")
                                          (("2"
                                            (lift-if 2)
                                            (("2"
                                              (split 2)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (cross-mult 1)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (case
                                                   "c*c>= min((x - eps) ^ 2, (eps + x) ^ 2)")
                                                  (("1"
                                                    (cross-mult 2)
                                                    (("1"
                                                      (split 2)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (lemma "abs_sq")
                                                        (("2"
                                                          (typepred
                                                           "sq(x-eps)")
                                                          (("2"
                                                            (typepred
                                                             "sq(x+eps)")
                                                            (("2"
                                                              (hide-all-but
                                                               (-1 -2 1))
                                                              (("2"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (hide (3 4 5))
                                                    (("2"
                                                      (flip-ineq 2)
                                                      (("2"
                                                        (name
                                                         "m"
                                                         "min(x, ep+x)")
                                                        (("2"
                                                          (replaces -1)
                                                          (("2"
                                                            (name
                                                             "M"
                                                             "max(x, ep+x)")
                                                            (("2"
                                                              (replaces -1)
                                                              (("2"
                                                                (expand
                                                                 "abs"
                                                                 -1)
                                                                (("2"
                                                                  (lift-if -1)
                                                                  (("2"
                                                                    (split -1)
                                                                    (("1"
                                                                      (flatten)
                                                                      (("1"
                                                                        (case
                                                                         "not min((x - eps) ^ 2, (eps + x) ^ 2) = (eps + x) ^ 2")
                                                                        (("1"
                                                                          (hide
                                                                           2)
                                                                          (("1"
                                                                            (move-terms
                                                                             -2
                                                                             r
                                                                             1)
                                                                            (("1"
                                                                              (case
                                                                               "NOT -(x-eps) >= -x-eps")
                                                                              (("1"
                                                                                (assert)
                                                                                nil
                                                                                nil)
                                                                               ("2"
                                                                                (mult-ineq
                                                                                 -1
                                                                                 -1)
                                                                                (("2"
                                                                                  (case
                                                                                   "NOT -(x - eps) * -(x - eps) = (x-eps)^2")
                                                                                  (("1"
                                                                                    (hide-all-but
                                                                                     1)
                                                                                    (("1"
                                                                                      (grind)
                                                                                      nil
                                                                                      nil))
                                                                                    nil)
                                                                                   ("2"
                                                                                    (replaces
                                                                                     -1)
                                                                                    (("2"
                                                                                      (case
                                                                                       "NOT (-x - eps) * (-x - eps) = (x+eps)^2")
                                                                                      (("1"
                                                                                        (hide-all-but
                                                                                         1)
                                                                                        (("1"
                                                                                          (grind)
                                                                                          nil
                                                                                          nil))
                                                                                        nil)
                                                                                       ("2"
                                                                                        (replaces
                                                                                         -1)
                                                                                        (("2"
                                                                                          (expand
                                                                                           "min")
                                                                                          (("2"
                                                                                            (ground)
                                                                                            (("2"
                                                                                              (lift-if
                                                                                               1)
                                                                                              (("2"
                                                                                                (split
                                                                                                 1)
                                                                                                (("1"
                                                                                                  (propax)
                                                                                                  nil
                                                                                                  nil)
                                                                                                 ("2"
                                                                                                  (flatten)
                                                                                                  (("2"
                                                                                                    (assert)
                                                                                                    nil
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (replaces
                                                                           -1)
                                                                          (("2"
                                                                            (case
                                                                             "NOT M<=x+eps")
                                                                            (("1"
                                                                              (expand
                                                                               "M")
                                                                              (("1"
                                                                                (expand
                                                                                 "max"
                                                                                 1)
                                                                                (("1"
                                                                                  (lift-if
                                                                                   1)
                                                                                  (("1"
                                                                                    (split
                                                                                     1)
                                                                                    (("1"
                                                                                      (flatten)
                                                                                      (("1"
                                                                                        (assert)
                                                                                        nil
                                                                                        nil))
                                                                                      nil)
                                                                                     ("2"
                                                                                      (flatten)
                                                                                      (("2"
                                                                                        (assert)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (move-terms
                                                                               -1
                                                                               l
                                                                               1)
                                                                              (("2"
                                                                                (move-terms
                                                                                 -1
                                                                                 r
                                                                                 1)
                                                                                (("2"
                                                                                  (move-terms
                                                                                   -1
                                                                                   r
                                                                                   1)
                                                                                  (("2"
                                                                                    (move-terms
                                                                                     -3
                                                                                     r
                                                                                     1)
                                                                                    (("2"
                                                                                      (move-terms
                                                                                       -8
                                                                                       r
                                                                                       1)
                                                                                      (("2"
                                                                                        (move-terms
                                                                                         -8
                                                                                         l
                                                                                         1)
                                                                                        (("2"
                                                                                          (simplify)
                                                                                          (("2"
                                                                                            (case
                                                                                             "NOT -c > -(x+eps)")
                                                                                            (("1"
                                                                                              (assert)
                                                                                              nil
                                                                                              nil)
                                                                                             ("2"
                                                                                              (mult-ineq
                                                                                               -1
                                                                                               -1)
                                                                                              (("2"
                                                                                                (case
                                                                                                 "NOT -(x + eps) * -(x + eps) = (eps+x)^2")
                                                                                                (("1"
                                                                                                  (hide-all-but
                                                                                                   1)
                                                                                                  (("1"
                                                                                                    (grind)
                                                                                                    nil
                                                                                                    nil))
                                                                                                  nil)
                                                                                                 ("2"
                                                                                                  (assert)
                                                                                                  nil
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (flatten)
                                                                      (("2"
                                                                        (move-terms
                                                                         -1
                                                                         r
                                                                         1)
                                                                        (("2"
                                                                          (flip-ineq
                                                                           1)
                                                                          (("2"
                                                                            (case
                                                                             "not x+eps>=x-eps")
                                                                            (("1"
                                                                              (assert)
                                                                              nil
                                                                              nil)
                                                                             ("2"
                                                                              (mult-ineq
                                                                               -1
                                                                               -1)
                                                                              (("2"
                                                                                (case
                                                                                 "not min((x - eps) ^ 2, (eps + x) ^ 2) = (x-eps)^2")
                                                                                (("1"
                                                                                  (expand
                                                                                   "min"
                                                                                   1)
                                                                                  (("1"
                                                                                    (lift-if
                                                                                     1)
                                                                                    (("1"
                                                                                      (split
                                                                                       1)
                                                                                      (("1"
                                                                                        (flatten)
                                                                                        (("1"
                                                                                          (assert)
                                                                                          (("1"
                                                                                            (expand
                                                                                             "^")
                                                                                            (("1"
                                                                                              (expand
                                                                                               "expt")
                                                                                              (("1"
                                                                                                (expand
                                                                                                 "expt")
                                                                                                (("1"
                                                                                                  (expand
                                                                                                   "expt")
                                                                                                  (("1"
                                                                                                    (assert)
                                                                                                    nil
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil)
                                                                                       ("2"
                                                                                        (propax)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil)
                                                                                 ("2"
                                                                                  (replaces
                                                                                   -1)
                                                                                  (("2"
                                                                                    (case
                                                                                     "not m>= x-eps")
                                                                                    (("1"
                                                                                      (assert)
                                                                                      (("1"
                                                                                        (expand
                                                                                         "m")
                                                                                        (("1"
                                                                                          (expand
                                                                                           "min"
                                                                                           1)
                                                                                          (("1"
                                                                                            (lift-if
                                                                                             1)
                                                                                            (("1"
                                                                                              (split
                                                                                               1)
                                                                                              (("1"
                                                                                                (flatten)
                                                                                                (("1"
                                                                                                  (assert)
                                                                                                  nil
                                                                                                  nil))
                                                                                                nil)
                                                                                               ("2"
                                                                                                (assert)
                                                                                                nil
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil)
                                                                                     ("2"
                                                                                      (case
                                                                                       "not c>= x-eps")
                                                                                      (("1"
                                                                                        (assert)
                                                                                        nil
                                                                                        nil)
                                                                                       ("2"
                                                                                        (mult-ineq
                                                                                         -1
                                                                                         -1)
                                                                                        (("2"
                                                                                          (expand
                                                                                           "^")
                                                                                          (("2"
                                                                                            (expand
                                                                                             "expt")
                                                                                            (("2"
                                                                                              (expand
                                                                                               "expt")
                                                                                              (("2"
                                                                                                (expand
                                                                                                 "expt")
                                                                                                (("2"
                                                                                                  (assert)
                                                                                                  nil
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (lemma "abs_sq")
                            (("2" (inst -1 "x1!1")
                              (("2" (expand "sq") (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil)
                           ("3" (lemma "abs_sq")
                            (("3" (inst -1 "x1!1")
                              (("3" (expand "sq") (("3" (assert) nil nil))
                                nil))
                              nil))
                            nil)
                           ("4" (expand "derivable?")
                            (("4" (inst?) (("4" (assert) nil nil)) nil)) nil)
                           ("5" (expand "derivable?")
                            (("5" (inst?) (("5" (assert) nil nil)) nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (mean_value_abs formula-decl nil derivative_props analysis)
    (deriv_atan_fun formula-decl nil atan trig)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (div_mult_pos_neg_le2 formula-decl nil extra_real_props nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sq const-decl "nonneg_real" sq reals)
    (nonneg_real_min application-judgement
     "{z: nonneg_real | z <= x AND z <= y}" real_defs nil)
    (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types
     nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (expt def-decl "real" exponentiation nil)
    (abs_sq formula-decl nil abs_lems reals)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (nnreal type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (<= const-decl "bool" reals nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (>= const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (TRUE const-decl "bool" booleans nil)
    (deriv const-decl "[T -> real]" derivatives analysis)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (deriv const-decl "real" derivatives_def analysis)
    (derivable? const-decl "bool" derivatives_def analysis)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}"
     real_defs nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (div_mult_pos_le1 formula-decl nil real_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (m skolem-const-decl "{p: real | p <= x AND p <= ep + x}" trig_fp_bounds
     nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (ge_times_ge_any1 formula-decl nil extra_real_props nil)
    (gt_times_gt_any1 formula-decl nil extra_real_props nil)
    (M skolem-const-decl "{p: real | p >= x AND p >= ep + x}" trig_fp_bounds
     nil)
    (le_div_le_pos formula-decl nil real_props nil)
    (times_div2 formula-decl nil real_props nil)
    (div_simp formula-decl nil real_props nil)
    (div_distributes formula-decl nil real_props nil)
    (div_cancel4 formula-decl nil real_props nil)
    (div_mult_pos_ge1 formula-decl nil real_props nil)
    (zero_times1 formula-decl nil real_props nil)
    (div_110 skolem-const-decl "nnreal" trig_fp_bounds nil)
    (pos_div_gt formula-decl nil real_props nil)
    (div_cancel3 formula-decl nil real_props nil)
    (div_times formula-decl nil real_props nil)
    (times_div1 formula-decl nil real_props nil)
    (div_div1 formula-decl nil real_props nil)
    (div_cancel1 formula-decl nil real_props nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (div_109 skolem-const-decl "nzreal" trig_fp_bounds nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (both_sides_times_pos_le1 formula-decl nil real_props nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (derivable? const-decl "bool" derivatives analysis)
    (atan const-decl "{x: real_abs_lt_pi2 | y = tan_restrict(x)}" atan trig)
    (tan_restrict const-decl "real" trig_basic trig)
    (real_abs_lt_pi2 nonempty-type-eq-decl nil trig_types trig)
    (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def
     trig)
    (cos const-decl "real" sincos_def trig)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil) (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (pi_bound name-judgement "{r: posreal | pi_lb < r AND r < pi_ub}"
     atan_approx trig)
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (generic_bounding 0
  (generic_bounding-1 nil 3696690818
   ("" (skeep)
    (("" (lemma "abs_abs")
      (("" (inst -1 "F(x+ep)")
        (("" (replaces -1 :dir rl)
          (("" (case "abs(F(x + ep)) = abs(F(x + ep))-abs(F(x)) +abs(F(x))")
            (("1" (replaces -1)
              (("1" (lemma "real_props.triangle")
                (("1" (inst -1 "abs(F(x + ep)) - abs(F(x))" "abs(F(x))")
                  (("1"
                    (case "FORALL (a,b:real): abs(abs(a)-abs(b))<=abs(a-b)")
                    (("1" (inst -1 " F(x+ep)" "F(x)")
                      (("1" (rewrite "abs_abs") (("1" (assert) nil nil)) nil))
                      nil)
                     ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((abs_abs formula-decl nil real_props nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (triangle formula-decl nil real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   shostak))
 (sin_ulp_bounded 0
  (sin_ulp_bounded-1 nil 3696693998
   ("" (skeep)
    (("" (lemma "sin_error_eps")
      (("" (lemma "generic_bounding")
        ((""
          (inst -1 "sin" "x" "ep" "eps"
           "LAMBDA (z:real, e:nnreal): min(2, e)")
          (("" (inst?) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((sin_error_eps formula-decl nil trig_fp_bounds nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (nonneg_real_min application-judgement
     "{z: nonneg_real | z <= x AND z <= y}" real_defs nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (sin const-decl "real" sincos_def trig)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (generic_bounding formula-decl nil trig_fp_bounds nil)
    (sin_range application-judgement "real_abs_le1" sincos trig))
   shostak))
 (cos_ulp_bounded 0
  (cos_ulp_bounded-1 nil 3696694356
   ("" (skeep)
    (("" (lemma "cos_error_eps")
      (("" (lemma "generic_bounding")
        ((""
          (inst -1 "cos" "x" "ep" "eps"
           "LAMBDA (z:real, e:nnreal): min(2, e)")
          (("" (inst?) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((cos_error_eps formula-decl nil trig_fp_bounds nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (nonneg_real_min application-judgement
     "{z: nonneg_real | z <= x AND z <= y}" real_defs nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (cos const-decl "real" sincos_def trig)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (generic_bounding formula-decl nil trig_fp_bounds nil)
    (cos_range application-judgement "real_abs_le1" sincos trig))
   shostak))
 (atan_ulp_bounded 0
  (atan_ulp_bounded-3 nil 3699628352
   ("" (skeep)
    (("" (case "NOT abs(x+h) <= abs(x) + eps")
      (("1" (hide 2) (("1" (grind) nil nil)) nil)
       ("2" (case "NOT abs(atan(x+h)) = atan(abs(x+h))")
        (("1" (hide 2)
          (("1" (expand "abs" 1 2)
            (("1" (lift-if 1)
              (("1" (split 1)
                (("1" (lemma "atan_neg")
                  (("1" (inst?)
                    (("1" (lemma "abs_neg")
                      (("1" (inst -1 "atan(h+x)")
                        (("1" (replace -2 -1 :dir rl)
                          (("1" (replace -2 -1)
                            (("1" (replace -1 :dir rl)
                              (("1" (replace -2 -1 :dir rl)
                                (("1" (replace -2 1 :dir rl)
                                  (("1" (flatten)
                                    (("1" (case "not atan(-(h + x)) >=0")
                                      (("1"
                                        (lemma "atan_0")
                                        (("1"
                                          (lemma "atan_strict_increasing")
                                          (("1"
                                            (expand "strict_increasing?")
                                            (("1"
                                              (inst -1 "0" "-(h+x)")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (expand "abs " 1)
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (flip-ineq 1)
                    (("2" (case "h+x=0")
                      (("1" (replaces -1)
                        (("1" (lemma "atan_0")
                          (("1" (assert)
                            (("1" (expand "abs") (("1" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert)
                        (("2" (lemma "atan_0")
                          (("2" (lemma "atan_strict_increasing")
                            (("2" (expand "strict_increasing?")
                              (("2" (inst -1 "0" "h+x")
                                (("2" (assert)
                                  (("2" (expand "abs")
                                    (("2" (propax) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (assert)
          (("2" (replaces -1)
            (("2" (case "abs(h + x) = abs(x) + eps")
              (("1" (assert) nil nil)
               ("2" (lemma "atan_strict_increasing")
                (("2" (expand "strict_increasing?")
                  (("2" (inst -1 "abs(h + x) " " abs(x) + eps")
                    (("2" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((atan_strict_increasing formula-decl nil atan trig)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (strict_increasing? const-decl "bool" real_fun_preds reals)
    (atan_0 formula-decl nil atan trig)
    (abs_neg formula-decl nil abs_lems reals)
    (atan_neg formula-decl nil atan trig)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (TRUE const-decl "bool" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (> const-decl "bool" reals nil) (cos const-decl "real" sincos_def trig)
    (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def
     trig)
    (real_abs_lt_pi2 nonempty-type-eq-decl nil trig_types trig)
    (tan_restrict const-decl "real" trig_basic trig)
    (atan const-decl "{x: real_abs_lt_pi2 | y = tan_restrict(x)}" atan trig)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnreal type-eq-decl nil real_types nil)
    (pi_bound name-judgement "{r: posreal | pi_lb < r AND r < pi_ub}"
     atan_approx trig)
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil))
   nil)
  (atan_ulp_bounded-2 nil 3696756247
   ("" (skeep)
    (("" (lemma "generic_bounding")
      (("" (lemma "atan_error_eps")
        (("" (inst?)
          (("" (inst?)
            ((""
              (inst -2 "atan" "x" "ep" "eps"
               "LAMBDA(z:real, e: nnreal): e/(1+ IF abs(z)<=e THEN 0 ELSE min((z-e)^2, (z+e)^2) ENDIF)")
              (("1" (assert)
                (("1" (split -2)
                  (("1" (propax) nil nil) ("2" (propax) nil nil)) nil))
                nil)
               ("2" (hide-all-but 1)
                (("2" (skeep)
                  (("2" (lift-if 1)
                    (("2" (split 1)
                      (("1" (flatten) (("1" (assert) nil nil)) nil)
                       ("2" (flatten)
                        (("2" (assert)
                          (("2" (expand "min")
                            (("2" (lift-if 2)
                              (("2" (split 2)
                                (("1" (flatten)
                                  (("1" (case "(e+z)^2 = sq(e+z)")
                                    (("1" (ground)
                                      (("1"
                                        (replace -1)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("2" (flatten)
                                  (("2" (case "(z-e)^2 = sq(z-e)")
                                    (("1" (replace -1)
                                      (("1" (assert) nil nil)) nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (hide-all-but 1)
                (("3" (skeep)
                  (("3" (lift-if -1)
                    (("3" (split -1)
                      (("1" (ground) nil nil)
                       ("2" (flatten)
                        (("2" (expand "min")
                          (("2" (lift-if -1)
                            (("2" (split)
                              (("1" (flatten)
                                (("1" (assert)
                                  (("1" (case "(e+z)^2 = sq(e+z)")
                                    (("1" (assert) nil nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (flatten)
                                (("2" (case "(z-e)^2 = sq(z-e)")
                                  (("1" (assert) nil nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((atan const-decl "{x: real_abs_lt_pi2 | y = tan_restrict(x)}" atan trig)
    (pi_bound name-judgement "{r: posreal | pi_lb < r AND r < pi_ub}"
     atan_approx trig)
    (sq const-decl "nonneg_real" sq reals))
   nil)
  (atan_ulp_bounded-1 nil 3696755084
   ("" (skeep)
    (("" (lemma "generic_bounding")
      (("" (lemma "atan_bound")
        (("" (inst?)
          (("" (inst?)
            ((""
              (inst -2 "atan" "x" "ep" "eps"
               "LAMBDA(z:real, e: nnreal): e/(1+ IF abs(z)<=e THEN 0 ELSE min((z-e)^2, (z+e)^2) ENDIF)")
              (("1" (assert)
                (("1" (split -2)
                  (("1" (propax) nil nil) ("2" (propax) nil nil)) nil))
                nil)
               ("2" (hide-all-but 1)
                (("2" (skeep)
                  (("2" (lift-if 1)
                    (("2" (split 1)
                      (("1" (flatten) (("1" (assert) nil nil)) nil)
                       ("2" (flatten)
                        (("2" (assert)
                          (("2" (expand "min")
                            (("2" (lift-if 2)
                              (("2" (split 2)
                                (("1" (flatten)
                                  (("1" (case "(e+z)^2 = sq(e+z)")
                                    (("1" (ground)
                                      (("1"
                                        (replace -1)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("2" (flatten)
                                  (("2" (case "(z-e)^2 = sq(z-e)")
                                    (("1" (replace -1)
                                      (("1" (assert) nil nil)) nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (hide-all-but 1)
                (("3" (skeep)
                  (("3" (lift-if -1)
                    (("3" (split -1)
                      (("1" (ground) nil nil)
                       ("2" (flatten)
                        (("2" (expand "min")
                          (("2" (lift-if -1)
                            (("2" (split)
                              (("1" (flatten)
                                (("1" (assert)
                                  (("1" (case "(e+z)^2 = sq(e+z)")
                                    (("1" (assert) nil nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (flatten)
                                (("2" (case "(z-e)^2 = sq(z-e)")
                                  (("1" (assert) nil nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((atan const-decl "{x: real_abs_lt_pi2 | y = tan_restrict(x)}" atan trig)
    (pi_bound name-judgement "{r: posreal | pi_lb < r AND r < pi_ub}"
     atan_approx trig)
    (sq const-decl "nonneg_real" sq reals))
   shostak)))

