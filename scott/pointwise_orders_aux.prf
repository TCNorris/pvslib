(pointwise_orders_aux
 (continuous_pointwise_preserves_directed_complete_partial_order 0
  (continuous_pointwise_preserves_directed_complete_partial_order-1 nil
   3353820348
   ("" (skosimp*)
    (("" (lemma "scott_continuous_dcpo[T1, T2, d1!1, d2!1]")
      (("" (expand "continuous_pointwise")
        (("" (expand "restrict") (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((directed_complete_partial_order? const-decl "bool" directed_orders
     orders)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T2 formal-type-decl nil pointwise_orders_aux nil)
    (T1 formal-type-decl nil pointwise_orders_aux nil)
    (scott_continuous_dcpo formula-decl nil scott_continuity nil)
    (restrict const-decl "R" restrict nil)
    (continuous_pointwise const-decl "bool" pointwise_orders_aux nil))
   nil
   (continuous_pointwise_preserves_directed_complete_partial_order subtype
    "pointwise_orders_aux.continuous_pointwise(pointwise_orders_aux.d1, pointwise_orders_aux.d2)"
    "(directed_orders[(scott_continuity[pointwise_orders_aux.T1, pointwise_orders_aux.T2, (pointwise_orders_aux.d1), (pointwise_orders_aux.d2)].scott_continuous?)].directed_complete_partial_order?)")))
 (continuous_pointwise_preserves_pointed_directed_complete_partial_order 0
  (continuous_pointwise_preserves_pointed_directed_complete_partial_order-1
   nil 3353820559
   ("" (skosimp)
    (("" (typepred "p1!1")
      (("" (typepred "p2!1")
        (("" (expand "pointed_directed_complete_partial_order?")
          (("" (flatten)
            (("" (expand "has_least?")
              (("" (expand "fullset")
                (("" (skosimp*)
                  (("" (inst + "LAMBDA (x:T1): t!1")
                    (("1" (expand "least?")
                      (("1" (expand "lower_bound?")
                        (("1" (skosimp)
                          (("1" (expand "continuous_pointwise")
                            (("1" (expand "pointwise")
                              (("1" (skosimp)
                                (("1" (inst -2 "r!1(x!1)") nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2"
                      (lemma "const_continuous[T1,scott_open_sets[T1,p1!1],
                                         T2,scott_open_sets[T2,p2!1]]")
                      (("1" (inst - "t!1")
                        (("1" (expand "const_fun")
                          (("1"
                            (rewrite
                             "scott_continuous_def[T1, T2, p1!1, p2!1]")
                            nil nil))
                          nil))
                        nil)
                       ("2" (rewrite "scott_topology[T2,p2!1]") nil nil)
                       ("3" (lemma "scott_topology[T1,p1!1]")
                        (("3" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pointed_directed_complete_partial_order? const-decl "bool"
     directed_orders orders)
    (pred type-eq-decl nil defined_types nil)
    (T1 formal-type-decl nil pointwise_orders_aux nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (continuous_pointwise_preserves_directed_complete_partial_order
     application-judgement
     "(directed_complete_partial_order?[(scott_continuous?[T1, T2, (d1), (d2)])])"
     pointwise_orders_aux nil)
    (has_least? const-decl "bool" minmax_orders orders)
    (const_continuous formula-decl nil constant_continuity topology)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (scott_open_sets const-decl "setofsets[T]" scott nil)
    (topology? const-decl "bool" topology_prelim topology)
    (const_fun const-decl "[S -> T]" const_fun_def structures)
    (scott_continuous_def formula-decl nil scott_continuity nil)
    (scott_topology formula-decl nil scott nil)
    (least? const-decl "bool" minmax_orders orders)
    (pointwise const-decl "bool" pointwise_orders orders)
    (TRUE const-decl "bool" booleans nil)
    (continuous_pointwise const-decl "bool" pointwise_orders_aux nil)
    (lower_bound? const-decl "bool" bounded_orders orders)
    (p1!1 skolem-const-decl "(pointed_directed_complete_partial_order?[T1])"
     pointwise_orders_aux nil)
    (p2!1 skolem-const-decl "(pointed_directed_complete_partial_order?[T2])"
     pointwise_orders_aux nil)
    (scott_continuous? const-decl "bool" scott_continuity nil)
    (t!1 skolem-const-decl "T2" pointwise_orders_aux nil)
    (fullset const-decl "set" sets nil)
    (T2 formal-type-decl nil pointwise_orders_aux nil))
   nil
   (continuous_pointwise_preserves_pointed_directed_complete_partial_order
    subtype
    "pointwise_orders_aux.continuous_pointwise(pointwise_orders_aux.p1, pointwise_orders_aux.p2)"
    "(directed_orders[(scott_continuity[pointwise_orders_aux.T1, pointwise_orders_aux.T2, (pointwise_orders_aux.p1), (pointwise_orders_aux.p2)].scott_continuous?)].pointed_directed_complete_partial_order?)"))))

