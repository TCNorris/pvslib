(tarski_query_matrix (TQ_vect3k_TCC1 0 (TQ_vect3k_TCC1-1 nil 3620050327 ("" (skeep) (("" (skosimp*) (("" (replaces -1) (("" (assert) (("" (lemma "base_n_lt_n") (("" (lemma "columns_form_matrix") (("" (inst?) (("" (assert) (("" (lemma "base_n_lt_n") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (columns_form_matrix formula-decl nil matrices matrices) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (base_n_lt_n formula-decl nil base_repr reals) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (TQ_vect3k subtype "tarski_query_matrix.GPFun(tarski_query_matrix.i, tarski_query_matrix.j)" "[nat -> integers.subrange(0, 2)]"))) (TQ_vect3k_TCC2 0 (TQ_vect3k_TCC2-1 nil 3621088362 ("" (skeep) (("" (skeep) (("" (rewrite "rows_form_matrix") (("" (lemma "columns_form_matrix") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (rows_form_matrix formula-decl nil matrices matrices) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (form_matrix_square application-judgement "FullMatrix" matrices matrices) (columns_form_matrix formula-decl nil matrices matrices)) nil (TQ_vect3k subtype "matrices.form_matrix(tarski_query_matrix.eij, exponentiation.^(3, ((number_fields.+)(tarski_query_matrix.k, 1))), 1)" "{v: matrices.PosFullMatrix | booleans.AND(matrices.rows(v) = exponentiation.^(3, (number_fields.+)(1, tarski_query_matrix.k)), matrices.columns(v) = 1)}"))) (TQ_vect6k_TCC1 0 (TQ_vect6k_TCC1-2 "" 3804272171 ("" (skeep) (("" (skeep) (("" (skeep) (("" (case "x1<=k") (("1" (inst + "x1") (("1" (replace -2 +) (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "GPFun(i,j)(x1)=0") (("1" (assert) nil nil) ("2" (replaces -1) (("2" (assert) (("2" (assert) (("2" (lemma "base_n_0") (("2" (inst?) (("2" (assert) (("2" (lemma "both_sides_expt_gt1_le_aux") (("2" (inst - "6" "k" "x1-1") (("2" (expand "^") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (TQ_vect6k subtype "tarski_query_matrix.GPFun(tarski_query_matrix.i, tarski_query_matrix.j)" "[nat -> integers.subrange(0, 2)]")) (TQ_vect6k_TCC1-1 nil 3620494852 ("" (skeep) (("" (skeep) (("" (skeep) (("" (case "x1<=k") (("1" (inst + "x1") (("1" (replace -2 +) (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "GPFun(i1,j1)(x1)=0") (("1" (assert) nil nil) ("2" (replaces -1) (("2" (assert) (("2" (assert) (("2" (lemma "base_n_0") (("2" (inst?) (("2" (assert) (("2" (lemma "both_sides_expt_gt1_le_aux") (("2" (inst - "6" "k" "x1-1") (("2" (expand "^") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (x1 skolem-const-decl "nat" tarski_query_matrix nil) (k skolem-const-decl "nat" tarski_query_matrix nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (base_n_0 formula-decl nil base_repr reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (int_plus_int_is_int application-judgement "int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (^ const-decl "real" exponentiation nil) (both_sides_expt_gt1_le_aux formula-decl nil exponentiation nil) (> const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil)) nil (TQ_vect6k subtype "tarski_query_matrix.GPFun(tarski_query_matrix.i, tarski_query_matrix.j)" "[nat -> integers.subrange(0, 2)]"))) (TQ_vect6k_TCC2 0 (TQ_vect6k_TCC2-1 nil 3620494852 ("" (skeep) (("" (skeep) (("" (rewrite "rows_form_matrix") (("" (assert) (("" (lemma "columns_form_matrix") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (rows_form_matrix formula-decl nil matrices matrices) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (columns_form_matrix formula-decl nil matrices matrices) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (form_matrix_square application-judgement "FullMatrix" matrices matrices)) nil (TQ_vect6k subtype "matrices.form_matrix(tarski_query_matrix.eij, exponentiation.^(6, ((number_fields.+)(tarski_query_matrix.k, 1))), 1)" "{v: matrices.PosFullMatrix | booleans.AND(matrices.rows(v) = exponentiation.^(6, (number_fields.+)(1, tarski_query_matrix.k)), matrices.columns(v) = 1)}"))) (NSol_vect3k_TCC1 0 (NSol_vect3k_TCC1-1 nil 3620051889 ("" (skosimp*) (("" (lemma "base_n_lt_n") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil) ((base_n_lt_n formula-decl nil base_repr reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (NSol_vect3k subtype "base_repr.base_n(3, tarski_query_matrix.i)" "[nat -> integers.subrange(0, 2)]"))) (NSol_vect3k_TCC2 0 (NSol_vect3k_TCC2-1 nil 3621088362 ("" (skeep) (("" (rewrite "rows_form_matrix") (("" (lemma "columns_form_matrix") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (rows_form_matrix formula-decl nil matrices matrices) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (form_matrix_square application-judgement "FullMatrix" matrices matrices) (columns_form_matrix formula-decl nil matrices matrices)) nil (NSol_vect3k subtype "matrices.form_matrix(tarski_query_matrix.eij, exponentiation.^(3, ((number_fields.+)(tarski_query_matrix.k, 1))), 1)" "{v: matrices.PosFullMatrix | booleans.AND(matrices.rows(v) = exponentiation.^(3, (number_fields.+)(1, tarski_query_matrix.k)), matrices.columns(v) = 1)}"))) (NSol_vect6k_TCC1 0 (NSol_vect6k_TCC1-1 nil 3620139071 ("" (skosimp*) (("" (lemma "base_n_lt_n") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil) ((base_n_lt_n formula-decl nil base_repr reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (NSol_vect6k subtype "base_repr.base_n(6, tarski_query_matrix.i)" "[nat -> integers.subrange(0, 5)]"))) (NSol_vect6k_TCC2 0 (NSol_vect6k_TCC2-1 nil 3621088362 ("" (skeep) (("" (rewrite "rows_form_matrix") (("" (assert) (("" (lemma "columns_form_matrix") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (rows_form_matrix formula-decl nil matrices matrices) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (columns_form_matrix formula-decl nil matrices matrices) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (form_matrix_square application-judgement "FullMatrix" matrices matrices)) nil (NSol_vect6k subtype "matrices.form_matrix(tarski_query_matrix.eij, exponentiation.^(6, ((number_fields.+)(tarski_query_matrix.k, 1))), 1)" "{v: matrices.PosFullMatrix | booleans.AND(matrices.rows(v) = exponentiation.^(6, (number_fields.+)(1, tarski_query_matrix.k)), matrices.columns(v) = 1)}"))) (A66_inv_TCC1 0 (A66_inv_TCC1-2 "" 3790099406 ("" (eval-formula) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil)) shostak (A66_inv subtype "(: (: 1, 1, 1, 0, 0, 0 :), (: 0, 1, (number_fields.-)(1), 0, 0, 0 :), (: 0, 1, 1, 0, 0, 0 :), (: 0, (number_fields.-)(1), (number_fields.-)(1), 1, 0, 0 :), (: (number_fields.-)(1), (number_fields.-)(1), 0, 0, 1, 0 :), (: (number_fields.-)(1), 0, (number_fields.-)(1), 0, 0, 1 :) :)" "{M: matrices.PosFullMatrix | booleans.AND(matrices.rows(M) = 6, matrices.columns(M) = 6)}")) (A66_inv_TCC1-1 nil 3620408236 ("" (eval-formula)) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil)) nil (A66_inv subtype "(: (: 1, 1, 1, 0, 0, 0 :), (: 0, 1, (number_fields.-)(1), 0, 0, 0 :), (: 0, 1, 1, 0, 0, 0 :), (: 0, (number_fields.-)(1), (number_fields.-)(1), 1, 0, 0 :), (: (number_fields.-)(1), (number_fields.-)(1), 0, 0, 1, 0 :), (: (number_fields.-)(1), 0, (number_fields.-)(1), 0, 0, 1 :) :)" "{M: matrices.PosFullMatrix | booleans.AND(matrices.rows(M) = 6, matrices.columns(M) = 6)}"))) (A66_TCC1 0 (A66_TCC1-1 nil 3621152270 ("" (skeep) (("" (eval-formula) nil nil)) nil) ((TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (A66 subtype "tarski_query_matrix.A66_inv" "{SQ | booleans.OR(matrix_props.det(matrix_inv.SQ) /= 0, matrix_inv.invertible?(matrix_inv.SQ))}"))) (A66_TCC2 0 (A66_TCC2-2 "" 3790099407 ("" (eval-formula) nil nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil)) shostak (A66 subtype "(: (: 1, 0, (number_fields.-)(1), 0, 0, 0 :), (: 0, number_fields./(1, 2), number_fields./(1, 2), 0, 0, 0 :), (: 0, number_fields./((number_fields.-)(1), 2), number_fields./(1, 2), 0, 0, 0 :), (: 0, 0, 1, 1, 0, 0 :), (: 1, number_fields./(1, 2), number_fields./((number_fields.-)(1), 2), 0, 1, 0 :), (: 1, number_fields./((number_fields.-)(1), 2), number_fields./((number_fields.-)(1), 2), 0, 0, 1 :) :)" "{M: matrices.PosFullMatrix | booleans.AND(matrices.rows(M) = 6, booleans.AND(matrices.columns(M) = 6, M = matrix_inv.inverse(tarski_query_matrix.A66_inv)))}")) (A66_TCC2-1 nil 3621152270 ("" (eval-formula)) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil)) nil (A66 subtype "(: (: 1, 0, (number_fields.-)(1), 0, 0, 0 :), (: 0, number_fields./(1, 2), number_fields./(1, 2), 0, 0, 0 :), (: 0, number_fields./((number_fields.-)(1), 2), number_fields./(1, 2), 0, 0, 0 :), (: 0, 0, 1, 1, 0, 0 :), (: 1, number_fields./(1, 2), number_fields./((number_fields.-)(1), 2), 0, 1, 0 :), (: 1, number_fields./((number_fields.-)(1), 2), number_fields./((number_fields.-)(1), 2), 0, 0, 1 :) :)" "{M: matrices.PosFullMatrix | booleans.AND(matrices.rows(M) = 6, booleans.AND(matrices.columns(M) = 6, M = matrix_inv.inverse(tarski_query_matrix.A66_inv)))}"))) (multi_sturm_tarski_6by6 0 (multi_sturm_tarski_6by6-2 "" 3790099415 ("" (skeep) (("" (case "2<3^(1+k) AND 3^(1+k)<6^(1+k)") (("1" (label "2lem" -1) (("1" (hide "2lem") (("1" (rewrite "full_matrix_eq" +) (("1" (invoke (case "NOT %1") (! 2 1)) (("1" (hide 3) (("1" (rewrite "rows_mult") (("1" (assert) (("1" (lemma "tensor_power_rows_alt") (("1" (inst?) (("1" (replaces -1 :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (invoke (case "NOT %1") (! 2 1)) (("1" (hide (-1 3)) (("1" (rewrite "columns_mult") (("1" (assert) nil nil) ("2" (lemma "tensor_power_rows_alt") (("2" (inst?) (("2" (expand "rows" -1 2) (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (skeep) (("2" (typepred "j") (("2" (typepred "i") (("2" (case "NOT i < 6^(k+1)") (("1" (assert) nil nil) ("2" (case "NOT j = 0") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (rewrite "entry_mult") (("2" (lemma "tensor_power_rows_alt") (("2" (inst?) (("2" (assert) (("2" (lemma "dot_eq_sigma") (("2" (expand "*" + 1) (("2" (rewrite -1 +) (("2" (expand "TQ_vect6k" +) (("2" (rewrite "entry_form_matrix") (("1" (case "EXISTS (p: upto(k)): base_n(6, i)(p) > 2") (("1" (replace -1) (("1" (rewrite "length_row" +) (("1" (rewrite "length_col" +) (("1" (assert) (("1" (lemma "tensor_power_columns_alt") (("1" (inst?) (("1" (assert) (("1" (replace -1 :dir rl) (("1" (expand "min" +) (("1" (case "NOT columns(A66_inv) = 6") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (lemma "mult_tarski_query_simple_6_above_2") (("2" (inst - "GF" "KF" "base_n(6,i)" "a" "k" "n") (("1" (assert) (("1" (replace -4) (("1" (replace -13) (("1" (invoke (case "%1 = %2") (! -1 1) (! 2 2)) (("1" (assert) nil nil) ("2" (hide (-1 3)) (("2" (rewrite "sigma_eq") (("1" (hide 2) (("1" (skosimp*) (("1" (case "FORALL (a1,a2,b1,b2:real): a1=b1 AND a2=b2 IMPLIES a1*a2 = b1*b2") (("1" (rewrite -1 1) (("1" (hide 2) (("1" (rewrite "access_row") (("1" (lemma "tensor_entry") (("1" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (expand "sign_coeff6_zero") (("1" (rewrite "product_eq") (("1" (hide 2) (("1" (skosimp*) (("1" (case "NOT rows(A66_inv)=6") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (replace -3) (("2" (expand "entry_pick" +) (("2" (case "NOT FORALL (ii1,jj2:upto(5)): IF ii1 = 0
                                          THEN (IF jj2 >= 3 THEN 0 ELSE 1 ENDIF)
                                        ELSIF ii1 = 1
                                          THEN (IF jj2 = 1 THEN 1
                                                ELSIF jj2 = 2 THEN -1
                                                ELSE 0
                                                ENDIF)
                                        ELSIF ii1 = 2
                                          THEN (IF 1 <= jj2 AND jj2 <= 2
                                                  THEN 1
                                                ELSE 0
                                                ENDIF)
                                        ELSIF ii1 = 3
                                          THEN (IF 1 <= jj2 AND jj2 <= 2
                                                  THEN -1
                                                ELSIF jj2 = 3 THEN 1
                                                ELSE 0
                                                ENDIF)
                                        ELSIF ii1 = 4
                                          THEN (IF jj2 <= 1 THEN -1
                                                ELSIF jj2 = 4 THEN 1
                                                ELSE 0
                                                ENDIF)
                                        ELSIF ii1 = 5
                                          THEN (IF jj2 = 0 OR jj2 = 2 THEN -1
                                                ELSIF jj2 = 5 THEN 1
                                                ELSE 0
                                                ENDIF)
                                        ELSE 0
                                        ENDIF
                                         = entry(A66_inv)(ii1, jj2)") (("1" (hide-all-but 1) (("1" (eval-formula) nil nil)) nil) ("2" (expand "sign_coeff6_zero_entry" +) (("2" (inst - "base_n(6,i)(n!2)" "base_n(6,n!1)(n!2)") (("1" (assert) (("1" (hide-all-but 1) (("1" (lemma "base_n_lt_n") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide-all-but 1) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (skeep) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "access_col") (("2" (expand "NSol_vect6k" +) (("2" (rewrite "entry_form_matrix") (("2" (hide 2) (("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (hide-all-but 1) (("3" (skosimp*) (("3" (lemma "base_n_lt_n") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skosimp*) (("3" (lemma "base_n_lt_n") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (skosimp*) (("4" (lemma "base_n_lt_n") (("4" (inst?) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "tensor_power_rows_alt") (("2" (inst?) (("2" (expand "rows" -1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (lemma "mult_tarski_query_simple_6_0_to_3") (("2" (inst - "GF" "base_n(6,i)" "KF" "a" "k" "n") (("2" (assert) (("2" (replace -10) (("2" (replace -1 +) (("2" (rewrite "length_row" +) (("1" (rewrite "length_col" +) (("1" (assert) (("1" (lemma "tensor_power_columns_alt") (("1" (inst?) (("1" (assert) (("1" (replace -1 :dir rl) (("1" (expand "min" +) (("1" (case "NOT columns(A66_inv) = 6") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (rewrite "sigma_eq") (("2" (hide 4) (("2" (skosimp*) (("2" (expand "sign_prod_coeff6" +) (("2" (case "EXISTS (p: upto(k)): base_n(6, n!1)(p) >= 3") (("1" (replace -1) (("1" (case "access(row(tensor_power_alt(A66_inv, 1 + k))(i))(n!1) = 0") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (rewrite "access_row") (("2" (lemma "tensor_entry") (("2" (inst?) (("2" (assert) (("2" (replaces -1) (("2" (expand "sign_prod_coeff6") (("2" (case "NOT rows(A66_inv)=6") (("1" (assert) nil nil) ("2" (replace -1) (("2" (replace -3) (("2" (assert) (("2" (lemma "product_eq_zero[nat]") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (skeep -2) (("2" (inst + "p") (("2" (expand "entry_pick" +) (("2" (case "FORALL (ii1,ii2:upto(5)): ii1<=2 AND ii2>=3 IMPLIES entry(A66_inv)(ii1,ii2)=0") (("1" (inst + "p") (("1" (inst - "base_n(6,i)(p)" "base_n(6,n!1)(p)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (lemma "base_n_lt_n") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (eval-formula) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (case "FORALL (a1,a2,b1,b2:real): a1=b1 AND a2=b2 IMPLIES a1*a2 = b1*b2") (("1" (rewrite -1 2) (("1" (hide 3) (("1" (rewrite "access_row") (("1" (lemma "tensor_entry") (("1" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (case "NOT rows(A66_inv)=6") (("1" (assert) nil nil) ("2" (replace -1) (("2" (replace -3) (("2" (assert) (("2" (expand "sign_prod" +) (("2" (rewrite "product_eq") (("1" (hide 2) (("1" (skosimp*) (("1" (hide -) (("1" (expand "entry_pick" +) (("1" (inst + "n!2") (("1" (inst + "n!2") (("1" (assert) (("1" (expand "sig_seq") (("1" (case "FORALL (ii1,ii2:upto(2)): entry(A66_inv)(ii1,ii2) = sig(ii2)^ii1") (("1" (inst - "base_n(6,i)(n!2)" "base_n(6,n!1)(n!2)") (("1" (assert) nil nil)) nil) ("2" (eval-formula 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("3" (skeep) (("3" (inst + "x1") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "upper_is_bound") (("2" (inst?) (("2" (assert) (("2" (split -1) (("1" (assert) nil nil) ("2" (expand "upper_index") (("2" (lift-if) (("2" (ground) (("2" (lemma "log_nat_bounds") (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (case "log_nat(n!1,6)`1<=k") (("1" (assert) nil nil) ("2" (lemma "both_sides_expt_gt1_le_aux") (("2" (inst - "6" "k" "log_nat(n!1,6)`1-1") (("2" (typepred "n!1") (("2" (expand "^") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (rewrite "access_col") (("2" (expand "NSol_vect6k" +) (("2" (rewrite "entry_form_matrix") (("1" (expand "NSol_seq6" 1) (("1" (replace 2) (("1" (expand "NSol_all") (("1" (expand "NSol") (("1" (case "Sol(k, a, n, GF, KF, sig_seq(base_n(6, n!1))) =
     Sol_all(k, a, n, GF, KF, base_n(6, n!1))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (decompose-equality 1) (("2" (iff) (("2" (expand "Sol" 1) (("2" (expand "Sol_all" 1) (("2" (ground) (("1" (skosimp 1) (("1" (inst - "i!1") (("1" (inst + "i!1") (("1" (assert) (("1" (expand "sig_seq") (("1" (expand "sig") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst - "i!1") (("2" (expand "sig_seq") (("2" (expand "sig") (("2" (lift-if) (("2" (assert) (("2" (inst + "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "rows" -3 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst - "6" "i!1" "x1!1") (("2" (assert) (("2" (inst + "x1!1") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "upper_is_bound") (("2" (inst?) (("2" (assert) (("2" (expand "upper_index") (("2" (lift-if) (("2" (ground) (("2" (case "log_nat(i!1,6)`1<=k") (("1" (assert) nil nil) ("2" (case "NOT i!1 <=expt(6,1+k)-1") (("1" (assert) (("1" (expand "^" +) (("1" (assert) (("1" (case "NOT FORALL (i1,i2:int): i1<i2 IMPLIES i1<=i2-1") (("1" (skeep) (("1" (assert) nil nil)) nil) ("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "log_nat_bounds") (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (expand "^") (("2" (assert) (("2" (lemma "both_sides_expt_gt1_le_aux") (("2" (inst - "6" "k" "log_nat(i!1,6)`1-1") (("2" (typepred "i!1") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (case "FORALL (dd:nat): 2 < 3 ^ (1 + dd) AND 3 ^ (1 + dd) < 6 ^ (1 + dd)") (("1" (inst - "k") nil nil) ("2" (hide 2) (("2" (induct "dd") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skeep) (("3" (expand "^") (("3" (expand "expt" +) (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (^ const-decl "real" exponentiation nil) (>= const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (rows_mult formula-decl nil matrices matrices) (tensor_power_rows_alt formula-decl nil tensor_product matrices) (TRUE const-decl "bool" booleans nil) (nat_exp application-judgement "nat" exponentiation nil) (columns_mult formula-decl nil matrices matrices) (listn_0 name-judgement "listn[int](0)" gcd_coeff Sturm) (expt def-decl "real" exponentiation nil) (nat_expt application-judgement "nat" exponentiation nil) (x1!1 skolem-const-decl "nat" tarski_query_matrix nil) (length_row formula-decl nil matrices matrices) (k skolem-const-decl "nat" tarski_query_matrix nil) (a skolem-const-decl "[nat -> int]" tarski_query_matrix nil) (n skolem-const-decl "posnat" tarski_query_matrix nil) (GF skolem-const-decl "[nat -> [nat -> int]]" tarski_query_matrix nil) (KF skolem-const-decl "[nat -> nat]" tarski_query_matrix nil) (i skolem-const-decl "below(rows(TQ_vect6k(k, a, n, GF, KF)))" tarski_query_matrix nil) (access const-decl "real" matrices matrices) (NSol_all const-decl "nat" poly_families nil) (sign_coeff6_zero const-decl "subrange(-1, 1)" poly_families nil) (- const-decl "[numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (sigma def-decl "real" sigma reals) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (sigma_int application-judgement "int" sigma_nat reals) (sigma_eq formula-decl nil sigma reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (access_row formula-decl nil matrices matrices) (T_low type-eq-decl nil product reals) (T_high type-eq-decl nil product reals) (entry_pick const-decl "real" tensor_product matrices) (sign_coeff6_zero_entry const-decl "subrange(-1, 1)" poly_families nil) (product_eq formula-decl nil product reals) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (n!2 skolem-const-decl "subrange(0, k)" tarski_query_matrix nil) (n!1 skolem-const-decl "subrange(0, 6 ^ (1 + k) - 1)" tarski_query_matrix nil) (base_n_lt_n formula-decl nil base_repr reals) (tensor_entry formula-decl nil tensor_product matrices) (access_col formula-decl nil matrices matrices) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (mult_tarski_query_simple_6_above_2 formula-decl nil poly_families nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (tensor_power_columns_alt formula-decl nil tensor_product matrices) (length_col formula-decl nil matrices matrices) (mult_tarski_query_simple_6_0_to_3 formula-decl nil poly_families nil) (NSol_seq6 const-decl "nat" poly_families nil) (sign_prod_coeff6 const-decl "subrange(-1, 1)" poly_families nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (product_eq_zero formula-decl nil product reals) (n!1 skolem-const-decl "subrange(0, 6 ^ (1 + k) - 1)" tarski_query_matrix nil) (p skolem-const-decl "upto(k)" tarski_query_matrix nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (Sol const-decl "finite_set[real]" poly_families nil) (Sol_all const-decl "finite_set[real]" poly_families nil) (i!1 skolem-const-decl "nat" tarski_query_matrix nil) (NSol const-decl "nat" poly_families nil) (log_nat_bounds formula-decl nil log_nat reals) (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat reals) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (int_plus_int_is_int application-judgement "int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (both_sides_expt_gt1_le_aux formula-decl nil exponentiation nil) (above nonempty-type-eq-decl nil integers nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (upper_index const-decl "nat" base_repr reals) (upper_is_bound formula-decl nil base_repr reals) (x1 skolem-const-decl "nat" tarski_query_matrix nil) (sig const-decl "subrange(-1, 1)" poly_families nil) (int_exp application-judgement "int" exponentiation nil) (sign_prod const-decl "subrange(-1, 1)" poly_families nil) (sig_seq const-decl "subrange(-1, 1)" poly_families nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (form_matrix_square application-judgement "FullMatrix" matrices matrices) (entry_form_matrix formula-decl nil matrices matrices) (IF const-decl "[boolean, T, T -> T]" if_def nil) (base_n def-decl "nat" base_repr reals) (subrange type-eq-decl nil integers nil) (TQ_fam const-decl "int" poly_families nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (dot_eq_sigma formula-decl nil matrices matrices) (entry_mult formula-decl nil matrices matrices) (posint_exp application-judgement "posint" exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NSol_vect6k const-decl "{v: PosFullMatrix | rows(v) = 6 ^ (k + 1) AND columns(v) = 1}" tarski_query_matrix nil) (A66_inv const-decl "{M: PosFullMatrix | rows(M) = 6 AND columns(M) = 6}" tarski_query_matrix nil) (tensor_power_alt def-decl "PosFullMatrix" tensor_product matrices) (* const-decl "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i: nat, j: nat): entry(A)(i, j) = row(M)(i) * col(N)(j)}" matrices matrices) (col def-decl "VectorN(rows(M))" matrices matrices) (VectorN type-eq-decl nil matrices matrices) (row const-decl "Vector" matrices matrices) (* const-decl "real" matrices matrices) (Vector type-eq-decl nil matrices matrices) (entry const-decl "real" matrices matrices) (MatrixMN type-eq-decl nil matrices matrices) (TQ_vect6k const-decl "{v: PosFullMatrix | rows(v) = 6 ^ (k + 1) AND columns(v) = 1}" tarski_query_matrix nil) (PosFullMatrix type-eq-decl nil matrices matrices) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices matrices) (rows const-decl "nat" matrices matrices) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (FullMatrix type-eq-decl nil matrices matrices) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Matrix type-eq-decl nil matrices matrices) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (full_matrix_eq formula-decl nil matrices matrices) (mult_full application-judgement "FullMatrix" matrices matrices) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil)) shostak) (multi_sturm_tarski_6by6-1 nil 3620495242 ("" (skeep) (("" (case "2<3^(1+k) AND 3^(1+k)<6^(1+k)") (("1" (label "2lem" -1) (("1" (hide "2lem") (("1" (rewrite "full_matrix_eq" +) (("1" (invoke (case "NOT %1") (! 2 1)) (("1" (hide 3) (("1" (rewrite "rows_mult") (("1" (assert) (("1" (lemma "tensor_power_rows_alt") (("1" (inst?) (("1" (replaces -1 :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (invoke (case "NOT %1") (! 2 1)) (("1" (hide (-1 3)) (("1" (rewrite "columns_mult") (("1" (assert) nil nil) ("2" (lemma "tensor_power_rows_alt") (("2" (inst?) (("2" (expand "rows" -1 2) (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (skeep) (("2" (typepred "j") (("2" (typepred "i") (("2" (case "NOT i < 6^(k+1)") (("1" (assert) nil nil) ("2" (case "NOT j = 0") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (rewrite "entry_mult") (("2" (assert) (("2" (lemma "tensor_power_rows_alt") (("2" (inst?) (("2" (assert) (("2" (lemma "dot_eq_sigma") (("2" (expand "*" + 1) (("2" (rewrite -1 +) (("2" (expand "TQ_vect6k" +) (("2" (rewrite "entry_form_matrix") (("1" (case "EXISTS (p: upto(k)): base_n(6, i)(p) > 2") (("1" (replace -1) (("1" (rewrite "length_row" +) (("1" (rewrite "length_col" +) (("1" (assert) (("1" (lemma "tensor_power_columns_alt") (("1" (inst?) (("1" (assert) (("1" (replace -1 :dir rl) (("1" (expand "min" +) (("1" (case "NOT columns(A66_inv) = 6") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (lemma "mult_tarski_query_simple_6_above_2") (("2" (inst - "GF" "KF" "base_n(6,i)" "a" "k" "n") (("1" (assert) (("1" (replace -4) (("1" (replace -13) (("1" (invoke (case "%1 = %2") (! -1 1) (! 2 2)) (("1" (assert) nil nil) ("2" (hide (-1 3)) (("2" (rewrite "sigma_eq") (("1" (hide 2) (("1" (skosimp*) (("1" (case "FORALL (a1,a2,b1,b2:real): a1=b1 AND a2=b2 IMPLIES a1*a2 = b1*b2") (("1" (rewrite -1 1) (("1" (hide 2) (("1" (rewrite "access_row") (("1" (lemma "tensor_entry") (("1" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (expand "sign_coeff6_zero") (("1" (rewrite "product_eq") (("1" (hide 2) (("1" (skosimp*) (("1" (case "NOT rows(A66_inv)=6") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (replace -3) (("2" (expand "entry_pick" +) (("2" (case "NOT FORALL (ii1,jj2:upto(5)): IF ii1 = 0
                                          THEN (IF jj2 >= 3 THEN 0 ELSE 1 ENDIF)
                                        ELSIF ii1 = 1
                                          THEN (IF jj2 = 1 THEN 1
                                                ELSIF jj2 = 2 THEN -1
                                                ELSE 0
                                                ENDIF)
                                        ELSIF ii1 = 2
                                          THEN (IF 1 <= jj2 AND jj2 <= 2
                                                  THEN 1
                                                ELSE 0
                                                ENDIF)
                                        ELSIF ii1 = 3
                                          THEN (IF 1 <= jj2 AND jj2 <= 2
                                                  THEN -1
                                                ELSIF jj2 = 3 THEN 1
                                                ELSE 0
                                                ENDIF)
                                        ELSIF ii1 = 4
                                          THEN (IF jj2 <= 1 THEN -1
                                                ELSIF jj2 = 4 THEN 1
                                                ELSE 0
                                                ENDIF)
                                        ELSIF ii1 = 5
                                          THEN (IF jj2 = 0 OR jj2 = 2 THEN -1
                                                ELSIF jj2 = 5 THEN 1
                                                ELSE 0
                                                ENDIF)
                                        ELSE 0
                                        ENDIF
                                         = entry(A66_inv)(ii1, jj2)") (("1" (hide-all-but 1) (("1" (eval-formula) nil nil)) nil) ("2" (expand "sign_coeff6_zero_entry" +) (("2" (inst - "base_n(6,i)(n!2)" "base_n(6,n!1)(n!2)") (("1" (assert) (("1" (hide-all-but 1) (("1" (lemma "base_n_lt_n") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide-all-but 1) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (skeep) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "access_col") (("2" (expand "NSol_vect6k" +) (("2" (rewrite "entry_form_matrix") (("2" (hide 2) (("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (hide-all-but 1) (("3" (skosimp*) (("3" (lemma "base_n_lt_n") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skosimp*) (("3" (lemma "base_n_lt_n") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (skosimp*) (("4" (lemma "base_n_lt_n") (("4" (inst?) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "tensor_power_rows_alt") (("2" (inst?) (("2" (expand "rows" -1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (lemma "mult_tarski_query_simple_6_0_to_3") (("2" (inst - "GF" "base_n(6,i)" "KF" "a" "k" "n") (("2" (assert) (("2" (replace -10) (("2" (replace -1 +) (("2" (rewrite "length_row" +) (("1" (rewrite "length_col" +) (("1" (assert) (("1" (lemma "tensor_power_columns_alt") (("1" (inst?) (("1" (assert) (("1" (replace -1 :dir rl) (("1" (expand "min" +) (("1" (case "NOT columns(A66_inv) = 6") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (rewrite "sigma_eq") (("2" (hide 4) (("2" (skosimp*) (("2" (expand "sign_prod_coeff6" +) (("2" (case "EXISTS (p: upto(k)): base_n(6, n!1)(p) >= 3") (("1" (replace -1) (("1" (case "access(row(tensor_power_alt(A66_inv, 1 + k))(i))(n!1) = 0") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (rewrite "access_row") (("2" (lemma "tensor_entry") (("2" (inst?) (("2" (assert) (("2" (replaces -1) (("2" (expand "sign_prod_coeff6") (("2" (case "NOT rows(A66_inv)=6") (("1" (assert) nil nil) ("2" (replace -1) (("2" (replace -3) (("2" (assert) (("2" (lemma "product_eq_zero[nat]") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (skeep -2) (("2" (inst + "p") (("2" (expand "entry_pick" +) (("2" (case "FORALL (ii1,ii2:upto(5)): ii1<=2 AND ii2>=3 IMPLIES entry(A66_inv)(ii1,ii2)=0") (("1" (inst + "p") (("1" (inst - "base_n(6,i)(p)" "base_n(6,n!1)(p)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (lemma "base_n_lt_n") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (eval-formula) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (case "FORALL (a1,a2,b1,b2:real): a1=b1 AND a2=b2 IMPLIES a1*a2 = b1*b2") (("1" (rewrite -1 2) (("1" (hide 3) (("1" (rewrite "access_row") (("1" (lemma "tensor_entry") (("1" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (case "NOT rows(A66_inv)=6") (("1" (assert) nil nil) ("2" (replace -1) (("2" (replace -3) (("2" (assert) (("2" (expand "sign_prod" +) (("2" (rewrite "product_eq") (("1" (hide 2) (("1" (skosimp*) (("1" (hide -) (("1" (expand "entry_pick" +) (("1" (inst + "n!2") (("1" (inst + "n!2") (("1" (assert) (("1" (expand "sig_seq") (("1" (case "FORALL (ii1,ii2:upto(2)): entry(A66_inv)(ii1,ii2) = sig(ii2)^ii1") (("1" (inst - "base_n(6,i)(n!2)" "base_n(6,n!1)(n!2)") (("1" (assert) nil nil)) nil) ("2" (eval-formula 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("3" (skeep) (("3" (inst + "x1") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "upper_is_bound") (("2" (inst?) (("2" (assert) (("2" (split -1) (("1" (assert) nil nil) ("2" (expand "upper_index") (("2" (lift-if) (("2" (ground) (("2" (lemma "log_nat_bounds") (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (case "log_nat(n!1,6)`1<=k") (("1" (assert) nil nil) ("2" (lemma "both_sides_expt_gt1_le_aux") (("2" (inst - "6" "k" "log_nat(n!1,6)`1-1") (("2" (typepred "n!1") (("2" (expand "^") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (rewrite "access_col") (("2" (expand "NSol_vect6k" +) (("2" (rewrite "entry_form_matrix") (("1" (expand "NSol_seq6" 1) (("1" (replace 2) (("1" (expand "NSol_all") (("1" (expand "NSol") (("1" (case "Sol(k, a, n, GF, KF, sig_seq(base_n(6, n!1))) =
     Sol_all(k, a, n, GF, KF, base_n(6, n!1))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (decompose-equality 1) (("2" (iff) (("2" (expand "Sol" 1) (("2" (expand "Sol_all" 1) (("2" (ground) (("1" (skosimp 1) (("1" (inst - "i!1") (("1" (inst + "i!1") (("1" (assert) (("1" (expand "sig_seq") (("1" (expand "sig") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst - "i!1") (("2" (expand "sig_seq") (("2" (expand "sig") (("2" (lift-if) (("2" (assert) (("2" (inst + "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "rows" -3 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst - "6" "i!1" "x1!1") (("2" (assert) (("2" (inst + "x1!1") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "upper_is_bound") (("2" (inst?) (("2" (assert) (("2" (expand "upper_index") (("2" (lift-if) (("2" (ground) (("2" (case "log_nat(i!1,6)`1<=k") (("1" (assert) nil nil) ("2" (case "NOT i!1 <=expt(6,1+k)-1") (("1" (assert) (("1" (expand "^" +) (("1" (assert) (("1" (case "NOT FORALL (i1,i2:int): i1<i2 IMPLIES i1<=i2-1") (("1" (skeep) (("1" (assert) nil nil)) nil) ("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "log_nat_bounds") (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (expand "^") (("2" (assert) (("2" (lemma "both_sides_expt_gt1_le_aux") (("2" (inst - "6" "k" "log_nat(i!1,6)`1-1") (("2" (typepred "i!1") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (case "FORALL (dd:nat): 2 < 3 ^ (1 + dd) AND 3 ^ (1 + dd) < 6 ^ (1 + dd)") (("1" (inst - "k") nil nil) ("2" (hide 2) (("2" (induct "dd") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skeep) (("3" (expand "^") (("3" (expand "expt" +) (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (^ const-decl "real" exponentiation nil) (>= const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (rows_mult formula-decl nil matrices matrices) (tensor_power_rows_alt formula-decl nil tensor_product matrices) (TRUE const-decl "bool" booleans nil) (nat_exp application-judgement "nat" exponentiation nil) (columns_mult formula-decl nil matrices matrices) nil (expt def-decl "real" exponentiation nil) (nat_expt application-judgement "nat" exponentiation nil) nil (length_row formula-decl nil matrices matrices) nil nil nil nil nil nil (access const-decl "real" matrices matrices) (NSol_all const-decl "nat" poly_families nil) (sign_coeff6_zero const-decl "subrange(-1, 1)" poly_families nil) (- const-decl "[numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (sigma def-decl "real" sigma reals) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) nil (sigma_eq formula-decl nil sigma reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (access_row formula-decl nil matrices matrices) (T_low type-eq-decl nil product reals) (T_high type-eq-decl nil product reals) (entry_pick const-decl "real" tensor_product matrices) (sign_coeff6_zero_entry const-decl "subrange(-1, 1)" poly_families nil) (product_eq formula-decl nil product reals) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) nil nil (base_n_lt_n formula-decl nil base_repr reals) (tensor_entry formula-decl nil tensor_product matrices) (access_col formula-decl nil matrices matrices) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (mult_tarski_query_simple_6_above_2 formula-decl nil poly_families nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (tensor_power_columns_alt formula-decl nil tensor_product matrices) (length_col formula-decl nil matrices matrices) (mult_tarski_query_simple_6_0_to_3 formula-decl nil poly_families nil) (NSol_seq6 const-decl "nat" poly_families nil) (sign_prod_coeff6 const-decl "subrange(-1, 1)" poly_families nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (product_eq_zero formula-decl nil product reals) nil nil (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (Sol const-decl "finite_set[real]" poly_families nil) (Sol_all const-decl "finite_set[real]" poly_families nil) nil (NSol const-decl "nat" poly_families nil) (log_nat_bounds formula-decl nil log_nat reals) (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat reals) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (int_plus_int_is_int application-judgement "int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (both_sides_expt_gt1_le_aux formula-decl nil exponentiation nil) (above nonempty-type-eq-decl nil integers nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (upper_index const-decl "nat" base_repr reals) (upper_is_bound formula-decl nil base_repr reals) nil (sig const-decl "subrange(-1, 1)" poly_families nil) (int_exp application-judgement "int" exponentiation nil) (sign_prod const-decl "subrange(-1, 1)" poly_families nil) (sig_seq const-decl "subrange(-1, 1)" poly_families nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (form_matrix_square application-judgement "FullMatrix" matrices matrices) (entry_form_matrix formula-decl nil matrices matrices) (IF const-decl "[boolean, T, T -> T]" if_def nil) (base_n def-decl "nat" base_repr reals) (subrange type-eq-decl nil integers nil) (TQ_fam const-decl "int" poly_families nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (dot_eq_sigma formula-decl nil matrices matrices) (entry_mult formula-decl nil matrices matrices) (posint_exp application-judgement "posint" exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NSol_vect6k const-decl "{v: PosFullMatrix | rows(v) = 6 ^ (k + 1) AND columns(v) = 1}" tarski_query_matrix nil) (A66_inv const-decl "{M: PosFullMatrix | rows(M) = 6 AND columns(M) = 6}" tarski_query_matrix nil) (tensor_power_alt def-decl "PosFullMatrix" tensor_product matrices) nil (col def-decl "VectorN(rows(M))" matrices matrices) (VectorN type-eq-decl nil matrices matrices) (row const-decl "Vector" matrices matrices) (* const-decl "real" matrices matrices) (Vector type-eq-decl nil matrices matrices) (entry const-decl "real" matrices matrices) (MatrixMN type-eq-decl nil matrices matrices) (TQ_vect6k const-decl "{v: PosFullMatrix | rows(v) = 6 ^ (k + 1) AND columns(v) = 1}" tarski_query_matrix nil) (PosFullMatrix type-eq-decl nil matrices matrices) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices matrices) (rows const-decl "nat" matrices matrices) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (FullMatrix type-eq-decl nil matrices matrices) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Matrix type-eq-decl nil matrices matrices) nil (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (full_matrix_eq formula-decl nil matrices matrices) (mult_full application-judgement "FullMatrix" matrices matrices) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil)) nil)) (multi_sturm_tarski_NSol 0 (multi_sturm_tarski_NSol-1 nil 3621152436 ("" (skeep) (("" (lemma "multi_sturm_tarski_6by6") (("" (inst?) (("" (assert) (("" (replace -2) (("" (case "NOT tensor_power_alt(A66, 1 + k)*TQ_vect6k(k, a, n, GF, KF) =
       tensor_power_alt(A66, 1 + k)*(tensor_power_alt(A66_inv, 1 + k) * NSol_vect6k(k, a, n, GF, KF))") (("1" (assert) nil nil) ("2" (rewrite "matrix_mult_assoc" :dir rl) (("1" (rewrite "power_assoc" :dir rl) (("1" (rewrite "power_assoc" :dir rl) (("1" (lemma "invertible_tensor_power") (("1" (inst - "A66_inv" "1+k") (("1" (split -) (("1" (flatten) (("1" (typepred "A66") (("1" (replace -7 :dir rl) (("1" (replace -9 :dir rl) (("1" (rewrite "mult_inverse_left") (("1" (rewrite "mult_Id_left") (("1" (assert) nil nil) ("2" (lemma "tensor_power_rows") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "invertible?") (("2" (inst + "A66") (("2" (hide-all-but 1) (("2" (eval-formula) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (lemma "tensor_power_rows_alt") (("2" (inst?) (("2" (assert) (("2" (expand "rows" -1 2) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((multi_sturm_tarski_6by6 formula-decl nil tarski_query_matrix nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (mult_full application-judgement "FullMatrix" matrices matrices) (NSol_vect6k const-decl "{v: PosFullMatrix | rows(v) = 6 ^ (k + 1) AND columns(v) = 1}" tarski_query_matrix nil) (TQ_vect6k const-decl "{v: PosFullMatrix | rows(v) = 6 ^ (k + 1) AND columns(v) = 1}" tarski_query_matrix nil) (^ const-decl "real" exponentiation nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (A66 const-decl "{M: PosFullMatrix | rows(M) = 6 AND columns(M) = 6 AND M = inverse(A66_inv)}" tarski_query_matrix nil) (A66_inv const-decl "{M: PosFullMatrix | rows(M) = 6 AND columns(M) = 6}" tarski_query_matrix nil) (inverse const-decl "{IQ |
   rows(IQ) = rows(SQ) AND
    IQ * SQ = Id(rows(SQ)) AND SQ * IQ = Id(rows(SQ))}" matrix_inv matrices) (Id const-decl "{M: SquareMatrix(pm) |
   (FORALL (i: nat, j: nat):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" matrices matrices) (IF const-decl "[boolean, T, T -> T]" if_def nil) (SquareMatrix type-eq-decl nil matrices matrices) (invertible? const-decl "bool" matrix_inv matrices) (det def-decl "real" matrix_props matrices) (/= const-decl "boolean" notequal nil) (Square type-eq-decl nil matrices matrices) (tensor_power_alt def-decl "PosFullMatrix" tensor_product matrices) (PosFullMatrix type-eq-decl nil matrices matrices) (FullMatrix type-eq-decl nil matrices matrices) (* const-decl "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i: nat, j: nat): entry(A)(i, j) = row(M)(i) * col(N)(j)}" matrices matrices) (col def-decl "VectorN(rows(M))" matrices matrices) (VectorN type-eq-decl nil matrices matrices) (row const-decl "Vector" matrices matrices) (* const-decl "real" matrices matrices) (Vector type-eq-decl nil matrices matrices) (entry const-decl "real" matrices matrices) (MatrixMN type-eq-decl nil matrices matrices) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices matrices) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (rows const-decl "nat" matrices matrices) (length def-decl "nat" list_props nil) (Matrix type-eq-decl nil matrices matrices) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (tensor_power_rows_alt formula-decl nil tensor_product matrices) (power_assoc formula-decl nil tensor_product matrices) (invertible_tensor_power formula-decl nil tensor_product matrices) (mult_Id_left formula-decl nil matrices matrices) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_exp application-judgement "nat" exponentiation nil) (tensor_power_rows formula-decl nil tensor_product matrices) (mult_inverse_left formula-decl nil matrix_inv matrices) (tensor_power def-decl "PosFullMatrix" tensor_product matrices) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (matrix_mult_assoc formula-decl nil matrices matrices) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (A63_TCC1 0 (A63_TCC1-2 "" 3790099418 ("" (eval-formula) nil nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil)) shostak (A63 subtype "(: (: 1, 0, (number_fields.-)(1) :), (: 0, number_fields./(1, 2), number_fields./(1, 2) :), (: 0, number_fields./((number_fields.-)(1), 2), number_fields./(1, 2) :), (: 0, 0, 1 :), (: 1, number_fields./(1, 2), number_fields./((number_fields.-)(1), 2) :), (: 1, number_fields./((number_fields.-)(1), 2), number_fields./((number_fields.-)(1), 2) :) :)" "{M: matrices.PosFullMatrix | booleans.AND(matrices.rows(M) = 6, matrices.columns(M) = 3)}")) (A63_TCC1-1 nil 3621167024 ("" (eval-formula)) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil)) nil (A63 subtype "(: (: 1, 0, (number_fields.-)(1) :), (: 0, number_fields./(1, 2), number_fields./(1, 2) :), (: 0, number_fields./((number_fields.-)(1), 2), number_fields./(1, 2) :), (: 0, 0, 1 :), (: 1, number_fields./(1, 2), number_fields./((number_fields.-)(1), 2) :), (: 1, number_fields./((number_fields.-)(1), 2), number_fields./((number_fields.-)(1), 2) :) :)" "{M: matrices.PosFullMatrix | booleans.AND(matrices.rows(M) = 6, matrices.columns(M) = 3)}"))) (A63_def 0 (A63_def-1 nil 3621167232 ("" (eval-formula) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil)) shostak)) (multi_sturm_tarski_NSol63 0 (multi_sturm_tarski_NSol63-3 "" 3790099429 ("" (skeep) (("" (lemma "multi_sturm_tarski_NSol") (("" (inst?) (("" (assert) (("" (replace -2) (("" (replaces -1) (("" (rewrite "full_matrix_eq") (("" (invoke (case "NOT %1") (! 2 1)) (("1" (hide 3) (("1" (rewrite "rows_mult") (("1" (rewrite "rows_mult") (("1" (assert) (("1" (lemma "tensor_power_rows_alt") (("1" (inst?) (("1" (replaces -1 :dir rl) (("1" (lemma "tensor_power_rows_alt") (("1" (inst - "A63" "1+k") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (invoke (case "NOT %1") (! 2 1)) (("1" (hide 3) (("1" (lemma "columns_mult") (("1" (inst?) (("1" (assert) (("1" (split -) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "columns_mult") (("1" (inst?) (("1" (split -) (("1" (replaces -1) (("1" (assert) nil nil)) nil) ("2" (lemma "tensor_power_rows_alt") (("2" (inst?) (("2" (expand "rows" -1 2) (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "tensor_power_rows_alt") (("2" (inst?) (("2" (expand "rows" -1 2) (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (skeep) (("2" (typepred "i") (("2" (case "NOT rows(tensor_power_alt(A66, 1 + k) * TQ_vect6k(k, a, n, GF, KF)) = 6^(1+k)") (("1" (assert) (("1" (rewrite "rows_mult") (("1" (lemma "tensor_power_rows_alt") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (case "NOT columns(tensor_power_alt(A66, 1 + k) * TQ_vect6k(k, a, n, GF, KF)) = 1") (("1" (lemma "columns_mult") (("1" (inst?) (("1" (assert) (("1" (lemma "tensor_power_rows_alt") (("1" (inst?) (("1" (expand "rows" -1 2) (("1" (expand "length" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT j = 0") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (rewrite "entry_mult") (("2" (rewrite "entry_mult") (("2" (lemma "tensor_power_rows_alt") (("2" (inst - "A66" "1+k") (("2" (lemma "tensor_power_rows_alt") (("2" (inst - "A63" "1+k") (("2" (assert) (("2" (lemma "dot_eq_sigma") (("2" (expand "*" +) (("2" (rewrite -1 +) (("2" (rewrite -1 +) (("2" (rewrite "length_row") (("1" (rewrite "length_row") (("1" (rewrite "length_col") (("1" (rewrite "length_col") (("1" (lemma "tensor_power_columns_alt") (("1" (inst - "A63" "1+k") (("1" (lemma "tensor_power_columns_alt") (("1" (inst - "A66" "1+k") (("1" (assert) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (expand "min" +) (("1" (case "NOT columns(A66) = 6") (("1" (assert) nil nil) ("2" (replace -1) (("2" (case "NOT columns(A63) = 3") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (name "siggy" "LAMBDA (i:nat): base_n_to_nat(6,base_n(3,i),k)") (("2" (invoke (name "F" "%1") (! 2 2 3)) (("2" (replaces -1) (("2" (invoke (name "G" "%1") (! 2 1 3)) (("2" (replaces -1) (("2" (lemma "sigma_inj") (("2" (inst - "F" "G" "3^(1+k)-1" "6^(1+k)-1" "0" "0" "siggy") (("2" (assert) (("2" (hide 3) (("2" (split 1) (("1" (skeep) (("1" (expand "siggy" 1) (("1" (assert) (("1" (split 1) (("1" (assert) nil nil) ("2" (lemma "base_n_to_nat_lt") (("2" (inst?) (("2" (assert) (("2" (split -) (("1" (assert) (("1" (case "FORALL (i1,i2:int): i1<i2 IMPLIES i1<=i2-1") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "siggy" -1) (("2" (lemma "base_n_to_nat_unique") (("2" (inst?) (("2" (assert) (("2" (inst - "k") (("2" (split -) (("1" (lemma "base_n_is_n_alt") (("1" (inst - "3" "i!1" "k") (("1" (lemma "base_n_is_n_alt") (("1" (inst - "3" "j!1" "k") (("1" (assert) (("1" (replaces -1 +) (("1" (replaces -1 +) (("1" (lemma "base_n_to_nat_eq") (("1" (inst?) (("1" (assert) (("1" (inst - "k") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) (("2" (lemma "base_n_lt_n") (("2" (hide -2) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (expand "G" +) (("3" (case "access(col(TQ_vect6k(k, a, n, GF, KF))(0))(i!1) = 0") (("1" (assert) nil nil) ("2" (hide 3) (("2" (rewrite "access_col") (("2" (expand "TQ_vect6k" 1) (("2" (rewrite "entry_form_matrix") (("1" (lift-if) (("1" (ground) (("1" (name "jj" "base_n_to_nat(3,base_n(6,i!1),k)") (("1" (inst 3 "jj") (("1" (expand "siggy" +) (("1" (expand "jj" 3) (("1" (lemma "base_n_base_n_to_nat") (("1" (inst?) (("1" (assert) (("1" (split -) (("1" (lemma "base_n_to_nat_eq") (("1" (inst - "6" "k" "k" "base_n(3, base_n_to_nat(3, base_n(6, i!1), k))" "base_n(6,i!1)") (("1" (replace -2) (("1" (replaces -1) (("1" (lemma "base_n_is_n_alt") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst + "i!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "jj" 1) (("2" (lemma "base_n_to_nat_lt") (("2" (inst?) (("2" (assert) (("2" (split -) (("1" (case "FORALL (i1,i2:int): i1<i2 IMPLIES i1<=i2-1") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (inst + "i!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (assert) (("2" (assert) (("2" (inst + "x1!1") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "base_n_0") (("2" (inst?) (("2" (assert) (("2" (lemma "both_sides_expt_gt1_le_aux") (("2" (inst - "6" "k" "x1!1-1") (("2" (assert) (("2" (expand "^") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (expand "F" 1) (("4" (expand "G" 1) (("4" (rewrite "access_row") (("4" (rewrite "access_row") (("4" (rewrite "access_col") (("4" (rewrite "access_col") (("4" (case "FORALL (a1,a2,b1,b2:real): a1=b1 AND a2=b2 IMPLIES a1*a2=b1*b2") (("1" (rewrite -1) (("1" (hide 2) (("1" (lemma "tensor_entry_alt") (("1" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (lemma "tensor_entry_alt") (("1" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (rewrite "product_eq") (("1" (hide 2) (("1" (skosimp*) (("1" (case "NOT rows(A66)=6") (("1" (assert) nil nil) ("2" (replace -1) (("2" (replace -4) (("2" (replace -5) (("2" (case "NOT rows(A63) = 6") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (expand "entry_pick" +) (("2" (case "base_n(6, siggy(i!1)) = base_n(3, i!1)") (("1" (replaces -1) (("1" (rewrite "A63_def" 1) (("1" (lemma "base_n_lt_n") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "siggy" 1) (("2" (lemma "base_n_base_n_to_nat") (("2" (inst?) (("2" (split -) (("1" (decompose-equality 1) (("1" (case "x!1<=k") (("1" (inst - "x!1") nil nil) ("2" (assert) (("2" (lemma "base_n_0") (("2" (inst?) (("2" (assert) (("2" (split -) (("1" (lemma "base_n_0") (("1" (replace -2) (("1" (inst - "3" "i!1" "x!1") (("1" (assert) (("1" (typepred "i!1") (("1" (lemma "both_sides_expt_gt1_le_aux") (("1" (inst - "3" "k" "x!1-1") (("1" (expand "^") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "base_n_to_nat_lt") (("2" (inst?) (("2" (assert) (("2" (split -) (("1" (lemma "both_sides_expt_gt1_le_aux") (("1" (inst - "6" "k" "x!1-1") (("1" (expand "^") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "siggy" 1) (("2" (lemma "base_n_to_nat_lt") (("2" (inst?) (("2" (assert) (("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "TQ_vect6k" +) (("2" (expand "TQ_vect3k" +) (("2" (rewrite "entry_form_matrix") (("1" (rewrite "entry_form_matrix") (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (split +) (("1" (flatten) (("1" (skeep -1) (("1" (expand "siggy" -1) (("1" (lemma "base_n_base_n_to_nat") (("1" (inst?) (("1" (split -) (("1" (rewrite -1 -2) (("1" (lemma "base_n_lt_n") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "base_n(3, i!1)=base_n(6, siggy(i!1))") (("1" (assert) nil nil) ("2" (hide 3) (("2" (hide 2) (("2" (expand "siggy" +) (("2" (lemma "base_n_base_n_to_nat") (("2" (inst?) (("2" (split -) (("1" (decompose-equality 1) (("1" (case "x!1<=k") (("1" (rewrite -2) nil nil) ("2" (lemma "base_n_0") (("2" (inst?) (("2" (assert) (("2" (split -) (("1" (replace -1) (("1" (lemma "base_n_0") (("1" (inst - "6" _ _) (("1" (inst?) (("1" (assert) (("1" (lemma "base_n_to_nat_lt") (("1" (inst?) (("1" (assert) (("1" (split -) (("1" (lemma "both_sides_expt_gt1_le_aux") (("1" (inst - "6" "k" "x!1-1") (("1" (expand "^") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "both_sides_expt_gt1_le_aux") (("2" (inst - "3" "k" "x!1-1") (("2" (expand "^") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "siggy" 1) (("2" (lemma "base_n_to_nat_lt") (("2" (inst?) (("2" (assert) (("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) (("2" (assert) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) (("2" (inst + "x1!1") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "base_n_0") (("2" (inst?) (("2" (assert) (("2" (lemma "both_sides_expt_gt1_le_aux") (("2" (inst - "6" "k" "x1!1-1") (("2" (expand "^") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) (("2" (assert) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (lemma "tensor_power_rows_alt") (("2" (inst?) (("2" (expand "rows" -1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide 2) (("2" (expand "rows" -3 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((multi_sturm_tarski_NSol formula-decl nil tarski_query_matrix nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (mult_full application-judgement "FullMatrix" matrices matrices) (TRUE const-decl "bool" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (rows_mult formula-decl nil matrices matrices) (nat_exp application-judgement "nat" exponentiation nil) (tensor_power_rows_alt formula-decl nil tensor_product matrices) (columns_mult formula-decl nil matrices matrices) (posint_exp application-judgement "posint" exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (entry_mult formula-decl nil matrices matrices) (listn_0 name-judgement "listn[int](0)" gcd_coeff Sturm) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (base_n_to_nat const-decl "nat" base_repr reals) (base_n def-decl "nat" base_repr reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (tensor_entry_alt formula-decl nil tensor_product matrices) (T_low type-eq-decl nil product reals) (T_high type-eq-decl nil product reals) (entry_pick const-decl "real" tensor_product matrices) (product_eq formula-decl nil product reals) (x!1 skolem-const-decl "nat" tarski_query_matrix nil) (A63_def formula-decl nil tarski_query_matrix nil) (i!1 skolem-const-decl "subrange(0, 3 ^ (1 + k) - 1)" tarski_query_matrix nil) (x1!1 skolem-const-decl "nat" tarski_query_matrix nil) (nat_expt application-judgement "nat" exponentiation nil) (x!1 skolem-const-decl "nat" tarski_query_matrix nil) (access_row formula-decl nil matrices matrices) (F skolem-const-decl "[nat -> real]" tarski_query_matrix nil) (access_col formula-decl nil matrices matrices) (TQ_fam const-decl "int" poly_families nil) (entry_form_matrix formula-decl nil matrices matrices) (form_matrix_square application-judgement "FullMatrix" matrices matrices) (jj skolem-const-decl "nat" tarski_query_matrix nil) (k skolem-const-decl "nat" tarski_query_matrix nil) (base_n_base_n_to_nat formula-decl nil base_repr reals) (i!2 skolem-const-decl "nat" tarski_query_matrix nil) (both_sides_expt_gt1_le_aux formula-decl nil exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (base_n_0 formula-decl nil base_repr reals) (x1!1 skolem-const-decl "nat" tarski_query_matrix nil) (G skolem-const-decl "[nat -> real]" tarski_query_matrix nil) (base_n_to_nat_unique formula-decl nil base_repr reals) (base_n_to_nat_eq formula-decl nil base_repr reals) (base_n_is_n_alt formula-decl nil base_repr reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (base_n_to_nat_lt formula-decl nil base_repr reals) (base_n_lt_n formula-decl nil base_repr reals) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (siggy skolem-const-decl "[nat -> nat]" tarski_query_matrix nil) (sigma_inj formula-decl nil sigma_nat reals) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (access const-decl "real" matrices matrices) (tensor_power_columns_alt formula-decl nil tensor_product matrices) (length_col formula-decl nil matrices matrices) (length_row formula-decl nil matrices matrices) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (dot_eq_sigma formula-decl nil matrices matrices) (TQ_vect3k const-decl "{v: PosFullMatrix | rows(v) = 3 ^ (k + 1) AND columns(v) = 1}" tarski_query_matrix nil) (A63 const-decl "{M: PosFullMatrix | rows(M) = 6 AND columns(M) = 3}" tarski_query_matrix nil) (TQ_vect6k const-decl "{v: PosFullMatrix | rows(v) = 6 ^ (k + 1) AND columns(v) = 1}" tarski_query_matrix nil) (^ const-decl "real" exponentiation nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (A66 const-decl "{M: PosFullMatrix | rows(M) = 6 AND columns(M) = 6 AND M = inverse(A66_inv)}" tarski_query_matrix nil) (A66_inv const-decl "{M: PosFullMatrix | rows(M) = 6 AND columns(M) = 6}" tarski_query_matrix nil) (inverse const-decl "{IQ |
   rows(IQ) = rows(SQ) AND
    IQ * SQ = Id(rows(SQ)) AND SQ * IQ = Id(rows(SQ))}" matrix_inv matrices) (Id const-decl "{M: SquareMatrix(pm) |
   (FORALL (i: nat, j: nat):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" matrices matrices) (IF const-decl "[boolean, T, T -> T]" if_def nil) (SquareMatrix type-eq-decl nil matrices matrices) (invertible? const-decl "bool" matrix_inv matrices) (det def-decl "real" matrix_props matrices) (/= const-decl "boolean" notequal nil) (Square type-eq-decl nil matrices matrices) (tensor_power_alt def-decl "PosFullMatrix" tensor_product matrices) (PosFullMatrix type-eq-decl nil matrices matrices) (* const-decl "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i: nat, j: nat): entry(A)(i, j) = row(M)(i) * col(N)(j)}" matrices matrices) (col def-decl "VectorN(rows(M))" matrices matrices) (VectorN type-eq-decl nil matrices matrices) (row const-decl "Vector" matrices matrices) (* const-decl "real" matrices matrices) (Vector type-eq-decl nil matrices matrices) (entry const-decl "real" matrices matrices) (MatrixMN type-eq-decl nil matrices matrices) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices matrices) (<= const-decl "bool" reals nil) (rows const-decl "nat" matrices matrices) (FullMatrix type-eq-decl nil matrices matrices) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices matrices) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (full_matrix_eq formula-decl nil matrices matrices) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak) (multi_sturm_tarski_NSol63-2 nil 3621168373 ("" (skeep) (("" (lemma "multi_sturm_tarski_NSol") (("" (inst?) (("" (assert) (("" (replace -2) (("" (replaces -1) (("" (rewrite "full_matrix_eq") (("" (invoke (case "NOT %1") (! 2 1)) (("1" (hide 3) (("1" (rewrite "rows_mult") (("1" (rewrite "rows_mult") (("1" (assert) (("1" (lemma "tensor_power_rows_alt") (("1" (inst?) (("1" (replaces -1 :dir rl) (("1" (lemma "tensor_power_rows_alt") (("1" (inst - "A63" "1+k") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (invoke (case "NOT %1") (! 2 1)) (("1" (hide 3) (("1" (lemma "columns_mult") (("1" (inst?) (("1" (assert) (("1" (split -) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "columns_mult") (("1" (inst?) (("1" (split -) (("1" (replaces -1) (("1" (assert) nil nil)) nil) ("2" (lemma "tensor_power_rows_alt") (("2" (inst?) (("2" (expand "rows" -1 2) (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "tensor_power_rows_alt") (("2" (inst?) (("2" (expand "rows" -1 2) (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (skeep) (("2" (typepred "i") (("2" (case "NOT rows(tensor_power_alt(A66, 1 + k) * TQ_vect6k(k, a, n, GF, KF)) = 6^(1+k)") (("1" (assert) (("1" (rewrite "rows_mult") (("1" (lemma "tensor_power_rows_alt") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (case "NOT columns(tensor_power_alt(A66, 1 + k) * TQ_vect6k(k, a, n, GF, KF)) = 1") (("1" (lemma "columns_mult") (("1" (inst?) (("1" (assert) (("1" (lemma "tensor_power_rows_alt") (("1" (inst?) (("1" (expand "rows" -1 2) (("1" (expand "length" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT j = 0") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (rewrite "entry_mult") (("2" (rewrite "entry_mult") (("2" (assert) (("2" (lemma "tensor_power_rows_alt") (("2" (inst - "A66" "1+k") (("2" (lemma "tensor_power_rows_alt") (("2" (inst - "A63" "1+k") (("2" (assert) (("2" (lemma "dot_eq_sigma") (("2" (expand "*" +) (("2" (rewrite -1 +) (("2" (rewrite -1 +) (("2" (rewrite "length_row") (("1" (rewrite "length_row") (("1" (rewrite "length_col") (("1" (rewrite "length_col") (("1" (lemma "tensor_power_columns_alt") (("1" (inst - "A63" "1+k") (("1" (lemma "tensor_power_columns_alt") (("1" (inst - "A66" "1+k") (("1" (assert) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (expand "min" +) (("1" (case "NOT columns(A66) = 6") (("1" (assert) nil nil) ("2" (replace -1) (("2" (case "NOT columns(A63) = 3") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (name "siggy" "LAMBDA (i:nat): base_n_to_nat(6,base_n(3,i),k)") (("2" (invoke (name "F" "%1") (! 2 2 3)) (("2" (replaces -1) (("2" (invoke (name "G" "%1") (! 2 1 3)) (("2" (replaces -1) (("2" (lemma "sigma_inj") (("2" (inst - "F" "G" "3^(1+k)-1" "6^(1+k)-1" "0" "0" "siggy") (("2" (assert) (("2" (hide 3) (("2" (split 1) (("1" (skeep) (("1" (expand "siggy" 1) (("1" (assert) (("1" (split 1) (("1" (assert) nil nil) ("2" (lemma "base_n_to_nat_lt") (("2" (inst?) (("2" (assert) (("2" (split -) (("1" (assert) (("1" (case "FORALL (i1,i2:int): i1<i2 IMPLIES i1<=i2-1") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "siggy" -1) (("2" (lemma "base_n_to_nat_unique") (("2" (inst?) (("2" (assert) (("2" (inst - "k") (("2" (split -) (("1" (lemma "base_n_is_n_alt") (("1" (inst - "3" "i!1" "k") (("1" (lemma "base_n_is_n_alt") (("1" (inst - "3" "j!1" "k") (("1" (assert) (("1" (replaces -1 +) (("1" (replaces -1 +) (("1" (lemma "base_n_to_nat_eq") (("1" (inst?) (("1" (assert) (("1" (inst - "k") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) (("2" (lemma "base_n_lt_n") (("2" (hide -2) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (expand "G" +) (("3" (case "access(col(TQ_vect6k(k, a, n, GF, KF))(0))(i!1) = 0") (("1" (assert) nil nil) ("2" (hide 3) (("2" (rewrite "access_col") (("2" (expand "TQ_vect6k" 1) (("2" (rewrite "entry_form_matrix") (("1" (lift-if) (("1" (ground) (("1" (name "jj" "base_n_to_nat(3,base_n(6,i!1),k)") (("1" (inst 3 "jj") (("1" (expand "siggy" +) (("1" (expand "jj" 3) (("1" (lemma "base_n_base_n_to_nat") (("1" (inst?) (("1" (assert) (("1" (split -) (("1" (lemma "base_n_to_nat_eq") (("1" (inst - "6" "k" "k" "base_n(3, base_n_to_nat(3, base_n(6, i!1), k))" "base_n(6,i!1)") (("1" (replace -2) (("1" (replaces -1) (("1" (lemma "base_n_is_n_alt") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst + "i!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "jj" 1) (("2" (lemma "base_n_to_nat_lt") (("2" (inst?) (("2" (assert) (("2" (split -) (("1" (case "FORALL (i1,i2:int): i1<i2 IMPLIES i1<=i2-1") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (inst + "i!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (assert) (("2" (assert) (("2" (inst + "x1!1") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "base_n_0") (("2" (inst?) (("2" (assert) (("2" (lemma "both_sides_expt_gt1_le_aux") (("2" (inst - "6" "k" "x1!1-1") (("2" (assert) (("2" (expand "^") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (expand "F" 1) (("4" (expand "G" 1) (("4" (rewrite "access_row") (("4" (rewrite "access_row") (("4" (rewrite "access_col") (("4" (rewrite "access_col") (("4" (case "FORALL (a1,a2,b1,b2:real): a1=b1 AND a2=b2 IMPLIES a1*a2=b1*b2") (("1" (rewrite -1) (("1" (hide 2) (("1" (lemma "tensor_entry_alt") (("1" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (lemma "tensor_entry_alt") (("1" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (rewrite "product_eq") (("1" (hide 2) (("1" (skosimp*) (("1" (case "NOT rows(A66)=6") (("1" (assert) nil nil) ("2" (replace -1) (("2" (replace -4) (("2" (replace -5) (("2" (case "NOT rows(A63) = 6") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (expand "entry_pick" +) (("2" (case "base_n(6, siggy(i!1)) = base_n(3, i!1)") (("1" (replaces -1) (("1" (rewrite "A63_def" 1) (("1" (lemma "base_n_lt_n") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "siggy" 1) (("2" (lemma "base_n_base_n_to_nat") (("2" (inst?) (("2" (split -) (("1" (decompose-equality 1) (("1" (case "x!1<=k") (("1" (inst - "x!1") nil nil) ("2" (assert) (("2" (lemma "base_n_0") (("2" (inst?) (("2" (assert) (("2" (split -) (("1" (lemma "base_n_0") (("1" (replace -2) (("1" (inst - "3" "i!1" "x!1") (("1" (assert) (("1" (typepred "i!1") (("1" (lemma "both_sides_expt_gt1_le_aux") (("1" (inst - "3" "k" "x!1-1") (("1" (expand "^") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "base_n_to_nat_lt") (("2" (inst?) (("2" (assert) (("2" (split -) (("1" (lemma "both_sides_expt_gt1_le_aux") (("1" (inst - "6" "k" "x!1-1") (("1" (expand "^") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "siggy" 1) (("2" (lemma "base_n_to_nat_lt") (("2" (inst?) (("2" (assert) (("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "TQ_vect6k" +) (("2" (expand "TQ_vect3k" +) (("2" (rewrite "entry_form_matrix") (("1" (rewrite "entry_form_matrix") (("1" (assert) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (split +) (("1" (flatten) (("1" (skeep -1) (("1" (expand "siggy" -1) (("1" (lemma "base_n_base_n_to_nat") (("1" (inst?) (("1" (split -) (("1" (rewrite -1 -2) (("1" (lemma "base_n_lt_n") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "base_n(3, i!1)=base_n(6, siggy(i!1))") (("1" (assert) nil nil) ("2" (hide 3) (("2" (hide 2) (("2" (expand "siggy" +) (("2" (lemma "base_n_base_n_to_nat") (("2" (inst?) (("2" (split -) (("1" (decompose-equality 1) (("1" (case "x!1<=k") (("1" (rewrite -2) nil nil) ("2" (lemma "base_n_0") (("2" (inst?) (("2" (assert) (("2" (split -) (("1" (replace -1) (("1" (lemma "base_n_0") (("1" (inst - "6" _ _) (("1" (inst?) (("1" (assert) (("1" (lemma "base_n_to_nat_lt") (("1" (inst?) (("1" (assert) (("1" (split -) (("1" (lemma "both_sides_expt_gt1_le_aux") (("1" (inst - "6" "k" "x!1-1") (("1" (expand "^") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "both_sides_expt_gt1_le_aux") (("2" (inst - "3" "k" "x!1-1") (("2" (expand "^") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "siggy" 1) (("2" (lemma "base_n_to_nat_lt") (("2" (inst?) (("2" (assert) (("2" (skosimp*) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) (("2" (assert) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) (("2" (inst + "x1!1") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "base_n_0") (("2" (inst?) (("2" (assert) (("2" (lemma "both_sides_expt_gt1_le_aux") (("2" (inst - "6" "k" "x1!1-1") (("2" (expand "^") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) (("2" (assert) (("2" (lemma "base_n_lt_n") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (lemma "tensor_power_rows_alt") (("2" (inst?) (("2" (expand "rows" -1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide 2) (("2" (expand "rows" -3 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((multi_sturm_tarski_NSol formula-decl nil tarski_query_matrix nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (mult_full application-judgement "FullMatrix" matrices matrices) (TRUE const-decl "bool" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (rows_mult formula-decl nil matrices matrices) (nat_exp application-judgement "nat" exponentiation nil) (tensor_power_rows_alt formula-decl nil tensor_product matrices) (columns_mult formula-decl nil matrices matrices) (posint_exp application-judgement "posint" exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (entry_mult formula-decl nil matrices matrices) nil (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (base_n_to_nat const-decl "nat" base_repr reals) (base_n def-decl "nat" base_repr reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (tensor_entry_alt formula-decl nil tensor_product matrices) (T_low type-eq-decl nil product reals) (T_high type-eq-decl nil product reals) (entry_pick const-decl "real" tensor_product matrices) (product_eq formula-decl nil product reals) nil (A63_def formula-decl nil tarski_query_matrix nil) nil nil (nat_expt application-judgement "nat" exponentiation nil) nil (access_row formula-decl nil matrices matrices) nil (access_col formula-decl nil matrices matrices) (TQ_fam const-decl "int" poly_families nil) (entry_form_matrix formula-decl nil matrices matrices) (form_matrix_square application-judgement "FullMatrix" matrices matrices) nil nil (base_n_base_n_to_nat formula-decl nil base_repr reals) nil (both_sides_expt_gt1_le_aux formula-decl nil exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (base_n_0 formula-decl nil base_repr reals) nil nil (base_n_to_nat_unique formula-decl nil base_repr reals) (base_n_to_nat_eq formula-decl nil base_repr reals) (base_n_is_n_alt formula-decl nil base_repr reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (base_n_to_nat_lt formula-decl nil base_repr reals) (base_n_lt_n formula-decl nil base_repr reals) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) nil (sigma_inj formula-decl nil sigma_nat reals) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (access const-decl "real" matrices matrices) (tensor_power_columns_alt formula-decl nil tensor_product matrices) (length_col formula-decl nil matrices matrices) (length_row formula-decl nil matrices matrices) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (dot_eq_sigma formula-decl nil matrices matrices) (TQ_vect3k const-decl "{v: PosFullMatrix | rows(v) = 3 ^ (k + 1) AND columns(v) = 1}" tarski_query_matrix nil) (A63 const-decl "{M: PosFullMatrix | rows(M) = 6 AND columns(M) = 3}" tarski_query_matrix nil) (TQ_vect6k const-decl "{v: PosFullMatrix | rows(v) = 6 ^ (k + 1) AND columns(v) = 1}" tarski_query_matrix nil) (^ const-decl "real" exponentiation nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (A66 const-decl "{M: PosFullMatrix | rows(M) = 6 AND columns(M) = 6 AND M = inverse(A66_inv)}" tarski_query_matrix nil) (A66_inv const-decl "{M: PosFullMatrix | rows(M) = 6 AND columns(M) = 6}" tarski_query_matrix nil) (inverse const-decl "{IQ |
   rows(IQ) = rows(SQ) AND
    IQ * SQ = Id(rows(SQ)) AND SQ * IQ = Id(rows(SQ))}" matrix_inv matrices) (Id const-decl "{M: SquareMatrix(pm) |
   (FORALL (i: nat, j: nat):
      entry(M)(i, j) = IF i < pm AND i = j THEN 1 ELSE 0 ENDIF)
    AND
    (FORALL (pn: posnat, N: MatrixMN(pm, pn)): M * N = N) AND
     (FORALL (pn: posnat, N: MatrixMN(pn, pm)): N * M = N)}" matrices matrices) (IF const-decl "[boolean, T, T -> T]" if_def nil) (SquareMatrix type-eq-decl nil matrices matrices) (invertible? const-decl "bool" matrix_inv matrices) (det def-decl "real" matrix_props matrices) (/= const-decl "boolean" notequal nil) (Square type-eq-decl nil matrices matrices) (tensor_power_alt def-decl "PosFullMatrix" tensor_product matrices) (PosFullMatrix type-eq-decl nil matrices matrices) nil (col def-decl "VectorN(rows(M))" matrices matrices) (VectorN type-eq-decl nil matrices matrices) (row const-decl "Vector" matrices matrices) (* const-decl "real" matrices matrices) (Vector type-eq-decl nil matrices matrices) (entry const-decl "real" matrices matrices) (MatrixMN type-eq-decl nil matrices matrices) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices matrices) (<= const-decl "bool" reals nil) (rows const-decl "nat" matrices matrices) (FullMatrix type-eq-decl nil matrices matrices) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices matrices) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (full_matrix_eq formula-decl nil matrices matrices) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil) (multi_sturm_tarski_NSol63-1 nil 3621167258 ("" (skeep) (("" (lemma "multi_sturm_tarski_NSol") (("" (inst?) (("" (assert) (("" (replace -2) (("" (replaces -1) (("" (rewrite "full_matrix_eq") (("" (invoke (case "NOT %1") (! 2 1)) (("1" (hide 3) (("1" (rewrite "rows_mult") (("1" (rewrite "rows_mult") (("1" (assert) (("1" (lemma "tensor_power_rows_alt") (("1" (inst?) (("1" (replaces -1 :dir rl) (("1" (lemma "tensor_power_rows_alt") (("1" (inst - "A63" "1+k") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (invoke (case "NOT %1") (! 2 1)) (("1" (hide 3) (("1" (lemma "columns_mult") (("1" (inst?) (("1" (assert) (("1" (split -) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "columns_mult") (("1" (inst?) (("1" (split -) (("1" (replaces -1) (("1" (assert) nil nil)) nil) ("2" (lemma "tensor_power_rows_alt") (("2" (inst?) (("2" (expand "rows" -1 2) (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "tensor_power_rows_alt") (("2" (inst?) (("2" (expand "rows" -1 2) (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (skeep) (("2" (typepred "i") (("2" (case "NOT rows(tensor_power_alt(A66, 1 + k) * TQ_vect6k(k, a, n, GF, KF)) = 6^(1+k)") (("1" (assert) (("1" (rewrite "rows_mult") (("1" (lemma "tensor_power_rows_alt") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (case "NOT columns(tensor_power_alt(A66, 1 + k) * TQ_vect6k(k, a, n, GF, KF)) = 1") (("1" (lemma "columns_mult") (("1" (inst?) (("1" (assert) (("1" (lemma "tensor_power_rows_alt") (("1" (inst?) (("1" (expand "rows" -1 2) (("1" (expand "length" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT j = 0") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (rewrite "entry_mult") (("2" (rewrite "entry_mult") (("2" (assert) (("2" (lemma "tensor_power_rows_alt") (("2" (inst - "A66" "1+k") (("2" (lemma "tensor_power_rows_alt") (("2" (inst - "A63" "1+k") (("2" (assert) (("2" (lemma "dot_eq_sigma") (("2" (expand "*" +) (("2" (rewrite -1 +) (("2" (rewrite -1 +) (("2" (rewrite "length_row") (("1" (rewrite "length_row") (("1" (rewrite "length_col") (("1" (rewrite "length_col") (("1" (lemma "tensor_power_columns_alt") (("1" (inst - "A63" "1+k") (("1" (lemma "tensor_power_columns_alt") (("1" (inst - "A66" "1+k") (("1" (assert) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (expand "min" +) (("1" (case "NOT columns(A66) = 6") (("1" (assert) nil nil) ("2" (replace -1) (("2" (case "NOT columns(A63) = 3") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (name "siggy" "LAMBDA (i:nat): base_n_to_nat(6,base_n(3,i),k+1)") (("2" (invoke (name "F" "%1") (! 2 2 3)) (("2" (replaces -1) (("2" (invoke (name "G" "%1") (! 2 1 3)) (("2" (replaces -1) (("2" (lemma "sigma_inj") (("2" (inst - "F" "G" "3^(1+k)-1" "6^(1+k)-1" "0" "0" "siggy") (("2" (assert) (("2" (hide 3) (("2" (split 1) (("1" (skeep) (("1" (expand "siggy" 1) (("1" (assert) (("1" (split 1) (("1" (assert) nil nil) ("2" (lemma "base_n_to_nat_lt") (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)))
