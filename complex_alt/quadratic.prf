(quadratic
 (c_term_quadratic_TCC1 0
  (c_term_quadratic_TCC1-1 nil 3722895528 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (Sign type-eq-decl nil sign "reals/")
    (minus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (c_term_quadratic subtype "(number_fields.-)(quadratic.d)"
    "nonneg_real")))
 (c_term_quadratic_TCC2 0
  (c_term_quadratic_TCC2-1 nil 3770600482 ("" (subtype-tcc) nil nil)
   nil nil
   (c_term_quadratic subtype
    "complex_types.complex_((number_fields.*(2, quadratic.a)), 0)"
    "nzcomplex")))
 (c_term_quadratic_d_eq_0 0
  (c_term_quadratic_d_eq_0-1 nil 3721320816 ("" (grind) nil nil)
   ((sqrt_0 formula-decl nil sqrt "reals/")
    (complex_ const-decl "complex" complex_types nil)
    (c_term_quadratic const-decl "complex" quadratic nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (minus_real_is_real application-judgement "real" reals nil))
   shostak))
 (c_term_quadratic_d_ge_0 0
  (c_term_quadratic_d_ge_0-1 nil 3721320935
   ("" (skeep)
    (("" (expand "c_term_quadratic") (("" (assert) nil nil)) nil)) nil)
   ((c_term_quadratic const-decl "complex" quadratic nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil))
   shostak))
 (c_term_quadratic_d_lt_0_TCC1 0
  (c_term_quadratic_d_lt_0_TCC1-1 nil 3721321068
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (c_term_quadratic_d_lt_0 subtype "(number_fields.-)(quadratic.d)"
    "nonneg_real")))
 (c_term_quadratic_d_lt_0_TCC2 0
  (c_term_quadratic_d_lt_0_TCC2-1 nil 3722881522
   ("" (subtype-tcc) nil nil)
   ((complex_ const-decl "complex" complex_types nil)) nil
   (c_term_quadratic_d_lt_0 subtype
    "complex_types.complex_((number_fields.*(2, quadratic.a)), 0)"
    "nzcomplex")))
 (c_term_quadratic_d_lt_0 0
  (c_term_quadratic_d_lt_0-1 nil 3721321087
   ("" (skeep)
    (("" (expand "c_term_quadratic") (("" (assert) nil nil)) nil)) nil)
   ((c_term_quadratic const-decl "complex" quadratic nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil))
   shostak))
 (c_term_quadratic_eq 0
  (c_term_quadratic_eq-1 nil 3721323160
   ("" (skeep)
    (("" (case-replace "d=0")
      (("1" (assert)
        (("1" (rewrite "c_term_quadratic_d_eq_0")
          (("1" (rewrite "c_term_quadratic_d_eq_0") nil nil)) nil))
        nil)
       ("2" (case "d > 0")
        (("1" (rewrite "c_term_quadratic_d_ge_0")
          (("1" (rewrite "c_term_quadratic_d_ge_0")
            (("1" (assert) (("1" (field -2) nil nil)) nil)) nil))
          nil)
         ("2" (assert)
          (("2" (rewrite "c_term_quadratic_d_lt_0")
            (("2" (rewrite "c_term_quadratic_d_lt_0")
              (("2" (rewrite "complex_ext")
                (("2" (typepred "eps") (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (c_term_quadratic_d_eq_0 formula-decl nil quadratic nil)
    (/= const-decl "boolean" notequal nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (Sign type-eq-decl nil sign "reals/")
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (sign_neg_clos application-judgement "Sign" sign "reals/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (sq const-decl "nonneg_real" sq "reals/")
    (sq_abs const-decl "nnreal" complex_types nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (posreal_plus_nnreal_is_posreal application-judgement "posreal"
     real_types nil)
    (Im_div1 formula-decl nil complex_types nil)
    (Re_div1 formula-decl nil complex_types nil)
    (Im_rew formula-decl nil complex_types nil)
    (Re_rew formula-decl nil complex_types nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (/ const-decl "complex" complex_types nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil)
    (complex_ const-decl "complex" complex_types nil)
    (complex type-eq-decl nil complex_types nil)
    (complex_ext formula-decl nil complex_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (c_term_quadratic_d_lt_0 formula-decl nil quadratic nil)
    (c_term_quadratic_d_ge_0 formula-decl nil quadratic nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (eq_rew formula-decl nil complex_types nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (>= const-decl "bool" reals nil)
    (both_sides_times1 formula-decl nil real_props nil)
    (both_sides_times1_imp formula-decl nil extra_real_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nnreal type-eq-decl nil real_types nil)
    (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt "reals/")
    (> const-decl "bool" reals nil))
   shostak))
 (c_term_quadratic_real 0
  (c_term_quadratic_real-1 nil 3721400915
   ("" (skeep)
    (("" (case-replace "d >= 0")
      (("1" (assert)
        (("1" (skeep)
          (("1" (rewrite "c_term_quadratic_d_ge_0")
            (("1" (grind) nil nil)) nil))
          nil))
        nil)
       ("2" (assert)
        (("2" (inst -1 "1")
          (("2" (rewrite "c_term_quadratic_d_lt_0")
            (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (complex_ const-decl "complex" complex_types nil)
    (real_? const-decl "bool" complex_types nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (Sign type-eq-decl nil sign "reals/")
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (c_term_quadratic_d_ge_0 formula-decl nil quadratic nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sq const-decl "nonneg_real" sq "reals/")
    (sq_abs const-decl "nnreal" complex_types nil)
    (/ const-decl "complex" complex_types nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (posreal_plus_nnreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (c_term_quadratic_d_lt_0 formula-decl nil quadratic nil))
   shostak))
 (c_term_quadratic_conj 0
  (c_term_quadratic_conj-1 nil 3721322470
   ("" (skeep)
    (("" (case-replace "d < 0")
      (("1" (assert)
        (("1" (rewrite "c_term_quadratic_d_lt_0")
          (("1" (rewrite "c_term_quadratic_d_lt_0")
            (("1" (expand "conjugate")
              (("1" (assert) (("1" (rewrite "complex_ext") nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (case-replace "d>0")
        (("1" (assert)
          (("1" (rewrite "c_term_quadratic_d_ge_0")
            (("1" (rewrite "c_term_quadratic_d_ge_0")
              (("1" (expand "conjugate")
                (("1" (assert) (("1" (field -2) nil nil)) nil)) nil))
              nil))
            nil))
          nil)
         ("2" (assert)
          (("2" (case-replace "d=0")
            (("1" (rewrite "c_term_quadratic_d_eq_0")
              (("1" (rewrite "c_term_quadratic_d_eq_0")
                (("1" (lemma "conjugate_eq")
                  (("1" (inst? -1)
                    (("1" (assert)
                      (("1" (expand "real_?") (("1" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (< const-decl "bool" reals nil)
    (c_term_quadratic_d_lt_0 formula-decl nil quadratic nil)
    (/= const-decl "boolean" notequal nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (Sign type-eq-decl nil sign "reals/")
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (conjugate const-decl "complex" complex_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sq_abs const-decl "nnreal" complex_types nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt "reals/")
    (nnreal type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/ const-decl "complex" complex_types nil)
    (nzcomplex nonempty-type-eq-decl nil complex_types nil)
    (complex_ const-decl "complex" complex_types nil)
    (complex type-eq-decl nil complex_types nil)
    (complex_ext formula-decl nil complex_types nil)
    (Im_div1 formula-decl nil complex_types nil)
    (Re_div1 formula-decl nil complex_types nil)
    (Im_rew formula-decl nil complex_types nil)
    (Re_rew formula-decl nil complex_types nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sign_neg_clos application-judgement "Sign" sign "reals/")
    (c_term_quadratic_d_eq_0 formula-decl nil quadratic nil)
    (conjugate_eq formula-decl nil complex_types nil)
    (real_? const-decl "bool" complex_types nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (eq_rew formula-decl nil complex_types nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (both_sides_times1 formula-decl nil real_props nil)
    (both_sides_times1_imp formula-decl nil extra_real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (c_term_quadratic_d_ge_0 formula-decl nil quadratic nil)
    (> const-decl "bool" reals nil))
   shostak))
 (c_term_quadratic_non_real 0
  (c_term_quadratic_non_real-1 nil 3721323357
   ("" (skeep)
    (("" (case-replace "d < 0")
      (("1" (assert)
        (("1" (skeep)
          (("1" (rewrite "c_term_quadratic_d_lt_0")
            (("1" (grind) (("1" (field -2) nil nil)) nil)) nil))
          nil))
        nil)
       ("2" (assert)
        (("2" (lemma "c_term_quadratic_real")
          (("2" (insteep)
            (("2" (assert)
              (("2" (inst -1 "1") (("2" (inst -2 "1") nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (< const-decl "bool" reals nil)
    (real_? const-decl "bool" complex_types nil)
    (/ const-decl "complex" complex_types nil)
    (sq_abs const-decl "nnreal" complex_types nil)
    (sq const-decl "nonneg_real" sq "reals/")
    (complex_ const-decl "complex" complex_types nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (posreal_plus_nnreal_is_posreal application-judgement "posreal"
     real_types nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (>= const-decl "bool" reals nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nnreal type-eq-decl nil real_types nil)
    (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (both_sides_times1_imp formula-decl nil extra_real_props nil)
    (nonzero_times3 formula-decl nil real_props nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (Sign type-eq-decl nil sign "reals/")
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (c_term_quadratic_d_lt_0 formula-decl nil quadratic nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (c_term_quadratic_real formula-decl nil quadratic nil))
   shostak))
 (discr_eq_0 0
  (discr_eq_0-1 nil 3721399479
   ("" (skeep)
    (("" (lemma "c_term_quadratic_eq")
      (("" (expand "quadratic_root") (("" (inst?) nil nil)) nil)) nil))
    nil)
   ((c_term_quadratic_eq formula-decl nil quadratic nil)
    (Sign type-eq-decl nil sign "reals/")
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (discr const-decl "real" quadratic "reals/")
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (quadratic_root const-decl "complex" quadratic nil))
   shostak))
 (discr_ge_0 0
  (discr_ge_0-1 nil 3721412648
   ("" (skeep)
    (("" (expand "quadratic_root")
      (("" (lemma "c_term_quadratic_real") (("" (inst?) nil nil)) nil))
      nil))
    nil)
   ((quadratic_root const-decl "complex" quadratic nil)
    (discr const-decl "real" quadratic "reals/")
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (c_term_quadratic_real formula-decl nil quadratic nil))
   shostak))
 (discr_le_0 0
  (discr_le_0-1 nil 3721412803
   ("" (skeep)
    (("" (lemma "c_term_quadratic_conj")
      (("" (expand "quadratic_root") (("" (inst?) nil nil)) nil)) nil))
    nil)
   ((c_term_quadratic_conj formula-decl nil quadratic nil)
    (Sign type-eq-decl nil sign "reals/")
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (discr const-decl "real" quadratic "reals/")
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (quadratic_root const-decl "complex" quadratic nil))
   shostak))
 (discr_lt_0 0
  (discr_lt_0-1 nil 3721412873
   ("" (skeep)
    (("" (expand "quadratic_root")
      (("" (lemma "c_term_quadratic_non_real") (("" (inst?) nil nil))
        nil))
      nil))
    nil)
   ((quadratic_root const-decl "complex" quadratic nil)
    (discr const-decl "real" quadratic "reals/")
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (c_term_quadratic_non_real formula-decl nil quadratic nil))
   shostak))
 (c_quadratic_decomposition 0
  (c_quadratic_decomposition-1 nil 3721583978
   ("" (skeep)
    (("" (expand "quadratic_root")
      (("" (name "D" "discr(a, b, c)")
        (("" (replace -1)
          (("" (case "D >= 0")
            (("1" (rewrite "c_term_quadratic_d_ge_0")
              (("1" (rewrite "c_term_quadratic_d_ge_0")
                (("1" (grind) nil nil)) nil))
              nil)
             ("2" (rewrite "c_term_quadratic_d_lt_0")
              (("2" (rewrite "c_term_quadratic_d_lt_0")
                (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((quadratic_root const-decl "complex" quadratic nil)
    (c_term_quadratic_d_lt_0 formula-decl nil quadratic nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sq_abs const-decl "nnreal" complex_types nil)
    (/ const-decl "complex" complex_types nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (posreal_plus_nnreal_is_posreal application-judgement "posreal"
     real_types nil)
    (c_term_quadratic_d_ge_0 formula-decl nil quadratic nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (Sign type-eq-decl nil sign "reals/")
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (sq const-decl "nonneg_real" sq "reals/")
    (complex_ const-decl "complex" complex_types nil)
    (* const-decl "complex" complex_types nil)
    (sq const-decl "complex" complex_types nil)
    (+ const-decl "complex" complex_types nil)
    (c_quadratic const-decl "complex" quadratic nil) nil
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (discr const-decl "real" quadratic "reals/")
    (nzreal nonempty-type-eq-decl nil reals nil))
   nil))
 (quadratic_root_correct 0
  (quadratic_root_correct-1 nil 3721583948
   ("" (skeep)
    (("" (rewrite "c_quadratic_decomposition")
      (("" (split)
        (("1" (flatten)
          (("1" (rewrite "zero_times")
            (("1" (split)
              (("1" (inst 1 "1")
                (("1" (name-replace "R" "quadratic_root(a,b,c,1)")
                  (("1" (grind :rewrites "complex_ext") nil nil)) nil))
                nil)
               ("2" (inst 1 "-1")
                (("2" (name-replace "R" "quadratic_root(a,b,c,-1)")
                  (("2" (grind :rewrites "complex_ext") nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (skeep)
            (("2" (typepred "eps")
              (("2" (split -2)
                (("1" (replaces -1)
                  (("1" (replaces -2 :dir rl)
                    (("1" (rewrite "complex_sub_zero")
                      (("1" (rewrite "zero_times")
                        (("1" (flatten)
                          (("1" (hide 3)
                            (("1" (grind :rewrites "complex_ext") nil
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (replaces -1)
                  (("2" (replaces -2 :dir rl)
                    (("2" (rewrite "complex_sub_zero")
                      (("2" (rewrite "zero_times") nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((c_quadratic_decomposition formula-decl nil quadratic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (complex type-eq-decl nil complex_types nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (complex_sub_zero formula-decl nil complex_types nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (complex_ext formula-decl nil complex_types nil)
    (quadratic_root const-decl "complex" quadratic nil)
    (Sign type-eq-decl nil sign "reals/")
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil) nil
    (complex_ const-decl "complex" complex_types nil)
    (* const-decl "complex" complex_types nil)
    (zero_times formula-decl nil complex_types nil))
   shostak))
 (quadratic_root_correct_discr_0 0
  (quadratic_root_correct_discr_0-1 nil 3722879459
   ("" (skeep*)
    (("" (lemma "quadratic_root_correct")
      (("" (insteep)
        (("" (replaces -1)
          (("" (expand "quadratic_root")
            (("" (lemma "c_term_quadratic_d_eq_0")
              (("" (insteep :but "eps")
                (("" (split)
                  (("1" (flatten)
                    (("1" (skeep)
                      (("1" (insteep) (("1" (assert) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (inst -2 "1")
                      (("2" (inst 1 "1") (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((quadratic_root_correct formula-decl nil quadratic nil)
    (c_term_quadratic_d_eq_0 formula-decl nil quadratic nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (Sign type-eq-decl nil sign "reals/")
    (quadratic_root const-decl "complex" quadratic nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (complex type-eq-decl nil complex_types nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (quadratic_roots_TCC1 0
  (quadratic_roots_TCC1-1 nil 3721323757 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (complex type-eq-decl nil complex_types nil)
    (list type-decl nil list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (length def-decl "nat" list_props nil))
   nil (quadratic_roots subtype "0" "below[length[complex](l)]")))
 (quadratic_roots_TCC2 0
  (quadratic_roots_TCC2-1 nil 3721323757
   ("" (grind :exclude "quadratic_root") nil nil)
   ((nth def-decl "T" list_props nil)
    (length def-decl "nat" list_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (complex type-eq-decl nil complex_types nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (/= const-decl "boolean" notequal nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil (quadratic_roots subtype "1" "below[length[complex](l)]")))
 (quadratic_roots_TCC3 0
  (quadratic_roots_TCC3-1 nil 3721325506
   ("" (skeep*)
    (("" (assert)
      (("" (expand "nth")
        (("" (expand "quadratic_root")
          (("" (replaces -1 :dir rl)
            (("" (replaces -)
              (("" (rewrite "c_term_quadratic_d_eq_0") nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((minus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (length_singleton formula-decl nil more_list_props "structures/")
    (quadratic_root const-decl "complex" quadratic nil)
    (Sign type-eq-decl nil sign "reals/")
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (c_term_quadratic_d_eq_0 formula-decl nil quadratic nil)
    (nth def-decl "T" list_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (quadratic_roots subtype
    "(: complex_types.complex_(number_fields./((number_fields.-)(quadratic.b), quadratic.a2), 0) :)"
    "{l: (list_adt[complex].cons?) | booleans.AND(reals.<=(list_props[complex].length(l), 2), booleans.AND(list_props[complex].nth(l, 0) = quadratic.quadratic_root(quadratic.a, quadratic.b, quadratic.c, 1), IF list_props[complex].length(l) = 1 THEN quadratic.discr(quadratic.a, quadratic.b, quadratic.c) = 0 ELSE booleans.AND(list_props[complex].nth(l, 1) = quadratic.quadratic_root(quadratic.a, quadratic.b, quadratic.c, (number_fields.-)(1)), quadratic.discr(quadratic.a, quadratic.b, quadratic.c) /= 0) ENDIF))}")))
 (quadratic_roots_TCC4 0
  (quadratic_roots_TCC4-1 nil 3721325506
   ("" (skeep*) (("" (assert) nil nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil (quadratic_roots subtype "quadratic.D" "nonneg_real")))
 (quadratic_roots_TCC5 0
  (quadratic_roots_TCC5-2 nil 3770654382
   ("" (skeep*)
    (("" (expand "length")
      (("" (expand "length")
        (("" (expand "length")
          (("" (expand "nth")
            (("" (expand "nth")
              (("" (rewrite "complex_div_real")
                (("" (rewrite "complex_div_real")
                  (("" (expand "quadratic_root")
                    (("" (rewrite "c_term_quadratic_d_ge_0")
                      (("" (rewrite "c_term_quadratic_d_ge_0")
                        (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nth def-decl "T" list_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (complex_div_real formula-decl nil complex_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (quadratic_root const-decl "complex" quadratic nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (c_term_quadratic_d_ge_0 formula-decl nil quadratic nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (discr const-decl "real" quadratic "reals/")
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Sign type-eq-decl nil sign "reals/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (minus_real_is_real application-judgement "real" reals nil))
   nil
   (quadratic_roots subtype
    "(: complex_types./(complex_types.complex_((number_fields.+)((number_fields.-)(quadratic.b), quadratic.sqrtd), 0), complex_types.complex_(quadratic.a2, 0)), complex_types./(complex_types.complex_((number_fields.-)((number_fields.-)(quadratic.b), quadratic.sqrtd), 0), complex_types.complex_(quadratic.a2, 0)) :)"
    "{l: (list_adt[complex].cons?) | booleans.AND(reals.<=(list_props[complex].length(l), 2), booleans.AND(list_props[complex].nth(l, 0) = quadratic.quadratic_root(quadratic.a, quadratic.b, quadratic.c, 1), IF list_props[complex].length(l) = 1 THEN quadratic.discr(quadratic.a, quadratic.b, quadratic.c) = 0 ELSE booleans.AND(list_props[complex].nth(l, 1) = quadratic.quadratic_root(quadratic.a, quadratic.b, quadratic.c, (number_fields.-)(1)), quadratic.discr(quadratic.a, quadratic.b, quadratic.c) /= 0) ENDIF))}"))
  (quadratic_roots_TCC5-1 nil 3721325506
   ("" (skeep*) (("" (assert) nil nil)) nil)
   ((eq_rew formula-decl nil complex_types nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (quadratic_roots subtype
    "(: complex_types./(complex_types.complex_((number_fields.+)((number_fields.-)(quadratic.b), quadratic.sqrtd), 0), complex_types.complex_(quadratic.a2, 0)), complex_types./(complex_types.complex_((number_fields.-)((number_fields.-)(quadratic.b), quadratic.sqrtd), 0), complex_types.complex_(quadratic.a2, 0)) :)"
    "{l: (list_adt[complex].cons?) | booleans.AND(reals.<=(list_props[complex].length(l), 2), booleans.AND(list_props[complex].nth(l, 0) = quadratic.quadratic_root(quadratic.a, quadratic.b, quadratic.c, 1), IF list_props[complex].length(l) = 1 THEN quadratic.discr(quadratic.a, quadratic.b, quadratic.c) = 0 ELSE booleans.AND(list_props[complex].nth(l, 1) = quadratic.quadratic_root(quadratic.a, quadratic.b, quadratic.c, (number_fields.-)(1)), quadratic.discr(quadratic.a, quadratic.b, quadratic.c) /= 0) ENDIF))}")))
 (quadratic_roots_TCC6 0
  (quadratic_roots_TCC6-2 nil 3722881825
   ("" (skeep*)
    (("" (expand "length")
      (("" (expand "length")
        (("" (expand "length")
          (("" (expand "nth")
            (("" (expand "nth")
              (("" (rewrite "complex_div_real")
                (("" (rewrite "complex_div_real")
                  (("" (expand "quadratic_root")
                    (("" (rewrite "c_term_quadratic_d_ge_0")
                      (("" (rewrite "c_term_quadratic_d_ge_0")
                        (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((minus_real_is_real application-judgement "real" reals nil)
    (length def-decl "nat" list_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (Sign type-eq-decl nil sign "reals/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (discr const-decl "real" quadratic "reals/")
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (c_term_quadratic_d_ge_0 formula-decl nil quadratic nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (quadratic_root const-decl "complex" quadratic nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nnreal type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (complex_div_real formula-decl nil complex_types nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (nth def-decl "T" list_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (quadratic_roots subtype "(number_fields.-)(quadratic.D)"
    "nonneg_real"))
  (quadratic_roots_TCC6-1 nil 3721390109
   ("" (skeep*) (("" (assert) nil nil)) nil) nil nil
   (quadratic_roots subtype "(number_fields.-)(quadratic.D)"
    "nonneg_real")))
 (quadratic_roots_TCC7 0
  (quadratic_roots_TCC7-2 nil 3770654825
   ("" (skeep*)
    (("" (expand "length")
      (("" (expand "length")
        (("" (expand "length")
          (("" (expand "nth")
            (("" (expand "nth")
              (("" (assert)
                (("" (expand "quadratic_root")
                  (("" (replaces -1 :dir rl)
                    (("" (replaces -)
                      (("" (rewrite "c_term_quadratic_d_lt_0")
                        (("" (rewrite "c_term_quadratic_d_lt_0")
                          (("" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nth def-decl "T" list_props nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (c_term_quadratic_d_lt_0 formula-decl nil quadratic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (Sign type-eq-decl nil sign "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (quadratic_root const-decl "complex" quadratic nil)
    (length def-decl "nat" list_props nil))
   nil
   (quadratic_roots subtype
    "(: complex_types./(complex_types.complex_((number_fields.-)(quadratic.b), quadratic.sqrtd), complex_types.complex_(quadratic.a2, 0)), complex_types./(complex_types.complex_((number_fields.-)(quadratic.b), (number_fields.-)(quadratic.sqrtd)), complex_types.complex_(quadratic.a2, 0)) :)"
    "{l: (list_adt[complex].cons?) | booleans.AND(reals.<=(list_props[complex].length(l), 2), booleans.AND(list_props[complex].nth(l, 0) = quadratic.quadratic_root(quadratic.a, quadratic.b, quadratic.c, 1), IF list_props[complex].length(l) = 1 THEN quadratic.discr(quadratic.a, quadratic.b, quadratic.c) = 0 ELSE booleans.AND(list_props[complex].nth(l, 1) = quadratic.quadratic_root(quadratic.a, quadratic.b, quadratic.c, (number_fields.-)(1)), quadratic.discr(quadratic.a, quadratic.b, quadratic.c) /= 0) ENDIF))}"))
  (quadratic_roots_TCC7-1 nil 3721390109
   ("" (skeep*) (("" (assert) nil nil)) nil)
   ((minus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (quadratic_roots subtype
    "(: complex_types./(complex_types.complex_((number_fields.-)(quadratic.b), quadratic.sqrtd), complex_types.complex_(quadratic.a2, 0)), complex_types./(complex_types.complex_((number_fields.-)(quadratic.b), (number_fields.-)(quadratic.sqrtd)), complex_types.complex_(quadratic.a2, 0)) :)"
    "{l: (list_adt[complex].cons?) | booleans.AND(reals.<=(list_props[complex].length(l), 2), booleans.AND(list_props[complex].nth(l, 0) = quadratic.quadratic_root(quadratic.a, quadratic.b, quadratic.c, 1), IF list_props[complex].length(l) = 1 THEN quadratic.discr(quadratic.a, quadratic.b, quadratic.c) = 0 ELSE booleans.AND(list_props[complex].nth(l, 1) = quadratic.quadratic_root(quadratic.a, quadratic.b, quadratic.c, (number_fields.-)(1)), quadratic.discr(quadratic.a, quadratic.b, quadratic.c) /= 0) ENDIF))}")))
 (quadratic_roots_correct 0
  (quadratic_roots_correct-1 nil 3721324048
   ("" (skeep)
    (("" (name "L" "quadratic_roots(a,b,c)")
      (("" (replace -1)
        (("" (hide -1)
          (("" (typepred "L")
            (("" (rewrite "member_iff_nth[complex]")
              (("" (split 1)
                (("1" (flatten)
                  (("1" (lemma "quadratic_root_correct")
                    (("1" (insteep -1)
                      (("1" (assert)
                        (("1" (case-replace "discr(a,b,c)=0")
                          (("1" (assert)
                            (("1" (lemma "discr_eq_0")
                              (("1"
                                (inst?)
                                (("1"
                                  (replaces -1)
                                  (("1"
                                    (skeep -2)
                                    (("1"
                                      (typepred "eps")
                                      (("1"
                                        (inst 1 "0")
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert)
                            (("2" (skeep)
                              (("2"
                                (typepred "eps")
                                (("2"
                                  (split -2)
                                  (("1"
                                    (inst 2 "0")
                                    (("1" (assert) nil nil))
                                    nil)
                                   ("2"
                                    (inst 2 "1")
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (lemma "quadratic_root_correct")
                    (("2" (insteep -1)
                      (("2" (replaces -1)
                        (("2" (skeep -1)
                          (("2" (case-replace "i=0")
                            (("1" (inst 1 "1") (("1" (assert) nil nil))
                              nil)
                             ("2" (case-replace "i=1")
                              (("1"
                                (inst 2 "-1")
                                (("1" (assert) nil nil))
                                nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((quadratic_roots const-decl "{l: (cons?[complex]) |
   length(l) <= 2 AND
    LET r1 = nth(l, 0) IN
      r1 = quadratic_root(a, b, c, 1) AND
       IF length(l) = 1 THEN discr(a, b, c) = 0
       ELSE LET r2 = nth(l, 1) IN
              r2 = quadratic_root(a, b, c, -1) AND discr(a, b, c) /= 0
       ENDIF}" quadratic nil)
    (discr const-decl "real" quadratic "reals/")
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (quadratic_root const-decl "complex" quadratic nil)
    (Sign type-eq-decl nil sign "reals/")
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (complex type-eq-decl nil complex_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (member_iff_nth formula-decl nil more_list_props "structures/")
    (discr_eq_0 formula-decl nil quadratic nil)
    (TRUE const-decl "bool" booleans nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (quadratic_root_correct formula-decl nil quadratic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   shostak))
 (quadratic_roots_1_TCC1 0
  (quadratic_roots_1_TCC1-1 nil 3721426799 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (/= const-decl "boolean" notequal nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sq const-decl "nonneg_real" sq "reals/")
    (discr const-decl "real" quadratic "reals/")
    (real_times_real_is_real application-judgement "real" reals nil))
   nil
   (quadratic_roots_1 subtype "0"
    "below[length[complex](quadratic_roots(a, b, c))]")))
 (quadratic_roots_1 0
  (quadratic_roots_1-1 nil 3721426799
   ("" (skeep)
    (("" (name "L" "quadratic_roots(a,b,c)")
      (("" (replaces -1)
        (("" (typepred "L")
          (("" (assert)
            (("" (hide -5)
              (("" (split)
                (("1" (assert)
                  (("1"
                    (case "discr(a,b,c) >= 0 IFF
    FORALL (eps) : real_?(quadratic_root(a,b,c,eps))")
                    (("1" (assert)
                      (("1" (inst -1 "1") (("1" (assert) nil nil))
                        nil))
                      nil)
                     ("2" (assert)
                      (("2" (lemma "c_term_quadratic_eq")
                        (("2" (expand "quadratic_root")
                          (("2" (inst?)
                            (("2" (assert) (("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (lemma "discr_eq_0")
                  (("2" (insteep)
                    (("2" (assert)
                      (("2" (typepred "eps") (("2" (ground) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (real_? const-decl "bool" complex_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (c_term_quadratic_eq formula-decl nil quadratic nil)
    (sq const-decl "nonneg_real" sq "reals/")
    (complex_ const-decl "complex" complex_types nil)
    (sq_abs const-decl "nnreal" complex_types nil)
    (/ const-decl "complex" complex_types nil)
    (c_term_quadratic const-decl "complex" quadratic nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (sign_neg_clos application-judgement "Sign" sign "reals/")
    (discr_eq_0 formula-decl nil quadratic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (complex type-eq-decl nil complex_types nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (/= const-decl "boolean" notequal nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (Sign type-eq-decl nil sign "reals/")
    (quadratic_root const-decl "complex" quadratic nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (discr const-decl "real" quadratic "reals/")
    (quadratic_roots const-decl "{l: (cons?[complex]) |
   length(l) <= 2 AND
    LET r1 = nth(l, 0) IN
      r1 = quadratic_root(a, b, c, 1) AND
       IF length(l) = 1 THEN discr(a, b, c) = 0
       ELSE LET r2 = nth(l, 1) IN
              r2 = quadratic_root(a, b, c, -1) AND discr(a, b, c) /= 0
       ENDIF}" quadratic nil))
   nil))
 (quadratic_roots_2_TCC1 0
  (quadratic_roots_2_TCC1-1 nil 3721426832 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (/= const-decl "boolean" notequal nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sq const-decl "nonneg_real" sq "reals/")
    (discr const-decl "real" quadratic "reals/")
    (real_times_real_is_real application-judgement "real" reals nil))
   nil
   (quadratic_roots_2 subtype "0"
    "below[length[complex](quadratic_roots(a, b, c))]")))
 (quadratic_roots_2_TCC2 0
  (quadratic_roots_2_TCC2-1 nil 3721426832 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (/= const-decl "boolean" notequal nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sq const-decl "nonneg_real" sq "reals/")
    (discr const-decl "real" quadratic "reals/")
    (real_times_real_is_real application-judgement "real" reals nil))
   nil
   (quadratic_roots_2 subtype "1"
    "below[length[complex](quadratic_roots(a, b, c))]")))
 (quadratic_roots_2 0
  (quadratic_roots_2-1 nil 3721426832
   ("" (skeep)
    (("" (name "L" "quadratic_roots(a,b,c)")
      (("" (replaces -1)
        (("" (typepred "L")
          (("" (case "discr(a, b, c) = 0")
            (("1" (assert) nil nil)
             ("2" (assert)
              (("2" (hide -4)
                (("2" (lemma "discr_eq_0")
                  (("2" (inst?)
                    (("2" (assert)
                      (("2" (case "discr(a,b,c) > 0")
                        (("1" (assert)
                          (("1"
                            (case "discr(a,b,c) >= 0 IFF
    FORALL (eps) : real_?(quadratic_root(a,b,c,eps))")
                            (("1" (assert)
                              (("1"
                                (inst-cp -1 "1")
                                (("1"
                                  (inst -1 "-1")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (expand "quadratic_root" 1)
                              (("2"
                                (lemma "c_term_quadratic_real")
                                (("2"
                                  (inst?)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (lemma "discr_lt_0")
                          (("2" (inst?)
                            (("2" (assert)
                              (("2"
                                (inst-cp -1 "1")
                                (("2"
                                  (inst -1 "-1")
                                  (("2"
                                    (assert)
                                    (("2"
                                      (lemma "discr_le_0")
                                      (("2"
                                        (insteep :but "eps")
                                        (("2"
                                          (assert)
                                          (("2"
                                            (inst -1 "1")
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (real_? const-decl "bool" complex_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (c_term_quadratic_real formula-decl nil quadratic nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (discr_le_0 formula-decl nil quadratic nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (discr_lt_0 formula-decl nil quadratic nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (discr_eq_0 formula-decl nil quadratic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (complex type-eq-decl nil complex_types nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (/= const-decl "boolean" notequal nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (Sign type-eq-decl nil sign "reals/")
    (quadratic_root const-decl "complex" quadratic nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (discr const-decl "real" quadratic "reals/")
    (quadratic_roots const-decl "{l: (cons?[complex]) |
   length(l) <= 2 AND
    LET r1 = nth(l, 0) IN
      r1 = quadratic_root(a, b, c, 1) AND
       IF length(l) = 1 THEN discr(a, b, c) = 0
       ELSE LET r2 = nth(l, 1) IN
              r2 = quadratic_root(a, b, c, -1) AND discr(a, b, c) /= 0
       ENDIF}" quadratic nil))
   nil))
 (qtest_r 0
  (qtest_r-1 nil 3721327717 ("" (grind) nil nil)
   ((minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers
     nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (quadratic_roots const-decl "{l: (cons?[complex]) |
   length(l) <= 2 AND
    LET r1 = nth(l, 0) IN
      r1 = quadratic_root(a, b, c, 1) AND
       IF length(l) = 1 THEN discr(a, b, c) = 0
       ELSE LET r2 = nth(l, 1) IN
              r2 = quadratic_root(a, b, c, -1) AND discr(a, b, c) /= 0
       ENDIF}" quadratic nil)
    (complex_ const-decl "complex" complex_types nil)
    (discr const-decl "real" quadratic "reals/")
    (sq const-decl "nonneg_real" sq "reals/"))
   shostak))
 (qtest_rr 0
  (qtest_rr-1 nil 3721327748
   ("" (grind)
    (("" (eval-expr "sq(7)")
      (("" (replaces -1 :dir rl)
        (("" (rewrite "reals@sqrt_sq") (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (sqrt_sq formula-decl nil sqrt "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (even_minus_even_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (posreal_plus_nnreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sqrt_pos application-judgement "posreal" sqrt "reals/")
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers
     nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (sq const-decl "nonneg_real" sq "reals/")
    (discr const-decl "real" quadratic "reals/")
    (complex_ const-decl "complex" complex_types nil)
    (sq_abs const-decl "nnreal" complex_types nil)
    (/ const-decl "complex" complex_types nil)
    (quadratic_roots const-decl "{l: (cons?[complex]) |
   length(l) <= 2 AND
    LET r1 = nth(l, 0) IN
      r1 = quadratic_root(a, b, c, 1) AND
       IF length(l) = 1 THEN discr(a, b, c) = 0
       ELSE LET r2 = nth(l, 1) IN
              r2 = quadratic_root(a, b, c, -1) AND discr(a, b, c) /= 0
       ENDIF}" quadratic nil))
   nil))
 (qtest_cc 0
  (qtest_cc-1 nil 3721327778 ("" (grind) nil nil)
   ((real_minus_real_is_real application-judgement "real" reals nil)
    (sq_nz_pos application-judgement "posreal" sq "reals/")
    (sqrt_pos application-judgement "posreal" sqrt "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (posreal_plus_nnreal_is_posreal application-judgement "posreal"
     real_types nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (quadratic_roots const-decl "{l: (cons?[complex]) |
   length(l) <= 2 AND
    LET r1 = nth(l, 0) IN
      r1 = quadratic_root(a, b, c, 1) AND
       IF length(l) = 1 THEN discr(a, b, c) = 0
       ELSE LET r2 = nth(l, 1) IN
              r2 = quadratic_root(a, b, c, -1) AND discr(a, b, c) /= 0
       ENDIF}" quadratic nil)
    (/ const-decl "complex" complex_types nil)
    (sq_abs const-decl "nnreal" complex_types nil)
    (complex_ const-decl "complex" complex_types nil)
    (sqrt_4 formula-decl nil sqrt "reals/")
    (discr const-decl "real" quadratic "reals/")
    (sq const-decl "nonneg_real" sq "reals/"))
   shostak)))

