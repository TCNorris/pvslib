(gsAccel
 (gsAccel_Vel_prep_TCC1 0
  (gsAccel_Vel_prep_TCC1-1 nil 3616237515 ("" (assuming-tcc) nil nil)
   ((vect2 const-decl "Vect2" vect_3D_2D vectors)
    (* const-decl "real" vectors_2D vectors)
    (sqv const-decl "nnreal" vectors_2D vectors)
    (norm const-decl "nnreal" vectors_2D vectors)
    (* const-decl "Vector" vectors_2D vectors)
    (Vect3 const-decl "{vv: Vect3 | vect2(vv) = w AND vv`z = z}" util nil)
    (gsAccelSplit const-decl "Vect3" gsAccel nil)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (real_times_real_is_real application-judgement "real" reals nil))
   nil
   (gsAccel_Vel_prep assuming "analysis@integral_def[real].integral_def"
    "connected_domain: ASSUMPTION deriv_domain_def[T].connected?")))
 (gsAccel_Vel_prep_TCC2 0
  (gsAccel_Vel_prep_TCC2-1 nil 3616237515
   ("" (skosimp*)
    (("" (expand "not_one_element?")
      (("" (skosimp*) (("" (inst 1 "x!1+1") (("" (ground) nil nil)) nil))
        nil))
      nil))
    nil)
   ((not_one_element? const-decl "bool" deriv_domain_def analysis)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil))
   nil
   (gsAccel_Vel_prep assuming "analysis@integral_def[real].integral_def"
    "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?")))
 (gsAccel_Vel_prep 0
  (gsAccel_Vel_prep-2 nil 3616237784
   ("" (skeep)
    (("" (skoletin)
      (("" (split)
        (("1"
          (lemma "Integral_const_fun[real]" ("a" "0" "b" "t" "D" "gsAS`x"))
          (("1" (flatten) nil nil)
           ("2" (ground)
            (("2" (expand "connected?") (("2" (propax) nil nil)) nil)) nil))
          nil)
         ("2"
          (lemma "Integral_const_fun[real]" ("a" "0" "b" "t" "D" "gsAS`y"))
          (("1" (flatten) nil nil)
           ("2" (ground)
            (("2" (expand "connected?") (("2" (propax) nil nil)) nil)) nil))
          nil)
         ("3"
          (lemma "Integral_const_fun[real]" ("a" "0" "b" "t" "D" "gsAS`z"))
          (("1" (flatten) nil nil)
           ("2" (ground)
            (("2" (expand "connected?") (("2" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (Vect3 type-eq-decl nil vectors_3D_def vectors)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (gsAccelSplit const-decl "Vect3" gsAccel nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Integrable? const-decl "bool" integral_def analysis)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (Integral_const_fun formula-decl nil integral analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (constant_seq1 application-judgement "(convergent?)" convergence_ops
     analysis)
    (derivable_const application-judgement "deriv_fun[real]" pi_def trig))
   nil)
  (gsAccel_Vel_prep-1 nil 3616237587
   ("" (skeep)
    (("" (skoletin)
      (("" (split)
        (("1"
          (lemma "Integral_const_fun[real]" ("a" "0" "b" "t" "D" "gsAS`x"))
          (("1" (flatten) nil nil)
           ("2" (ground)
            (("2" (expand "connected?") (("2" (propax) nil nil)) nil)) nil))
          nil)
         ("2" (ground)
          (("2"
            (lemma "Integral_const_fun[real]" ("a" "0" "b" "t" "D" "gsAS`y"))
            (("1" (flatten) nil nil)
             ("2" (ground)
              (("2" (expand "connected?") (("2" (propax) nil nil)) nil)) nil))
            nil))
          nil)
         ("3" (ground)
          (("3"
            (lemma "Integral_const_fun[real]" ("a" "0" "b" "t" "D" "gsAS`z"))
            (("1" (flatten) nil nil)
             ("2" (ground)
              (("2" (expand "connected?") (("2" (propax) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Vect3 type-eq-decl nil vectors_3D_def vectors)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (Integrable? const-decl "bool" integral_def analysis)
    (Integral_const_fun formula-decl nil integral analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis))
   shostak))
 (gsAccel_Vel_Int_TCC1 0
  (gsAccel_Vel_Int_TCC1-1 nil 3616236812
   ("" (skeep)
    (("" (lemma "gsAccel_Vel_prep" ("vo3" "vo3" "a" "a" "t" "t"))
      (("" (skoletin) (("" (flatten) (("" (ground) nil nil)) nil)) nil)) nil))
    nil)
   ((real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Vect3 type-eq-decl nil vectors_3D_def vectors)
    (real nonempty-type-from-decl nil reals nil)
    (gsAccel_Vel_prep formula-decl nil gsAccel nil)
    (constant_seq1 application-judgement "(convergent?)" convergence_ops
     analysis)
    (derivable_const application-judgement "deriv_fun[real]" pi_def trig)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (Integrable? const-decl "bool" integral_def analysis)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (gsAccelSplit const-decl "Vect3" gsAccel nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   nil
   (gsAccel_Vel_Int subtype "real_fun_ops[real].const_fun(gsAccel.gsAS`x)"
    "integral_def[real].Integrable_funs(0, gsAccel.t)")))
 (gsAccel_Vel_Int_TCC2 0
  (gsAccel_Vel_Int_TCC2-1 nil 3616236812
   ("" (skeep)
    (("" (skeep)
      (("" (lemma "gsAccel_Vel_prep" ("vo3" "vo3" "a" "a" "t" "t"))
        (("" (skoletin) (("" (flatten) (("" (ground) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (gsAccelSplit const-decl "Vect3" gsAccel nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Integrable? const-decl "bool" integral_def analysis)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (derivable_const application-judgement "deriv_fun[real]" pi_def trig)
    (constant_seq1 application-judgement "(convergent?)" convergence_ops
     analysis)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (gsAccel_Vel_prep formula-decl nil gsAccel nil)
    (real nonempty-type-from-decl nil reals nil)
    (Vect3 type-eq-decl nil vectors_3D_def vectors)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil))
   nil
   (gsAccel_Vel_Int subtype "real_fun_ops[real].const_fun(gsAccel.gsAS`y)"
    "integral_def[real].Integrable_funs(0, gsAccel.t)")))
 (gsAccel_Vel_Int_TCC3 0
  (gsAccel_Vel_Int_TCC3-1 nil 3616236812
   ("" (skeep)
    (("" (skeep)
      (("" (skeep)
        (("" (lemma "gsAccel_Vel_prep" ("vo3" "vo3" "a" "a" "t" "t"))
          (("" (skoletin) (("" (flatten) (("" (ground) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Vect3 type-eq-decl nil vectors_3D_def vectors)
    (real nonempty-type-from-decl nil reals nil)
    (gsAccel_Vel_prep formula-decl nil gsAccel nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (constant_seq1 application-judgement "(convergent?)" convergence_ops
     analysis)
    (derivable_const application-judgement "deriv_fun[real]" pi_def trig)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (Integrable? const-decl "bool" integral_def analysis)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (gsAccelSplit const-decl "Vect3" gsAccel nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   nil
   (gsAccel_Vel_Int subtype "real_fun_ops[real].const_fun(gsAccel.gsAS`z)"
    "integral_def[real].Integrable_funs(0, gsAccel.t)")))
 (Integral_gsAccel_Vel 0
  (Integral_gsAccel_Vel-1 nil 3616238097
   ("" (skeep)
    (("" (case "connected?[real]")
      (("1" (decompose-equality)
        (("1" (expand "gsAccel_Vel_Int")
          (("1"
            (lemma "Integral_const_fun[real]"
             ("a" "0" "b" "t" "D" "gsAccelSplit(vo3, a)`x"))
            (("1" (flatten)
              (("1" (replace -2)
                (("1" (expand "gsAccel_Vel_Calc") (("1" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "gsAccel_Vel_Int")
          (("2"
            (lemma "Integral_const_fun[real]"
             ("a" "0" "b" "t" "D" "gsAccelSplit(vo3, a)`y"))
            (("2" (flatten)
              (("2" (replace -2)
                (("2" (expand "gsAccel_Vel_Calc") (("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (expand "gsAccel_Vel_Int")
          (("3"
            (lemma "Integral_const_fun[real]"
             ("a" "0" "b" "t" "D" "gsAccelSplit(vo3, a)`z"))
            (("3" (flatten)
              (("3" (replace -2)
                (("3" (expand "gsAccel_Vel_Calc")
                  (("3" (expand "gsAccelSplit")
                    (("3" (expand "Vect3") (("3" (ground) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "connected?") (("2" (propax) nil nil)) nil))
      nil))
    nil)
   ((connected? const-decl "bool" deriv_domain_def analysis)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Vect3 const-decl "{vv: Vect3 | vect2(vv) = w AND vv`z = z}" util nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (constant_seq1 application-judgement "(convergent?)" convergence_ops
     analysis)
    (derivable_const application-judgement "deriv_fun[real]" pi_def trig)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (gsAccelSplit const-decl "Vect3" gsAccel nil)
    (Integral_const_fun formula-decl nil integral analysis)
    (Vect3 type-eq-decl nil vectors_3D_def vectors)
    (gsAccel_Vel_Calc const-decl "Vect3" gsAccel nil)
    (gsAccel_Vel_Int const-decl "Vect3" gsAccel nil))
   shostak))
 (gsAccel_Pos_prep 0
  (gsAccel_Pos_prep-1 nil 3616239824
   ("" (skeep)
    (("" (lemma "integral_linear[real]")
      (("1" (expand "gsAccel_Vel_Calc")
        (("1" (split)
          (("1" (inst -1 "0" "t" "gsAccelSplit(vo3, a)`x" "vo3`x")
            (("1" (skoletin) (("1" (flatten) (("1" (ground) nil nil)) nil))
              nil))
            nil)
           ("2" (inst -1 "0" "t" "gsAccelSplit(vo3, a)`y" "vo3`y")
            (("2" (skoletin) (("2" (flatten) (("2" (ground) nil nil)) nil))
              nil))
            nil)
           ("3" (inst -1 "0" "t" "0" "vo3`z")
            (("3" (skoletin) (("3" (flatten) (("3" (ground) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "connected?") (("2" (propax) nil nil)) nil))
      nil))
    nil)
   ((real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Integrable? const-decl "bool" integral_def analysis)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (^ const-decl "real" exponentiation nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Integral const-decl "real" integral_def analysis)
    (Integrable_funs type-eq-decl nil integral_def analysis)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (nat_exp application-judgement "nat" exponentiation nil)
    (hat_02n formula-decl nil power_series series)
    (Vect3 type-eq-decl nil vectors_3D_def vectors)
    (gsAccelSplit const-decl "Vect3" gsAccel nil)
    (gsAccel_Vel_Calc const-decl "Vect3" gsAccel nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   shostak))
 (gsAccel_Pos_Int_TCC1 0
  (gsAccel_Pos_Int_TCC1-1 nil 3616240762
   ("" (skeep)
    (("" (lemma "gsAccel_Pos_prep" ("so3" "vo3" "vo3" "vo3" "a" "a" "t" "t"))
      (("" (flatten) nil nil)) nil))
    nil)
   ((real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Vect3 type-eq-decl nil vectors_3D_def vectors)
    (real nonempty-type-from-decl nil reals nil)
    (gsAccel_Pos_prep formula-decl nil gsAccel nil))
   nil
   (gsAccel_Pos_Int subtype
    "LAMBDA (s: reals.real): gsAccel.gsAccel_Vel_Calc(gsAccel.vo3, gsAccel.a, s)`x"
    "integral_def[real].Integrable_funs(0, gsAccel.t)")))
 (gsAccel_Pos_Int_TCC2 0
  (gsAccel_Pos_Int_TCC2-1 nil 3616240762
   ("" (skeep)
    (("" (lemma "gsAccel_Pos_prep" ("so3" "vo3" "vo3" "vo3" "a" "a" "t" "t"))
      (("" (flatten) nil nil)) nil))
    nil)
   ((real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Vect3 type-eq-decl nil vectors_3D_def vectors)
    (real nonempty-type-from-decl nil reals nil)
    (gsAccel_Pos_prep formula-decl nil gsAccel nil))
   nil
   (gsAccel_Pos_Int subtype
    "LAMBDA (s: reals.real): gsAccel.gsAccel_Vel_Calc(gsAccel.vo3, gsAccel.a, s)`y"
    "integral_def[real].Integrable_funs(0, gsAccel.t)")))
 (gsAccel_Pos_Int_TCC3 0
  (gsAccel_Pos_Int_TCC3-1 nil 3616240762
   ("" (skeep)
    (("" (skeep)
      ((""
        (lemma "gsAccel_Pos_prep" ("so3" "vo3" "vo3" "vo3" "a" "a" "t" "t"))
        (("" (flatten) nil nil)) nil))
      nil))
    nil)
   ((gsAccel_Pos_prep formula-decl nil gsAccel nil)
    (real nonempty-type-from-decl nil reals nil)
    (Vect3 type-eq-decl nil vectors_3D_def vectors)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil))
   nil
   (gsAccel_Pos_Int subtype
    "LAMBDA (s: reals.real): gsAccel.gsAccel_Vel_Calc(gsAccel.vo3, gsAccel.a, s)`z"
    "integral_def[real].Integrable_funs(0, gsAccel.t)")))
 (gsAccel_Pos_Calc_TCC1 0
  (gsAccel_Pos_Calc_TCC1-1 nil 3616240762 ("" (subtype-tcc) nil nil)
   ((vect2 const-decl "Vect2" vect_3D_2D vectors)
    (* const-decl "real" vectors_2D vectors)
    (sqv const-decl "nnreal" vectors_2D vectors)
    (norm const-decl "nnreal" vectors_2D vectors)
    (* const-decl "Vector" vectors_2D vectors)
    (Vect3 const-decl "{vv: Vect3 | vect2(vv) = w AND vv`z = z}" util nil)
    (gsAccelSplit const-decl "Vect3" gsAccel nil)
    (/= const-decl "boolean" notequal nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   nil
   (gsAccel_Pos_Calc subtype "2"
    "{i: integers.int | booleans.OR(gsAccel.t /= 0, reals.>=(i, 0))}")))
 (Integral_gsAccel_Pos 0
  (Integral_gsAccel_Pos-2 "" 3790107329
   ("" (case "connected?[real]")
    (("1" (skeep)
      (("1" (lemma "integral_linear[real]")
        (("1" (decompose-equality)
          (("1" (expand "gsAccel_Pos_Int")
            (("1" (expand "gsAccel_Vel_Calc")
              (("1" (inst -1 "0" "t" "gsAccelSplit(vo3, a)`x" "vo3`x")
                (("1" (flatten)
                  (("1" (replace -2)
                    (("1" (expand "gsAccel_Pos_Calc") (("1" (ground) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand "gsAccel_Pos_Int")
            (("2" (expand "gsAccel_Vel_Calc")
              (("2" (inst -1 "0" "t" "gsAccelSplit(vo3, a)`y" "vo3`y")
                (("2" (flatten)
                  (("2" (replace -2)
                    (("2" (expand "gsAccel_Pos_Calc") (("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (expand "gsAccel_Pos_Int")
            (("3" (expand "gsAccel_Vel_Calc")
              (("3" (inst -1 "0" "t" "0" "vo3`z")
                (("3" (flatten)
                  (("3" (replace -2)
                    (("3" (expand "gsAccel_Pos_Calc") (("3" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (propax) nil nil))
        nil))
      nil)
     ("2" (expand "connected?") (("2" (propax) nil nil)) nil))
    nil)
   nil shostak)
  (Integral_gsAccel_Pos-1 nil 3616241128
   ("" (case "connected?[real]")
    (("1" (skeep)
      (("1" (lemma "integral_linear[real]")
        (("1" (decompose-equality)
          (("1" (expand "gsAccel_Pos_Int")
            (("1" (expand "gsAccel_Vel_Calc")
              (("1" (inst -1 "0" "t" "gsAccelSplit(vo3, a)`x" "vo3`x")
                (("1" (flatten)
                  (("1" (replace -2)
                    (("1" (expand "gsAccel_Pos_Calc")
                      (("1" (ground) (("1" (grind) nil nil)) nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand "gsAccel_Pos_Int")
            (("2" (expand "gsAccel_Vel_Calc")
              (("2" (inst -1 "0" "t" "gsAccelSplit(vo3, a)`y" "vo3`y")
                (("2" (flatten)
                  (("2" (replace -2)
                    (("2" (expand "gsAccel_Pos_Calc") (("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (expand "gsAccel_Pos_Int")
            (("3" (expand "gsAccel_Vel_Calc")
              (("3" (inst -1 "0" "t" "0" "vo3`z")
                (("3" (flatten)
                  (("3" (replace -2)
                    (("3" (expand "gsAccel_Pos_Calc") (("3" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (propax) nil nil))
        nil))
      nil)
     ("2" (expand "connected?") (("2" (propax) nil nil)) nil))
    nil)
   ((real_minus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (gsAccel_Pos_Calc const-decl "Vect3" gsAccel nil)
    (gsAccel_Pos_Int const-decl "Vect3" gsAccel nil)
    (Vect3 type-eq-decl nil vectors_3D_def vectors)
    (gsAccel_Vel_Calc const-decl "Vect3" gsAccel nil)
    (nat_exp application-judgement "nat" exponentiation nil)
    (hat_02n formula-decl nil power_series series)
    (gsAccelSplit const-decl "Vect3" gsAccel nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nat_expt application-judgement "nat" exponentiation nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (Vect3 const-decl "{vv: Vect3 | vect2(vv) = w AND vv`z = z}" util nil)
    (* const-decl "Vector" vectors_2D vectors)
    (comp_zero_y formula-decl nil vectors_2D vectors)
    (comp_zero_x formula-decl nil vectors_2D vectors)
    (Hat const-decl "{v: Vect2 |
   (v = zero IFF w = zero) AND
    (w /= zero IFF (norm(v) = 1 AND v = (1 / norm(w)) * w))}" util nil)
    (Vect2 const-decl "{vv: Vect2 | vv`x = x AND vv`y = y}" util nil)
    (norm const-decl "nnreal" vectors_2D vectors)
    (sqv const-decl "nnreal" vectors_2D vectors)
    (* const-decl "real" vectors_2D vectors)
    (vect2 const-decl "Vect2" vect_3D_2D vectors)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (connected? const-decl "bool" deriv_domain_def analysis))
   shostak))
 (gsAccelToRTA_possible_TCC1 0
  (gsAccelToRTA_possible_TCC1-1 nil 3616430961 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (gsAccelToRTA_possible subtype "2"
    "{i: integers.int | booleans.OR(gsAccel.t /= 0, reals.>=(i, 0))}")))
 (gsAccelToRTA_possible_TCC2 0
  (gsAccelToRTA_possible_TCC2-1 nil 3616430961 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)
    (minus_real_is_real application-judgement "real" reals nil))
   nil
   (gsAccelToRTA_possible subtype "2"
    "{i: integers.int | booleans.OR(gsAccel.t /= 0, reals.>=(i, 0))}")))
 (gsAccelToRTA_possible_TCC3 0
  (gsAccelToRTA_possible_TCC3-1 nil 3616433064
   ("" (skeep)
    (("" (skeep)
      (("" (expand "min")
        (("" (lift-if)
          (("" (split)
            (("1" (flatten)
              (("1" (grind)
                (("1" (typepred (gsIn))
                  (("1" (div-by -1 "-a") (("1" (grind) nil nil)) nil)) nil))
                nil))
              nil)
             ("2" (flatten) (("2" (typepred (t)) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (both_sides_div_pos_ge1 formula-decl nil real_props nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (minus_real_is_real application-judgement "real" reals nil))
   nil (gsAccelToRTA_possible subtype "gsAccel.T" "nnreal")))
 (neg_groundspeed 0
  (neg_groundspeed-1 nil 3616430978
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (split)
          (("1" (flip-ineq 1)
            (("1" (typepred (gsIn))
              (("1" (mult-by -2 "t") (("1" (add-formulas -1 -2) nil nil))
                nil))
              nil))
            nil)
           ("2" (case "a<0")
            (("1" (cross-mult 1) (("1" (ground) nil nil)) nil)
             ("2" (flip-ineq 1)
              (("2" (typepred (gsIn))
                (("2" (mult-by -2 "t") (("2" (add-formulas -1 -2) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten) (("2" (cross-mult) nil nil)) nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (nnreal type-eq-decl nil real_types nil)
    (zero_times1 formula-decl nil real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (div_mult_neg_gt2 formula-decl nil extra_real_props nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (negreal nonempty-type-eq-decl nil real_types nil)
    (nonpos_real nonempty-type-eq-decl nil real_types nil)
    (a skolem-const-decl "nzreal" gsAccel nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (< const-decl "bool" reals nil))
   shostak)))

