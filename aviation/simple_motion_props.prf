(simple_motion_props
 (IMP_integral_split_fun_TCC1 0
  (IMP_integral_split_fun_TCC1-1 nil 3625504150
   ("" (expand "deriv_domain?")
    (("" (skeep)
      (("" (inst 1 "e/2") (("" (ground) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}"
     real_defs nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (nnreal type-eq-decl nil real_types nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types
     nil)
    (deriv_domain? const-decl "bool" deriv_domain_def analysis)
    (real_plus_real_is_real application-judgement "real" reals nil))
   nil
   (IMP_integral_split_fun assuming
    "analysis@integral_split_fun[nnreal].integral_split_fun"
    "deriv_domain: ASSUMPTION deriv_domain_def[T].deriv_domain?")))
 (IMP_integral_split_fun_TCC2 0
  (IMP_integral_split_fun_TCC2-1 nil 3625504150 ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (connected? const-decl "bool" deriv_domain_def analysis))
   nil
   (IMP_integral_split_fun assuming
    "analysis@integral_split_fun[nnreal].integral_split_fun"
    "connected_domain: ASSUMPTION deriv_domain_def[T].connected?")))
 (IMP_integral_split_fun_TCC3 0
  (IMP_integral_split_fun_TCC3-1 nil 3625504150
   ("" (expand "not_one_element?")
    (("" (skeep) (("" (inst 1 "x+1") (("" (ground) nil nil)) nil)) nil)) nil)
   ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (not_one_element? const-decl "bool" deriv_domain_def analysis))
   nil
   (IMP_integral_split_fun assuming
    "analysis@integral_split_fun[nnreal].integral_split_fun"
    "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?")))
 (accel_int? 0
  (accel_int?-1 nil 3625503615
   ("" (skeep)
    (("" (expand "accel_comp")
      (("" (lemma "Integral_const_fun[nnreal]")
        (("1" (expand "const_fun")
          (("1" (inst?) (("1" (ground) nil nil)) nil)) nil)
         ("2" (expand "connected?")
          (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((accel_comp const-decl "real" simple_motion nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (Integral_const_fun formula-decl nil integral analysis)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil))
   shostak))
 (vel_fnd_TCC1 0
  (vel_fnd_TCC1-1 nil 3625501166
   ("" (skeep)
    (("" (case-replace "accel_comp(a) = const_fun[nnreal](a)")
      (("1" (lemma "Integral_const_fun[nnreal]")
        (("1" (inst?) (("1" (ground) nil nil)) nil)
         ("2" (expand "connected?")
          (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
        nil)
       ("2" (decompose-equality 1)
        (("2" (expand "accel_comp")
          (("2" (expand "const_fun") (("2" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((derivable_const application-judgement "deriv_fun" derivatives_lam
     analysis)
    (constant_seq1 application-judgement "(convergent?)" convergence_ops
     analysis)
    (derivable_const application-judgement "deriv_fun[real]" pi_def trig)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (accel_comp const-decl "real" simple_motion nil)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (Integral_const_fun formula-decl nil integral analysis))
   nil
   (vel_fnd subtype "simple_motion.accel_comp(simple_motion_props.a)"
    "integral_def[nnreal].Integrable_funs(0, simple_motion_props.t)")))
 (vel_equal 0
  (vel_equal-1 nil 3625502049
   ("" (skeep)
    (("" (expand "vel_comp")
      (("" (expand "vel_fnd")
        (("" (decompose-equality)
          (("1" (lemma "Integral_const_fun[nnreal]")
            (("1" (expand "accel_comp")
              (("1" (expand "const_fun")
                (("1" (inst?) (("1" (ground) nil nil)) nil)) nil))
              nil)
             ("2" (expand "connected?")
              (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
            nil)
           ("2" (skeep)
            (("2" (expand "accel_comp")
              (("2" (lemma "Integral_const_fun[nnreal]")
                (("1" (expand "const_fun")
                  (("1" (inst?) (("1" (ground) nil nil)) nil)) nil)
                 ("2" (expand "connected?")
                  (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((vel_comp const-decl "real" simple_motion nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (a skolem-const-decl "real" simple_motion_props nil)
    (accel_comp const-decl "real" simple_motion nil)
    (Integrable? const-decl "bool" integral_def analysis)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Integrable_funs type-eq-decl nil integral_def analysis)
    (Integral const-decl "real" integral_def analysis)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (Integral_const_fun formula-decl nil integral analysis)
    (vel_fnd const-decl "real" simple_motion_props nil))
   shostak))
 (vel_int? 0
  (vel_int?-1 nil 3625503706
   ("" (skeep)
    (("" (expand "vel_comp")
      (("" (lemma "integral_linear[nnreal]")
        (("1" (inst -1 "0" "t" "a" "v")
          (("1" (ground) (("1" (flatten) nil nil)) nil)) nil)
         ("2" (expand "connected?")
          (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((vel_comp const-decl "real" simple_motion nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (zero_hat formula-decl nil exponent_props reals)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil))
   shostak))
 (pos_fnd_TCC1 0
  (pos_fnd_TCC1-1 nil 3625501166
   ("" (skeep)
    (("" (expand "vel_comp")
      (("" (lemma "integral_linear[nnreal]")
        (("1" (inst -1 "0" "t" "a" "v")
          (("1" (ground) (("1" (flatten) nil nil)) nil)) nil)
         ("2" (expand "connected?")
          (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((vel_comp const-decl "real" simple_motion nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (zero_hat formula-decl nil exponent_props reals)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil))
   nil
   (pos_fnd subtype
    "simple_motion.vel_comp(simple_motion_props.v, simple_motion_props.a)"
    "integral_def[nnreal].Integrable_funs(0, simple_motion_props.t)")))
 (pos_equal 0
  (pos_equal-1 nil 3625502232
   ("" (skeep)
    (("" (lemma "integral_linear[nnreal]")
      (("1" (inst -1 "0" "_" "a" "v")
        (("1" (decompose-equality 1)
          (("1" (expand "pos_comp")
            (("1" (expand "pos_fnd")
              (("1" (inst -1 "x!1")
                (("1" (ground)
                  (("1" (expand "vel_comp")
                    (("1" (ground)
                      (("1" (replace -2)
                        (("1" (ground)
                          (("1" (hide -)
                            (("1" (expand "^")
                              (("1" (expand "expt")
                                (("1" (expand "expt")
                                  (("1" (expand "expt")
                                    (("1" (ground) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "connected?") (("2" (skeep) (("2" (ground) nil nil)) nil))
        nil))
      nil))
    nil)
   ((nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (zero_hat formula-decl nil exponent_props reals)
    (pos_fnd const-decl "real" simple_motion_props nil)
    (pos_comp const-decl "real" simple_motion nil)
    (^ const-decl "real" exponentiation nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (expt def-decl "real" exponentiation nil)
    (vel_comp const-decl "real" simple_motion nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   shostak))
 (accelUntil_int? 0
  (accelUntil_int?-1 nil 3625503773
   ("" (skeep)
    ((""
      (case-replace
       "accelUntil_comp(a, t1) = split_fun[nnreal](t1, const_fun[nnreal](a), const_fun[nnreal](0))")
      (("1" (lemma "split_fun_Integrable")
        (("1"
          (inst -1 "const_fun[nnreal](a)" "const_fun[nnreal](0)" "0"
           "max(t, t1)" "t1")
          (("1" (lemma "Integral_const_fun[nnreal]")
            (("1" (ground)
              (("1" (lemma "Integrable?_inside[nnreal]")
                (("1"
                  (inst -1 "0" "max(t, t1)"
                   "split_fun(t1, const_fun[nnreal](a), const_fun[nnreal](0))"
                   "0" "t")
                  (("1" (ground) nil nil)) nil))
                nil)
               ("2" (hide 2) (("2" (inst?) (("2" (ground) nil nil)) nil)) nil)
               ("3" (hide 2) (("3" (inst?) (("3" (ground) nil nil)) nil))
                nil))
              nil)
             ("2" (expand "connected?")
              (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
            nil))
          nil))
        nil)
       ("2" (decompose-equality 1)
        (("2" (expand "accelUntil_comp")
          (("2" (expand "split_fun")
            (("2" (expand "const_fun") (("2" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (accelUntil_comp const-decl "real" simple_motion nil)
    (split_fun const-decl "[T -> real]" integral_split_fun analysis)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (nonneg_real_max application-judgement
     "{z: nonneg_real | z >= x AND z >= y}" real_defs nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (derivable_const application-judgement "deriv_fun" derivatives_lam
     analysis)
    (constant_seq1 application-judgement "(convergent?)" convergence_ops
     analysis)
    (derivable_const application-judgement "deriv_fun[real]" pi_def trig)
    (real_times_real_is_real application-judgement "real" reals nil)
    (Integrable?_inside formula-decl nil integral analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (Integral_const_fun formula-decl nil integral analysis)
    (split_fun_Integrable formula-decl nil integral_split_fun analysis))
   shostak))
 (velUntil_fnd_TCC1 0
  (velUntil_fnd_TCC1-1 nil 3625503538
   ("" (lemma "accelUntil_int?") (("" (propax) nil nil)) nil)
   ((accelUntil_int? formula-decl nil simple_motion_props nil)) nil
   (velUntil_fnd subtype
    "simple_motion.accelUntil_comp(simple_motion_props.a, simple_motion_props.t1)"
    "integral_def[nnreal].Integrable_funs(0, simple_motion_props.t)")))
 (velUntil_equal 0
  (velUntil_equal-1 nil 3625505760
   ("" (skeep)
    (("" (decompose-equality 1)
      (("" (expand "velUntil_fnd")
        ((""
          (case-replace
           "accelUntil_comp(a, t1) = split_fun[nnreal](t1, const_fun[nnreal](a), const_fun[nnreal](0))")
          (("1" (lemma "Integral_split_fun")
            (("1"
              (inst -1 "const_fun[nnreal](a)" "const_fun[nnreal](0)" "0"
               "max(x!1, t1)" "t1" "x!1")
              (("1" (lemma "Integral_const_fun[nnreal]")
                (("1" (ground)
                  (("1" (replace -2)
                    (("1" (inst-cp -3 "a" "0" "x!1")
                      (("1" (inst-cp -3 "a" "0" "t1")
                        (("1" (inst-cp -3 "0" "t1" "x!1")
                          (("1" (flatten)
                            (("1" (replaces -5)
                              (("1" (replaces -6)
                                (("1" (replaces -7)
                                  (("1" (expand "velUntil_comp")
                                    (("1" (hide -) (("1" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inst? -1) (("2" (ground) nil nil)) nil)
                   ("3" (inst? -1) (("3" (ground) nil nil)) nil))
                  nil)
                 ("2" (expand "connected?")
                  (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
                nil))
              nil))
            nil)
           ("2" (decompose-equality 1)
            (("2" (expand "accelUntil_comp")
              (("2" (expand "split_fun")
                (("2" (expand "const_fun") (("2" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((velUntil_comp const-decl "real" simple_motion nil)
    (velUntil_fnd const-decl "real" simple_motion_props nil)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (accelUntil_comp const-decl "real" simple_motion nil)
    (split_fun const-decl "[T -> real]" integral_split_fun analysis)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (nonneg_real_max application-judgement
     "{z: nonneg_real | z >= x AND z >= y}" real_defs nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (derivable_const application-judgement "deriv_fun" derivatives_lam
     analysis)
    (constant_seq1 application-judgement "(convergent?)" convergence_ops
     analysis)
    (derivable_const application-judgement "deriv_fun[real]" pi_def trig)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (TRUE const-decl "bool" booleans nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (Integral_const_fun formula-decl nil integral analysis)
    (Integral_split_fun formula-decl nil integral_split_fun analysis))
   shostak))
 (velUntil_int? 0
  (velUntil_int?-1 nil 3625509462
   ("" (skeep)
    ((""
      (case-replace
       "velUntil_comp(v, a, t1) = split_fun(t1, (LAMBDA(s:nnreal): v+a*s), const_fun[nnreal](v+a*t1))")
      (("1" (hide -)
        (("1" (lemma "split_fun_Integrable")
          (("1"
            (inst -1 "(LAMBDA (s: nnreal): v + a * s)" "
                            const_fun[nnreal](v + a * t1)" "0" "max(t, t1)"
             "t1")
            (("1" (ground)
              (("1" (lemma "Integrable?_inside[nnreal]")
                (("1"
                  (inst -1 "0" "max(t, t1)"
                   "split_fun(t1, (LAMBDA (s: nnreal): a * s + v),
                            const_fun[nnreal](a * t1 + v))" "0" "t")
                  (("1" (ground) nil nil)) nil)
                 ("2" (expand "connected?")
                  (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
                nil)
               ("2" (lemma "integral_linear[nnreal]")
                (("1" (inst?)
                  (("1" (inst?)
                    (("1" (inst -1 "t1") (("1" (ground) nil nil)) nil)) nil))
                  nil)
                 ("2" (expand "connected?")
                  (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
                nil)
               ("3" (lemma "Integral_const_fun[nnreal]")
                (("1" (inst?) (("1" (ground) nil nil)) nil)
                 ("2" (expand "connected?")
                  (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (decompose-equality 1)
        (("2" (expand "velUntil_comp")
          (("2" (expand "split_fun")
            (("2" (expand "const_fun") (("2" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_plus_real_is_real application-judgement "real" reals nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (velUntil_comp const-decl "real" simple_motion nil)
    (split_fun const-decl "[T -> real]" integral_split_fun analysis)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (split_fun_Integrable formula-decl nil integral_split_fun analysis)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (derivable_const application-judgement "deriv_fun" derivatives_lam
     analysis)
    (constant_seq1 application-judgement "(convergent?)" convergence_ops
     analysis)
    (derivable_const application-judgement "deriv_fun[real]" pi_def trig)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (Integrable?_inside formula-decl nil integral analysis)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (zero_hat formula-decl nil exponent_props reals)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (Integral_const_fun formula-decl nil integral analysis)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (nonneg_real_max application-judgement
     "{z: nonneg_real | z >= x AND z >= y}" real_defs nil))
   shostak))
 (posUntil_fnd_TCC1 0
  (posUntil_fnd_TCC1-1 nil 3625505524
   ("" (lemma "velUntil_int?") (("" (propax) nil nil)) nil)
   ((velUntil_int? formula-decl nil simple_motion_props nil)) nil
   (posUntil_fnd subtype
    "simple_motion.velUntil_comp(simple_motion_props.v, simple_motion_props.a, simple_motion_props.t1)"
    "integral_def[nnreal].Integrable_funs(0, simple_motion_props.t)")))
 (posUntil_equal 0
  (posUntil_equal-2 "" 3790106695
   ("" (skeep)
    (("" (decompose-equality 1)
      (("" (expand "posUntil_fnd")
        ((""
          (case-replace
           "velUntil_comp(v, a, t1) = split_fun[nnreal](t1, (LAMBDA(x:nnreal): v+a*x), const_fun[nnreal](v+a*t1))")
          (("1" (hide -1)
            (("1" (lemma "Integral_split_fun")
              (("1"
                (inst -1 "(LAMBDA (x: nnreal): v + a * x)" "
                     const_fun[nnreal](v + a * t1)" "0" "max(x!1, t1)" "t1"
                 "x!1")
                (("1" (ground)
                  (("1" (replace -2)
                    (("1" (lemma "integral_linear[nnreal]")
                      (("1" (inst -1 "0" "_" "a" "v")
                        (("1" (inst-cp -1 "x!1")
                          (("1" (inst -1 "t1")
                            (("1" (lemma "Integral_const_fun[nnreal]")
                              (("1" (inst -1 "a*t1+v" "t1" "x!1")
                                (("1" (flatten)
                                  (("1" (ground)
                                    (("1" (flatten)
                                      (("1"
                                        (replaces -2)
                                        (("1"
                                          (replaces -3)
                                          (("1"
                                            (replaces -4)
                                            (("1"
                                              (hide -)
                                              (("1"
                                                (expand "posUntil_comp")
                                                (("1"
                                                  (expand "^")
                                                  (("1"
                                                    (expand "expt")
                                                    (("1"
                                                      (expand "expt")
                                                      (("1"
                                                        (expand "expt")
                                                        (("1"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand "connected?")
                        (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
                      nil))
                    nil)
                   ("2" (lemma "integral_linear[nnreal]")
                    (("1" (inst?)
                      (("1" (inst -1 "0" "t1") (("1" (ground) nil nil)) nil))
                      nil)
                     ("2" (expand "connected?")
                      (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
                    nil)
                   ("3" (lemma "Integral_const_fun[nnreal]")
                    (("1" (inst?) (("1" (ground) nil nil)) nil)
                     ("2" (expand "connected?")
                      (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (decompose-equality 1)
            (("2" (expand "split_fun")
              (("2" (expand "velUntil_comp")
                (("2" (hide 2)
                  (("2" (expand "const_fun") (("2" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (posUntil_equal-1 nil 3625510323
   ("" (skeep)
    (("" (decompose-equality 1)
      (("" (expand "posUntil_fnd")
        ((""
          (case-replace
           "velUntil_comp(v, a, t1) = split_fun[nnreal](t1, (LAMBDA(x:nnreal): v+a*x), const_fun[nnreal](v+a*t1))")
          (("1" (hide -1)
            (("1" (lemma "Integral_split_fun")
              (("1"
                (inst -1 "(LAMBDA (x: nnreal): v + a * x)" "
                     const_fun[nnreal](v + a * t1)" "0" "max(x!1, t1)" "t1"
                 "x!1")
                (("1" (ground)
                  (("1" (replace -2)
                    (("1" (lemma "integral_linear[nnreal]")
                      (("1" (inst -1 "0" "_" "a" "v")
                        (("1" (inst-cp -1 "x!1")
                          (("1" (inst -1 "t1")
                            (("1" (lemma "Integral_const_fun[nnreal]")
                              (("1" (inst -1 "a*t1+v" "t1" "x!1")
                                (("1" (flatten)
                                  (("1" (ground)
                                    (("1" (flatten)
                                      (("1"
                                        (replaces -2)
                                        (("1"
                                          (replaces -3)
                                          (("1"
                                            (replaces -4)
                                            (("1"
                                              (hide -)
                                              (("1"
                                                (expand "posUntil_comp")
                                                (("1"
                                                  (expand "^")
                                                  (("1"
                                                    (expand "expt")
                                                    (("1"
                                                      (expand "expt")
                                                      (("1"
                                                        (expand "expt")
                                                        (("1"
                                                          (ground)
                                                          (("1"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand "connected?")
                        (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
                      nil))
                    nil)
                   ("2" (lemma "integral_linear[nnreal]")
                    (("1" (inst?)
                      (("1" (inst -1 "0" "t1") (("1" (ground) nil nil)) nil))
                      nil)
                     ("2" (expand "connected?")
                      (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
                    nil)
                   ("3" (lemma "Integral_const_fun[nnreal]")
                    (("1" (inst?) (("1" (ground) nil nil)) nil)
                     ("2" (expand "connected?")
                      (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (decompose-equality 1)
            (("2" (expand "split_fun")
              (("2" (expand "velUntil_comp")
                (("2" (hide 2)
                  (("2" (expand "const_fun") (("2" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posUntil_comp const-decl "real" simple_motion nil)
    (posUntil_fnd const-decl "real" simple_motion_props nil)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (velUntil_comp const-decl "real" simple_motion nil)
    (split_fun const-decl "[T -> real]" integral_split_fun analysis)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (Integral_split_fun formula-decl nil integral_split_fun analysis)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (derivable_const application-judgement "deriv_fun" derivatives_lam
     analysis)
    (constant_seq1 application-judgement "(convergent?)" convergence_ops
     analysis)
    (derivable_const application-judgement "deriv_fun[real]" pi_def trig)
    (real_times_real_is_real application-judgement "real" reals nil)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (Integral_const_fun formula-decl nil integral analysis)
    (nnreal_expt application-judgement "nnreal" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (TRUE const-decl "bool" booleans nil)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (zero_hat formula-decl nil exponent_props reals)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (nonneg_real_max application-judgement
     "{z: nonneg_real | z >= x AND z >= y}" real_defs nil))
   shostak))
 (accelUntil_reach_goal 0
  (accelUntil_reach_goal-1 nil 3625565894
   ("" (skeep)
    (("" (expand "accelUntil")
      (("" (expand "velUntil_comp")
        (("" (lift-if 1)
          (("" (split 1)
            (("1" (ground) nil nil)
             ("2" (ground)
              (("2" (hide 1)
                (("2" (expand "accelUntil_param")
                  (("2" (hide -) (("2" (grind) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((accelUntil const-decl "[real, real]" simple_motion nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (accelUntil_param const-decl "[real, nnreal]" simple_motion nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (velUntil_comp const-decl "real" simple_motion nil))
   shostak))
 (accelUntilRamp_int? 0
  (accelUntilRamp_int?-1 nil 3625579715
   ("" (skeep)
    ((""
      (case-replace
       "accelUntilRamp_comp(a,t1, t2) = split_fun2[nnreal](t1, t2, (LAMBDA(x:nnreal): a*x), const_fun[nnreal](a*t1), const_fun[nnreal](0))")
      (("1" (hide -1)
        (("1" (lemma "split_fun2_Integrable[nnreal]")
          (("1"
            (inst -1 " (LAMBDA (x: nnreal): a * x)" "
                       const_fun[nnreal](a * t1)" " const_fun[nnreal](0)" "0"
             "max(t, t2)" "t1" "t2")
            (("1" (case "connected?[nnreal]")
              (("1" (lemma "integral_linear[nnreal]")
                (("1" (inst -1 "0" "t1" "a" "0")
                  (("1" (lemma "Integral_const_fun[nnreal]")
                    (("1" (inst-cp -1 "a*t1" "t1" "t2")
                      (("1" (inst -1 "0" "t2" "max(t, t2)")
                        (("1" (expand "in_order?")
                          (("1" (ground)
                            (("1" (lemma "Integrable?_inside[nnreal]")
                              (("1"
                                (inst -1 "0" "max(t, t2)" "split_fun2[nnreal]
                      (t1, t2, (LAMBDA (x: nnreal): a * x),
                       const_fun[nnreal](a * t1), const_fun[nnreal](0))" "0"
                                 "t")
                                (("1" (ground) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (propax) nil nil))
                nil)
               ("2" (expand "connected?")
                (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (decompose-equality 1)
          (("2" (expand "accelUntilRamp_comp")
            (("2" (expand "split_fun2")
              (("2" (expand "const_fun") (("2" (propax) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (accelUntilRamp_comp const-decl "real" simple_motion nil)
    (<= const-decl "bool" reals nil)
    (split_fun2 const-decl "[T -> real]" integral_split_fun analysis)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (split_fun2_Integrable formula-decl nil integral_split_fun analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (in_order? const-decl "bool" integral_split_fun analysis)
    (Integrable?_inside formula-decl nil integral analysis)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (zero_hat formula-decl nil exponent_props reals)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (derivable_const application-judgement "deriv_fun[real]" pi_def trig)
    (constant_seq1 application-judgement "(convergent?)" convergence_ops
     analysis)
    (derivable_const application-judgement "deriv_fun" derivatives_lam
     analysis)
    (Integral_const_fun formula-decl nil integral analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (nonneg_real_max application-judgement
     "{z: nonneg_real | z >= x AND z >= y}" real_defs nil))
   shostak))
 (velUntilRamp_fnd_TCC1 0
  (velUntilRamp_fnd_TCC1-1 nil 3625574309
   ("" (lemma "accelUntilRamp_int?") (("" (propax) nil nil)) nil)
   ((accelUntilRamp_int? formula-decl nil simple_motion_props nil)) nil
   (velUntilRamp_fnd subtype
    "simple_motion.accelUntilRamp_comp(simple_motion_props.a, simple_motion_props.t1, simple_motion_props.t2)"
    "integral_def[nnreal].Integrable_funs(0, simple_motion_props.t)")))
 (velUntilRamp_equal 0
  (velUntilRamp_equal-2 "" 3790106697
   ("" (skeep)
    (("" (decompose-equality 1)
      (("" (expand "velUntilRamp_fnd")
        ((""
          (case-replace
           "accelUntilRamp_comp(a,t1, t2) = split_fun2[nnreal](t1, t2, (LAMBDA(x:nnreal): a*x), const_fun[nnreal](a*t1), const_fun[nnreal](0))")
          (("1" (hide -1)
            (("1" (lemma "Integral_split_fun2[nnreal]")
              (("1" (case "connected?[nnreal]")
                (("1" (lemma "integral_linear[nnreal]")
                  (("1" (inst -1 "0" "t1" "a" "0")
                    (("1" (lemma "Integral_const_fun[nnreal]")
                      (("1" (inst-cp -1 "a*t1" "t1" "t2")
                        (("1" (inst -1 "0" "t2" "max(x!1, t2)")
                          (("1"
                            (inst -5 " (LAMBDA (x: nnreal): a * x)"
                             "                       const_fun[nnreal](a * t1)"
                             " const_fun[nnreal](0)" "0" "max(x!1, t2)" "t1"
                             "t2" "x!1")
                            (("1" (ground)
                              (("1" (replace -2)
                                (("1" (expand "velUntilRamp_comp")
                                  (("1" (replaces -6)
                                    (("1" (flatten)
                                      (("1"
                                        (replaces -7)
                                        (("1"
                                          (hide (-1 -2 -3 -5 -6))
                                          (("1"
                                            (lemma "integral_linear[nnreal]")
                                            (("1"
                                              (inst -1 "0" "x!1" "a" "0")
                                              (("1"
                                                (ground)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (replaces -2)
                                                    (("1"
                                                      (lemma
                                                       "Integral_const_fun[nnreal]")
                                                      (("1"
                                                        (inst-cp
                                                         -1
                                                         "a*t1"
                                                         "t1"
                                                         "x!1
      ")
                                                        (("1"
                                                          (inst
                                                           -1
                                                           "0"
                                                           "t2"
                                                           "x!1")
                                                          (("1"
                                                            (flatten)
                                                            (("1"
                                                              (replaces -2)
                                                              (("1"
                                                                (replaces -3)
                                                                (("1"
                                                                  (hide -)
                                                                  (("1"
                                                                    (expand
                                                                     "^")
                                                                    (("1"
                                                                      (expand
                                                                       "expt")
                                                                      (("1"
                                                                        (expand
                                                                         "expt")
                                                                        (("1"
                                                                          (expand
                                                                           "expt")
                                                                          (("1"
                                                                            (grind)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (hide-all-but 1)
                                (("2" (expand "in_order?")
                                  (("2" (propax) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (propax) nil nil))
                  nil)
                 ("2" (expand "connected?")
                  (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
                nil))
              nil))
            nil)
           ("2" (decompose-equality 1)
            (("2" (expand "accelUntilRamp_comp")
              (("2" (expand "split_fun2")
                (("2" (expand "const_fun") (("2" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (velUntilRamp_equal-1 nil 3625580616
   ("" (skeep)
    (("" (decompose-equality 1)
      (("" (expand "velUntilRamp_fnd")
        ((""
          (case-replace
           "accelUntilRamp_comp(a,t1, t2) = split_fun2[nnreal](t1, t2, (LAMBDA(x:nnreal): a*x), const_fun[nnreal](a*t1), const_fun[nnreal](0))")
          (("1" (hide -1)
            (("1" (lemma "Integral_split_fun2[nnreal]")
              (("1" (case "connected?[nnreal]")
                (("1" (lemma "integral_linear[nnreal]")
                  (("1" (inst -1 "0" "t1" "a" "0")
                    (("1" (lemma "Integral_const_fun[nnreal]")
                      (("1" (inst-cp -1 "a*t1" "t1" "t2")
                        (("1" (inst -1 "0" "t2" "max(x!1, t2)")
                          (("1"
                            (inst -5 " (LAMBDA (x: nnreal): a * x)"
                             "                       const_fun[nnreal](a * t1)"
                             " const_fun[nnreal](0)" "0" "max(x!1, t2)" "t1"
                             "t2" "x!1")
                            (("1" (ground)
                              (("1" (replace -2)
                                (("1" (expand "velUntilRamp_comp")
                                  (("1" (replaces -6)
                                    (("1" (flatten)
                                      (("1"
                                        (replaces -7)
                                        (("1"
                                          (hide (-1 -2 -3 -5 -6))
                                          (("1"
                                            (lemma "integral_linear[nnreal]")
                                            (("1"
                                              (inst -1 "0" "x!1" "a" "0")
                                              (("1"
                                                (ground)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (replaces -2)
                                                    (("1"
                                                      (lemma
                                                       "Integral_const_fun[nnreal]")
                                                      (("1"
                                                        (inst-cp
                                                         -1
                                                         "a*t1"
                                                         "t1"
                                                         "x!1
      ")
                                                        (("1"
                                                          (inst
                                                           -1
                                                           "0"
                                                           "t2"
                                                           "x!1")
                                                          (("1"
                                                            (flatten)
                                                            (("1"
                                                              (replaces -2)
                                                              (("1"
                                                                (replaces -3)
                                                                (("1"
                                                                  (hide -)
                                                                  (("1"
                                                                    (expand
                                                                     "^")
                                                                    (("1"
                                                                      (expand
                                                                       "expt")
                                                                      (("1"
                                                                        (expand
                                                                         "expt")
                                                                        (("1"
                                                                          (expand
                                                                           "expt")
                                                                          (("1"
                                                                            (ground)
                                                                            (("1"
                                                                              (grind)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (hide-all-but 1)
                                (("2" (expand "in_order?")
                                  (("2" (propax) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (propax) nil nil))
                  nil)
                 ("2" (expand "connected?")
                  (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
                nil))
              nil))
            nil)
           ("2" (decompose-equality 1)
            (("2" (expand "accelUntilRamp_comp")
              (("2" (expand "split_fun2")
                (("2" (expand "const_fun") (("2" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((<= const-decl "bool" reals nil)
    (velUntilRamp_fnd const-decl "real" simple_motion_props nil)
    (velUntilRamp_comp const-decl "real" simple_motion nil)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (accelUntilRamp_comp const-decl "real" simple_motion nil)
    (split_fun2 const-decl "[T -> real]" integral_split_fun analysis)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (Integral_split_fun2 formula-decl nil integral_split_fun analysis)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (Integral_const_fun formula-decl nil integral analysis)
    (nonneg_real_max application-judgement
     "{z: nonneg_real | z >= x AND z >= y}" real_defs nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (derivable_const application-judgement "deriv_fun" derivatives_lam
     analysis)
    (constant_seq1 application-judgement "(convergent?)" convergence_ops
     analysis)
    (derivable_const application-judgement "deriv_fun[real]" pi_def trig)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (zero_hat formula-decl nil exponent_props reals)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (nnreal_expt application-judgement "nnreal" exponentiation nil)
    (TRUE const-decl "bool" booleans nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (in_order? const-decl "bool" integral_split_fun analysis)
    (connected? const-decl "bool" deriv_domain_def analysis))
   shostak))
 (velUntilRamp_int? 0
  (velUntilRamp_int?-1 nil 3625582581
   ("" (skeep)
    ((""
      (case-replace
       "velUntilRamp_comp(v, a,t1, t2) = split_fun2[nnreal](t1, t2, (LAMBDA(x:nnreal):v+ (0.5*a)*x^2), (LAMBDA(x:nnreal):(v+ 0.5*a*t1*t1-a*t1*t1) + (a*t1)*x), const_fun[nnreal](v+0.5*a*t1*t1+a*t1*(t2-t1)))")
      (("1" (hide -1)
        (("1" (lemma "split_fun2_Integrable[nnreal]")
          (("1"
            (inst -1 "(LAMBDA(x:nnreal):v+ (0.5*a)*x^2)"
             "LAMBDA(x:nnreal):(v+ 0.5*a*t1*t1-a*t1*t1 + (a*t1)*x)"
             " const_fun[nnreal](v+0.5*a*t1*t1+a*t1*(t2-t1))" "0" "max(t, t2)"
             "t1" "t2")
            (("1" (case "connected?[nnreal]")
              (("1" (lemma "integral_linear[nnreal]")
                (("1"
                  (inst -1 "t1" "t2" "(a*t1)"
                   "(v + 0.5 * a * t1 * t1 - a * t1 * t1)")
                  (("1" (lemma "integral_quadratic[nnreal]")
                    (("1" (inst -1 "0" "t1" "0.5*a" "0" "v")
                      (("1" (lemma "Integral_const_fun[nnreal]")
                        (("1"
                          (inst -1
                           "(v + 0.5 * a * t1 * t1 + a * t1 * (t2 - t1))" "t2"
                           "max(t, t2)")
                          (("1" (ground)
                            (("1" (lemma "Integrable?_inside[nnreal]")
                              (("1" (inst -1 "0" "max(t, t2)" "_" "0" "t")
                                (("1" (inst?) (("1" (ground) nil nil)) nil))
                                nil))
                              nil)
                             ("2" (expand "in_order?")
                              (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (propax) nil nil))
                nil)
               ("2" (expand "connected?")
                (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (decompose-equality 1)
        (("2" (expand "velUntilRamp_comp")
          (("2" (expand "split_fun2")
            (("2" (hide 2) (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_plus_real_is_real application-judgement "real" reals nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (velUntilRamp_comp const-decl "real" simple_motion nil)
    (<= const-decl "bool" reals nil)
    (split_fun2 const-decl "[T -> real]" integral_split_fun analysis)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (^ const-decl "real" exponentiation nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (split_fun2_Integrable formula-decl nil integral_split_fun analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (in_order? const-decl "bool" integral_split_fun analysis)
    (Integrable?_inside formula-decl nil integral analysis)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (zero_hat formula-decl nil exponent_props reals)
    (nat_exp application-judgement "nat" exponentiation nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (derivable_const application-judgement "deriv_fun[real]" pi_def trig)
    (constant_seq1 application-judgement "(convergent?)" convergence_ops
     analysis)
    (derivable_const application-judgement "deriv_fun" derivatives_lam
     analysis)
    (Integral_const_fun formula-decl nil integral analysis)
    (integral_quadratic formula-decl nil table_of_integrals analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (nonneg_real_max application-judgement
     "{z: nonneg_real | z >= x AND z >= y}" real_defs nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (expt def-decl "real" exponentiation nil))
   shostak))
 (posUntilRamp_fnd_TCC1 0
  (posUntilRamp_fnd_TCC1-1 nil 3625574309
   ("" (lemma "velUntilRamp_int?") (("" (propax) nil nil)) nil)
   ((velUntilRamp_int? formula-decl nil simple_motion_props nil)) nil
   (posUntilRamp_fnd subtype
    "simple_motion.velUntilRamp_comp(simple_motion_props.v, simple_motion_props.a, simple_motion_props.t1, simple_motion_props.t2)"
    "integral_def[nnreal].Integrable_funs(0, simple_motion_props.t)")))
 (posUntilRamp_equal 0
  (posUntilRamp_equal-1 nil 3625583951
   ("" (skeep)
    (("" (decompose-equality 1)
      (("" (expand "posUntilRamp_fnd")
        ((""
          (case-replace
           "velUntilRamp_comp(v, a,t1, t2) = split_fun2[nnreal](t1, t2, (LAMBDA(x:nnreal):v+ (0.5*a)*x^2), (LAMBDA(x:nnreal):(v+ 0.5*a*t1*t1-a*t1*t1) + (a*t1)*x), const_fun[nnreal](v+0.5*a*t1*t1+a*t1*(t2-t1)))")
          (("1" (hide -1)
            (("1" (lemma "Integral_split_fun2[nnreal]")
              (("1"
                (inst -1 "(LAMBDA(x:nnreal):v+ (0.5*a)*x^2)"
                 "LAMBDA(x:nnreal):(v+ 0.5*a*t1*t1-a*t1*t1 + (a*t1)*x)"
                 " const_fun[nnreal](v+0.5*a*t1*t1+a*t1*(t2-t1))" "0"
                 "max(x!1, t2)" "t1" "t2" "x!1")
                (("1" (case "connected?[nnreal]")
                  (("1" (lemma "integral_linear[nnreal]")
                    (("1"
                      (inst-cp -1 "t1" "t2" "(a*t1)"
                       "(v + 0.5 * a * t1 * t1 - a * t1 * t1)")
                      (("1"
                        (inst -1 "t1" "x!1" "(a*t1)"
                         "(v + 0.5 * a * t1 * t1 - a * t1 * t1)")
                        (("1" (lemma "integral_quadratic[nnreal]")
                          (("1" (inst-cp -1 "0" "t1" "0.5*a" "0" "v")
                            (("1" (inst -1 "0" "x!1" "0.5*a" "0" "v")
                              (("1" (ground)
                                (("1" (replaces -2)
                                  (("1" (replaces -3)
                                    (("1" (replaces -4)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (replaces -5)
                                          (("1"
                                            (replaces -6)
                                            (("1"
                                              (lemma
                                               "Integral_const_fun[nnreal]")
                                              (("1"
                                                (inst
                                                 -1
                                                 "(v + 0.5 * a * t1 * t1 + a * t1 * (t2 - t1))"
                                                 "t2"
                                                 "x!1")
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (case-replace
                                                     "(v + 0.5 * a * t1 * t1 + a * t1 * (t2 - t1)) = (a * t1 * t2 - 1/2 * (a * t1 * t1) + v)")
                                                    (("1"
                                                      (replaces -3)
                                                      (("1"
                                                        (hide -)
                                                        (("1"
                                                          (expand
                                                           "posUntilRamp_comp")
                                                          (("1"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (hide-all-but 1)
                                                      (("2" (ground) nil nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (expand "in_order?")
                                  (("2" (propax) nil nil)) nil)
                                 ("3" (lemma "Integral_const_fun[nnreal]")
                                  (("3"
                                    (inst -1
                                     "a * t1 * t2 - 1/2 * (a * t1 * t1) + v"
                                     "t2" "max(x!1, t2)")
                                    (("3" (flatten) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (propax) nil nil))
                    nil)
                   ("2" (expand "connected?")
                    (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (decompose-equality 1)
            (("2" (expand "velUntilRamp_comp")
              (("2" (expand "split_fun2")
                (("2" (hide 2) (("2" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posUntilRamp_comp const-decl "real" simple_motion nil)
    (<= const-decl "bool" reals nil)
    (posUntilRamp_fnd const-decl "real" simple_motion_props nil)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (velUntilRamp_comp const-decl "real" simple_motion nil)
    (split_fun2 const-decl "[T -> real]" integral_split_fun analysis)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (^ const-decl "real" exponentiation nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (Integral_split_fun2 formula-decl nil integral_split_fun analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (integral_quadratic formula-decl nil table_of_integrals analysis)
    (in_order? const-decl "bool" integral_split_fun analysis)
    (TRUE const-decl "bool" booleans nil)
    (Integral_const_fun formula-decl nil integral analysis)
    (nprat_div_posrat_is_nprat application-judgement "nprat" rationals nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (expt def-decl "real" exponentiation nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (derivable_const application-judgement "deriv_fun[real]" pi_def trig)
    (constant_seq1 application-judgement "(convergent?)" convergence_ops
     analysis)
    (derivable_const application-judgement "deriv_fun" derivatives_lam
     analysis)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (zero_hat formula-decl nil exponent_props reals)
    (nat_exp application-judgement "nat" exponentiation nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (nonneg_real_max application-judgement
     "{z: nonneg_real | z >= x AND z >= y}" real_defs nil))
   shostak))
 (accelUntilRamp_param_ordered 0
  (accelUntilRamp_param_ordered-2 "" 3790106705
   ("" (skeep)
    (("" (expand "in_order?")
      (("" (split)
        (("1" (grind) nil nil)
         ("2" (grind)
          (("1" (cross-mult 2) nil nil) ("2" (cross-mult 3) nil nil)) nil)
         ("3" (grind) nil nil))
        nil))
      nil))
    nil)
   nil shostak)
  (accelUntilRamp_param_ordered-1 nil 3625574710
   ("" (skeep)
    (("" (expand "in_order?")
      (("" (split)
        (("1" (grind) nil nil)
         ("2" (grind)
          (("1" (cross-mult 2) (("1" (cancel-by 2 "rt") nil nil)) nil)
           ("2" (cross-mult 3) (("2" (cancel-by 3 "rt") nil nil)) nil))
          nil)
         ("3" (grind) nil nil))
        nil))
      nil))
    nil)
   ((in_order? const-decl "bool" integral_split_fun analysis)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (div_mult_pos_le2 formula-decl nil real_props nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (times_div2 formula-decl nil real_props nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (accelUntilRamp_param const-decl "[real, real, real]" simple_motion nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   shostak))
 (accelUntilRamp_reach_goal 0
  (accelUntilRamp_reach_goal-1 nil 3625574861
   ("" (skeep)
    (("" (expand "accelUntilRamp")
      (("" (expand "velUntilRamp_comp")
        (("" (lemma "accelUntilRamp_param_ordered")
          (("" (inst?)
            (("" (inst -1 "accelUntilRamp_param(v, goalV, accel, rt)`3")
              (("1" (expand "in_order?")
                (("1" (flatten)
                  (("1" (ground)
                    (("1" (hide (-1 -2 -3))
                      (("1" (expand "accelUntilRamp_param")
                        (("1"
                          (case-replace "(abs(goalV-v)<=1/2*accel*rt) = TRUE")
                          (("1" (lemma "sq_sqrt")
                            (("1"
                              (inst -1 "2 * (abs(goalV - v) * rt) / accel")
                              (("1" (prop)
                                (("1" (expand "sq")
                                  (("1" (replaces -1)
                                    (("1" (ground)
                                      (("1"
                                        (case-replace "(goalV>=v) = TRUE")
                                        (("1"
                                          (ground)
                                          (("1"
                                            (case-replace
                                             "abs(goalV-v) = goalV-v")
                                            (("1" (ground) nil nil)
                                             ("2"
                                              (hide 1)
                                              (("2"
                                                (expand "abs")
                                                (("2" (ground) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (ground)
                                          (("2"
                                            (expand "abs")
                                            (("2" (ground) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (hide 2) (("2" (ground) nil nil)) nil))
                                nil))
                              nil))
                            nil)
                           ("2" (ground)
                            (("2" (case-replace "(goalV>=v) = TRUE")
                              (("1" (expand "abs") (("1" (ground) nil nil))
                                nil)
                               ("2" (ground) (("2" (grind) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (lemma "accelUntilRamp_param_ordered")
                (("2" (inst?)
                  (("2"
                    (inst -1
                     "abs(accelUntilRamp_param(v, goalV, accel, rt)`3)")
                    (("2" (expand "in_order?") (("2" (ground) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((accelUntilRamp const-decl "[real, real]" simple_motion nil)
    (accelUntilRamp_param_ordered formula-decl nil simple_motion_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (accelUntilRamp_param const-decl "[real, real, real]" simple_motion nil)
    (v skolem-const-decl "real" simple_motion_props nil)
    (goalV skolem-const-decl "real" simple_motion_props nil)
    (accel skolem-const-decl "posreal" simple_motion_props nil)
    (rt skolem-const-decl "posreal" simple_motion_props nil)
    (nnreal type-eq-decl nil real_types nil)
    (TRUE const-decl "bool" booleans nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (sq const-decl "nonneg_real" sq reals)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (sq_sqrt formula-decl nil sqrt reals)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (in_order? const-decl "bool" integral_split_fun analysis)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (velUntilRamp_comp const-decl "real" simple_motion nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   shostak)))

