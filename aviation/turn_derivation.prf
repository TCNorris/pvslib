(turn_derivation
 (turn_vx_prep_TCC1 0
  (turn_vx_prep_TCC1-1 nil 3601210589
   ("" (lemma "connected_domain") (("" (propax) nil nil)) nil)
   ((connected_domain formula-decl nil turn_derivation nil)) nil
   (turn_vx_prep assuming "motion[T].motion"
    "connected_domain: ASSUMPTION deriv_domain_def[T].connected?")))
 (turn_vx_prep_TCC2 0
  (turn_vx_prep_TCC2-1 nil 3601210589
   ("" (lemma "not_one_element") (("" (propax) nil nil)) nil)
   ((not_one_element formula-decl nil turn_derivation nil)) nil
   (turn_vx_prep assuming "motion[T].motion"
    "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?")))
 (turn_vx_prep_TCC3 0
  (turn_vx_prep_TCC3-1 nil 3601210589
   ("" (lemma "T_pred0") (("" (propax) nil nil)) nil)
   ((T_pred0 formula-decl nil turn_derivation nil)) nil
   (turn_vx_prep assuming "motion[T].motion"
    "zero_in: ASSUMPTION motion[T].T_pred(0)")))
 (turn_vx_prep 0
  (turn_vx_prep-1 nil 3601210590
   ("" (skeep)
    (("" (tccs-formula)
      (("" (lemma "derivable_scal1_lam[T]")
        (("1" (inst -1 "v" "(LAMBDA (t: T): sin(f(t)))")
          (("1" (lemma "composition_derivable_fun[T,real]")
            (("1" (inst -1 "f" "sin")
              (("1" (expand "o")
                (("1" (lemma "sin_derivable_fun")
                  (("1" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
         ("3" (hide 2)
          (("3" (lemma "connected_deriv_domain[T]")
            (("3" (assert)
              (("3" (hide 2)
                (("3" (lemma "not_one_element")
                  (("3" (assert)
                    (("3" (lemma "connected_domain")
                      (("3" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" turn_derivation nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (connected_domain formula-decl nil turn_derivation nil)
    (connected_deriv_domain formula-decl nil deriv_domain_def analysis)
    (not_one_element formula-decl nil turn_derivation nil)
    (sin_range application-judgement "real_abs_le1" sincos trig)
    (Rate_fun type-eq-decl nil motion nil)
    (sin const-decl "real" sincos_def trig)
    (deriv_fun type-eq-decl nil derivatives analysis)
    (derivable? const-decl "bool" derivatives analysis)
    (f skolem-const-decl "Rate_fun[T]" turn_derivation nil)
    (sin_derivable_fun formula-decl nil sincos trig)
    (O const-decl "T3" function_props nil)
    (composition_derivable_fun formula-decl nil chain_rule analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (deriv_domain? const-decl "bool" deriv_domain_def analysis)
    (T formal-nonempty-subtype-decl nil turn_derivation nil)
    (derivable_scal1_lam formula-decl nil derivatives_lam analysis))
   shostak))
 (turn_vy_prep 0
  (turn_vy_prep-1 nil 3601210876
   ("" (skeep)
    (("" (tccs-formula 1)
      (("" (lemma "derivable_scal1_lam[T]")
        (("1" (inst -1 "v" "LAMBDA(t:T): cos(f(t))")
          (("1" (lemma "composition_derivable_fun[T,real]")
            (("1" (inst -1 "f" "cos")
              (("1" (lemma "cos_derivable_fun")
                (("1" (expand "o") (("1" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil)
         ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
         ("3" (lemma "connected_deriv_domain[T]")
          (("3" (assert)
            (("3" (lemma "connected_domain")
              (("3" (assert)
                (("3" (lemma "not_one_element")
                  (("3" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" turn_derivation nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (connected_deriv_domain formula-decl nil deriv_domain_def analysis)
    (connected_domain formula-decl nil turn_derivation nil)
    (not_one_element formula-decl nil turn_derivation nil)
    (cos_range application-judgement "real_abs_le1" sincos trig)
    (Rate_fun type-eq-decl nil motion nil)
    (cos const-decl "real" sincos_def trig)
    (deriv_fun type-eq-decl nil derivatives analysis)
    (derivable? const-decl "bool" derivatives analysis)
    (f skolem-const-decl "Rate_fun[T]" turn_derivation nil)
    (O const-decl "T3" function_props nil)
    (cos_derivable_fun formula-decl nil sincos trig)
    (composition_derivable_fun formula-decl nil chain_rule analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (deriv_domain? const-decl "bool" deriv_domain_def analysis)
    (T formal-nonempty-subtype-decl nil turn_derivation nil)
    (derivable_scal1_lam formula-decl nil derivatives_lam analysis))
   shostak))
 (turn_vx_TCC1 0
  (turn_vx_TCC1-1 nil 3579949643
   ("" (skosimp*) (("" (rewrite "turn_vx_prep") nil nil)) nil)
   ((turn_vx_prep formula-decl nil turn_derivation nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" turn_derivation nil)
    (T formal-nonempty-subtype-decl nil turn_derivation nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (derivable? const-decl "bool" derivatives analysis)
    (Rate_fun type-eq-decl nil motion nil))
   nil
   (turn_vx subtype
    "(LAMBDA (t: turn_derivation.T): number_fields.*(turn_derivation.v, sincos_def.sin(turn_derivation.f(t))))"
    "Rate_fun[T]")))
 (turn_vy_TCC1 0
  (turn_vy_TCC1-1 nil 3579949643
   ("" (skosimp*) (("" (rewrite "turn_vy_prep") nil nil)) nil)
   ((turn_vy_prep formula-decl nil turn_derivation nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" turn_derivation nil)
    (T formal-nonempty-subtype-decl nil turn_derivation nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (derivable? const-decl "bool" derivatives analysis)
    (Rate_fun type-eq-decl nil motion nil))
   nil
   (turn_vy subtype
    "(LAMBDA (t: turn_derivation.T): number_fields.*(turn_derivation.v, sincos_def.cos(turn_derivation.f(t))))"
    "Rate_fun[T]")))
 (linear_angular_TCC1 0
  (linear_angular_TCC1-1 nil 3579949643
   ("" (skeep)
    (("" (tccs-formula 1)
      (("" (lemma "derivable_add_lam[T]")
        (("1" (inst -1 "LAMBDA(t:T): theta" "LAMBDA(t:T): w*t")
          (("1" (lemma "derivable_scal1_lam[T]")
            (("1" (inst -1 "w" "LAMBDA(t:T): t")
              (("1" (lemma "derivable_id_lam[T]")
                (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (lemma "derivable_const_lam[T]")
            (("2" (inst -1 "theta") nil nil)) nil))
          nil)
         ("2" (lemma "not_one_element") (("2" (propax) nil nil)) nil)
         ("3" (lemma "connected_deriv_domain[T]")
          (("3" (lemma "not_one_element")
            (("3" (lemma "connected_domain") (("3" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (connected_deriv_domain formula-decl nil deriv_domain_def analysis)
    (connected_domain formula-decl nil turn_derivation nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (not_one_element formula-decl nil turn_derivation nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (derivable? const-decl "bool" derivatives analysis)
    (deriv_fun type-eq-decl nil derivatives analysis)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (theta skolem-const-decl "real" turn_derivation nil)
    (w skolem-const-decl "nzreal" turn_derivation nil)
    (derivable_id_lam formula-decl nil derivatives_lam analysis)
    (derivable_scal1_lam formula-decl nil derivatives_lam analysis)
    (derivable_const_lam formula-decl nil derivatives_lam analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (deriv_domain? const-decl "bool" deriv_domain_def analysis)
    (derivable_add_lam formula-decl nil derivatives_lam analysis)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" turn_derivation nil)
    (T formal-nonempty-subtype-decl nil turn_derivation nil))
   nil
   (linear_angular subtype
    "(LAMBDA (t: turn_derivation.T): (number_fields.+)(turn_derivation.theta, number_fields.*(turn_derivation.w, t)))"
    "Rate_fun[T]")))
 (turn_position_x 0
  (turn_position_x-1 nil 3579950071
   ("" (skeep)
    (("" (tccs-formula 1)
      (("" (expand "position")
        (("" (apply-extensionality 1)
          (("1" (hide 2)
            (("1" (expand "turn_vx_angular")
              (("1" (expand "turn_vx")
                (("1" (expand "linear_angular")
                  (("1" (lemma "Integral_sin_lin[T]")
                    (("1" (assert)
                      (("1" (inst -1 "0" "x!1" "theta" "v" "w")
                        (("1" (assert) nil nil)) nil))
                      nil)
                     ("2" (lemma "T_pred0") (("2" (propax) nil nil))
                      nil)
                     ("3" (lemma "not_one_element")
                      (("3" (propax) nil nil)) nil)
                     ("4" (lemma "connected_domain")
                      (("4" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (hide 2)
            (("2" (skeep)
              (("2" (tccs-formula 1)
                (("2" (typepred "turn_vx_angular(v, theta, w)")
                  (("2" (lemma "derivable_Integrable?[T]")
                    (("1"
                      (inst -1 "0" "t" "turn_vx_angular(v, theta, w)")
                      (("1" (assert) nil nil)) nil)
                     ("2" (lemma "T_pred0")
                      (("2" (lemma "not_one_element")
                        (("2" (propax) nil nil)) nil))
                      nil)
                     ("3" (lemma "connected_domain")
                      (("3" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (lemma "T_pred0") (("3" (propax) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (T formal-nonempty-subtype-decl nil turn_derivation nil)
    (T_pred const-decl "[real -> boolean]" turn_derivation nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (cos const-decl "real" sincos_def trig)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Integral const-decl "real" integral_def analysis)
    (Integrable_funs type-eq-decl nil integral_def analysis)
    (w skolem-const-decl "nzreal" turn_derivation nil)
    (theta skolem-const-decl "real" turn_derivation nil)
    (v skolem-const-decl "real" turn_derivation nil)
    (turn_vx_angular const-decl "Rate_fun[T]" turn_derivation nil)
    (Rate_fun type-eq-decl nil motion nil)
    (derivable? const-decl "bool" derivatives analysis)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (Integrable? const-decl "bool" integral_def analysis)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (linear_angular const-decl "Rate_fun[T]" turn_derivation nil)
    (connected_domain formula-decl nil turn_derivation nil)
    (not_one_element formula-decl nil turn_derivation nil)
    (T_pred0 formula-decl nil turn_derivation nil)
    (sin_range application-judgement "real_abs_le1" sincos trig)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (Integral_sin_lin formula-decl nil integral_sincos_lin trig)
    (turn_vx const-decl "Rate_fun[T]" turn_derivation nil)
    (derivable_Integrable? formula-decl nil fundamental_theorem
     analysis)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (position const-decl "Rate_fun" motion nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (cos_range application-judgement "real_abs_le1" sincos trig))
   shostak))
 (turn_position_y 0
  (turn_position_y-1 nil 3579950304
   ("" (skeep)
    (("" (expand "position")
      (("" (apply-extensionality 1)
        (("1" (hide 2)
          (("1" (expand "turn_vy_angular")
            (("1" (expand "turn_vy")
              (("1" (expand "linear_angular")
                (("1" (lemma "Integral_cos_lin[T]")
                  (("1" (inst -1 "0" "x!1" "theta" "v" "w")
                    (("1" (assert) nil nil)) nil)
                   ("2" (hide 2)
                    (("2" (tccs-formula 1)
                      (("2" (lemma "T_pred0") (("2" (propax) nil nil))
                        nil))
                      nil))
                    nil)
                   ("3" (lemma "not_one_element")
                    (("3" (propax) nil nil)) nil)
                   ("4" (lemma "connected_domain")
                    (("4" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 2)
          (("2" (tccs-formula 1)
            (("2" (skeep)
              (("2" (tccs-formula 1)
                (("2" (typepred "turn_vy_angular(v, theta, w)")
                  (("2" (lemma "derivable_Integrable?[T]")
                    (("1"
                      (inst -1 "0" "t" "turn_vy_angular(v, theta, w)")
                      (("1" (assert) nil nil)) nil)
                     ("2" (lemma "not_one_element")
                      (("2" (propax) nil nil)) nil)
                     ("3" (lemma "connected_domain")
                      (("3" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (lemma "T_pred0") (("3" (propax) nil nil)) nil))
        nil))
      nil))
    nil)
   ((sin_range application-judgement "real_abs_le1" sincos trig)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (position const-decl "Rate_fun" motion nil)
    (derivable_Integrable? formula-decl nil fundamental_theorem
     analysis)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (turn_vy const-decl "Rate_fun[T]" turn_derivation nil)
    (Integral_cos_lin formula-decl nil integral_sincos_lin trig)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (cos_range application-judgement "real_abs_le1" sincos trig)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (T_pred0 formula-decl nil turn_derivation nil)
    (not_one_element formula-decl nil turn_derivation nil)
    (connected_domain formula-decl nil turn_derivation nil)
    (linear_angular const-decl "Rate_fun[T]" turn_derivation nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (w skolem-const-decl "nzreal" turn_derivation nil)
    (theta skolem-const-decl "real" turn_derivation nil)
    (v skolem-const-decl "real" turn_derivation nil)
    (turn_vy_angular const-decl "Rate_fun[T]" turn_derivation nil)
    (Rate_fun type-eq-decl nil motion nil)
    (derivable? const-decl "bool" derivatives analysis)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (Integrable? const-decl "bool" integral_def analysis)
    (bool nonempty-type-eq-decl nil booleans nil)
    (Integrable_funs type-eq-decl nil integral_def analysis)
    (Integral const-decl "real" integral_def analysis)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sin const-decl "real" sincos_def trig)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (T formal-nonempty-subtype-decl nil turn_derivation nil)
    (T_pred const-decl "[real -> boolean]" turn_derivation nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak)))

