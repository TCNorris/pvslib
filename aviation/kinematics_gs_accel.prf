(kinematics_gs_accel (gsAccel_equals_fnd 0 (gsAccel_equals_fnd-1 nil 3616242887 ("" (skeep) (("" (decompose-equality) (("1" (decompose-equality) (("1" (expand "gsAccel") (("1" (expand "gsAccel_fnd") (("1" (expand "gsAccel_Pos_Calc") (("1" (expand "gsAccelPos") (("1" (expand "Vect3") (("1" (case-replace "(vect2(so3) +
                    (norm(vect2(vo3)) * t + 1/2 * (a * t * t)) * (Hat(vect2(vo3))))`x = so3`x + vo3`x*t+ 1/2*(a*t*t)*Hat(vect2(vo3))`x") (("1" (grind) nil nil) ("2" (hide 2) (("2" (expand "Hat") (("2" (lemma "vectors_2D.norm_eq_0") (("2" (inst?) (("2" (flatten) (("2" (grind) (("2" (expand "zero") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gsAccel") (("2" (expand "gsAccel_fnd") (("2" (expand "gsAccel_Pos_Calc") (("2" (expand "gsAccelPos") (("2" (expand "Vect3") (("2" (case-replace "(vect2(so3) +
                    (norm(vect2(vo3)) * t + 1/2 * (a * t * t)) * (Hat(vect2(vo3))))`y = so3`y + vo3`y*t+ 1/2*(a*t*t)*Hat(vect2(vo3))`y") (("1" (grind) nil nil) ("2" (hide 2) (("2" (expand "Hat") (("2" (lemma "vectors_2D.norm_eq_0") (("2" (inst?) (("2" (flatten) (("2" (grind) (("2" (expand "zero") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil) ("2" (decompose-equality) (("1" (expand "gsAccel") (("1" (expand "gsAccel_fnd") (("1" (expand "gsAccel_Vel_Calc") (("1" (case "vect2(vo3)= zero") (("1" (lemma "vectors_2D.norm_eq_0") (("1" (inst?) (("1" (flatten) (("1" (expand "zero") (("1" (expand "gs") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "vectors_2D.norm_eq_0") (("2" (inst?) (("2" (flatten) (("2" (expand "zero") (("2" (expand "gs") (("2" (expand "mkTrkGsVs") (("2" (expand "trk") (("2" (rewrite "track.sin_track") (("1" (grind) nil nil) ("2" (expand "/=") (("2" (expand "zero") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gsAccel") (("2" (expand "gsAccel_fnd") (("2" (expand "gsAccel_Vel_Calc") (("2" (lemma "vectors_2D.norm_eq_0") (("2" (inst?) (("2" (flatten) (("2" (expand "zero") (("2" (expand "gs") (("2" (case-replace "vect2(vo3)=zero") (("1" (expand "zero") (("1" (grind) nil nil)) nil) ("2" (expand "mkTrkGsVs") (("2" (expand "trk") (("2" (expand "zero") (("2" (rewrite "track.cos_track") (("1" (grind) nil nil) ("2" (expand "/=") (("2" (expand "zero") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (gsAccel const-decl "[Vect3, Vect3]" kinematics_gs_accel nil) (gsAccel_fnd const-decl "[Vect3, Vect3]" gsAccel nil) (Vect3 type-eq-decl nil vectors_3D_def vectors) (real nonempty-type-from-decl nil reals nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (sin_range application-judgement "real_abs_le1" sincos trig) (cos_range application-judgement "real_abs_le1" sincos trig) (gsAccel_Vel_Calc const-decl "Vect3" gsAccel nil) (mkTrkGsVs const-decl "Velocity" Velocity nil) (vs const-decl "real" Velocity nil) (trk const-decl "nnreal_lt_2pi" track nil) (track const-decl "nnreal_lt_2pi" track nil) (atan2 const-decl "real" atan2 trig) (gs const-decl "nnreal" Velocity nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (gsAccel_Pos_Calc const-decl "Vect3" gsAccel nil) (Vect3 const-decl "{vv: Vect3 | vect2(vv) = w AND vv`z = z}" util nil) (norm_eq_0 formula-decl nil vectors_2D vectors) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (* const-decl "real" vectors_2D vectors) (sqv const-decl "nnreal" vectors_2D vectors) (Vect2 const-decl "{vv: Vect2 | vv`x = x AND vv`y = y}" util nil) (comp_zero_x formula-decl nil vectors_2D vectors) (comp_zero_y formula-decl nil vectors_2D vectors) (gsAccelSplit const-decl "Vect3" gsAccel nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (Hat const-decl "{v: Vect2 |
   (v = zero IFF w = zero) AND
    (w /= zero IFF (norm(v) = 1 AND v = (1 / norm(w)) * w))}" util nil) (zero const-decl "Vector" vectors_2D vectors) (IFF const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (norm const-decl "nnreal" vectors_2D vectors) (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "Vector" vectors_2D vectors) (vect2 const-decl "Vect2" vect_3D_2D vectors) (Vect2 type-eq-decl nil vectors_2D_def vectors) (+ const-decl "Vector" vectors_2D vectors) (Vector type-eq-decl nil vectors_2D vectors) (= const-decl "[T, T -> boolean]" equalities nil) (real_plus_real_is_real application-judgement "real" reals nil) (gsAccelPos const-decl "Vect3" kinematics_gs_accel nil) (real_times_real_is_real application-judgement "real" reals nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (sqrt_0 formula-decl nil sqrt reals) (cos_track formula-decl nil track nil) (sin_track formula-decl nil track nil) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil)) shostak)) (reach_goal 0 (reach_goal-1 nil 3616319721 ("" (skeep) (("" (skoletin) (("" (flatten) (("" (rewrite "gsAccel_equals_fnd") (("" (expand "gsAccel_fnd") (("" (expand "gsAccel_Vel_Calc") (("" (expand "gsAccelSplit") (("" (expand "gs" 1) (("" (expand "Hat") (("" (simplify 2) (("" (case "(norm(vect2(vo3))=0)=FALSE") (("1" (replace -1 2) (("1" (case-replace "Vect3(sgn_1 * gsAccel!1 *
                         Vect2(vect2(vo3)`x / norm(vect2(vo3)),
                               vect2(vo3)`y / norm(vect2(vo3))),
                        0)`x
                   * gsAccelTime(vo3, goalGs, gsAccel!1) = sgn_1*vo3`x*abs(gs(vo3)-goalGs)/gs(vo3)") (("1" (case-replace "Vect3(sgn_1 * gsAccel!1 *
                         Vect2(vect2(vo3)`x / norm(vect2(vo3)),
                               vect2(vo3)`y / norm(vect2(vo3))),
                        0)`y
                   * gsAccelTime(vo3, goalGs, gsAccel!1) = sgn_1*vo3`y*abs(gs(vo3)-goalGs)/gs(vo3)") (("1" (expand "gs") (("1" (expand "vect2") (("1" (name-replace "nrmV" "norm((# x := vo3`x, y := vo3`y #))") (("1" (case-replace "(# x := vo3`x + abs(nrmV - goalGs) * vo3`x * sgn_1 / nrmV,
              y := vo3`y + abs(nrmV - goalGs) * vo3`y * sgn_1 / nrmV #) = (goalGs/nrmV)*(# x:= vo3`x, y:=vo3`y #)") (("1" (rewrite "norm_scal") (("1" (typepred (nrmV)) (("1" (typepred (goalGs)) (("1" (div-by -2 "nrmV") (("1" (simplify -2) (("1" (expand "abs") (("1" (lift-if 3) (("1" (prop) (("1" (ground) nil nil) ("2" (expand "nrmV") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (case-replace "(goalGs/nrmV) = 1+sgn_1*abs(nrmV-goalGs)/nrmV") (("1" (ground) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "abs") (("2" (hide 2) (("2" (case-replace "nrmV = goalGs") (("1" (ground) nil nil) ("2" (lift-if 2) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "Vect3") (("2" (expand "Vect2") (("2" (expand "gs") (("2" (expand "gsAccelTime") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "gsAccelTime") (("2" (expand "gs") (("2" (ground) (("2" (expand "Vect2") (("2" (expand "Vect3") (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "gs") (("3" (ground) nil nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (real_times_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (Velocity type-eq-decl nil Velocity nil) (nnreal type-eq-decl nil real_types nil) (gs const-decl "nnreal" Velocity nil) (Vect3 type-eq-decl nil vectors_3D_def vectors) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (gsAccel const-decl "[Vect3, Vect3]" kinematics_gs_accel nil) (gsAccelTime const-decl "real" kinematics_gs_accel nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (gsAccel_equals_fnd formula-decl nil kinematics_gs_accel nil) (gsAccel_Vel_Calc const-decl "Vect3" gsAccel nil) (real_plus_real_is_real application-judgement "real" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (both_sides_div_pos_gt1 formula-decl nil real_props nil) (nrmV skolem-const-decl "nnreal" kinematics_gs_accel nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}" real_defs nil) (norm_scal formula-decl nil vectors_2D vectors) (minus_real_is_real application-judgement "real" reals nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (sqv const-decl "nnreal" vectors_2D vectors) (* const-decl "real" vectors_2D vectors) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Vect3 const-decl "{vv: Vect3 | vect2(vv) = w AND vv`z = z}" util nil) (* const-decl "Vector" vectors_2D vectors) (Vect2 const-decl "{vv: Vect2 | vv`x = x AND vv`y = y}" util nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (FALSE const-decl "bool" booleans nil) (vect2 const-decl "Vect2" vect_3D_2D vectors) (Vect2 type-eq-decl nil vectors_2D_def vectors) (norm const-decl "nnreal" vectors_2D vectors) (Vector type-eq-decl nil vectors_2D vectors) (Hat const-decl "{v: Vect2 |
   (v = zero IFF w = zero) AND
    (w /= zero IFF (norm(v) = 1 AND v = (1 / norm(w)) * w))}" util nil) (gsAccelSplit const-decl "Vect3" gsAccel nil) (gsAccel_fnd const-decl "[Vect3, Vect3]" gsAccel nil)) shostak)) (gsAccelUntil_checks 0 (gsAccelUntil_checks-3 nil 3616762344 ("" (skeep) (("" (skoletin) (("" (skoletin) (("" (skoletin) (("" (skoletin) (("" (case "FORALL (TK: real, GS:real, VS:real): gs(mkTrkGsVs(TK, GS, VS))=abs(GS)") (("1" (flatten) (("1" (split 2) (("1" (replace -2 :dir rl) (("1" (expand "gsAccel") (("1" (decompose-equality 1) (("1" (expand "gsAccelPos") (("1" (lemma "vectors_2D.scal_0") (("1" (inst -1 "(Hat(vect2(nsv`2)))") (("1" (replace -1) (("1" (expand "+ ") (("1" (expand "zero") (("1" (expand "vect2") (("1" (expand "Vect3") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "IF gs(nsv`2) = 0 THEN 0 ELSE gs(nsv`2) ENDIF = gs(nsv`2)") (("1" (lemma "reach_goal" ("so3" "so3" "vo3" "vo3" "goalGs" "goalGs" "gsAccel" "gsAccel!1")) (("1" (replace -7 :dir rl) (("1" (skoletin) (("1" (replace -2) (("1" (replace -6 :dir rl) (("1" (replace -7 :dir rl) (("1" (split -1) (("1" (case-replace "trk(vect2(nsv`2)) = track(vect2(nsv`2))") (("1" (expand "nsv") (("1" (expand "gsAccel") (("1" (case-replace "vs(mkTrkGsVs(trk(vect2(vo3)), gs(vo3) + a * accelTime,
                                            vs(vo3))) = vs(vo3)") (("1" (inst -6 "trk(vect2(vo3))" " gs(vo3) + a * accelTime" "vs(vo3)") (("1" (case-replace "abs(gs(vo3)+a*accelTime) = gs(vo3)+a*accelTime") (("1" (replace -7) (("1" (case-replace "track(vect2(mkTrkGsVs(trk(vect2(vo3)),
                                                         gs(vo3) + a * accelTime,
                                                         vs(vo3)))) = trk(vect2(vo3))") (("1" (hide 2) (("1" (expand "trk") (("1" (case "vect2(vo3)/=zero") (("1" (case-replace "IF vect2(vo3)`x = 0 AND vect2(vo3)`y = 0 THEN 0
                           ELSE track(vect2(vo3))
                           ENDIF = track(vect2(vo3))") (("1" (expand "mkTrkGsVs") (("1" (expand "vect2") (("1" (rewrite "track.sin_track") (("1" (rewrite "track.cos_track") (("1" (case-replace "(# x
                                       := gs(vo3) * (vo3`x / norm((# x := vo3`x, y := vo3`y #)))
                                           +
                                           vo3`x / norm((# x := vo3`x, y := vo3`y #)) * a *
                                            accelTime,
                                     y
                                       := vo3`y / norm((# x := vo3`x, y := vo3`y #)) * gs(vo3) +
                                           vo3`y / norm((# x := vo3`x, y := vo3`y #)) * a *
                                            accelTime #) = ((gs(vo3)+a*accelTime)/norm((# x := vo3`x, y := vo3`y #)))*(# x := vo3`x, y := vo3`y #)") (("1" (case-replace "gs(vo3)+a*accelTime = goalGs") (("1" (lemma "track.track_scal" ("c" "(goalGs / norm((# x := vo3`x, y := vo3`y #)))" "v" "(# x := vo3`x, y := vo3`y #)")) (("1" (propax) nil nil) ("2" (typepred (goalGs)) (("2" (typepred ("norm((# x := vo3`x, y := vo3`y #))")) (("2" (lemma "vectors_2D.norm_eq_0") (("2" (inst?) (("2" (expand "gs" 3) (("2" (expand "vect2") (("2" (flatten) (("2" (div-by -5 "norm((# x := vo3`x, y := vo3`y #))") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "*") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if 1) (("2" (expand "zero") (("2" (expand "/=") (("2" (split 1) (("1" (flatten) (("1" (decompose-equality 2) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (flatten) nil nil)) nil) ("2" (hide-all-but (1 3)) (("2" (expand "/=") (("2" (expand "gs") (("2" (lemma "vectors_2D.norm_eq_0") (("2" (inst?) (("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "gs(vo3) + a * accelTime = goalGs") (("1" (expand "abs") (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "a") (("2" (expand "accelTime") (("2" (expand "gsAccelTime") (("2" (expand "sgn_1") (("2" (expand "abs") (("2" (lift-if 1) (("2" (lift-if 1) (("2" (lift-if 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "vs") (("2" (expand "mkTrkGsVs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "trk") (("2" (expand "gs") (("2" (lemma "vectors_2D.norm_eq_0") (("2" (inst -1 "vect2(gsAccel(so3, vo3, accelTime, a)`2)") (("2" (flatten) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (expand "nsv") (("1" (hide-all-but (-1 -2 -3 -4 -5)) (("1" (replace -5) (("1" (split -4) (("1" (ground) nil nil) ("2" (expand "zero") (("2" (ground) (("2" (expand "vect2") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "gs") (("3" (expand "nsv" 1) (("3" (lemma "vectors_2D.norm_eq_0") (("3" (expand "/=") (("3" (inst -1 "vect2(gsAccel(so3, vo3, accelTime, a)`2)") (("3" (flatten) (("3" (hide -1) (("3" (prop) (("3" (replace -1) (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "gsAccelUntil") (("2" (replace -5 :dir rl) (("2" (replace -6 :dir rl) (("2" (replace -4 :dir rl) (("2" (lift-if 1) (("2" (assert) (("2" (expand "gsAccel") (("2" (inst-cp -2 "trk(vect2(vo3))" "                                   gs(vo3) + a * accelTime" "vs(vo3)") (("2" (replace -3) (("2" (case-replace "IF abs(gs(vo3) + a * accelTime) = 0 THEN 0
                                         ELSE abs(gs(vo3) + a * accelTime)
                                         ENDIF = abs(gs(vo3)+a*accelTime)") (("1" (inst -3 "trk(vect2(mkTrkGsVs(trk(vect2(vo3)),
                                                                   gs(vo3) + a * accelTime,
                                                                   vs(vo3))))" "                   abs(gs(vo3) + a * accelTime)" "                   vs(mkTrkGsVs(trk(vect2(vo3)), gs(vo3) + a * accelTime,
                                                            vs(vo3)))") (("1" (replace -3) (("1" (expand "accelTime") (("1" (expand "gsAccelTime") (("1" (expand "a") (("1" (hide -) (("1" (expand "sgn_1") (("1" (expand "abs") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "gsAccelUntil") (("3" (expand "gsAccel") (("3" (expand "vs") (("3" (expand "mkTrkGsVs") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "mkTrkGsVs") (("2" (expand "gs") (("2" (expand "vect2") (("2" (expand "norm") (("2" (expand "sqv") (("2" (expand "*") (("2" (lemma "sin2_cos2") (("2" (inst -1 "TK") (("2" (expand "sq") (("2" (mult-by -1 "GS*GS") (("2" (simplify -1) (("2" (replace -1) (("2" (lemma "sqrt_sq") (("2" (case-replace "1*(GS*GS) = sq(abs(GS))") (("1" (inst?) (("1" (split -2) (("1" (propax) nil nil) ("2" (ground) nil nil)) nil)) nil) ("2" (expand "sq") (("2" (expand "abs") (("2" (hide-all-but 1) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (Velocity type-eq-decl nil Velocity nil) (nnreal type-eq-decl nil real_types nil) (gs const-decl "nnreal" Velocity nil) (Vect3 type-eq-decl nil vectors_3D_def vectors) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (gsAccel const-decl "[Vect3, Vect3]" kinematics_gs_accel nil) (gsAccelUntil const-decl "[Vect3, Vect3]" kinematics_gs_accel nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (gsAccelTime const-decl "real" kinematics_gs_accel nil) (mkTrkGsVs const-decl "Velocity" Velocity nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (track const-decl "nnreal_lt_2pi" track nil) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (a skolem-const-decl "real" kinematics_gs_accel nil) (real_minus_real_is_real application-judgement "real" reals nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sgn_1 skolem-const-decl "int" kinematics_gs_accel nil) (accelTime skolem-const-decl "real" kinematics_gs_accel nil) (sin_range application-judgement "real_abs_le1" sincos trig) (cos_range application-judgement "real_abs_le1" sincos trig) (sin_track formula-decl nil track nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (track_scal formula-decl nil track nil) (both_sides_div_pos_gt1 formula-decl nil real_props nil) (vo3 skolem-const-decl "Vect3" kinematics_gs_accel nil) (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}" real_defs nil) (norm_eq_0 formula-decl nil vectors_2D vectors) (cos_track formula-decl nil track nil) (NOT const-decl "[bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nsv skolem-const-decl "[Vect3, Vect3]" kinematics_gs_accel nil) (reach_goal formula-decl nil kinematics_gs_accel nil) (Hat const-decl "{v: Vect2 |
   (v = zero IFF w = zero) AND
    (w /= zero IFF (norm(v) = 1 AND v = (1 / norm(w)) * w))}" util nil) (* const-decl "Vector" vectors_2D vectors) (norm const-decl "nnreal" vectors_2D vectors) (zero const-decl "Vector" vectors_2D vectors) (Vector type-eq-decl nil vectors_2D vectors) (+ const-decl "Vector" vectors_2D vectors) (Vect3 const-decl "{vv: Vect3 | vect2(vv) = w AND vv`z = z}" util nil) (scal_0 formula-decl nil vectors_2D vectors) (gsAccelPos const-decl "Vect3" kinematics_gs_accel nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (< const-decl "bool" reals nil) (cos const-decl "real" sincos_def trig) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig) (nnreal_lt_2pi nonempty-type-eq-decl nil trig_types trig) (trk const-decl "nnreal_lt_2pi" track nil) (vect2 const-decl "Vect2" vect_3D_2D vectors) (vs const-decl "real" Velocity nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig) (real_plus_real_is_real application-judgement "real" reals nil) (* const-decl "real" vectors_2D vectors) (sqv const-decl "nnreal" vectors_2D vectors) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (sin const-decl "real" sincos_def trig) (sqrt_sq formula-decl nil sqrt reals) (sq const-decl "nonneg_real" sq reals) (sin2_cos2 formula-decl nil sincos_def trig)) nil) (gsAccelUntil_checks-2 nil 3616760503 ("" (skeep) (("" (skoletin) (("" (skoletin) (("" (skoletin) (("" (skoletin) (("" (case "FORALL (TK: real, GS, VS:nnreal): gs(mkTrkGsVs(TK, GS, VS))=GS") (("1" (flatten) (("1" (split 2) (("1" (postpone) nil nil) ("2" (flatten) (("2" (expand "gsAccelUntil") (("2" (replace -5 :dir rl) (("2" (replace -6 :dir rl) (("2" (replace -4 :dir rl) (("2" (lift-if 1) (("2" (assert) (("2" (expand "gsAccel") (("2" (inst-cp -2 "trk(vect2(vo3))" "
                                   gs(vo3) + a * accelTime" "vs(vo3)") (("1" (replace -3) (("1" (case-replace "IF gs(vo3) + a * accelTime = 0 THEN 0
                   ELSE gs(vo3) + a * accelTime
                   ENDIF = gs(vo3)+a*accelTime") (("1" (inst -3 "trk(vect2(mkTrkGsVs(trk(vect2(vo3)),
                                       gs(vo3) + a * accelTime,
                                       vs(vo3))))" "
                   gs(vo3) + a * accelTime" "
                   vs(mkTrkGsVs(trk(vect2(vo3)), gs(vo3) + a * accelTime,
                                vs(vo3)))") (("1" (replace -3) (("1" (expand "accelTime") (("1" (expand "gsAccelTime") (("1" (expand "a") (("1" (expand "abs") (("1" (expand "sgn_1") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (flip-ineq 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (hide-all-but (-1 1 2 3)) (("1" (case-replace "goalGs = gs(vo3)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide -) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil) ("2" (hide-all-but 1) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "gsAccelUntil") (("3" (expand "gsAccel") (("3" (expand "vs") (("3" (expand "mkTrkGsVs") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "mkTrkGsVs") (("2" (expand "gs") (("2" (expand "vect2") (("2" (expand "norm") (("2" (expand "sqv") (("2" (expand "*") (("2" (lemma "trig_basic.sin2_cos2") (("2" (inst -1 "TK") (("2" (expand "sq") (("2" (mult-by -1 "GS*GS") (("2" (simplify -1) (("2" (replace -1) (("2" (lemma "sqrt_sq") (("2" (case-replace "1*(GS*GS) = sq(GS)") (("1" (inst?) (("1" (split -2) (("1" (propax) nil nil) ("2" (ground) nil nil)) nil)) nil) ("2" (expand "sq") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (gsAccelUntil_checks-1 nil 3616507255 ("" (skeep) (("" (skoletin) (("" (skoletin) (("" (skoletin) (("" (skoletin) (("" (case "FORALL (TK, GS, VS:real): gs(mkTrkGsVs(TK, GS, VS))=GS") (("1" (flatten) (("1" (split 2) (("1" (postpone) nil nil) ("2" (flatten) (("2" (expand "gsAccelUntil") (("2" (replace -5 :dir rl) (("2" (lift-if 1) (("2" (assert) (("2" (expand "gsAccel") (("2" (case-replace "IF gs(nsv`2) = 0 THEN 0 ELSE gs(nsv`2) ENDIF = gs(nsv`2)") (("1" (postpone) nil nil) ("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "gsAccelUntil") (("3" (expand "gsAccel") (("3" (expand "vs") (("3" (expand "mkTrkGsVs") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "mkTrkGsVs") (("2" (expand "gs") (("2" (expand "vect2") (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (gsAccelToRTA_TCC1 0 (gsAccelToRTA_TCC1-1 nil 3616432391 ("" (skeep) (("" (skeep) (("" (assert) (("" (lift-if -2) (("" (split -2) (("1" (assert) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) nil (gsAccelToRTA subtype "number_fields.*(kinematics_gs_accel.sgn, kinematics_gs_accel.gsAccel)" "nzreal"))) (gsAccelToRTA_TCC2 0 (gsAccelToRTA_TCC2-3 "" 3804577743 ("" (skeep) (("" (skeep) (("" (expand "gsAccelToRTA_possible") (("" (lift-if -4) (("" (split -4) (("1" (flatten) (("1" (replace -2) (("1" (simplify -6) (("1" (case "(a / 2) * rta ^ 2 + gsIn * rta >= dist") (("1" (mult-by -1 "2*a") (("1" (expand "discr") (("1" (hide (-2 -3 -4 -5 -6 -7)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "(a / 2) * rta ^ 2 + gsIn * rta <= dist") (("1" (hide (-2 -3 -4 -5 -6)) (("1" (case "-2*a>=0") (("1" (mult-by -2 "-2*a") (("1" (expand "discr") (("1" (grind) nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (gsAccelToRTA subtype "kinematics_gs_accel.C" "{c: reals.real | reals.>=(quadratic.discr(kinematics_gs_accel.A, kinematics_gs_accel.B, c), 0)}")) (gsAccelToRTA_TCC2-2 nil 3765286303 ("" (skeep) (("" (skeep) (("" (skeep) (("" (skeep) (("" (skeep) (("" (skeep) (("" (skeep) (("" (expand "gsAccelToRTA_possible") (("" (lift-if -5) (("" (split -5) (("1" (flatten) (("1" (replace -2) (("1" (simplify -6) (("1" (case "(a / 2) * rta ^ 2 + gsIn * rta >= dist") (("1" (mult-by -1 "2*a") (("1" (expand "discr") (("1" (hide (-2 -3 -4 -5 -6 -7)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "(a / 2) * rta ^ 2 + gsIn * rta <= dist") (("1" (hide (-2 -3 -4 -5 -6)) (("1" (case "-2*a>=0") (("1" (mult-by -2 "-2*a") (("1" (expand "discr") (("1" (grind) nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nzreal_min application-judgement "{z: nzreal | z <= x AND z <= y}" real_defs nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (a skolem-const-decl "nzreal" kinematics_gs_accel nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_expt application-judgement "posreal" exponentiation nil) (real_minus_real_is_real application-judgement "real" reals nil) (sq_nz_pos application-judgement "posreal" sq reals) (sq const-decl "nonneg_real" sq reals) (expt def-decl "real" exponentiation nil) (discr const-decl "real" quadratic reals) (real_times_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nzreal nonempty-type-eq-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (gsAccelToRTA_possible const-decl "[bool, nnreal]" gsAccel nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (posreal_exp application-judgement "posreal" exponentiation nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) nil (gsAccelToRTA subtype "kinematics_gs_accel.C" "{c: reals.real | reals.>=(quadratic.discr(kinematics_gs_accel.A, kinematics_gs_accel.B, c), 0)}")) (gsAccelToRTA_TCC2-1 nil 3616432391 ("" (skeep) (("" (skeep) (("" (skeep) (("" (skeep) (("" (skeep) (("" (skeep) (("" (skeep) (("" (ground) (("" (lift-if -2) (("" (split -2) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (gsAccelToRTA subtype "kinematics_gs_accel.C" "{c: reals.real | reals.>=(quadratic.discr(kinematics_gs_accel.A, kinematics_gs_accel.B, c), 0)}"))) (gsAccelToRTA_TCC3 0 (gsAccelToRTA_TCC3-1 nil 3765272604 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nzreal nonempty-type-eq-decl nil reals nil) (minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (^ const-decl "real" exponentiation nil) (gsAccelToRTA_possible const-decl "[bool, nnreal]" gsAccel nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nzreal_min application-judgement "{z: nzreal | z <= x AND z <= y}" real_defs nil) (posreal_expt application-judgement "posreal" exponentiation nil) (posreal_exp application-judgement "posreal" exponentiation nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (minus_int_is_int application-judgement "int" integers nil) (/= const-decl "boolean" notequal nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil)) nil (gsAccelToRTA subtype "(number_fields.-)(kinematics_gs_accel.sgn)" "Sign"))) (gsAccelToRTA_checks_TCC1 0 (gsAccelToRTA_checks_TCC1-1 nil 3616838793 ("" (skeep) (("" (expand "gs") (("" (expand "vect2") (("" (lemma "vectors_2D.norm_eq_0") (("" (typepred (vo3)) (("" (inst -2 "vect2(vo3)") (("" (flatten) (("" (hide -2) (("" (prop) (("" (expand "vect2") (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((gs const-decl "nnreal" Velocity nil) (norm_eq_0 formula-decl nil vectors_2D vectors) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Vector type-eq-decl nil vectors_2D vectors) (/= const-decl "boolean" notequal nil) (Vect3 type-eq-decl nil vectors_3D_def vectors) (Vect2 type-eq-decl nil vectors_2D_def vectors) (zero const-decl "Vector" vectors_2D vectors) (nzhVect3 nonempty-type-eq-decl nil track_3D nil) (vect2 const-decl "Vect2" vect_3D_2D vectors)) nil (gsAccelToRTA_checks subtype "Velocity.gs(kinematics_gs_accel.vo3)" "posreal"))) (gsAccelToRTA_checks_TCC2 0 (gsAccelToRTA_checks_TCC2-2 "" 3804604895 ("" (skeep) (("" (case "gsTor`1>0") (("1" (ground) nil nil) ("2" (hide 3) (("2" (expand "gsAccelToRTA") (("2" (name-replace "a" "IF dist / rta >= gs(vo3) THEN 1
                                                ELSE -1
                                                ENDIF*gsAccel!1") (("2" (name-replace "TorPos" "gsAccelToRTA_possible(gs(vo3), rta, dist, a)") (("1" (name-replace "sgn" "IF dist / rta >= gs(vo3) THEN 1
                                             ELSE -1
                                             ENDIF") (("1" (case-replace "-sgn = IF dist / rta >= gs(vo3) THEN -1
                                             ELSE --1
                                             ENDIF") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lift-if -1) (("1" (split) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (case "discr(a/2, -a*rta, dist-gs(vo3)*rta)>=0") (("1" (lemma "roots_ge_0") (("1" (inst -1 "a/2" "-a*rta" "dist-gs(vo3)*rta" "-sgn") (("1" (split -1) (("1" (flatten) (("1" (hide -2) (("1" (expand "TorPos" -5) (("1" (expand "gsAccelToRTA_possible") (("1" (split -5) (("1" (flatten) (("1" (split -3) (("1" (flatten) (("1" (case-replace "sgn =1") (("1" (mult-by -3 "gsAccel!1") (("1" (case "gs(vo3)>0") (("1" (add-formulas -1 -2) (("1" (ground) (("1" (case-replace "-(a*rta) = -a*rta") (("1" (ground) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil) ("2" (lemma "vectors_2D.norm_eq_0" ("v" "vect2(vo3)")) (("2" (flatten) (("2" (expand "gs") (("2" (typepred (vo3)) (("2" (split -2) (("1" (ground) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "sgn") (("2" (expand "a") (("2" (lift-if 1) (("2" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (lift-if -3) (("2" (split -3) (("1" (flatten) nil nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (cancel-by 1 "a/2") (("2" (case "dist/rta>=gs(vo3)") (("1" (cross-mult -1) (("1" (ground) nil nil)) nil) ("2" (expand "a") (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (ground) (("3" (cancel-by 1 "rta") nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case-replace "sgn=-1") (("1" (name-replace "rt" "root(a / 2, -a * rta, dist - gs(vo3) * rta, --1)") (("1" (expand "TorPos" -5) (("1" (expand "gsAccelToRTA_possible") (("1" (lift-if -5) (("1" (split -5) (("1" (flatten) nil nil) ("2" (flatten) (("2" (replace -6) (("2" (simplify 3) (("2" (case "-rt>0") (("1" (mult-by -1 "gsAccel!1") (("1" (typepred ("gs(vo3)")) (("1" (add-formulas -1 -2) (("1" (hide -5) (("1" (ground) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (mult-by -1 "gsAccel!1") (("2" (both-sides "-" "gs(vo3)" -1) (("2" (hide -4) (("2" (case "min(rta, -gs(vo3) / a) * gsAccel!1 - gs(vo3)<=0") (("1" (case "rt * gsAccel!1 - gs(vo3) <0") (("1" (split-ineq -2) (("1" (replace -1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (case "min(rta, -gs(vo3)/a)<= -gs(vo3)/a") (("1" (mult-by -1 "gsAccel!1") (("1" (expand "a") (("1" (expand "sgn") (("1" (replace -3) (("1" (case-replace "-gs(vo3) / (-1 * gsAccel!1) * gsAccel!1 = gs(vo3)") (("1" (ground) nil nil) ("2" (hide-all-but 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "min") (("2" (ground) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "sgn") (("2" (expand "a") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (lift-if 2) (("1" (split 2) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma "gsAccelToRTA_TCC2") (("2" (inst -1 "gs(vo3)" "dist" "rta" "gsAccel!1" "dist/rta" _ _ _) (("1" (inst -1 "sgn" _ _) (("1" (inst -1 "a" _) (("1" (inst -1 "TorPos") (("1" (split -1) (("1" (inst -1 "a/2" _ _) (("1" (inst -1 "-a*rta" _) (("1" (inst -1 "dist-gs(vo3)*rta") nil nil) ("2" (expand "a") (("2" (assert) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "sgn") (("2" (propax) nil nil)) nil) ("3" (expand "sgn") (("3" (assert) (("3" (expand "a") (("3" (propax) nil nil)) nil)) nil)) nil) ("4" (expand "TorPos") (("4" (propax) nil nil)) nil) ("5" (propax) nil nil)) nil)) nil) ("2" (expand "a") (("2" (assert) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gs") (("2" (lemma "vectors_2D.norm_eq_0") (("2" (inst -1 "vect2(vo3)") (("2" (typepred (vo3)) (("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "sgn") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "a") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (gsAccelToRTA_checks subtype "kinematics_gs_accel.gsTor`1" "posreal")) (gsAccelToRTA_checks_TCC2-1 nil 3616838793 ("" (skeep) (("" (case "gsTor`1>0") (("1" (ground) nil nil) ("2" (hide 3) (("2" (expand "gsAccelToRTA") (("2" (name-replace "a" "IF dist / rta >= gs(vo3) THEN 1
                                            ELSE -1
                                            ENDIF*gsAccel!1") (("2" (name-replace "TorPos" "gsAccelToRTA_possible(gs(vo3), rta, dist, a)") (("1" (name-replace "sgn" "IF dist / rta >= gs(vo3) THEN 1
                                       ELSE -1
                                       ENDIF") (("1" (case-replace "-sgn = IF dist / rta >= gs(vo3) THEN -1
                                       ELSE --1
                                       ENDIF") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lift-if -1) (("1" (split) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (case "discr(a/2, -a*rta, dist-gs(vo3)*rta)>=0") (("1" (lemma "roots_ge_0") (("1" (inst -1 "a/2" "-a*rta" "dist-gs(vo3)*rta" "-sgn") (("1" (split -1) (("1" (flatten) (("1" (hide -2) (("1" (expand "TorPos" -5) (("1" (expand "gsAccelToRTA_possible") (("1" (split -5) (("1" (flatten) (("1" (split -3) (("1" (flatten) (("1" (case-replace "sgn =1") (("1" (mult-by -3 "gsAccel!1") (("1" (case "gs(vo3)>0") (("1" (add-formulas -1 -2) (("1" (ground) (("1" (case-replace "-(a*rta) = -a*rta") (("1" (ground) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil) ("2" (lemma "vectors_2D.norm_eq_0" ("v" "vect2(vo3)")) (("2" (flatten) (("2" (expand "gs") (("2" (typepred (vo3)) (("2" (split -2) (("1" (ground) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "sgn") (("2" (expand "a") (("2" (lift-if 1) (("2" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (lift-if -3) (("2" (split -3) (("1" (flatten) nil nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (cancel-by 1 "a/2") (("2" (case "dist/rta>=gs(vo3)") (("1" (cross-mult -1) (("1" (ground) nil nil)) nil) ("2" (expand "a") (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (ground) (("3" (cancel-by 1 "rta") nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case-replace "sgn=-1") (("1" (name-replace "rt" "root(a / 2, -a * rta, dist - gs(vo3) * rta, --1)") (("1" (expand "TorPos" -5) (("1" (expand "gsAccelToRTA_possible") (("1" (lift-if -5) (("1" (split -5) (("1" (flatten) nil nil) ("2" (flatten) (("2" (replace -6) (("2" (simplify 3) (("2" (case "-rt>0") (("1" (mult-by -1 "gsAccel!1") (("1" (typepred ("gs(vo3)")) (("1" (add-formulas -1 -2) (("1" (hide -5) (("1" (ground) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (mult-by -1 "gsAccel!1") (("2" (both-sides "-" "gs(vo3)" -1) (("2" (hide -4) (("2" (case "min(rta, -gs(vo3) / a) * gsAccel!1 - gs(vo3)<=0") (("1" (case "rt * gsAccel!1 - gs(vo3) <0") (("1" (split-ineq -2) (("1" (replace -1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (case "min(rta, -gs(vo3)/a)<= -gs(vo3)/a") (("1" (mult-by -1 "gsAccel!1") (("1" (expand "a") (("1" (expand "sgn") (("1" (replace -3) (("1" (case-replace "-gs(vo3) / (-1 * gsAccel!1) * gsAccel!1 = gs(vo3)") (("1" (ground) nil nil) ("2" (hide-all-but 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "min") (("2" (ground) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "sgn") (("2" (expand "a") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (lift-if 2) (("1" (split 2) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma "gsAccelToRTA_TCC2") (("2" (inst -1 "gs(vo3)" "dist" "rta" "gsAccel!1" "dist/rta") (("1" (inst -1 "sgn") (("1" (split -1) (("1" (inst -1 "a") (("1" (prop) (("1" (inst -1 "TorPos") (("1" (split -1) (("1" (inst -1 "a/2") (("1" (inst -1 "-a*rta") (("1" (inst -1 "dist-gs(vo3)*rta") nil nil) ("2" (expand "a") (("2" (assert) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (expand "TorPos") (("3" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "sgn") (("2" (assert) (("2" (expand "a") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "a") (("2" (assert) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "sgn") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "gs") (("2" (lemma "vectors_2D.norm_eq_0") (("2" (inst -1 "vect2(vo3)") (("2" (typepred (vo3)) (("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "sgn") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "a") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_real_is_real application-judgement "real" reals nil) (gsAccelToRTA const-decl "[real, real]" kinematics_gs_accel nil) (gsAccelToRTA_possible const-decl "[bool, nnreal]" gsAccel nil) (nzreal nonempty-type-eq-decl nil reals nil) (odd_int nonempty-type-eq-decl nil integers nil) (odd? const-decl "bool" integers nil) (minus_int_is_int application-judgement "int" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (discr const-decl "real" quadratic reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (Sign type-eq-decl nil sign reals) (OR const-decl "[bool, bool -> bool]" booleans nil) (nzint nonempty-type-eq-decl nil integers nil) (TorPos skolem-const-decl "[bool, nnreal]" kinematics_gs_accel nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (zero_times1 formula-decl nil real_props nil) (neg_mult formula-decl nil extra_tegies nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_plus_real_is_real application-judgement "real" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (norm_eq_0 formula-decl nil vectors_2D vectors) (a skolem-const-decl "real" kinematics_gs_accel nil) (rta skolem-const-decl "posreal" kinematics_gs_accel nil) (dist skolem-const-decl "posreal" kinematics_gs_accel nil) (vo3 skolem-const-decl "nzhVect3" kinematics_gs_accel nil) (root const-decl "real" quadratic reals) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (sgn skolem-const-decl "int" kinematics_gs_accel nil) (zero_div formula-decl nil extra_tegies nil) (pos_div_gt formula-decl nil real_props nil) (div_div1 formula-decl nil real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (div_mult_pos_ge1 formula-decl nil real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (div_181 skolem-const-decl "real" kinematics_gs_accel nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil) (<= const-decl "bool" reals nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (* const-decl "real" vectors_2D vectors) (sqv const-decl "nnreal" vectors_2D vectors) (norm const-decl "nnreal" vectors_2D vectors) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (sq const-decl "nonneg_real" sq reals) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal_expt application-judgement "posreal" exponentiation nil) (both_sides_minus_lt1 formula-decl nil real_props nil) (< const-decl "bool" reals nil) (both_sides_times_pos_gt1 formula-decl nil real_props nil) (add_neg formula-decl nil extra_tegies nil) (posreal_exp application-judgement "posreal" exponentiation nil) (roots_ge_0 formula-decl nil quadratic reals) (gsAccelToRTA_TCC2 subtype-tcc nil kinematics_gs_accel nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (nzhVect3 nonempty-type-eq-decl nil track_3D nil) (zero const-decl "Vector" vectors_2D vectors) (vect2 const-decl "Vect2" vect_3D_2D vectors) (Vect2 type-eq-decl nil vectors_2D_def vectors) (Vector type-eq-decl nil vectors_2D vectors) (Vect3 type-eq-decl nil vectors_3D_def vectors) (gs const-decl "nnreal" Velocity nil) (nnreal type-eq-decl nil real_types nil) (Velocity type-eq-decl nil Velocity nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil)) nil (gsAccelToRTA_checks subtype "kinematics_gs_accel.gsTor`1" "posreal"))) (gsAccelToRTA_checks 0 (gsAccelToRTA_checks-5 "" 3804605604 ("" (skeep) (("" (skoletin) (("" (flatten) (("" (expand "gsAccelToRTA") (("" (name-replace "a" "IF dist / rta >= gs(vo3) THEN 1 ELSE -1 ENDIF *
                               gsAccel!1") (("" (name-replace "sgn" "IF dist/rta>=gs(vo3) THEN 1 ELSE -1 ENDIF") (("" (case-replace "IF dist / rta >= gs(vo3) THEN -1 ELSE --1 ENDIF = -sgn") (("1" (lift-if -2) (("1" (split -2) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (name-replace "TorPos" "gsAccelToRTA_possible(gs(vo3), rta, dist, a)") (("1" (hide -4) (("1" (hide 1) (("1" (case "discr(a/2, -a * rta, dist - gs(vo3) * rta)>=0") (("1" (lemma "roots_ge_0") (("1" (inst -1 "a/2" "-a*rta" "dist-gs(vo3)*rta" "sgn") (("1" (split -1) (("1" (flatten) (("1" (hide -2) (("1" (split -1) (("1" (name-replace "rt" "root(a / 2, -a * rta, dist - gs(vo3) * rta, -sgn)") (("1" (flatten) (("1" (hide -2) (("1" (case "rt = gsAccelTime(vo3, gsTor`1, gsAccel!1)") (("1" (expand "gsAccelUntil") (("1" (expand "TorPos" -4) (("1" (expand "gsAccelToRTA_possible") (("1" (case "IF a > 0 THEN rta ELSE min(rta, -gs(vo3) / a) ENDIF <= rta") (("1" (replace -2 :dir rl) (("1" (case "rt<rta") (("1" (name-replace "SGN" "IF gsTor`1 >= gs(vo3) THEN 1 ELSE -1 ENDIF") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (name "nsv" "gsAccel(zero, vo3, rt, SGN*gsAccel!1)") (("2" (replace -1) (("2" (name-replace "FinVect" "gsAccel(nsv`1, nsv`2, rta - rt, 0)") (("2" (expand "gsAccel") (("2" (case-replace "(gs(vo3)=0)=FALSE") (("1" (expand "trk") (("1" (lift-if -2) (("1" (split -2) (("1" (flatten) (("1" (lemma "vectors_2D.norm_eq_0") (("1" (inst -1 "vect2(vo3)") (("1" (flatten) (("1" (expand "gs") (("1" (split -2) (("1" (propax) nil nil) ("2" (expand "zero") (("2" (decompose-equality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "mkTrkGsVs") (("2" (rewrite "sin_track") (("2" (rewrite "cos_track") (("2" (expand "vect2") (("2" (expand "vs") (("2" (expand "gs" -1) (("2" (expand "vect2") (("2" (simplify -1) (("2" (case "norm((# x := vo3`x, y := vo3`y #)) *
                                                                                                                   (vo3`x / norm((# x := vo3`x, y := vo3`y #))) = vo3`x") (("1" (replace -1) (("1" (case-replace "vo3`y / norm((# x := vo3`x, y := vo3`y #)) *
                                                                                                          norm((# x := vo3`x, y := vo3`y #)) = vo3`y") (("1" (expand "gsAccelPos") (("1" (expand "zero") (("1" (expand "vect2") (("1" (expand "Hat") (("1" (hide (-1 -2)) (("1" (case-replace "(norm((# x := vo3`x, y := vo3`y #)) = 0) = FALSE") (("1" (hide -1) (("1" (expand "Vect2") (("1" (expand "+") (("1" (expand "Vect3") (("1" (expand "*") (("1" (case-replace "norm((# x := vo3`x, y := vo3`y #)) *
                                                                                                                       (vo3`x / norm((# x := vo3`x, y := vo3`y #))) = vo3`x") (("1" (case-replace " norm((# x := vo3`x, y := vo3`y #)) *
                                                                                                                             (vo3`y / norm((# x := vo3`x, y := vo3`y #))) = vo3`y") (("1" (hide (-1 -2)) (("1" (expand "FinVect") (("1" (expand "gsAccel") (("1" (expand "gsAccelPos") (("1" (expand "Vect3") (("1" (name-replace "NRM" "norm((# x := vo3`x, y := vo3`y #))") (("1" (case-replace "vect2(nsv`1) = (1/2*rt*rt*SGN*gsAccel!1/NRM +rt)*vect2(vo3)") (("1" (case-replace "vect2(nsv`2) = (1+SGN*gsAccel!1*rt/NRM)*vect2(vo3)") (("1" (case-replace "rt=0") (("1" (lemma "root_eq_0") (("1" (inst -1 "a/2" "-a * rta " " dist - gs(vo3) * rta" "-sgn") (("1" (split -1) (("1" (flatten) (("1" (hide -1) (("1" (expand "rt" -2) (("1" (split -1) (("1" (flatten) (("1" (simplify 2) (("1" (case-replace "0/NRM = 0") (("1" (simplify 2) (("1" (expand "vect2") (("1" (expand "*") (("1" (simplify 2) (("1" (expand "Hat") (("1" (case-replace "(norm((# x := 1 * vo3`x,
                                                                                                                                                                                                      y := 1 * vo3`y #))
                                                                                                                                                                                               = 0) = FALSE") (("1" (expand "Vect2") (("1" (expand "+") (("1" (case-replace "(# x
                                                                                                                                                                                  := norm((# x := 1 * vo3`x, y := 1 * vo3`y #)) *
                                                                                                                                                                                      (1 * vo3`x /
                                                                                                                                                                                        norm((# x := 1 * vo3`x, y := 1 * vo3`y #)))
                                                                                                                                                                                      * rta,
                                                                                                                                                                                y
                                                                                                                                                                                  := norm((# x := 1 * vo3`x, y := 1 * vo3`y #)) *
                                                                                                                                                                                      (1 * vo3`y /
                                                                                                                                                                                        norm((# x := 1 * vo3`x, y := 1 * vo3`y #)))
                                                                                                                                                                                      * rta #) = rta*vect2(vo3)") (("1" (rewrite "vectors_2D.norm_scal") (("1" (expand "gs") (("1" (case-replace "abs(rta) = rta") (("1" (ground) nil nil) ("2" (hide-all-but 1) (("2" (expand "abs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "vect2") (("2" (expand "*") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gs") (("2" (hide 4) (("2" (expand "vect2") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "sgn") (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "SGN = sgn") (("1" (case-replace "sgn*gsAccel!1 = a") (("1" (hide -5) (("1" (case "1+a*rt/NRM = 0") (("1" (mult-by -1 "NRM") (("1" (simplify -1) (("1" (case-replace "a * rt / NRM * NRM = a*rt") (("1" (hide -1) (("1" (case-replace "NRM = gs(vo3)") (("1" (hide -1) (("1" (case-replace "rt = -gs(vo3)/a") (("1" (hide 3) (("1" (case "a>0") (("1" (case "rt<0") (("1" (replace -3) (("1" (ground) nil nil)) nil) ("2" (typepred ("gs(vo3)")) (("2" (div-by -1 "a") (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (lift-if -13) (("2" (split -13) (("1" (flatten) nil nil) ("2" (flatten) (("2" (case "min(rta, -gs(vo3)/a)<=-gs(vo3)/a") (("1" (split-ineq -1) nil nil) ("2" (hide-all-but 1) (("2" (expand "min") (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (cross-mult 1) (("2" (ground) nil nil)) nil) ("3" (expand "a") (("3" (assert) (("3" (lift-if 1) (("3" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gs") (("2" (expand "NRM") (("2" (expand "vect2") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil) ("2" (expand "Hat") (("2" (case-replace "(norm((1 + a * rt / NRM) * vect2(vo3)) = 0)=FALSE") (("1" (expand "Vect2") (("1" (case "1+a*rt/NRM>0") (("1" (rewrite "vectors_2D.norm_scal") (("1" (case-replace "abs((1 + a * rt / NRM)) = (1+a*rt/NRM)") (("1" (case-replace "(# x
                                                                                                                                                                                                   := ((1 + a * rt / NRM) * vect2(vo3))`x /
                                                                                                                                                                                                       ((1 + a * rt / NRM) * norm(vect2(vo3))),
                                                                                                                                                                                                 y
                                                                                                                                                                                                   := ((1 + a * rt / NRM) * vect2(vo3))`y /
                                                                                                                                                                                                       ((1 + a * rt / NRM) *
                                                                                                                                                                                                         norm(vect2(vo3))) #) = (1/norm(vect2(vo3)))*vect2(vo3)") (("1" (case-replace "((1/2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt) *
                                                                                                                                                                                                   vect2(vo3)
                                                                                                                                                                                                   +
                                                                                                                                                                                                   ((1 + a * rt / NRM) * norm(vect2(vo3)) * rta -
                                                                                                                                                                                                     (1 + a * rt / NRM) * norm(vect2(vo3)) * rt)
                                                                                                                                                                                                    * ((1 / norm(vect2(vo3))) * vect2(vo3))) = ((1/2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt)
                                                                                                                                                                                                    + (1+a*rt/NRM)*(rta-rt))*vect2(vo3)") (("1" (case-replace "(# x
                                                                                                                                                                                                    := (((1 / 2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt) +
                                                                                                                                                                                                          (1 + a * rt / NRM) * (rta - rt))
                                                                                                                                                                                                         * vect2(vo3))`x,
                                                                                                                                                                                                  y
                                                                                                                                                                                                    := (((1 / 2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt) +
                                                                                                                                                                                                          (1 + a * rt / NRM) * (rta - rt))
                                                                                                                                                                                                         * vect2(vo3))`y #) = ((1 / 2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt) +
                                                                                                                                                                                                          (1 + a * rt / NRM) * (rta - rt))*vect2(vo3)") (("1" (lemma "quadratic_eq_0") (("1" (hide (-2 -3 -4)) (("1" (inst -1 "a / 2" " -a * rta" " dist - gs(vo3) * rta" "rt") (("1" (flatten) (("1" (hide -1) (("1" (split -1) (("1" (rewrite "vectors_2D.norm_scal") (("1" (expand "vect2") (("1" (expand "NRM") (("1" (case-replace "norm((#x:=vo3`x, y:=vo3`y#))=gs(vo3)") (("1" (case-replace "1/2 * (gsAccel!1 * rt * rt * sgn) / gs(vo3) -
                                                                                                                                                                                                                 a * rt / gs(vo3) * rt = -a/2*sq(rt)/gs(vo3)") (("1" (hide -1) (("1" (case "gs(vo3) = abs(gs(vo3))") (("1" (replace -1 5) (("1" (lemma "abs_mult") (("1" (inst -1 "-a / 2 * sq(rt) / abs(gs(vo3)) + a * rt / abs(gs(vo3)) * rta +
                                                                                                                                                                                                                             rta " " gs(vo3)") (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (hide -1) (("1" (case-replace "(-a / 2 * sq(rt) / gs(vo3) + a * rt / gs(vo3) * rta + rta) *
                                                                                                                                                                                                                             gs(vo3) = -a/2*sq(rt)+a*rt*rta+rta*gs(vo3)") (("1" (case "dist = -a / 2 * sq(rt) + a * rt * rta + rta * gs(vo3)") (("1" (typepred (dist)) (("1" (replace -3 -2) (("1" (case-replace "abs(-a / 2 * sq(rt) + a * rt * rta + rta * gs(vo3)) = -a / 2 * sq(rt) + a * rt * rta + rta * gs(vo3)") (("1" (ground) nil nil) ("2" (hide-all-but (-2 1)) (("2" (ground) (("2" (expand "abs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil) ("2" (hide-all-but 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "abs") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "a") (("2" (expand "sq") (("2" (expand "sgn") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gs") (("2" (expand "vect2") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (flatten) (("3" (hide-all-but (1 2)) (("3" (expand "rt") (("3" (expand "sgn") (("3" (lift-if) (("3" (split) (("1" (flatten) (("1" (split) (("1" (propax) nil nil) ("2" (flatten) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (propax) nil nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "vect2") (("2" (expand "*") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "vect2") (("2" (expand "*") (("2" (ground) (("2" (expand "+") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 5) (("2" (expand "vect2") (("2" (expand "*") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (expand "gs") (("3" (ground) nil nil)) nil)) nil) ("2" (expand "abs") (("2" (hide 6) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flip-ineq 1) (("2" (mult-by -1 "NRM") (("2" (case-replace "NRM = gs(vo3)") (("1" (simplify -2) (("1" (case-replace " gs(vo3) * (a * rt / gs(vo3))= a*rt") (("1" (hide 4) (("1" (case "a>0") (("1" (case "rt<=-gs(vo3)/a") (("1" (case "-gs(vo3)/a<0") (("1" (ground) nil nil) ("2" (cross-mult 1) (("2" (ground) nil nil)) nil)) nil) ("2" (cross-mult 1) (("2" (ground) nil nil)) nil) ("3" (expand "a") (("3" (lift-if 1) (("3" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "rt>=gs(vo3)/(-a)") (("1" (case-replace "gs(vo3)/(-a) = -gs(vo3)/a") (("1" (hide -1) (("1" (lift-if -16) (("1" (split -16) (("1" (flatten) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil) ("2" (ground) nil nil) ("3" (expand "a") (("3" (lift-if 1) (("3" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flip-ineq 2) (("2" (cross-mult 1) (("2" (ground) nil nil)) nil)) nil) ("3" (expand "a") (("3" (lift-if 1) (("3" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (expand "NRM") (("2" (expand "gs") (("2" (expand "vect2") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 5) (("2" (rewrite "vectors_2D.norm_scal") (("2" (simplify 1) (("2" (typepred ("gs(vo3)")) (("2" (simplify -7) (("2" (case "abs(1+a*rt/NRM) /= 0 ") (("1" (expand "gs") (("1" (real-props) nil nil)) nil) ("2" (expand "/=") (("2" (expand "abs") (("2" (lift-if -1) (("2" (split -1) (("1" (ground) nil nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "sgn") (("2" (expand "a") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "SGN") (("2" (replace -11 1) (("2" (simplify 1) (("2" (lift-if 1) (("2" (hide (-1 -2 -3)) (("2" (split 1) (("1" (flatten) (("1" (both-sides "-" " gs(vo3)" -1) (("1" (simplify -1) (("1" (expand "sgn") (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (lift-if -1) (("2" (flatten) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (typepred (gsAccel!1)) (("2" (case "rt>0") (("1" (mult-ineq -1 -3) (("1" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "sgn") (("2" (lift-if 1) (("2" (split 1) (("1" (lift-if 2) (("1" (split 2) (("1" (flatten) (("1" (both-sides "-" "gs(vo3)" 2) (("1" (simplify 2) (("1" (case "rt>0") (("1" (typepred (gsAccel!1)) (("1" (mult-ineq -2 -3) (("1" (ground) nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (lift-if 3) (("2" (split 3) (("1" (flatten) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vect2") (("2" (hide 3) (("2" (replace -2 :dir rl) (("2" (decompose-equality 1) (("1" (expand "*") (("1" (ground) nil nil)) nil) ("2" (expand "*") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "vect2") (("2" (expand "*") (("2" (split 1) (("1" (replace -1 :dir rl) (("1" (ground) nil nil)) nil) ("2" (replace -1 :dir rl) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gs") (("2" (expand "vect2") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred ("vo3")) (("2" (lemma "vectors_2D.norm_eq_0") (("2" (inst -1 "vect2(vo3)") (("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (expand "gs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) (("2" (split-ineq -1) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (flip-ineq 2) (("2" (hide-all-but (-1 -2 -6 1)) (("2" (name-replace "MIN" "IF a > 0 THEN rta ELSE min(rta, -gs(vo3) / a) ENDIF") (("2" (case "rt<=MIN") (("1" (ground) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (expand "min") (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (hide 2) (("3" (expand "a") (("3" (lift-if -1) (("3" (split -1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gsAccelTime") (("2" (replace -4 1) (("2" (simplify 1) (("2" (case-replace "abs(-1 * (gsAccel!1 * rt * sgn)) = gsAccel!1*rt") (("1" (ground) nil nil) ("2" (typepred (gsAccel!1)) (("2" (hide (-4 -5 -6 -7 2 3)) (("2" (expand "abs") (("2" (expand "sgn") (("2" (grind) (("1" (split-ineq -4) (("1" (mult-by -2 "rt") (("1" (ground) nil nil)) nil)) nil) ("2" (mult-by -2 "rt") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "gsAccelToRTA_checks_TCC2") (("3" (inst -1 "vo3" " dist" " rta" " gsAccel!1" " gsTor") (("3" (reveal 1) (("3" (split -1) (("1" (ground) nil nil) ("2" (expand "gsTor") (("2" (propax) nil nil)) nil) ("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "dist/rta>=gs(vo3)") (("1" (case "a/2>=0") (("1" (cross-mult -2) (("1" (mult-by -2 "a/2") (("1" (ground) nil nil)) nil)) nil) ("2" (cross-mult 1) (("2" (expand "a") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (copy 1) (("2" (flip-ineq 1) (("2" (cross-mult -1) (("2" (case "-a/2>0") (("1" (mult-by -2 "-a/2") (("1" (ground) nil nil)) nil) ("2" (expand "a") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (cancel-by 1 "rta") nil nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (expand "sgn") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "gsAccelToRTA_TCC2") (("2" (inst -1 "gs(vo3)" "dist" "rta" "gsAccel!1" "dist/rta" _ _ _) (("1" (inst -1 "sgn" _ _) (("1" (inst -1 "a" _) (("1" (inst -1 "TorPos") (("1" (split -1) (("1" (inst -1 "a/2" "-a*rta" "dist - gs(vo3) * rta") (("1" (assert) (("1" (expand "a") (("1" (lift-if -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "a") (("2" (expand "sgn") (("2" (propax) nil nil)) nil)) nil) ("3" (expand "a") (("3" (expand "sgn") (("3" (propax) nil nil)) nil)) nil) ("4" (expand "TorPos") (("4" (propax) nil nil)) nil) ("5" (propax) nil nil)) nil)) nil) ("2" (expand "a") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gs") (("2" (lemma "vectors_2D.norm_eq_0") (("2" (inst -1 "vect2(vo3)") (("2" (typepred (vo3)) (("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil) ("2" (expand "sgn") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (gsAccelToRTA_checks-4 nil 3765287257 ("" (skeep) (("" (skoletin) (("" (flatten) (("" (expand "gsAccelToRTA") (("" (name-replace "a" "IF dist / rta >= gs(vo3) THEN 1 ELSE -1 ENDIF *
                               gsAccel!1") (("" (name-replace "sgn" "IF dist/rta>=gs(vo3) THEN 1 ELSE -1 ENDIF") (("" (case-replace "IF dist / rta >= gs(vo3) THEN -1 ELSE --1 ENDIF = -sgn") (("1" (lift-if -2) (("1" (split -2) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (name-replace "TorPos" "gsAccelToRTA_possible(gs(vo3), rta, dist, a)") (("1" (hide -4) (("1" (hide 1) (("1" (case "discr(a/2, -a * rta, dist - gs(vo3) * rta)>=0") (("1" (lemma "roots_ge_0") (("1" (inst -1 "a/2" "-a*rta" "dist-gs(vo3)*rta" "sgn") (("1" (split -1) (("1" (flatten) (("1" (hide -2) (("1" (split -1) (("1" (name-replace "rt" "root(a / 2, -a * rta, dist - gs(vo3) * rta, -sgn)") (("1" (flatten) (("1" (hide -2) (("1" (case "rt = gsAccelTime(vo3, gsTor`1, gsAccel!1)") (("1" (expand "gsAccelUntil") (("1" (expand "TorPos" -4) (("1" (expand "gsAccelToRTA_possible") (("1" (case "IF a > 0 THEN rta ELSE min(rta, -gs(vo3) / a) ENDIF <= rta") (("1" (replace -2 :dir rl) (("1" (case "rt<rta") (("1" (name-replace "SGN" "IF gsTor`1 >= gs(vo3) THEN 1 ELSE -1 ENDIF") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (name "nsv" "gsAccel(zero, vo3, rt, SGN*gsAccel!1)") (("2" (replace -1) (("2" (name-replace "FinVect" "gsAccel(nsv`1, nsv`2, rta - rt, 0)") (("2" (expand "gsAccel") (("2" (case-replace "(gs(vo3)=0)=FALSE") (("1" (expand "trk") (("1" (lift-if -2) (("1" (split -2) (("1" (flatten) (("1" (lemma "vectors_2D.norm_eq_0") (("1" (inst -1 "vect2(vo3)") (("1" (flatten) (("1" (expand "gs") (("1" (split -2) (("1" (propax) nil nil) ("2" (expand "zero") (("2" (decompose-equality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "mkTrkGsVs") (("2" (rewrite "sin_track") (("2" (rewrite "cos_track") (("2" (expand "vect2") (("2" (expand "vs") (("2" (expand "gs" -1) (("2" (expand "vect2") (("2" (simplify -1) (("2" (case "norm((# x := vo3`x, y := vo3`y #)) *
                                                                                                                   (vo3`x / norm((# x := vo3`x, y := vo3`y #))) = vo3`x") (("1" (replace -1) (("1" (case-replace "vo3`y / norm((# x := vo3`x, y := vo3`y #)) *
                                                                                                          norm((# x := vo3`x, y := vo3`y #)) = vo3`y") (("1" (expand "gsAccelPos") (("1" (expand "zero") (("1" (expand "vect2") (("1" (expand "Hat") (("1" (hide (-1 -2)) (("1" (case-replace "(norm((# x := vo3`x, y := vo3`y #)) = 0) = FALSE") (("1" (hide -1) (("1" (expand "Vect2") (("1" (expand "+") (("1" (expand "Vect3") (("1" (expand "*") (("1" (case-replace "norm((# x := vo3`x, y := vo3`y #)) *
                                                                                                                       (vo3`x / norm((# x := vo3`x, y := vo3`y #))) = vo3`x") (("1" (case-replace " norm((# x := vo3`x, y := vo3`y #)) *
                                                                                                                             (vo3`y / norm((# x := vo3`x, y := vo3`y #))) = vo3`y") (("1" (hide (-1 -2)) (("1" (expand "FinVect") (("1" (expand "gsAccel") (("1" (expand "gsAccelPos") (("1" (expand "Vect3") (("1" (name-replace "NRM" "norm((# x := vo3`x, y := vo3`y #))") (("1" (case-replace "vect2(nsv`1) = (1/2*rt*rt*SGN*gsAccel!1/NRM +rt)*vect2(vo3)") (("1" (case-replace "vect2(nsv`2) = (1+SGN*gsAccel!1*rt/NRM)*vect2(vo3)") (("1" (case-replace "rt=0") (("1" (lemma "root_eq_0") (("1" (inst -1 "a/2" "-a * rta " " dist - gs(vo3) * rta" "-sgn") (("1" (split -1) (("1" (flatten) (("1" (hide -1) (("1" (expand "rt" -2) (("1" (split -1) (("1" (flatten) (("1" (simplify 2) (("1" (case-replace "0/NRM = 0") (("1" (simplify 2) (("1" (expand "vect2") (("1" (expand "*") (("1" (simplify 2) (("1" (expand "Hat") (("1" (case-replace "(norm((# x := 1 * vo3`x,
                                                                                                                                                                                                      y := 1 * vo3`y #))
                                                                                                                                                                                               = 0) = FALSE") (("1" (expand "Vect2") (("1" (expand "+") (("1" (case-replace "(# x
                                                                                                                                                                                  := norm((# x := 1 * vo3`x, y := 1 * vo3`y #)) *
                                                                                                                                                                                      (1 * vo3`x /
                                                                                                                                                                                        norm((# x := 1 * vo3`x, y := 1 * vo3`y #)))
                                                                                                                                                                                      * rta,
                                                                                                                                                                                y
                                                                                                                                                                                  := norm((# x := 1 * vo3`x, y := 1 * vo3`y #)) *
                                                                                                                                                                                      (1 * vo3`y /
                                                                                                                                                                                        norm((# x := 1 * vo3`x, y := 1 * vo3`y #)))
                                                                                                                                                                                      * rta #) = rta*vect2(vo3)") (("1" (rewrite "vectors_2D.norm_scal") (("1" (expand "gs") (("1" (case-replace "abs(rta) = rta") (("1" (ground) nil nil) ("2" (hide-all-but 1) (("2" (expand "abs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "vect2") (("2" (expand "*") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gs") (("2" (hide 4) (("2" (expand "vect2") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "sgn") (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "SGN = sgn") (("1" (case-replace "sgn*gsAccel!1 = a") (("1" (hide -5) (("1" (case "1+a*rt/NRM = 0") (("1" (mult-by -1 "NRM") (("1" (simplify -1) (("1" (case-replace "a * rt / NRM * NRM = a*rt") (("1" (hide -1) (("1" (case-replace "NRM = gs(vo3)") (("1" (hide -1) (("1" (case-replace "rt = -gs(vo3)/a") (("1" (hide 3) (("1" (case "a>0") (("1" (case "rt<0") (("1" (replace -3) (("1" (ground) nil nil)) nil) ("2" (typepred ("gs(vo3)")) (("2" (div-by -1 "a") (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (lift-if -13) (("2" (split -13) (("1" (flatten) nil nil) ("2" (flatten) (("2" (case "min(rta, -gs(vo3)/a)<=-gs(vo3)/a") (("1" (split-ineq -1) nil nil) ("2" (hide-all-but 1) (("2" (expand "min") (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (cross-mult 1) (("2" (ground) nil nil)) nil) ("3" (expand "a") (("3" (assert) (("3" (lift-if 1) (("3" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gs") (("2" (expand "NRM") (("2" (expand "vect2") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil) ("2" (expand "Hat") (("2" (case-replace "(norm((1 + a * rt / NRM) * vect2(vo3)) = 0)=FALSE") (("1" (expand "Vect2") (("1" (case "1+a*rt/NRM>0") (("1" (rewrite "vectors_2D.norm_scal") (("1" (case-replace "abs((1 + a * rt / NRM)) = (1+a*rt/NRM)") (("1" (case-replace "(# x
                                                                                                                                                                                                   := ((1 + a * rt / NRM) * vect2(vo3))`x /
                                                                                                                                                                                                       ((1 + a * rt / NRM) * norm(vect2(vo3))),
                                                                                                                                                                                                 y
                                                                                                                                                                                                   := ((1 + a * rt / NRM) * vect2(vo3))`y /
                                                                                                                                                                                                       ((1 + a * rt / NRM) *
                                                                                                                                                                                                         norm(vect2(vo3))) #) = (1/norm(vect2(vo3)))*vect2(vo3)") (("1" (case-replace "((1/2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt) *
                                                                                                                                                                                                   vect2(vo3)
                                                                                                                                                                                                   +
                                                                                                                                                                                                   ((1 + a * rt / NRM) * norm(vect2(vo3)) * rta -
                                                                                                                                                                                                     (1 + a * rt / NRM) * norm(vect2(vo3)) * rt)
                                                                                                                                                                                                    * ((1 / norm(vect2(vo3))) * vect2(vo3))) = ((1/2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt)
                                                                                                                                                                                                    + (1+a*rt/NRM)*(rta-rt))*vect2(vo3)") (("1" (case-replace "(# x
                                                                                                                                                                                                    := (((1 / 2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt) +
                                                                                                                                                                                                          (1 + a * rt / NRM) * (rta - rt))
                                                                                                                                                                                                         * vect2(vo3))`x,
                                                                                                                                                                                                  y
                                                                                                                                                                                                    := (((1 / 2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt) +
                                                                                                                                                                                                          (1 + a * rt / NRM) * (rta - rt))
                                                                                                                                                                                                         * vect2(vo3))`y #) = ((1 / 2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt) +
                                                                                                                                                                                                          (1 + a * rt / NRM) * (rta - rt))*vect2(vo3)") (("1" (lemma "quadratic_eq_0") (("1" (hide (-2 -3 -4)) (("1" (inst -1 "a / 2" " -a * rta" " dist - gs(vo3) * rta" "rt") (("1" (flatten) (("1" (hide -1) (("1" (split -1) (("1" (rewrite "vectors_2D.norm_scal") (("1" (expand "vect2") (("1" (expand "NRM") (("1" (case-replace "norm((#x:=vo3`x, y:=vo3`y#))=gs(vo3)") (("1" (case-replace "1/2 * (gsAccel!1 * rt * rt * sgn) / gs(vo3) -
                                                                                                                                                                                                                 a * rt / gs(vo3) * rt = -a/2*sq(rt)/gs(vo3)") (("1" (hide -1) (("1" (case "gs(vo3) = abs(gs(vo3))") (("1" (replace -1 5) (("1" (lemma "abs_mult") (("1" (inst -1 "-a / 2 * sq(rt) / abs(gs(vo3)) + a * rt / abs(gs(vo3)) * rta +
                                                                                                                                                                                                                             rta " " gs(vo3)") (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (hide -1) (("1" (case-replace "(-a / 2 * sq(rt) / gs(vo3) + a * rt / gs(vo3) * rta + rta) *
                                                                                                                                                                                                                             gs(vo3) = -a/2*sq(rt)+a*rt*rta+rta*gs(vo3)") (("1" (case "dist = -a / 2 * sq(rt) + a * rt * rta + rta * gs(vo3)") (("1" (typepred (dist)) (("1" (replace -3 -2) (("1" (case-replace "abs(-a / 2 * sq(rt) + a * rt * rta + rta * gs(vo3)) = -a / 2 * sq(rt) + a * rt * rta + rta * gs(vo3)") (("1" (ground) nil nil) ("2" (hide-all-but (-2 1)) (("2" (ground) (("2" (expand "abs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil) ("2" (hide-all-but 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "abs") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "a") (("2" (expand "sq") (("2" (expand "sgn") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gs") (("2" (expand "vect2") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (flatten) (("3" (hide-all-but (1 2)) (("3" (expand "rt") (("3" (expand "sgn") (("3" (lift-if) (("3" (split) (("1" (flatten) (("1" (split) (("1" (propax) nil nil) ("2" (flatten) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (propax) nil nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "vect2") (("2" (expand "*") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "vect2") (("2" (expand "*") (("2" (ground) (("2" (expand "+") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 5) (("2" (expand "vect2") (("2" (expand "*") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (expand "gs") (("3" (ground) nil nil)) nil)) nil) ("2" (expand "abs") (("2" (hide 6) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flip-ineq 1) (("2" (mult-by -1 "NRM") (("2" (case-replace "NRM = gs(vo3)") (("1" (simplify -2) (("1" (case-replace " gs(vo3) * (a * rt / gs(vo3))= a*rt") (("1" (hide 4) (("1" (case "a>0") (("1" (case "rt<=-gs(vo3)/a") (("1" (case "-gs(vo3)/a<0") (("1" (ground) nil nil) ("2" (cross-mult 1) (("2" (ground) nil nil)) nil)) nil) ("2" (cross-mult 1) (("2" (ground) nil nil)) nil) ("3" (expand "a") (("3" (lift-if 1) (("3" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "rt>=gs(vo3)/(-a)") (("1" (case-replace "gs(vo3)/(-a) = -gs(vo3)/a") (("1" (hide -1) (("1" (lift-if -16) (("1" (split -16) (("1" (flatten) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil) ("2" (ground) nil nil) ("3" (expand "a") (("3" (lift-if 1) (("3" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flip-ineq 2) (("2" (cross-mult 1) (("2" (ground) nil nil)) nil)) nil) ("3" (expand "a") (("3" (lift-if 1) (("3" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (expand "NRM") (("2" (expand "gs") (("2" (expand "vect2") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 5) (("2" (rewrite "vectors_2D.norm_scal") (("2" (simplify 1) (("2" (typepred ("gs(vo3)")) (("2" (simplify -7) (("2" (case "abs(1+a*rt/NRM) /= 0 ") (("1" (expand "gs") (("1" (real-props) nil nil)) nil) ("2" (expand "/=") (("2" (expand "abs") (("2" (lift-if -1) (("2" (split -1) (("1" (ground) nil nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "sgn") (("2" (expand "a") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "SGN") (("2" (replace -11 1) (("2" (simplify 1) (("2" (lift-if 1) (("2" (hide (-1 -2 -3)) (("2" (split 1) (("1" (flatten) (("1" (both-sides "-" " gs(vo3)" -1) (("1" (simplify -1) (("1" (expand "sgn") (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (lift-if -1) (("2" (flatten) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (typepred (gsAccel!1)) (("2" (case "rt>0") (("1" (mult-ineq -1 -3) (("1" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "sgn") (("2" (lift-if 1) (("2" (split 1) (("1" (lift-if 2) (("1" (split 2) (("1" (flatten) (("1" (both-sides "-" "gs(vo3)" 2) (("1" (simplify 2) (("1" (case "rt>0") (("1" (typepred (gsAccel!1)) (("1" (mult-ineq -2 -3) (("1" (ground) nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (lift-if 3) (("2" (split 3) (("1" (flatten) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vect2") (("2" (hide 3) (("2" (replace -2 :dir rl) (("2" (decompose-equality 1) (("1" (expand "*") (("1" (ground) nil nil)) nil) ("2" (expand "*") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "vect2") (("2" (expand "*") (("2" (split 1) (("1" (replace -1 :dir rl) (("1" (ground) nil nil)) nil) ("2" (replace -1 :dir rl) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gs") (("2" (expand "vect2") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred ("vo3")) (("2" (lemma "vectors_2D.norm_eq_0") (("2" (inst -1 "vect2(vo3)") (("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (expand "gs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) (("2" (split-ineq -1) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (flip-ineq 2) (("2" (hide-all-but (-1 -2 -6 1)) (("2" (name-replace "MIN" "IF a > 0 THEN rta ELSE min(rta, -gs(vo3) / a) ENDIF") (("2" (case "rt<=MIN") (("1" (ground) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (expand "min") (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (hide 2) (("3" (expand "a") (("3" (lift-if -1) (("3" (split -1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gsAccelTime") (("2" (replace -4 1) (("2" (simplify 1) (("2" (case-replace "abs(-1 * (gsAccel!1 * rt * sgn)) = gsAccel!1*rt") (("1" (ground) nil nil) ("2" (typepred (gsAccel!1)) (("2" (hide (-4 -5 -6 -7 2 3)) (("2" (expand "abs") (("2" (expand "sgn") (("2" (grind) (("1" (split-ineq -4) (("1" (mult-by -2 "rt") (("1" (ground) nil nil)) nil)) nil) ("2" (mult-by -2 "rt") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "gsAccelToRTA_checks_TCC2") (("3" (inst -1 "vo3" " dist" " rta" " gsAccel!1" " gsTor") (("3" (reveal 1) (("3" (split -1) (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (expand "gsTor") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "dist/rta>=gs(vo3)") (("1" (case "a/2>=0") (("1" (cross-mult -2) (("1" (mult-by -2 "a/2") (("1" (ground) nil nil)) nil)) nil) ("2" (cross-mult 1) (("2" (expand "a") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (copy 1) (("2" (flip-ineq 1) (("2" (cross-mult -1) (("2" (case "-a/2>0") (("1" (mult-by -2 "-a/2") (("1" (ground) nil nil)) nil) ("2" (expand "a") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (cancel-by 1 "rta") nil nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (expand "sgn") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "gsAccelToRTA_TCC2") (("2" (inst -1 "gs(vo3)" "dist" "rta" "gsAccel!1" "dist/rta") (("1" (inst -1 "sgn") (("1" (split -1) (("1" (inst -1 "a") (("1" (prop) (("1" (inst -1 "TorPos") (("1" (split -1) (("1" (inst -1 "a/2") (("1" (inst -1 "-a*rta") (("1" (inst -1 "dist - gs(vo3) * rta") nil nil) ("2" (assert) (("2" (expand "a") (("2" (lift-if -1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (expand "TorPos") (("3" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "a") (("2" (expand "sgn") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "a") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "sgn") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "gs") (("2" (lemma "vectors_2D.norm_eq_0") (("2" (inst -1 "vect2(vo3)") (("2" (typepred (vo3)) (("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil) ("2" (expand "sgn") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (odd_int nonempty-type-eq-decl nil integers nil) (odd? const-decl "bool" integers nil) (minus_int_is_int application-judgement "int" integers nil) (gsAccelToRTA_possible const-decl "[bool, nnreal]" gsAccel nil) (nzreal nonempty-type-eq-decl nil reals nil) (gsAccelToRTA_TCC2 subtype-tcc nil kinematics_gs_accel nil) (rta skolem-const-decl "posreal" kinematics_gs_accel nil) (vo3 skolem-const-decl "nzhVect3" kinematics_gs_accel nil) (roots_ge_0 formula-decl nil quadratic reals) (both_sides_times_pos_le1 formula-decl nil real_props nil) (div_mult_pos_ge1 formula-decl nil real_props nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (root const-decl "real" quadratic reals) (gsAccelToRTA_checks_TCC2 subtype-tcc nil kinematics_gs_accel nil) (gsTor skolem-const-decl "[real, real]" kinematics_gs_accel nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (both_sides_times_pos_gt1 formula-decl nil real_props nil) (posreal_exp application-judgement "posreal" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (trk const-decl "nnreal_lt_2pi" track nil) (norm_eq_0 formula-decl nil vectors_2D vectors) (sin_range application-judgement "real_abs_le1" sincos trig) (cos_range application-judgement "real_abs_le1" sincos trig) (mkTrkGsVs const-decl "Velocity" Velocity nil) (cos_track formula-decl nil track nil) (vs const-decl "real" Velocity nil) (Hat const-decl "{v: Vect2 |
   (v = zero IFF w = zero) AND
    (w /= zero IFF (norm(v) = 1 AND v = (1 / norm(w)) * w))}" util nil) (Vect2 const-decl "{vv: Vect2 | vv`x = x AND vv`y = y}" util nil) (Vect3 const-decl "{vv: Vect3 | vect2(vv) = w AND vv`z = z}" util nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (rt skolem-const-decl "real" kinematics_gs_accel nil) (norm_scal formula-decl nil vectors_2D vectors) (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}" real_defs nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (root_eq_0 formula-decl nil quadratic reals) (both_sides_minus_ge1 formula-decl nil real_props nil) (both_sides_plus_ge2 formula-decl nil real_props nil) (pos_times_ge formula-decl nil real_props nil) (neg_times_ge formula-decl nil real_props nil) (gt_times_gt_any1 formula-decl nil extra_real_props nil) (int_times_even_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (SGN skolem-const-decl "int" kinematics_gs_accel nil) (NRM skolem-const-decl "nnreal" kinematics_gs_accel nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (div_cancel4 formula-decl nil real_props nil) (scal_0 formula-decl nil vectors_2D vectors) (both_sides_div_pos_ge1 formula-decl nil real_props nil) (a skolem-const-decl "real" kinematics_gs_accel nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (quadratic_eq_0 formula-decl nil quadratic reals) (sq const-decl "nonneg_real" sq reals) (abs_mult formula-decl nil real_props nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (sqv const-decl "nnreal" vectors_2D vectors) (* const-decl "real" vectors_2D vectors) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (div_mult_pos_ge2 formula-decl nil real_props nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (div_mult_pos_le2 formula-decl nil real_props nil) (zero_times3 formula-decl nil real_props nil) (times_div2 formula-decl nil real_props nil) (div_div2 formula-decl nil real_props nil) (FinVect skolem-const-decl "[Vect3, Vect3]" kinematics_gs_accel nil) (* const-decl "Vector" vectors_2D vectors) (+ const-decl "Vector" vectors_2D vectors) (gsAccelPos const-decl "Vect3" kinematics_gs_accel nil) (real_plus_real_is_real application-judgement "real" reals nil) (sin_track formula-decl nil track nil) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (FALSE const-decl "bool" booleans nil) (gsAccel const-decl "[Vect3, Vect3]" kinematics_gs_accel nil) (< const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (<= const-decl "bool" reals nil) (TorPos skolem-const-decl "[bool, nnreal]" kinematics_gs_accel nil) (gsAccelTime const-decl "real" kinematics_gs_accel nil) (nzint nonempty-type-eq-decl nil integers nil) (Sign type-eq-decl nil sign reals) (OR const-decl "[bool, bool -> bool]" booleans nil) (sgn skolem-const-decl "int" kinematics_gs_accel nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (discr const-decl "real" quadratic reals) (nonzero_real nonempty-type-eq-decl nil reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (zero const-decl "Vector" vectors_3D vectors) (Vector type-eq-decl nil vectors_3D vectors) (gsAccelUntil const-decl "[Vect3, Vect3]" kinematics_gs_accel nil) (norm const-decl "nnreal" vectors_2D vectors) (IFF const-decl "[bool, bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (gsAccelToRTA const-decl "[real, real]" kinematics_gs_accel nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (Velocity type-eq-decl nil Velocity nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (gs const-decl "nnreal" Velocity nil) (Vect3 type-eq-decl nil vectors_3D_def vectors) (Vector type-eq-decl nil vectors_2D vectors) (/= const-decl "boolean" notequal nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (vect2 const-decl "Vect2" vect_3D_2D vectors) (zero const-decl "Vector" vectors_2D vectors) (nzhVect3 nonempty-type-eq-decl nil track_3D nil)) nil) (gsAccelToRTA_checks-3 nil 3708766907 ("" (skeep) (("" (skoletin) (("" (flatten) (("" (expand "gsAccelToRTA") (("" (name-replace "a" "IF dist / rta >= gs(vo3) THEN 1 ELSE -1 ENDIF *
                             gsAccel!1") (("" (name-replace "sgn" "IF dist/rta>=gs(vo3) THEN 1 ELSE -1 ENDIF") (("" (case-replace "IF dist / rta >= gs(vo3) THEN -1 ELSE --1 ENDIF = -sgn") (("1" (lift-if -2) (("1" (split -2) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (name-replace "TorPos" "gsAccelToRTA_possible(gs(vo3), rta, dist, a)") (("1" (hide -4) (("1" (hide 1) (("1" (case "discr(a/2, -a * rta, dist - gs(vo3) * rta)>=0") (("1" (lemma "roots_ge_0") (("1" (inst -1 "a/2" "-a*rta" "dist-gs(vo3)*rta" "sgn") (("1" (split -1) (("1" (flatten) (("1" (hide -2) (("1" (split -1) (("1" (name-replace "rt" "root(a / 2, -a * rta, dist - gs(vo3) * rta, -sgn)") (("1" (flatten) (("1" (hide -2) (("1" (case "rt = gsAccelTime(vo3, gsTor`1, gsAccel!1)") (("1" (expand "gsAccelUntil") (("1" (expand "TorPos" -4) (("1" (expand "gsAccelToRTA_possible") (("1" (case "IF a > 0 THEN rta ELSE min(rta, -gs(vo3) / a) ENDIF <= rta") (("1" (replace -2 :dir rl) (("1" (case "rt<rta") (("1" (name-replace "SGN" "IF gsTor`1 >= gs(vo3) THEN 1 ELSE -1 ENDIF") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (name "nsv" "gsAccel(zero, vo3, rt, SGN*gsAccel!1)") (("2" (replace -1) (("2" (name-replace "FinVect" "gsAccel(nsv`1, nsv`2, rta - rt, 0)") (("2" (expand "gsAccel") (("2" (case-replace "(gs(vo3)=0)=FALSE") (("1" (expand "trk") (("1" (lift-if -2) (("1" (split -2) (("1" (flatten) (("1" (lemma "vectors_2D.norm_eq_0") (("1" (inst -1 "vect2(vo3)") (("1" (flatten) (("1" (expand "gs") (("1" (split -2) (("1" (propax) nil nil) ("2" (expand "zero") (("2" (decompose-equality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "mkTrkGsVs") (("2" (rewrite "sin_track") (("2" (rewrite "cos_track") (("2" (expand "vect2") (("2" (expand "vs") (("2" (expand "gs" -1) (("2" (expand "vect2") (("2" (simplify -1) (("2" (case "norm((# x := vo3`x, y := vo3`y #)) *
                                                                                  (vo3`x / norm((# x := vo3`x, y := vo3`y #))) = vo3`x") (("1" (replace -1) (("1" (case-replace "vo3`y / norm((# x := vo3`x, y := vo3`y #)) *
                                                                            norm((# x := vo3`x, y := vo3`y #)) = vo3`y") (("1" (expand "gsAccelPos") (("1" (expand "zero") (("1" (expand "vect2") (("1" (expand "Hat") (("1" (hide (-1 -2)) (("1" (case-replace "(norm((# x := vo3`x, y := vo3`y #)) = 0) = FALSE") (("1" (hide -1) (("1" (expand "Vect2") (("1" (expand "+") (("1" (expand "Vect3") (("1" (expand "*") (("1" (case-replace "norm((# x := vo3`x, y := vo3`y #)) *
                                                                                     (vo3`x / norm((# x := vo3`x, y := vo3`y #))) = vo3`x") (("1" (case-replace " norm((# x := vo3`x, y := vo3`y #)) *
                                                                                         (vo3`y / norm((# x := vo3`x, y := vo3`y #))) = vo3`y") (("1" (hide (-1 -2)) (("1" (expand "FinVect") (("1" (expand "gsAccel") (("1" (expand "gsAccelPos") (("1" (expand "Vect3") (("1" (name-replace "NRM" "norm((# x := vo3`x, y := vo3`y #))") (("1" (case-replace "vect2(nsv`1) = (1/2*rt*rt*SGN*gsAccel!1/NRM +rt)*vect2(vo3)") (("1" (case-replace "vect2(nsv`2) = (1+SGN*gsAccel!1*rt/NRM)*vect2(vo3)") (("1" (case-replace "rt=0") (("1" (lemma "root_eq_0") (("1" (inst -1 "a/2" "-a * rta " " dist - gs(vo3) * rta" "-sgn") (("1" (split -1) (("1" (flatten) (("1" (hide -1) (("1" (expand "rt" -2) (("1" (split -1) (("1" (flatten) (("1" (simplify 2) (("1" (case-replace "0/NRM = 0") (("1" (simplify 2) (("1" (expand "vect2") (("1" (expand "*") (("1" (simplify 2) (("1" (expand "Hat") (("1" (case-replace "(norm((# x := 1 * vo3`x,
                                                                                                                                                  y := 1 * vo3`y #))
                                                                                                                                           = 0) = FALSE") (("1" (expand "Vect2") (("1" (expand "+") (("1" (case-replace "(# x
                                                                                                                            := norm((# x := 1 * vo3`x, y := 1 * vo3`y #)) *
                                                                                                                                (1 * vo3`x /
                                                                                                                                  norm((# x := 1 * vo3`x, y := 1 * vo3`y #)))
                                                                                                                                * rta,
                                                                                                                          y
                                                                                                                            := norm((# x := 1 * vo3`x, y := 1 * vo3`y #)) *
                                                                                                                                (1 * vo3`y /
                                                                                                                                  norm((# x := 1 * vo3`x, y := 1 * vo3`y #)))
                                                                                                                                * rta #) = rta*vect2(vo3)") (("1" (rewrite "vectors_2D.norm_scal") (("1" (expand "gs") (("1" (case-replace "abs(rta) = rta") (("1" (ground) nil nil) ("2" (hide-all-but 1) (("2" (expand "abs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "vect2") (("2" (expand "*") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gs") (("2" (hide 4) (("2" (expand "vect2") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "sgn") (("2" (flatten) (("2" (lift-if) (("2" (split) (("1" (split) (("1" (propax) nil nil) ("2" (flatten) nil nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "SGN = sgn") (("1" (case-replace "sgn*gsAccel!1 = a") (("1" (hide -5) (("1" (case "1+a*rt/NRM = 0") (("1" (mult-by -1 "NRM") (("1" (simplify -1) (("1" (case-replace "a * rt / NRM * NRM = a*rt") (("1" (hide -1) (("1" (case-replace "NRM = gs(vo3)") (("1" (hide -1) (("1" (case-replace "rt = -gs(vo3)/a") (("1" (hide 3) (("1" (case "a>0") (("1" (case "rt<0") (("1" (replace -3) (("1" (ground) nil nil)) nil) ("2" (typepred ("gs(vo3)")) (("2" (div-by -1 "a") (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (lift-if -13) (("2" (split -13) (("1" (flatten) nil nil) ("2" (flatten) (("2" (case "min(rta, -gs(vo3)/a)<=-gs(vo3)/a") (("1" (split-ineq -1) nil nil) ("2" (hide-all-but 1) (("2" (expand "min") (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (cross-mult 1) (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (expand "gs") (("2" (expand "NRM") (("2" (expand "vect2") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil) ("2" (expand "Hat") (("2" (case-replace "(norm((1 + a * rt / NRM) * vect2(vo3)) = 0)=FALSE") (("1" (expand "Vect2") (("1" (case "1+a*rt/NRM>0") (("1" (rewrite "vectors_2D.norm_scal") (("1" (case-replace "abs((1 + a * rt / NRM)) = (1+a*rt/NRM)") (("1" (case-replace "(# x
                                                                                                                                           := ((1 + a * rt / NRM) * vect2(vo3))`x /
                                                                                                                                               ((1 + a * rt / NRM) * norm(vect2(vo3))),
                                                                                                                                         y
                                                                                                                                           := ((1 + a * rt / NRM) * vect2(vo3))`y /
                                                                                                                                               ((1 + a * rt / NRM) *
                                                                                                                                                 norm(vect2(vo3))) #) = (1/norm(vect2(vo3)))*vect2(vo3)") (("1" (case-replace "((1/2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt) *
                                                                                                                                         vect2(vo3)
                                                                                                                                         +
                                                                                                                                         ((1 + a * rt / NRM) * norm(vect2(vo3)) * rta -
                                                                                                                                           (1 + a * rt / NRM) * norm(vect2(vo3)) * rt)
                                                                                                                                          * ((1 / norm(vect2(vo3))) * vect2(vo3))) = ((1/2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt)
                                                                                                                                          + (1+a*rt/NRM)*(rta-rt))*vect2(vo3)") (("1" (case-replace "(# x
                                                                                                                                        := (((1 / 2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt) +
                                                                                                                                              (1 + a * rt / NRM) * (rta - rt))
                                                                                                                                             * vect2(vo3))`x,
                                                                                                                                      y
                                                                                                                                        := (((1 / 2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt) +
                                                                                                                                              (1 + a * rt / NRM) * (rta - rt))
                                                                                                                                             * vect2(vo3))`y #) = ((1 / 2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt) +
                                                                                                                                              (1 + a * rt / NRM) * (rta - rt))*vect2(vo3)") (("1" (lemma "quadratic_eq_0") (("1" (hide (-2 -3 -4)) (("1" (inst -1 "a / 2" " -a * rta" " dist - gs(vo3) * rta" "rt") (("1" (flatten) (("1" (hide -1) (("1" (split -1) (("1" (rewrite "vectors_2D.norm_scal") (("1" (expand "vect2") (("1" (expand "NRM") (("1" (case-replace "norm((#x:=vo3`x, y:=vo3`y#))=gs(vo3)") (("1" (case-replace "1/2 * (gsAccel!1 * rt * rt * sgn) / gs(vo3) -
                                                                                                                                               a * rt / gs(vo3) * rt = -a/2*sq(rt)/gs(vo3)") (("1" (hide -1) (("1" (case "gs(vo3) = abs(gs(vo3))") (("1" (replace -1 5) (("1" (lemma "abs_mult") (("1" (inst -1 "-a / 2 * sq(rt) / abs(gs(vo3)) + a * rt / abs(gs(vo3)) * rta +
                                                                                                                                                       rta " " gs(vo3)") (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (hide -1) (("1" (case-replace "(-a / 2 * sq(rt) / gs(vo3) + a * rt / gs(vo3) * rta + rta) *
                                                                                                                                                       gs(vo3) = -a/2*sq(rt)+a*rt*rta+rta*gs(vo3)") (("1" (case "dist = -a / 2 * sq(rt) + a * rt * rta + rta * gs(vo3)") (("1" (typepred (dist)) (("1" (replace -3 -2) (("1" (case-replace "abs(-a / 2 * sq(rt) + a * rt * rta + rta * gs(vo3)) = -a / 2 * sq(rt) + a * rt * rta + rta * gs(vo3)") (("1" (ground) nil nil) ("2" (hide-all-but (-2 1)) (("2" (ground) (("2" (expand "abs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil) ("2" (hide-all-but 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "abs") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "a") (("2" (expand "sq") (("2" (expand "sgn") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gs") (("2" (expand "vect2") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (flatten) (("3" (hide-all-but (1 2)) (("3" (expand "rt") (("3" (expand "sgn") (("3" (lift-if) (("3" (split) (("1" (flatten) (("1" (split) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) nil nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "vect2") (("2" (expand "*") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "vect2") (("2" (expand "*") (("2" (ground) (("2" (expand "+") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 5) (("2" (expand "vect2") (("2" (expand "*") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (expand "gs") (("3" (ground) nil nil)) nil)) nil) ("2" (expand "abs") (("2" (hide 6) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flip-ineq 1) (("2" (mult-by -1 "NRM") (("2" (case-replace "NRM = gs(vo3)") (("1" (simplify -2) (("1" (case-replace " gs(vo3) * (a * rt / gs(vo3))= a*rt") (("1" (hide 4) (("1" (case "a>0") (("1" (case "rt<=-gs(vo3)/a") (("1" (case "-gs(vo3)/a<0") (("1" (ground) nil nil) ("2" (cross-mult 1) (("2" (ground) nil nil)) nil)) nil) ("2" (cross-mult 1) (("2" (ground) nil nil)) nil)) nil) ("2" (case "rt>=gs(vo3)/(-a)") (("1" (case-replace "gs(vo3)/(-a) = -gs(vo3)/a") (("1" (hide -1) (("1" (lift-if -16) (("1" (split -16) (("1" (flatten) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil) ("2" (flip-ineq 2) (("2" (cross-mult 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (expand "NRM") (("2" (expand "gs") (("2" (expand "vect2") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 5) (("2" (rewrite "vectors_2D.norm_scal") (("2" (simplify 1) (("2" (typepred ("gs(vo3)")) (("2" (simplify -7) (("2" (case "abs(1+a*rt/NRM) /= 0 ") (("1" (expand "gs") (("1" (real-props) nil nil)) nil) ("2" (expand "/=") (("2" (expand "abs") (("2" (lift-if -1) (("2" (split -1) (("1" (ground) nil nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "sgn") (("2" (expand "a") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "SGN") (("2" (replace -11 1) (("2" (simplify 1) (("2" (lift-if 1) (("2" (hide (-1 -2 -3)) (("2" (split 1) (("1" (flatten) (("1" (both-sides "-" " gs(vo3)" -1) (("1" (simplify -1) (("1" (expand "sgn") (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (lift-if -1) (("2" (flatten) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (typepred (gsAccel!1)) (("2" (case "rt>0") (("1" (mult-ineq -1 -3) (("1" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "sgn") (("2" (lift-if 1) (("2" (split 1) (("1" (lift-if 2) (("1" (split 2) (("1" (flatten) (("1" (both-sides "-" "gs(vo3)" 2) (("1" (simplify 2) (("1" (case "rt>0") (("1" (typepred (gsAccel!1)) (("1" (mult-ineq -2 -3) (("1" (ground) nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (lift-if 3) (("2" (split 3) (("1" (flatten) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vect2") (("2" (hide 3) (("2" (replace -2 :dir rl) (("2" (decompose-equality 1) (("1" (expand "*") (("1" (ground) nil nil)) nil) ("2" (expand "*") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "vect2") (("2" (expand "*") (("2" (split 1) (("1" (replace -1 :dir rl) (("1" (ground) nil nil)) nil) ("2" (replace -1 :dir rl) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gs") (("2" (expand "vect2") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred ("vo3")) (("2" (lemma "vectors_2D.norm_eq_0") (("2" (inst -1 "vect2(vo3)") (("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (expand "gs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) (("2" (split-ineq -1) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (flip-ineq 2) (("2" (hide-all-but (-1 -2 -6 1)) (("2" (name-replace "MIN" "IF a > 0 THEN rta ELSE min(rta, -gs(vo3) / a) ENDIF") (("2" (case "rt<=MIN") (("1" (ground) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (expand "min") (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gsAccelTime") (("2" (replace -4 1) (("2" (simplify 1) (("2" (case-replace "abs(-1 * (gsAccel!1 * rt * sgn)) = gsAccel!1*rt") (("1" (ground) nil nil) ("2" (typepred (gsAccel!1)) (("2" (hide (-4 -5 -6 -7 2 3)) (("2" (expand "abs") (("2" (expand "sgn") (("2" (grind) (("1" (split-ineq -4) (("1" (mult-by -2 "rt") (("1" (ground) nil nil)) nil)) nil) ("2" (mult-by -2 "rt") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "gsAccelToRTA_checks_TCC2") (("3" (inst -1 "vo3" " dist" " rta" " gsAccel!1" " gsTor") (("3" (reveal 1) (("3" (split -1) (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (expand "gsTor") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "dist/rta>=gs(vo3)") (("1" (case "a/2>=0") (("1" (cross-mult -2) (("1" (mult-by -2 "a/2") (("1" (ground) nil nil)) nil)) nil) ("2" (cross-mult 1) (("2" (expand "a") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (copy 1) (("2" (flip-ineq 1) (("2" (cross-mult -1) (("2" (case "-a/2>0") (("1" (mult-by -2 "-a/2") (("1" (ground) nil nil)) nil) ("2" (expand "a") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (cancel-by 1 "rta") nil nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (expand "sgn") (("2" (flatten) (("2" (lift-if 1) (("2" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (lift-if 3) (("2" (split 3) (("1" (flatten) nil nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "gsAccelToRTA_TCC1") (("2" (inst -1 "gs(vo3)" "dist" "rta" "gsAccel!1" "dist/rta") (("1" (inst -1 "sgn") (("1" (split -1) (("1" (inst -1 "a") (("1" (prop) (("1" (inst -1 "TorPos") (("1" (split -1) (("1" (inst -1 "a/2") (("1" (inst -1 "-a*rta") (("1" (inst -1 "dist - gs(vo3) * rta") nil nil)) nil)) nil) ("2" (propax) nil nil) ("3" (expand "TorPos") (("3" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "a") (("2" (expand "sgn") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "sgn") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "gs") (("2" (lemma "vectors_2D.norm_eq_0") (("2" (inst -1 "vect2(vo3)") (("2" (typepred (vo3)) (("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil) ("2" (expand "sgn") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nzhVect3 nonempty-type-eq-decl nil track_3D nil) (zero const-decl "Vector" vectors_2D vectors) (vect2 const-decl "Vect2" vect_3D_2D vectors) (Vect2 type-eq-decl nil vectors_2D_def vectors) (Vector type-eq-decl nil vectors_2D vectors) (Vect3 type-eq-decl nil vectors_3D_def vectors) (gs const-decl "nnreal" Velocity nil) (Velocity type-eq-decl nil Velocity nil) (norm const-decl "nnreal" vectors_2D vectors) (Vector type-eq-decl nil vectors_3D vectors) (zero const-decl "Vector" vectors_3D vectors) (discr const-decl "real" quadratic reals) (Sign type-eq-decl nil sign reals) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (sin_track formula-decl nil track nil) (+ const-decl "Vector" vectors_2D vectors) (* const-decl "Vector" vectors_2D vectors) (* const-decl "real" vectors_2D vectors) (sqv const-decl "nnreal" vectors_2D vectors) (sq const-decl "nonneg_real" sq reals) (quadratic_eq_0 formula-decl nil quadratic reals) (scal_0 formula-decl nil vectors_2D vectors) (root_eq_0 formula-decl nil quadratic reals) (norm_scal formula-decl nil vectors_2D vectors) (Vect3 const-decl "{vv: Vect3 | vect2(vv) = w AND vv`z = z}" util nil) (Vect2 const-decl "{vv: Vect2 | vv`x = x AND vv`y = y}" util nil) (Hat const-decl "{v: Vect2 |
   (v = zero IFF w = zero) AND
    (w /= zero IFF (norm(v) = 1 AND v = (1 / norm(w)) * w))}" util nil) (vs const-decl "real" Velocity nil) (cos_track formula-decl nil track nil) (mkTrkGsVs const-decl "Velocity" Velocity nil) (cos_range application-judgement "real_abs_le1" sincos trig) (sin_range application-judgement "real_abs_le1" sincos trig) (norm_eq_0 formula-decl nil vectors_2D vectors) (trk const-decl "nnreal_lt_2pi" track nil) (root const-decl "real" quadratic reals) (roots_ge_0 formula-decl nil quadratic reals) (gsAccelToRTA_possible const-decl "[bool, nnreal]" gsAccel nil)) nil) (gsAccelToRTA_checks-2 nil 3708426876 ("" (skeep) (("" (skoletin) (("" (flatten) (("" (expand "gsAccelToRTA") (("" (name-replace "a" "IF dist / rta >= gs(vo3) THEN 1 ELSE -1 ENDIF *
                           gsAccel!1") (("" (name-replace "sgn" "IF dist/rta>=gs(vo3) THEN 1 ELSE -1 ENDIF") (("" (case-replace "IF dist / rta >= gs(vo3) THEN -1 ELSE --1 ENDIF = -sgn") (("1" (lift-if -2) (("1" (split -2) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (name-replace "TorPos" "gsAccelToRTA_possible(gs(vo3), rta, dist, a)") (("1" (hide -4) (("1" (hide 1) (("1" (case "discr(a/2, -a * rta, dist - gs(vo3) * rta)>=0") (("1" (lemma "roots_ge_0") (("1" (inst -1 "a/2" "-a*rta" "dist-gs(vo3)*rta" "sgn") (("1" (split -1) (("1" (flatten) (("1" (hide -2) (("1" (split -1) (("1" (name-replace "rt" "root(a / 2, -a * rta, dist - gs(vo3) * rta, -sgn)") (("1" (flatten) (("1" (hide -2) (("1" (case "rt = gsAccelTime(vo3, gsTor`1, gsAccel!1)") (("1" (expand "gsAccelUntil") (("1" (expand "TorPos" -4) (("1" (expand "gsAccelToRTA_possible") (("1" (case "IF a > 0 THEN rta ELSE min(rta, -gs(vo3) / a) ENDIF <= rta") (("1" (replace -2 :dir rl) (("1" (case "rt<rta") (("1" (name-replace "SGN" "IF gsTor`1 >= gs(vo3) THEN 1 ELSE -1 ENDIF") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (ground) nil))) ("2" (flatten) (("2" (hide 1) (("2" (name "nsv" "gsAccel(zero, vo3, rt, SGN*gsAccel!1)") (("2" (replace -1) (("2" (name-replace "FinVect" "gsAccel(nsv`1, nsv`2, rta - rt, 0)") (("2" (expand "gsAccel") (("2" (case-replace "(gs(vo3)=0)=FALSE") (("1" (expand "trk") (("1" (lift-if -2) (("1" (split -2) (("1" (flatten) (("1" (lemma "vectors_2D.norm_eq_0") (("1" (inst -1 "vect2(vo3)") (("1" (flatten) (("1" (expand "gs") (("1" (split -2) (("1" (propax) nil) ("2" (expand "zero") (("2" (decompose-equality 1) nil))))))))))))))) ("2" (flatten) (("2" (expand "mkTrkGsVs") (("2" (rewrite "track_sin_track") (("2" (rewrite "track.cos_track") (("2" (expand "vect2") (("2" (expand "vs") (("2" (expand "gs" -1) (("2" (expand "vect2") (("2" (simplify -1) (("2" (case "norm((# x := vo3`x, y := vo3`y #)) *
                                                 (vo3`x / norm((# x := vo3`x, y := vo3`y #))) = vo3`x") (("1" (replace -1) (("1" (case-replace "vo3`y / norm((# x := vo3`x, y := vo3`y #)) *
                                              norm((# x := vo3`x, y := vo3`y #)) = vo3`y") (("1" (expand "gsAccelPos") (("1" (expand "zero") (("1" (expand "vect2") (("1" (expand "Hat") (("1" (hide (-1 -2)) (("1" (case-replace "(norm((# x := vo3`x, y := vo3`y #)) = 0) = FALSE") (("1" (hide -1) (("1" (expand "Vect2") (("1" (expand "+") (("1" (expand "Vect3") (("1" (expand "*") (("1" (case-replace "norm((# x := vo3`x, y := vo3`y #)) *
                                                   (vo3`x / norm((# x := vo3`x, y := vo3`y #))) = vo3`x") (("1" (case-replace " norm((# x := vo3`x, y := vo3`y #)) *
                                                     (vo3`y / norm((# x := vo3`x, y := vo3`y #))) = vo3`y") (("1" (hide (-1 -2)) (("1" (expand "FinVect") (("1" (expand "gsAccel") (("1" (expand "gsAccelPos") (("1" (expand "Vect3") (("1" (name-replace "NRM" "norm((# x := vo3`x, y := vo3`y #))") (("1" (case-replace "vect2(nsv`1) = (1/2*rt*rt*SGN*gsAccel!1/NRM +rt)*vect2(vo3)") (("1" (case-replace "vect2(nsv`2) = (1+SGN*gsAccel!1*rt/NRM)*vect2(vo3)") (("1" (case-replace "rt=0") (("1" (lemma "root_eq_0") (("1" (inst -1 "a/2" "-a * rta " " dist - gs(vo3) * rta" "-sgn") (("1" (split -1) (("1" (flatten) (("1" (hide -1) (("1" (expand "rt" -2) (("1" (split -1) (("1" (flatten) (("1" (simplify 2) (("1" (case-replace "0/NRM = 0") (("1" (simplify 2) (("1" (expand "vect2") (("1" (expand "*") (("1" (simplify 2) (("1" (expand "Hat") (("1" (case-replace "(norm((# x := 1 * vo3`x,
                                                                                              y := 1 * vo3`y #))
                                                                                       = 0) = FALSE") (("1" (expand "Vect2") (("1" (expand "+") (("1" (case-replace "(# x
                                                                      := norm((# x := 1 * vo3`x, y := 1 * vo3`y #)) *
                                                                          (1 * vo3`x /
                                                                            norm((# x := 1 * vo3`x, y := 1 * vo3`y #)))
                                                                          * rta,
                                                                    y
                                                                      := norm((# x := 1 * vo3`x, y := 1 * vo3`y #)) *
                                                                          (1 * vo3`y /
                                                                            norm((# x := 1 * vo3`x, y := 1 * vo3`y #)))
                                                                          * rta #) = rta*vect2(vo3)") (("1" (rewrite "vectors_2D.norm_scal") (("1" (expand "gs") (("1" (case-replace "abs(rta) = rta") (("1" (ground) nil) ("2" (hide-all-but 1) (("2" (expand "abs") (("2" (propax) nil))))))))))) ("2" (hide 3) (("2" (expand "vect2") (("2" (expand "*") (("2" (propax) nil))))))))))))) ("2" (expand "gs") (("2" (hide 4) (("2" (expand "vect2") (("2" (ground) nil))))))))))))))))))) ("2" (ground) nil))))))) ("2" (propax) nil))))))))) ("2" (propax) nil))) ("2" (hide-all-but 1) (("2" (expand "sgn") (("2" (flatten) (("2" (lift-if) (("2" (split) (("1" (split) (("1" (propax) nil) ("2" (flatten) nil))) ("2" (flatten) (("2" (ground) nil))))))))))))))))) ("2" (case-replace "SGN = sgn") (("1" (case-replace "sgn*gsAccel!1 = a") (("1" (hide -5) (("1" (case "1+a*rt/NRM = 0") (("1" (mult-by -1 "NRM") (("1" (simplify -1) (("1" (case-replace "a * rt / NRM * NRM = a*rt") (("1" (hide -1) (("1" (case-replace "NRM = gs(vo3)") (("1" (hide -1) (("1" (case-replace "rt = -gs(vo3)/a") (("1" (hide 3) (("1" (case "a>0") (("1" (case "rt<0") (("1" (replace -3) (("1" (ground) nil))) ("2" (typepred ("gs(vo3)")) (("2" (div-by -1 "a") (("2" (ground) nil))))))) ("2" (lift-if -13) (("2" (split -13) (("1" (flatten) nil) ("2" (flatten) (("2" (case "min(rta, -gs(vo3)/a)<=-gs(vo3)/a") (("1" (split-ineq -1) nil) ("2" (hide-all-but 1) (("2" (expand "min") (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (ground) nil))) ("2" (ground) nil))))))))))))))))))))) ("2" (cross-mult 1) (("2" (ground) nil))))))) ("2" (expand "gs") (("2" (expand "NRM") (("2" (expand "vect2") (("2" (propax) nil))))))))))) ("2" (ground) nil))))))) ("2" (expand "Hat") (("2" (case-replace "(norm((1 + a * rt / NRM) * vect2(vo3)) = 0)=FALSE") (("1" (expand "Vect2") (("1" (case "1+a*rt/NRM>0") (("1" (rewrite "vectors_2D.norm_scal") (("1" (case-replace "abs((1 + a * rt / NRM)) = (1+a*rt/NRM)") (("1" (case-replace "(# x
                                                                                   := ((1 + a * rt / NRM) * vect2(vo3))`x /
                                                                                       ((1 + a * rt / NRM) * norm(vect2(vo3))),
                                                                                 y
                                                                                   := ((1 + a * rt / NRM) * vect2(vo3))`y /
                                                                                       ((1 + a * rt / NRM) *
                                                                                         norm(vect2(vo3))) #) = (1/norm(vect2(vo3)))*vect2(vo3)") (("1" (case-replace "((1/2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt) *
                                                                               vect2(vo3)
                                                                               +
                                                                               ((1 + a * rt / NRM) * norm(vect2(vo3)) * rta -
                                                                                 (1 + a * rt / NRM) * norm(vect2(vo3)) * rt)
                                                                                * ((1 / norm(vect2(vo3))) * vect2(vo3))) = ((1/2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt)
                                                                                + (1+a*rt/NRM)*(rta-rt))*vect2(vo3)") (("1" (case-replace "(# x
                                                                            := (((1 / 2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt) +
                                                                                  (1 + a * rt / NRM) * (rta - rt))
                                                                                 * vect2(vo3))`x,
                                                                          y
                                                                            := (((1 / 2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt) +
                                                                                  (1 + a * rt / NRM) * (rta - rt))
                                                                                 * vect2(vo3))`y #) = ((1 / 2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt) +
                                                                                  (1 + a * rt / NRM) * (rta - rt))*vect2(vo3)") (("1" (lemma "quadratic_eq_0") (("1" (hide (-2 -3 -4)) (("1" (inst -1 "a / 2" " -a * rta" " dist - gs(vo3) * rta" "rt") (("1" (flatten) (("1" (hide -1) (("1" (split -1) (("1" (rewrite "vectors_2D.norm_scal") (("1" (expand "vect2") (("1" (expand "NRM") (("1" (case-replace "norm((#x:=vo3`x, y:=vo3`y#))=gs(vo3)") (("1" (case-replace "1/2 * (gsAccel!1 * rt * rt * sgn) / gs(vo3) -
                                                                             a * rt / gs(vo3) * rt = -a/2*sq(rt)/gs(vo3)") (("1" (hide -1) (("1" (case "gs(vo3) = abs(gs(vo3))") (("1" (replace -1 5) (("1" (lemma "abs_mult") (("1" (inst -1 "-a / 2 * sq(rt) / abs(gs(vo3)) + a * rt / abs(gs(vo3)) * rta +
                                                                                 rta " " gs(vo3)") (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (hide -1) (("1" (case-replace "(-a / 2 * sq(rt) / gs(vo3) + a * rt / gs(vo3) * rta + rta) *
                                                                                 gs(vo3) = -a/2*sq(rt)+a*rt*rta+rta*gs(vo3)") (("1" (case "dist = -a / 2 * sq(rt) + a * rt * rta + rta * gs(vo3)") (("1" (typepred (dist)) (("1" (replace -3 -2) (("1" (case-replace "abs(-a / 2 * sq(rt) + a * rt * rta + rta * gs(vo3)) = -a / 2 * sq(rt) + a * rt * rta + rta * gs(vo3)") (("1" (ground) nil) ("2" (hide-all-but (-2 1)) (("2" (ground) (("2" (expand "abs") (("2" (propax) nil))))))))))))) ("2" (ground) nil))) ("2" (hide-all-but 1) (("2" (ground) nil))))))))))))))))) ("2" (expand "abs") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil))) ("2" (propax) nil))))))))))) ("2" (hide-all-but 1) (("2" (expand "a") (("2" (expand "sq") (("2" (expand "sgn") (("2" (grind) nil))))))))))) ("2" (expand "gs") (("2" (expand "vect2") (("2" (propax) nil))))))))))))) ("2" (propax) nil) ("3" (flatten) (("3" (hide-all-but (1 2)) (("3" (expand "rt") (("3" (expand "sgn") (("3" (lift-if) (("3" (split) (("1" (flatten) (("1" (split) (("1" (flatten) (("1" (ground) nil))) ("2" (flatten) nil))))) ("2" (flatten) (("2" (split) (("1" (flatten) nil) ("2" (flatten) (("2" (ground) nil))))))))))))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (expand "vect2") (("2" (expand "*") (("2" (propax) nil))))))))) ("2" (hide-all-but 1) (("2" (expand "vect2") (("2" (expand "*") (("2" (ground) (("2" (expand "+") (("2" (propax) nil))))))))))))) ("2" (hide 5) (("2" (expand "vect2") (("2" (expand "*") (("2" (propax) nil))))))) ("3" (expand "gs") (("3" (ground) nil))))) ("2" (expand "abs") (("2" (hide 6) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil))) ("2" (propax) nil))))))))))))) ("2" (flip-ineq 1) (("2" (mult-by -1 "NRM") (("2" (case-replace "NRM = gs(vo3)") (("1" (simplify -2) (("1" (case-replace " gs(vo3) * (a * rt / gs(vo3))= a*rt") (("1" (hide 4) (("1" (case "a>0") (("1" (case "rt<=-gs(vo3)/a") (("1" (case "-gs(vo3)/a<0") (("1" (ground) nil) ("2" (cross-mult 1) (("2" (ground) nil))))) ("2" (cross-mult 1) (("2" (ground) nil))))) ("2" (case "rt>=gs(vo3)/(-a)") (("1" (case-replace "gs(vo3)/(-a) = -gs(vo3)/a") (("1" (hide -1) (("1" (lift-if -16) (("1" (split -16) (("1" (flatten) nil) ("2" (ground) nil))))))) ("2" (ground) nil))) ("2" (flip-ineq 2) (("2" (cross-mult 1) (("2" (ground) nil))))))))))) ("2" (hide-all-but 1) (("2" (ground) nil))))))) ("2" (expand "NRM") (("2" (expand "gs") (("2" (expand "vect2") (("2" (propax) nil))))))))))))))))) ("2" (hide 5) (("2" (rewrite "vectors_2D.norm_scal") (("2" (simplify 1) (("2" (typepred ("gs(vo3)")) (("2" (simplify -7) (("2" (case "abs(1+a*rt/NRM) /= 0 ") (("1" (expand "gs") (("1" (real-props) nil))) ("2" (expand "/=") (("2" (expand "abs") (("2" (lift-if -1) (("2" (split -1) (("1" (ground) nil) ("2" (flatten) nil))))))))))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (expand "sgn") (("2" (expand "a") (("2" (propax) nil))))))))) ("2" (hide 4) (("2" (expand "SGN") (("2" (replace -11 1) (("2" (simplify 1) (("2" (lift-if 1) (("2" (hide (-1 -2 -3)) (("2" (split 1) (("1" (flatten) (("1" (both-sides "-" " gs(vo3)" -1) (("1" (simplify -1) (("1" (expand "sgn") (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil) ("2" (lift-if -1) (("2" (flatten) (("2" (split -1) (("1" (flatten) nil) ("2" (flatten) (("2" (typepred (gsAccel!1)) (("2" (case "rt>0") (("1" (mult-ineq -1 -3) (("1" (ground) nil))) ("2" (ground) nil))))))))))))))))))))))))) ("2" (flatten) (("2" (expand "sgn") (("2" (lift-if 1) (("2" (split 1) (("1" (lift-if 2) (("1" (split 2) (("1" (flatten) (("1" (both-sides "-" "gs(vo3)" 2) (("1" (simplify 2) (("1" (case "rt>0") (("1" (typepred (gsAccel!1)) (("1" (mult-ineq -2 -3) (("1" (ground) nil))))) ("2" (ground) nil))))))))) ("2" (propax) nil))))) ("2" (flatten) (("2" (lift-if 3) (("2" (split 3) (("1" (flatten) nil) ("2" (propax) nil))))))))))))))))))))))))))))))))) ("2" (expand "vect2") (("2" (hide 3) (("2" (replace -2 :dir rl) (("2" (decompose-equality 1) (("1" (expand "*") (("1" (ground) nil))) ("2" (expand "*") (("2" (ground) nil))))))))))))) ("2" (hide 3) (("2" (expand "vect2") (("2" (expand "*") (("2" (split 1) (("1" (replace -1 :dir rl) (("1" (ground) nil))) ("2" (replace -1 :dir rl) (("2" (ground) nil))))))))))))))))))))))))) ("2" (ground) nil))) ("2" (ground) nil))))))))))))) ("2" (expand "gs") (("2" (expand "vect2") (("2" (ground) nil))))))))))))))))) ("2" (ground) nil))))) ("2" (hide-all-but (-2 1)) (("2" (ground) nil))))))))))))))))))))))))))))) ("2" (typepred ("vo3")) (("2" (lemma "vectors_2D.norm_eq_0") (("2" (inst -1 "vect2(vo3)") (("2" (flatten) (("2" (split -1) (("1" (propax) nil) ("2" (expand "gs") (("2" (propax) nil))))))))))))))))))))))))))))))))) ("2" (ground) (("2" (split-ineq -1) (("1" (replace -1) (("1" (propax) nil))) ("2" (flip-ineq 2) (("2" (hide-all-but (-1 -2 -6 1)) (("2" (name-replace "MIN" "IF a > 0 THEN rta ELSE min(rta, -gs(vo3) / a) ENDIF") (("2" (case "rt<=MIN") (("1" (ground) nil) ("2" (ground) nil))))))))))))))))) ("2" (hide 2) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil))) ("2" (flatten) (("2" (expand "min") (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (ground) nil))) ("2" (flatten) (("2" (ground) nil))))))))))))))))))))))))) ("2" (expand "gsAccelTime") (("2" (replace -4 1) (("2" (simplify 1) (("2" (case-replace "abs(-1 * (gsAccel!1 * rt * sgn)) = gsAccel!1*rt") (("1" (ground) nil) ("2" (typepred (gsAccel!1)) (("2" (hide (-4 -5 -6 -7 2 3)) (("2" (expand "abs") (("2" (expand "sgn") (("2" (grind) (("1" (split-ineq -4) (("1" (mult-by -2 "rt") (("1" (ground) nil))))) ("2" (mult-by -2 "rt") (("2" (ground) nil))))))))))))))))))))) ("3" (lemma "gsAccelToRTA_checks_TCC2") (("3" (inst -1 "vo3" " dist" " rta" " gsAccel!1" " gsTor") (("3" (reveal 1) (("3" (split -1) (("1" (ground) nil) ("2" (ground) nil) ("3" (expand "gsTor") (("3" (propax) nil))))))))))))))))))) ("2" (case "dist/rta>=gs(vo3)") (("1" (case "a/2>=0") (("1" (cross-mult -2) (("1" (mult-by -2 "a/2") (("1" (ground) nil))))) ("2" (cross-mult 1) (("2" (expand "a") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil))) ("2" (flatten) nil))))))))))) ("2" (copy 1) (("2" (flip-ineq 1) (("2" (cross-mult -1) (("2" (case "-a/2>0") (("1" (mult-by -2 "-a/2") (("1" (ground) nil))) ("2" (expand "a") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) nil) ("2" (flatten) (("2" (ground) nil))))))))))))))))))) ("3" (cancel-by 1 "rta") nil))))))) ("2" (propax) nil))) ("2" (expand "sgn") (("2" (flatten) (("2" (lift-if 1) (("2" (split 1) (("1" (propax) nil) ("2" (flatten) (("2" (lift-if 3) (("2" (split 3) (("1" (flatten) nil) ("2" (flatten) (("2" (ground) nil))))))))))))))))))))) ("2" (lemma "gsAccelToRTA_TCC1") (("2" (inst -1 "gs(vo3)" "dist" "rta" "gsAccel!1" "dist/rta") (("1" (inst -1 "sgn") (("1" (split -1) (("1" (inst -1 "a") (("1" (prop) (("1" (inst -1 "TorPos") (("1" (split -1) (("1" (inst -1 "a/2") (("1" (inst -1 "-a*rta") (("1" (inst -1 "dist - gs(vo3) * rta") nil))))) ("2" (propax) nil) ("3" (expand "TorPos") (("3" (propax) nil))))))) ("2" (expand "a") (("2" (expand "sgn") (("2" (propax) nil))))))))) ("2" (expand "sgn") (("2" (propax) nil))))))) ("2" (expand "gs") (("2" (lemma "vectors_2D.norm_eq_0") (("2" (inst -1 "vect2(vo3)") (("2" (typepred (vo3)) (("2" (flatten) (("2" (split -1) (("1" (propax) nil) ("2" (ground) nil))))))))))))))))))))))))))) ("2" (flatten) nil))))) ("2" (flatten) nil))))) ("2" (expand "sgn") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil))) ("2" (propax) nil)))))))))))))))))))) nil) nil nil) (gsAccelToRTA_checks-1 nil 3616850121 ("" (skeep) (("" (skoletin) (("" (flatten) (("" (expand "gsAccelToRTA") (("" (name-replace "a" "IF dist / rta >= gs(vo3) THEN 1 ELSE -1 ENDIF *
                         gsAccel!1") (("" (name-replace "sgn" "IF dist/rta>=gs(vo3) THEN 1 ELSE -1 ENDIF") (("" (case-replace "IF dist / rta >= gs(vo3) THEN -1 ELSE --1 ENDIF = -sgn") (("1" (lift-if -2) (("1" (split -2) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (name-replace "TorPos" "gsAccelToRTA_possible(gs(vo3), rta, dist, a)") (("1" (hide -4) (("1" (hide 1) (("1" (case "discr(a/2, -a * rta, dist - gs(vo3) * rta)>=0") (("1" (lemma "roots_ge_0") (("1" (inst -1 "a/2" "-a*rta" "dist-gs(vo3)*rta" "sgn") (("1" (split -1) (("1" (flatten) (("1" (hide -2) (("1" (split -1) (("1" (name-replace "rt" "root(a / 2, -a * rta, dist - gs(vo3) * rta, -sgn)") (("1" (flatten) (("1" (hide -2) (("1" (case "rt = gsAccelTime(vo3, gsTor`1, gsAccel!1)") (("1" (expand "gsAccelUntil") (("1" (expand "TorPos" -4) (("1" (expand "gsAccelToRTA_possible") (("1" (case "IF a > 0 THEN rta ELSE min(rta, -gs(vo3) / a) ENDIF <= rta") (("1" (replace -2 :dir rl) (("1" (case "rt<rta") (("1" (name-replace "SGN" "IF gsTor`1 >= gs(vo3) THEN 1 ELSE -1 ENDIF") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (name "nsv" "gsAccel(zero, vo3, rt, SGN*gsAccel!1)") (("2" (replace -1) (("2" (name-replace "FinVect" "gsAccel(nsv`1, nsv`2, rta - rt, 0)") (("2" (expand "gsAccel") (("2" (case-replace "(gs(vo3)=0)=FALSE") (("1" (expand "trk") (("1" (lift-if -2) (("1" (split -2) (("1" (flatten) (("1" (lemma "vectors_2D.norm_eq_0") (("1" (inst -1 "vect2(vo3)") (("1" (flatten) (("1" (expand "gs") (("1" (split -2) (("1" (propax) nil nil) ("2" (expand "zero") (("2" (decompose-equality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "mkTrkGsVs") (("2" (rewrite "sin_track") (("2" (rewrite "cos_track") (("2" (expand "vect2") (("2" (expand "vs") (("2" (expand "gs" -1) (("2" (expand "vect2") (("2" (simplify -1) (("2" (case "norm((# x := vo3`x, y := vo3`y #)) *
                (vo3`x / norm((# x := vo3`x, y := vo3`y #))) = vo3`x") (("1" (replace -1) (("1" (case-replace "vo3`y / norm((# x := vo3`x, y := vo3`y #)) *
                norm((# x := vo3`x, y := vo3`y #)) = vo3`y") (("1" (expand "gsAccelPos") (("1" (expand "zero") (("1" (expand "vect2") (("1" (expand "Hat") (("1" (hide (-1 -2)) (("1" (case-replace "(norm((# x := vo3`x, y := vo3`y #)) = 0) = FALSE") (("1" (hide -1) (("1" (expand "Vect2") (("1" (expand "+
") (("1" (expand "Vect3") (("1" (expand "*") (("1" (case-replace "norm((# x := vo3`x, y := vo3`y #)) *
                 (vo3`x / norm((# x := vo3`x, y := vo3`y #))) = vo3`x") (("1" (case-replace " norm((# x := vo3`x, y := vo3`y #)) *
                 (vo3`y / norm((# x := vo3`x, y := vo3`y #))) = vo3`y") (("1" (hide (-1 -2)) (("1" (expand "FinVect") (("1" (expand "gsAccel") (("1" (expand "gsAccelPos") (("1" (expand "Vect3") (("1" (name-replace "NRM" "norm((# x := vo3`x, y := vo3`y #))") (("1" (case-replace "vect2(nsv`1) = (1/2*rt*rt*SGN*gsAccel!1/NRM +rt)*vect2(vo3)") (("1" (case-replace "vect2(nsv`2) = (1+SGN*gsAccel!1*rt/NRM)*vect2(vo3)") (("1" (case-replace "rt=0") (("1" (lemma "root_eq_0") (("1" (inst -1 "a/2" "-a * rta " " dist - gs(vo3) * rta" "-sgn") (("1" (split -1) (("1" (flatten) (("1" (hide -1) (("1" (expand "rt" -2) (("1" (split -1) (("1" (flatten) (("1" (simplify 2) (("1" (case-replace "0/NRM = 0") (("1" (simplify 2) (("1" (expand "vect2") (("1" (expand "*") (("1" (simplify 2) (("1" (expand "Hat") (("1" (case-replace "(norm((# x := 1 * vo3`x,
                                          y := 1 * vo3`y #))
                                   = 0) = FALSE") (("1" (expand "Vect2") (("1" (expand "+
") (("1" (case-replace "(# x
                := norm((# x := 1 * vo3`x, y := 1 * vo3`y #)) *
                    (1 * vo3`x /
                      norm((# x := 1 * vo3`x, y := 1 * vo3`y #)))
                    * rta,
              y
                := norm((# x := 1 * vo3`x, y := 1 * vo3`y #)) *
                    (1 * vo3`y /
                      norm((# x := 1 * vo3`x, y := 1 * vo3`y #)))
                    * rta #) = rta*vect2(vo3)") (("1" (rewrite "vectors_2D.norm_scal") (("1" (expand "gs") (("1" (case-replace "abs(rta) = rta") (("1" (ground) nil nil) ("2" (hide-all-but 1) (("2" (expand "abs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "vect2") (("2" (expand "*") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gs") (("2" (hide 4) (("2" (expand "vect2") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "sgn") (("2" (flatten) (("2" (lift-if) (("2" (split) (("1" (split) (("1" (propax) nil nil) ("2" (flatten) nil nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "SGN = sgn") (("1" (case-replace "sgn*gsAccel!1 = a") (("1" (hide -5) (("1" (case "1+a*rt/NRM = 0") (("1" (mult-by -1 "NRM") (("1" (simplify -1) (("1" (case-replace "a * rt / NRM * NRM = a*rt") (("1" (hide -1) (("1" (case-replace "NRM = gs(vo3)") (("1" (hide -1) (("1" (case-replace "rt = -gs(vo3)/a") (("1" (hide 3) (("1" (case "a>0") (("1" (case "rt<0") (("1" (replace -3) (("1" (ground) nil nil)) nil) ("2" (typepred ("gs(vo3)")) (("2" (div-by -1 "a") (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (lift-if -13) (("2" (split -13) (("1" (flatten) nil nil) ("2" (flatten) (("2" (case "min(rta, -gs(vo3)/a)<=-gs(vo3)/a") (("1" (split-ineq -1) nil nil) ("2" (hide-all-but 1) (("2" (expand "min") (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (cross-mult 1) (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (expand "gs") (("2" (expand "NRM") (("2" (expand "vect2") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil) ("2" (expand "Hat") (("2" (case-replace "(norm((1 + a * rt / NRM) * vect2(vo3)) = 0)=FALSE") (("1" (expand "Vect2") (("1" (case "1+a*rt/NRM>0") (("1" (rewrite "vectors_2D.norm_scal") (("1" (case-replace "abs((1 + a * rt / NRM)) = (1+a*rt/NRM)") (("1" (case-replace "(# x
                           := ((1 + a * rt / NRM) * vect2(vo3))`x /
                               ((1 + a * rt / NRM) * norm(vect2(vo3))),
                         y
                           := ((1 + a * rt / NRM) * vect2(vo3))`y /
                               ((1 + a * rt / NRM) *
                                 norm(vect2(vo3))) #) = (1/norm(vect2(vo3)))*vect2(vo3)") (("1" (case-replace "((1/2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt) *
                     vect2(vo3)
                     +
                     ((1 + a * rt / NRM) * norm(vect2(vo3)) * rta -
                       (1 + a * rt / NRM) * norm(vect2(vo3)) * rt)
                      * ((1 / norm(vect2(vo3))) * vect2(vo3))) = ((1/2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt)
                      + (1+a*rt/NRM)*(rta-rt))*vect2(vo3)") (("1" (case-replace "(# x
                := (((1 / 2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt) +
                      (1 + a * rt / NRM) * (rta - rt))
                     * vect2(vo3))`x,
              y
                := (((1 / 2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt) +
                      (1 + a * rt / NRM) * (rta - rt))
                     * vect2(vo3))`y #) = ((1 / 2 * (gsAccel!1 * rt * rt * sgn) / NRM + rt) +
                      (1 + a * rt / NRM) * (rta - rt))*vect2(vo3)") (("1" (lemma "quadratic_eq_0") (("1" (hide (-2 -3 -4)) (("1" (inst -1 "a / 2" " -a * rta" " dist - gs(vo3) * rta" "rt") (("1" (flatten) (("1" (hide -1) (("1" (split -1) (("1" (rewrite "vectors_2D.norm_scal") (("1" (expand "vect2") (("1" (expand "NRM") (("1" (case-replace "norm((#x:=vo3`x, y:=vo3`y#))=gs(vo3)") (("1" (case-replace "1/2 * (gsAccel!1 * rt * rt * sgn) / gs(vo3) -
           a * rt / gs(vo3) * rt = -a/2*sq(rt)/gs(vo3)") (("1" (hide -1) (("1" (case "gs(vo3) = abs(gs(vo3))") (("1" (replace -1 5) (("1" (lemma "abs_mult") (("1" (inst -1 "-a / 2 * sq(rt) / abs(gs(vo3)) + a * rt / abs(gs(vo3)) * rta +
           rta " " gs(vo3)") (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (hide -1) (("1" (case-replace "(-a / 2 * sq(rt) / gs(vo3) + a * rt / gs(vo3) * rta + rta) *
           gs(vo3) = -a/2*sq(rt)+a*rt*rta+rta*gs(vo3)") (("1" (case "dist = -a / 2 * sq(rt) + a * rt * rta + rta * gs(vo3)") (("1" (typepred (dist)) (("1" (replace -3 -2) (("1" (case-replace "abs(-a / 2 * sq(rt) + a * rt * rta + rta * gs(vo3)) = -a / 2 * sq(rt) + a * rt * rta + rta * gs(vo3)") (("1" (ground) nil nil) ("2" (hide-all-but (-2 1)) (("2" (ground) (("2" (expand "abs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil) ("2" (hide-all-but 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "abs") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "a") (("2" (expand "sq") (("2" (expand "sgn") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gs") (("2" (expand "vect2") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (flatten) (("3" (hide-all-but (1 2)) (("3" (expand "rt") (("3" (expand "sgn") (("3" (lift-if) (("3" (split) (("1" (flatten) (("1" (split) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) nil nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "vect2") (("2" (expand "*") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "vect2") (("2" (expand "*") (("2" (ground) (("2" (expand "+
") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 5) (("2" (expand "vect2") (("2" (expand "*") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (expand "gs") (("3" (ground) nil nil)) nil)) nil) ("2" (expand "abs") (("2" (hide 6) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flip-ineq 1) (("2" (mult-by -1 "NRM") (("2" (case-replace "NRM = gs(vo3)") (("1" (simplify -2) (("1" (case-replace " gs(vo3) * (a * rt / gs(vo3))= a*rt") (("1" (hide 4) (("1" (case "a>0") (("1" (case "rt<=-gs(vo3)/a") (("1" (case "-gs(vo3)/a<0") (("1" (ground) nil nil) ("2" (cross-mult 1) (("2" (ground) nil nil)) nil)) nil) ("2" (cross-mult 1) (("2" (ground) nil nil)) nil)) nil) ("2" (case "rt>=gs(vo3)/(-a)") (("1" (case-replace "gs(vo3)/(-a) = -gs(vo3)/a") (("1" (hide -1) (("1" (lift-if -16) (("1" (split -16) (("1" (flatten) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil) ("2" (flip-ineq 2) (("2" (cross-mult 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (expand "NRM") (("2" (expand "gs") (("2" (expand "vect2") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 5) (("2" (rewrite "vectors_2D.norm_scal") (("2" (simplify 1) (("2" (typepred ("gs(vo3)")) (("2" (simplify -7) (("2" (case "abs(1+a*rt/NRM) /= 0 ") (("1" (expand "gs") (("1" (real-props) nil nil)) nil) ("2" (expand "/=") (("2" (expand "abs") (("2" (lift-if -1) (("2" (split -1) (("1" (ground) nil nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "sgn") (("2" (expand "a") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "SGN") (("2" (replace -11 1) (("2" (simplify 1) (("2" (lift-if 1) (("2" (hide (-1 -2 -3)) (("2" (split 1) (("1" (flatten) (("1" (both-sides "-" " gs(vo3)" -1) (("1" (simplify -1) (("1" (expand "sgn") (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (lift-if -1) (("2" (flatten) (("2" (split -1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (typepred (gsAccel!1)) (("2" (case "rt>0") (("1" (mult-ineq -1 -3) (("1" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "sgn") (("2" (lift-if 1) (("2" (split 1) (("1" (lift-if 2) (("1" (split 2) (("1" (flatten) (("1" (both-sides "-" "gs(vo3)" 2) (("1" (simplify 2) (("1" (case "rt>0") (("1" (typepred (gsAccel!1)) (("1" (mult-ineq -2 -3) (("1" (ground) nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (lift-if 3) (("2" (split 3) (("1" (flatten) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vect2") (("2" (hide 3) (("2" (replace -2 :dir rl) (("2" (decompose-equality 1) (("1" (expand "*") (("1" (ground) nil nil)) nil) ("2" (expand "*") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "vect2") (("2" (expand "*") (("2" (split 1) (("1" (replace -1 :dir rl) (("1" (ground) nil nil)) nil) ("2" (replace -1 :dir rl) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gs") (("2" (expand "vect2") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred ("vo3")) (("2" (lemma "vectors_2D.norm_eq_0") (("2" (inst -1 "vect2(vo3)") (("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (expand "gs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) (("2" (split-ineq -1) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (flip-ineq 2) (("2" (hide-all-but (-1 -2 -6 1)) (("2" (name-replace "MIN" "IF a > 0 THEN rta ELSE min(rta, -gs(vo3) / a) ENDIF") (("2" (case "rt<=MIN") (("1" (ground) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (expand "min") (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gsAccelTime") (("2" (replace -4 1) (("2" (simplify 1) (("2" (case-replace "abs(-1 * (gsAccel!1 * rt * sgn)) = gsAccel!1*rt") (("1" (ground) nil nil) ("2" (typepred (gsAccel!1)) (("2" (hide (-4 -5 -6 -7 2 3)) (("2" (expand "abs") (("2" (expand "sgn") (("2" (grind) (("1" (split-ineq -4) (("1" (mult-by -2 "rt") (("1" (ground) nil nil)) nil)) nil) ("2" (mult-by -2 "rt") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "gsAccelToRTA_checks_TCC2") (("3" (inst -1 "vo3" " dist" " rta" " gsAccel!1" " gsTor") (("3" (reveal 1) (("3" (split -1) (("1" (ground) nil nil) ("2" (ground) nil nil) ("3" (expand "gsTor") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "dist/rta>=gs(vo3)") (("1" (case "a/2>=0") (("1" (cross-mult -2) (("1" (mult-by -2 "a/2") (("1" (ground) nil nil)) nil)) nil) ("2" (cross-mult 1) (("2" (expand "a") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (copy 1) (("2" (flip-ineq 1) (("2" (cross-mult -1) (("2" (case "-a/2>0") (("1" (mult-by -2 "-a/2") (("1" (ground) nil nil)) nil) ("2" (expand "a") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) nil nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (cancel-by 1 "rta") nil nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (expand "sgn") (("2" (flatten) (("2" (lift-if 1) (("2" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (lift-if 3) (("2" (split 3) (("1" (flatten) nil nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "gsAccelToRTA_TCC1") (("2" (inst -1 "gs(vo3)" "dist" "rta" "gsAccel!1" "dist/rta") (("1" (inst -1 "sgn") (("1" (split -1) (("1" (inst -1 "a") (("1" (prop) (("1" (inst -1 "TorPos") (("1" (split -1) (("1" (inst -1 "a/2") (("1" (inst -1 "-a*rta") (("1" (inst -1 "dist - gs(vo3) * rta") nil nil)) nil)) nil) ("2" (propax) nil nil) ("3" (expand "TorPos") (("3" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "a") (("2" (expand "sgn") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "sgn") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "gs") (("2" (lemma "vectors_2D.norm_eq_0") (("2" (inst -1 "vect2(vo3)") (("2" (typepred (vo3)) (("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil) ("2" (expand "sgn") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nzhVect3 nonempty-type-eq-decl nil track_3D nil) (zero const-decl "Vector" vectors_2D vectors) (vect2 const-decl "Vect2" vect_3D_2D vectors) (Vect2 type-eq-decl nil vectors_2D_def vectors) (Vector type-eq-decl nil vectors_2D vectors) (Vect3 type-eq-decl nil vectors_3D_def vectors) (norm const-decl "nnreal" vectors_2D vectors) (Vector type-eq-decl nil vectors_3D vectors) (zero const-decl "Vector" vectors_3D vectors) (discr const-decl "real" quadratic reals) (Sign type-eq-decl nil sign reals) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (sin_track formula-decl nil track nil) (+ const-decl "Vector" vectors_2D vectors) (* const-decl "Vector" vectors_2D vectors) (* const-decl "real" vectors_2D vectors) (sqv const-decl "nnreal" vectors_2D vectors) (sq const-decl "nonneg_real" sq reals) (quadratic_eq_0 formula-decl nil quadratic reals) (scal_0 formula-decl nil vectors_2D vectors) (root_eq_0 formula-decl nil quadratic reals) (norm_scal formula-decl nil vectors_2D vectors) (Vect3 const-decl "{vv: Vect3 | vect2(vv) = w AND vv`z = z}" util nil) (Vect2 const-decl "{vv: Vect2 | vv`x = x AND vv`y = y}" util nil) (Hat const-decl "{v: Vect2 |
   (v = zero IFF w = zero) AND
    (w /= zero IFF (norm(v) = 1 AND v = (1 / norm(w)) * w))}" util nil) (cos_track formula-decl nil track nil) (norm_eq_0 formula-decl nil vectors_2D vectors) (trk const-decl "nnreal_lt_2pi" track nil) (root const-decl "real" quadratic reals) (roots_ge_0 formula-decl nil quadratic reals) (gsAccelToRTA_possible const-decl "[bool, nnreal]" gsAccel nil)) shostak)))
