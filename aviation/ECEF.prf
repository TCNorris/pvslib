(ECEF (spherical2xyz_TCC1 0 (spherical2xyz_TCC1-3 "" 3790106417 ("" (skeep) (("" (name "theta" "pi/2-lat") (("" (name "phi" "pi-lon") (("" (name "xx" "r*sin(theta)*cos(phi)") (("" (name "yy" "r*sin(theta)*sin(phi)") (("" (name "zz" "r*cos(theta)") (("" (replace -4) (("" (replace -5) (("" (assert) (("" (replace -1) (("" (replace -3) (("" (replace -2) (("" (case "sq(xx) + sq(yy) + sq(zz) = sq(r)") (("1" (case "NOT (xx=0 AND yy = 0 AND zz=0)") (("1" (hide-all-but (-7 1)) (("1" (expand "zero") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (replace -2) (("2" (replace -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "sq(xx) + sq(yy) = sq(r*sin(theta))") (("1" (replace -1) (("1" (lemma "sin2_cos2") (("1" (inst - "theta") (("1" (mult-by -1 "sq(r)") (("1" (expand "zz" +) (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "xx") (("2" (expand "yy") (("2" (lemma "sin2_cos2") (("2" (inst - "phi") (("2" (mult-by -1 "sq(r*sin(theta))") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig) (cos const-decl "real" sincos_def trig) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (number_field nonempty-type-from-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_minus_real_is_real application-judgement "real" reals nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig) (real_times_real_is_real application-judgement "real" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (sin const-decl "real" sincos_def trig) (sin2_cos2 formula-decl nil sincos_def trig) (both_sides_times1_imp formula-decl nil extra_real_props nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (zz skolem-const-decl "real" ECEF nil) (xx skolem-const-decl "real" ECEF nil) (yy skolem-const-decl "real" ECEF nil) (NOT const-decl "[bool -> bool]" booleans nil) (zero const-decl "Vector" vectors_3D vectors) (sq_0 formula-decl nil sq reals) (sq const-decl "nonneg_real" sq reals) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (sq_nz_pos application-judgement "posreal" sq reals) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (sin_range application-judgement "real_abs_le1" sincos trig) (cos_range application-judgement "real_abs_le1" sincos trig)) shostak (spherical2xyz subtype "(# x := (LET theta = (number_fields.-)(number_fields./(pi_def.pi, 2), ECEF.lat), phi = (number_fields.-)(pi_def.pi, ECEF.lon), x = number_fields.*(number_fields.*(ECEF.r, sincos_def.sin(ECEF.theta)), sincos_def.cos(ECEF.phi)), y = number_fields.*(number_fields.*(ECEF.r, sincos_def.sin(ECEF.theta)), sincos_def.sin(ECEF.phi)), z = number_fields.*(ECEF.r, sincos_def.cos(ECEF.theta)) IN (ECEF.x, ECEF.y, ECEF.z))`1, y := (LET theta = (number_fields.-)(number_fields./(pi_def.pi, 2), ECEF.lat), phi = (number_fields.-)(pi_def.pi, ECEF.lon), x = number_fields.*(number_fields.*(ECEF.r, sincos_def.sin(ECEF.theta)), sincos_def.cos(ECEF.phi)), y = number_fields.*(number_fields.*(ECEF.r, sincos_def.sin(ECEF.theta)), sincos_def.sin(ECEF.phi)), z = number_fields.*(ECEF.r, sincos_def.cos(ECEF.theta)) IN (ECEF.x, ECEF.y, ECEF.z))`2, z := (LET theta = (number_fields.-)(number_fields./(pi_def.pi, 2), ECEF.lat), phi = (number_fields.-)(pi_def.pi, ECEF.lon), x = number_fields.*(number_fields.*(ECEF.r, sincos_def.sin(ECEF.theta)), sincos_def.cos(ECEF.phi)), y = number_fields.*(number_fields.*(ECEF.r, sincos_def.sin(ECEF.theta)), sincos_def.sin(ECEF.phi)), z = number_fields.*(ECEF.r, sincos_def.cos(ECEF.theta)) IN (ECEF.x, ECEF.y, ECEF.z))`3 #)" "Nz_vect3")) (spherical2xyz_TCC1-2 nil 3521211413 ("" (skeep) (("" (name "theta" "pi/2-lat") (("" (name "phi" "pi-lon") (("" (name "xx" "r*sin(theta)*cos(phi)") (("" (name "yy" "r*sin(theta)*sin(phi)") (("" (name "zz" "r*cos(theta)") (("" (replace -4) (("" (replace -5) (("" (assert) (("" (replace -1) (("" (replace -3) (("" (replace -2) (("" (case "sq(xx) + sq(yy) + sq(zz) = sq(r)") (("1" (case "NOT (xx=0 AND yy = 0 AND zz=0)") (("1" (hide-all-but (-7 1)) (("1" (expand "zero") (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (replace -2) (("2" (replace -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "sq(xx) + sq(yy) = sq(r*sin(theta))") (("1" (replace -1) (("1" (lemma "sin2_cos2") (("1" (inst - "theta") (("1" (mult-by -1 "sq(r)") (("1" (expand "zz" +) (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "xx") (("2" (expand "yy") (("2" (lemma "sin2_cos2") (("2" (inst - "phi") (("2" (mult-by -1 "sq(r*sin(theta))") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig) (cos const-decl "real" sincos_def trig) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (number_field nonempty-type-from-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_minus_real_is_real application-judgement "real" reals nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig) (real_times_real_is_real application-judgement "real" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (sin const-decl "real" sincos_def trig) (sin2_cos2 formula-decl nil sincos_def trig) (both_sides_times1_imp formula-decl nil extra_real_props nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) nil nil nil (NOT const-decl "[bool -> bool]" booleans nil) (zero const-decl "Vector" vectors_3D vectors) (sq_0 formula-decl nil sq reals) (sq const-decl "nonneg_real" sq reals) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (sq_nz_pos application-judgement "posreal" sq reals) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (sin_range application-judgement "real_abs_le1" sincos trig) (cos_range application-judgement "real_abs_le1" sincos trig)) nil (spherical2xyz subtype "(# x := (LET theta = (number_fields.-)(number_fields./(pi_def.pi, 2), ECEF.lat), phi = (number_fields.-)(pi_def.pi, ECEF.lon), x = number_fields.*(number_fields.*(ECEF.r, sincos_def.sin(ECEF.theta)), sincos_def.cos(ECEF.phi)), y = number_fields.*(number_fields.*(ECEF.r, sincos_def.sin(ECEF.theta)), sincos_def.sin(ECEF.phi)), z = number_fields.*(ECEF.r, sincos_def.cos(ECEF.theta)) IN (ECEF.x, ECEF.y, ECEF.z))`1, y := (LET theta = (number_fields.-)(number_fields./(pi_def.pi, 2), ECEF.lat), phi = (number_fields.-)(pi_def.pi, ECEF.lon), x = number_fields.*(number_fields.*(ECEF.r, sincos_def.sin(ECEF.theta)), sincos_def.cos(ECEF.phi)), y = number_fields.*(number_fields.*(ECEF.r, sincos_def.sin(ECEF.theta)), sincos_def.sin(ECEF.phi)), z = number_fields.*(ECEF.r, sincos_def.cos(ECEF.theta)) IN (ECEF.x, ECEF.y, ECEF.z))`2, z := (LET theta = (number_fields.-)(number_fields./(pi_def.pi, 2), ECEF.lat), phi = (number_fields.-)(pi_def.pi, ECEF.lon), x = number_fields.*(number_fields.*(ECEF.r, sincos_def.sin(ECEF.theta)), sincos_def.cos(ECEF.phi)), y = number_fields.*(number_fields.*(ECEF.r, sincos_def.sin(ECEF.theta)), sincos_def.sin(ECEF.phi)), z = number_fields.*(ECEF.r, sincos_def.cos(ECEF.theta)) IN (ECEF.x, ECEF.y, ECEF.z))`3 #)" "Nz_vect3")) (spherical2xyz_TCC1-1 nil 3521211363 ("" (subtype-tcc) nil nil) nil nil (spherical2xyz subtype "(# x := (LET theta = (number_fields.-)(number_fields./(pi_def.pi, 2), ECEF.lat), phi = (number_fields.-)(pi_def.pi, ECEF.lon), x = number_fields.*(number_fields.*(ECEF.r, sincos_def.sin(ECEF.theta)), sincos_def.cos(ECEF.phi)), y = number_fields.*(number_fields.*(ECEF.r, sincos_def.sin(ECEF.theta)), sincos_def.sin(ECEF.phi)), z = number_fields.*(ECEF.r, sincos_def.cos(ECEF.theta)) IN (ECEF.x, ECEF.y, ECEF.z))`1, y := (LET theta = (number_fields.-)(number_fields./(pi_def.pi, 2), ECEF.lat), phi = (number_fields.-)(pi_def.pi, ECEF.lon), x = number_fields.*(number_fields.*(ECEF.r, sincos_def.sin(ECEF.theta)), sincos_def.cos(ECEF.phi)), y = number_fields.*(number_fields.*(ECEF.r, sincos_def.sin(ECEF.theta)), sincos_def.sin(ECEF.phi)), z = number_fields.*(ECEF.r, sincos_def.cos(ECEF.theta)) IN (ECEF.x, ECEF.y, ECEF.z))`2, z := (LET theta = (number_fields.-)(number_fields./(pi_def.pi, 2), ECEF.lat), phi = (number_fields.-)(pi_def.pi, ECEF.lon), x = number_fields.*(number_fields.*(ECEF.r, sincos_def.sin(ECEF.theta)), sincos_def.cos(ECEF.phi)), y = number_fields.*(number_fields.*(ECEF.r, sincos_def.sin(ECEF.theta)), sincos_def.sin(ECEF.phi)), z = number_fields.*(ECEF.r, sincos_def.cos(ECEF.theta)) IN (ECEF.x, ECEF.y, ECEF.z))`3 #)" "Nz_vect3"))) (spherical2xyz_norm 0 (spherical2xyz_norm-1 nil 3521203582 ("" (skeep) (("" (skoletin 1) (("" (name "theta" "pi/2-lat") (("" (name "phi" "pi-lon") (("" (name "xx" "r*sin(theta)*cos(phi)") (("" (name "yy" "r*sin(theta)*sin(phi)") (("" (name "zz" "r*cos(theta)") (("" (case "vv = (xx,yy,zz)") (("1" (case "sq(xx) + sq(yy) = sq(r*sin(theta))") (("1" (case "sqv(vv) = sq(r)") (("1" (hide-all-but (-1 1)) (("1" (lemma "sqrt_eq") (("1" (inst?) (("1" (assert) (("1" (rewrite "sqrt_sqv_norm") nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case "sqv(vv) = sq(xx) + sq(yy) + sq(zz)") (("1" (replace -1) (("1" (hide -1) (("1" (replace -1) (("1" (hide -1) (("1" (replace -2 :dir rl) (("1" (hide-all-but 1) (("1" (lemma "sin2_cos2") (("1" (inst - "theta") (("1" (mult-by -1 "sq(r)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -2 +) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "xx") (("2" (expand "yy") (("2" (lemma "sin2_cos2") (("2" (inst - "phi") (("2" (mult-by -1 "sq(r*sin(theta))") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "vv") (("2" (expand "spherical2xyz") (("2" (expand "xx") (("2" (expand "yy") (("2" (expand "zz") (("2" (expand "theta") (("2" (expand "phi") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Vector type-eq-decl nil vectors_3D vectors) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (/= const-decl "boolean" notequal nil) (zero const-decl "Vector" vectors_3D vectors) (Nz_vect3 type-eq-decl nil vectors_3D vectors) (spherical2xyz const-decl "Nz_vect3" ECEF nil) (nz_norm_gt_0 application-judgement "posreal" vectors_3D vectors) (nnreal type-eq-decl nil real_types nil) (norm const-decl "nnreal" vectors_3D vectors) (yy skolem-const-decl "real" ECEF nil) (xx skolem-const-decl "real" ECEF nil) (nz_sqv_gt_0 application-judgement "posreal" vectors_3D vectors) (sq_nz_pos application-judgement "posreal" sq reals) (sqv const-decl "nnreal" vectors_3D vectors) (sqrt_eq formula-decl nil sqrt reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sqrt_pos application-judgement "posreal" sqrt reals) (sqrt_sq formula-decl nil sqrt reals) (sqrt_sqv_norm formula-decl nil vectors_3D vectors) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (sin2_cos2 formula-decl nil sincos_def trig) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (cos_range application-judgement "real_abs_le1" sincos trig) (sin_range application-judgement "real_abs_le1" sincos trig) (real_plus_real_is_real application-judgement "real" reals nil) (* const-decl "real" vectors_3D vectors) (sq const-decl "nonneg_real" sq reals) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (vv skolem-const-decl "Nz_vect3" ECEF nil) (zz skolem-const-decl "real" ECEF nil) (phi skolem-const-decl "real" ECEF nil) (theta skolem-const-decl "real" ECEF nil) (sin const-decl "real" sincos_def trig) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_times_real_is_real application-judgement "real" reals nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig) (cos const-decl "real" sincos_def trig) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_minus_real_is_real application-judgement "real" reals nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig)) shostak)) (sin_acos_ecef_TCC1 0 (sin_acos_ecef_TCC1-1 nil 3650987963 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) nil (sin_acos_ecef subtype "ECEF.sig" "real_abs_le1"))) (sin_acos_ecef_TCC2 0 (sin_acos_ecef_TCC2-1 nil 3650988130 ("" (skeep) (("" (typepred "sig") (("" (grind) (("1" (mult-ineq -2 -2) (("1" (assert) nil nil)) nil) ("2" (mult-ineq -1 -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (odd_times_odd_is_odd application-judgement "odd_int" integers nil) (le_times_le_any1 formula-decl nil extra_real_props nil) (minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (sq const-decl "nonneg_real" sq reals)) nil (sin_acos_ecef subtype "(number_fields.-)(1, sq.sq(ECEF.sig))" "nonneg_real"))) (sin_acos_ecef 0 (sin_acos_ecef-1 nil 3650987964 ("" (skeep) (("" (lemma "sin2_cos2") (("" (inst?) (("" (both-sides-f 1 "sq") (("1" (both-sides "-" "sq(cos(acos(sig)))" -1) (("1" (assert) (("1" (replaces -1) (("1" (rewrite "cos_acos") (("1" (rewrite "sq_sqrt") nil nil)) nil)) nil)) nil) ("2" (iff) (("2" (ground) nil nil)) nil)) nil) ("2" (case "FORALL (zz,qq:nnreal): sq(zz) = sq(qq) IMPLIES zz=qq") (("1" (invoke (inst - "%1" "%2") (! 1 1) (! 1 2)) (("1" (assert) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (assert) (("3" (lemma "sin_ge_0") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (case "sqrt(sq(zz)) = sqrt(sq(qq))") (("1" (assert) nil nil) ("2" (replaces -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sin2_cos2 formula-decl nil sincos_def trig) (real_minus_real_is_real application-judgement "real" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (sin_range application-judgement "real_abs_le1" sincos trig) (sq const-decl "nonneg_real" sq reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (sin const-decl "real" sincos_def trig) (cos_acos formula-decl nil trig_inverses trig) (sq_sqrt formula-decl nil sqrt reals) (cos_range application-judgement "real_abs_le1" sincos trig) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sqrt_sq formula-decl nil sqrt reals) (sig skolem-const-decl "{s: real | abs(s) <= 1}" ECEF nil) (sin_ge_0 formula-decl nil trig_ineq trig) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (acos const-decl "nnreal_le_pi" acos trig) (nnreal_le_pi nonempty-type-eq-decl nil trig_types trig) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (cos const-decl "real" sincos_def trig) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (real_abs_le1 nonempty-type-eq-decl nil trig_types trig) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (xyz2spherical_TCC1 0 (xyz2spherical_TCC1-1 nil 3650973818 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (xyz2spherical subtype "2" "{i: integers.int | booleans.OR(ECEF.x /= 0, reals.>=(i, 0))}"))) (xyz2spherical_TCC2 0 (xyz2spherical_TCC2-1 nil 3650973818 ("" (skeep) (("" (typepred "sq(x)") (("" (typepred "sq(y)") (("" (typepred "sq(z)") (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((sq const-decl "nonneg_real" sq reals) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil)) nil (xyz2spherical subtype "(number_fields.+)((number_fields.+)(exponentiation.^(ECEF.x, 2), exponentiation.^(ECEF.y, 2)), exponentiation.^(ECEF.z, 2))" "nonneg_real"))) (xyz2spherical_TCC3 0 (xyz2spherical_TCC3-1 nil 3650973818 ("" (subtype-tcc) nil nil) ((^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil (xyz2spherical subtype "2" "{i: integers.int | booleans.OR(ECEF.y /= 0, reals.>=(i, 0))}"))) (xyz2spherical_TCC4 0 (xyz2spherical_TCC4-1 nil 3650973818 ("" (skeep*) (("" (typepred "sq(x)") (("" (typepred "sq(y)") (("" (grind) nil nil)) nil)) nil)) nil) ((sq const-decl "nonneg_real" sq reals) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil (xyz2spherical subtype "(number_fields.+)(exponentiation.^(ECEF.x, 2), exponentiation.^(ECEF.y, 2))" "nonneg_real"))) (xyz2spherical_TCC5 0 (xyz2spherical_TCC5-1 nil 3650973818 ("" (skeep*) (("" (lemma "sq_eq_0") (("" (lemma "sqrt_pos") (("" (inst?) (("1" (assert) nil nil) ("2" (case "sq(x)+sq(y)+sq(z)>0") (("1" (grind) nil nil) ("2" (hide 2) (("2" (ground) (("1" (inst - "x") (("1" (assert) nil nil)) nil) ("2" (inst - "y") (("2" (assert) nil nil)) nil) ("3" (inst - "z") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sq_eq_0 formula-decl nil sq reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (z skolem-const-decl "real" ECEF nil) (y skolem-const-decl "real" ECEF nil) (x skolem-const-decl "real" ECEF nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (expt def-decl "real" exponentiation nil) (sq const-decl "nonneg_real" sq reals) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (sqrt_pos judgement-tcc nil sqrt reals) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil (xyz2spherical subtype "ECEF.r" "{rr: real_types.nnreal | booleans.IMPLIES((booleans.OR(ECEF.x /= 0, booleans.OR(ECEF.y /= 0, ECEF.z /= 0))), reals.>(rr, 0))}"))) (xyz2spherical_TCC6 0 (xyz2spherical_TCC6-1 nil 3650973818 ("" (skeep*) (("" (assert) (("" (case "sq(x)+sq(y)+sq(z)>0") (("1" (case "x^2+y^2+z^2>0") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil) ("2" (lemma "sq_eq_0") (("2" (inst - "z") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sq_eq_0 formula-decl nil sq reals) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (expt def-decl "real" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (sq const-decl "nonneg_real" sq reals) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil (xyz2spherical subtype "ECEF.r" "{rr: real_types.nnreal | booleans.IMPLIES((booleans.OR(ECEF.x /= 0, booleans.OR(ECEF.y /= 0, ECEF.z /= 0))), reals.>(rr, 0))}"))) (xyz2spherical_TCC7 0 (xyz2spherical_TCC7-1 nil 3650973818 ("" (skeep*) (("" (assert) (("" (hide 2) (("" (replaces -1) (("" (replaces -1) (("" (lemma "sqrt_eq_0") (("" (inst - "sq(x)+sq(y)+sq(z)") (("" (assert) (("" (split -) (("1" (hide -2) (("1" (lemma "sq_eq_0") (("1" (inst - "sqrt(x^2+y^2)") (("1" (assert) (("1" (hide 2) (("1" (rewrite "sq_sqrt") (("1" (case "sq(x)+sq(y)=0") (("1" (grind) nil nil) ("2" (assert) nil nil)) nil) ("2" (typepred "sq(x)") (("2" (typepred "sq(y)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "sq(x)") (("2" (typepred "sq(y)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (sq const-decl "nonneg_real" sq reals) (sq_eq_0 formula-decl nil sq reals) (NOT const-decl "[bool -> bool]" booleans nil) (real_times_real_is_real application-judgement "real" reals nil) (expt def-decl "real" exponentiation nil) (sq_sqrt formula-decl nil sqrt reals) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (nnreal type-eq-decl nil real_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (x skolem-const-decl "real" ECEF nil) (y skolem-const-decl "real" ECEF nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sqrt_eq_0 formula-decl nil sqrt reals) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil (xyz2spherical subtype "ECEF.r" "nznum"))) (xyz2spherical_TCC8 0 (xyz2spherical_TCC8-1 nil 3650973818 ("" (skeep*) (("" (case "abs(z/r)<=1") (("1" (grind) nil nil) ("2" (rewrite "abs_div") (("2" (case "r = 0") (("1" (replaces -1) (("1" (case "NOT x^2+y^2+z^2=0") (("1" (assert) nil nil) ("2" (case "NOT sq(x)+sq(y)+sq(z)=0") (("1" (grind) nil nil) ("2" (lemma "sq_eq_0") (("2" (inst-cp - "x") (("2" (inst-cp - "y") (("2" (inst - "z") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (cross-mult 2) (("2" (lemma "sq_le") (("2" (inst?) (("2" (assert) (("2" (case "FORALL (zzzz:real): 1*zzzz=zzzz") (("1" (rewrite -1) (("1" (hide -1) (("1" (assert) (("1" (replaces -1) (("1" (rewrite "sq_sqrt") (("1" (typepred "sq(x)") (("1" (typepred "sq(y)") (("1" (grind) nil nil)) nil)) nil) ("2" (typepred "sq(x)+sq(y)+sq(z)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (flatten) (("3" (replaces -1) (("3" (case "NOT sq(x)+sq(y)+sq(z)=0") (("1" (case "NOT x^2+y^2+z^2=0") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil) ("2" (lemma "sq_eq_0") (("2" (inst-cp - "x") (("2" (inst - "y") (("2" (assert) (("2" (replaces -1) (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((^ const-decl "real" exponentiation nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (nnreal type-eq-decl nil real_types nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (expt def-decl "real" exponentiation nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (sq_eq_0 formula-decl nil sq reals) (sq const-decl "nonneg_real" sq reals) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (sq_le formula-decl nil sq reals) (sq_abs formula-decl nil sq reals) (sq_sqrt formula-decl nil sqrt reals) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (x skolem-const-decl "real" ECEF nil) (y skolem-const-decl "real" ECEF nil) (z skolem-const-decl "real" ECEF nil) (r skolem-const-decl "{nnz: nnreal | nnz * nnz = x ^ 2 + y ^ 2 + z ^ 2}" ECEF nil) (posreal nonempty-type-eq-decl nil real_types nil) (div_mult_pos_le1 formula-decl nil real_props nil) (abs_div formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (sqrt_0 formula-decl nil sqrt reals) (nat_expt application-judgement "nat" exponentiation nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nat_exp application-judgement "nat" exponentiation nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil (xyz2spherical subtype "number_fields./(ECEF.z, ECEF.r)" "real_abs_le1"))) (xyz2spherical_TCC9 0 (xyz2spherical_TCC9-1 nil 3650973818 ("" (skeep*) (("" (assert) (("" (replaces -4) (("" (replaces -4) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_expt application-judgement "nat" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (sqrt_0 formula-decl nil sqrt reals) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (nat_exp application-judgement "nat" exponentiation nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil (xyz2spherical subtype "ECEF.y" "{z: reals.real | booleans.=>(ECEF.x = 0, z /= 0)}"))) (xyz2spherical_TCC10 0 (xyz2spherical_TCC10-2 "" 3804605807 ("" (skeep*) (("" (replaces -1) (("" (case "NOT x^2+y^2+z^2=0") (("1" (assert) nil nil) ("2" (case "NOT sq(x)+sq(y)+sq(z)=0") (("1" (assert) (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil)) nil) ("2" (case "FORALL (aa:nzreal): sq(aa)>0") (("1" (hide 1) (("1" (ground) (("1" (inst - "x") (("1" (assert) nil nil)) nil) ("2" (inst - "y") (("2" (assert) nil nil)) nil) ("3" (inst - "z") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (xyz2spherical subtype "ECEF.r" "{rr: real_types.nnreal | booleans.IMPLIES((booleans.OR(ECEF.x /= 0, booleans.OR(ECEF.y /= 0, ECEF.z /= 0))), reals.>(rr, 0))}")) (xyz2spherical_TCC10-1 nil 3650983952 ("" (skeep*) (("" (replaces -1) (("" (case "NOT x^2+y^2+z^2=0") (("1" (assert) nil nil) ("2" (case "NOT sq(x)+sq(y)+sq(z)=0") (("1" (assert) (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil)) nil) ("2" (case "FORALL (aa:nzreal): sq(aa)>0") (("1" (hide 2) (("1" (ground) (("1" (inst - "x") (("1" (assert) nil nil)) nil) ("2" (inst - "y") (("2" (assert) nil nil)) nil) ("3" (inst - "z") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (sq const-decl "nonneg_real" sq reals) (real_times_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (expt def-decl "real" exponentiation nil) (sq_nz_pos application-judgement "posreal" sq reals) (> const-decl "bool" reals nil) (nzreal nonempty-type-eq-decl nil reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig) (real_div_nzreal_is_real application-judgement "real" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real nonempty-type-from-decl nil reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (real_plus_real_is_real application-judgement "real" reals nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig)) nil (xyz2spherical subtype "ECEF.r" "{rr: real_types.nnreal | booleans.IMPLIES((booleans.OR(ECEF.x /= 0, booleans.OR(ECEF.y /= 0, ECEF.z /= 0))), reals.>(rr, 0))}"))) (spherical2xyz_def_TCC1 0 (spherical2xyz_def_TCC1-1 nil 3650983952 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil (spherical2xyz_def subtype "ECEF.r" "posreal"))) (spherical2xyz_def 0 (spherical2xyz_def-3 "" 3790106440 ("" (case "FORALL (zz,qq:nnreal): sq(zz) = sq(qq) IMPLIES zz=qq") (("1" (label "igz" -1) (("1" (hide "igz") (("1" (skeep) (("1" (skoletin :var "AA") (("1" (assert) (("1" (expand "xyz2spherical") (("1" (assert) (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (case "x = 0 AND y=0") (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (replaces -5) (("1" (assert) (("1" (replace -1) (("1" (replace -2) (("1" (assert) (("1" (expand "^" + 1) (("1" (expand "expt") (("1" (assert) (("1" (lemma "sqrt_sq") (("1" (inst - "z") (("1" (split -) (("1" (expand "expt") (("1" (expand "expt") (("1" (expand "sq") (("1" (replaces -1) (("1" (assert) (("1" (expand "spherical2xyz") (("1" (assert) (("1" (rewrite "cos_pi") (("1" (rewrite "sin_0") (("1" (rewrite "sin_pi") (("1" (rewrite "cos_0") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (case "NOT x^2+y^2=0") (("1" (assert) nil nil) ("2" (case "NOT sq(x)+sq(y)=0") (("1" (grind) nil nil) ("2" (lemma "sq_eq_0") (("2" (inst-cp - "x") (("2" (inst - "y") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (assert) (("1" (hide -3) (("1" (lift-if) (("1" (split -) (("1" (ground) nil nil) ("2" (flatten) (("2" (hide 1) (("2" (replaces -1) (("2" (assert) (("2" (case "x = 0 AND y = 0") (("1" (flatten) (("1" (replaces -1) (("1" (replaces -1) (("1" (assert) (("1" (case-replace "sqrt(z^2) = -z") (("1" (expand "spherical2xyz") (("1" (rewrite "cos_pi") (("1" (assert) (("1" (rewrite "sin_pi") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (rewrite "expt_x2") (("2" (rewrite "sq" :dir rl) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (2 3)) (("2" (case "NOT x^2+y^2=0") (("1" (assert) nil nil) ("2" (case "NOT sq(x)+sq(y)=0") (("1" (grind) nil nil) ("2" (lemma "sq_eq_0") (("2" (inst-cp - "x") (("2" (inst - "y") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 2) (("2" (assert) (("2" (replaces -1) (("2" (assert) (("2" (expand "spherical2xyz") (("2" (name "R" "sqrt(x^2+y^2+z^2)") (("1" (replace -1) (("1" (case "R > 0") (("1" (case "x/=0 OR y/=0") (("1" (hide -4) (("1" (assert) (("1" (split +) (("1" (rewrite "cos_atan2") (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (rewrite "sin_acos_ecef") (("1" (case "sqrt(1 - sq(z / R)) * (1 / sqrt(1 + sq(y / x))) * R = abs(x)") (("1" (split +) (("1" (flatten) (("1" (expand "abs") (("1" (expand "sq") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "abs") (("2" (expand "sq") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (reveal "igz") (("2" (invoke (inst - "%1" "%2") (! 1 1) (! 1 2)) (("2" (assert) (("2" (hide 2) (("2" (rewrite "sq_times") (("2" (rewrite "sq_times") (("2" (rewrite "sq_div") (("2" (rewrite "sq_div") (("1" (rewrite "sq_div") (("1" (rewrite "sq_sqrt") (("1" (field) (("1" (replaces -2 1 :dir rl) (("1" (rewrite "sq_sqrt") (("1" (grind) nil nil) ("2" (typepred "sq(x)+sq(y)+sq(z)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "nnreal_div_posreal_is_nnreal") (("2" (inst?) (("1" (assert) nil nil) ("2" (lemma "sq_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "sqrt_eq_0") (("2" (inst - "1+sq(y)/sq(x)") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (lemma "nnreal_div_posreal_is_nnreal") (("3" (inst?) (("1" (assert) nil nil) ("2" (lemma "sq_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("2" (rewrite "abs_div") (("2" (expand "abs" + 2) (("2" (cross-mult 1) (("2" (lemma "sq_le") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (case "FORALL (rr:real): 1*rr = rr") (("1" (rewrite -1) (("1" (hide -1) (("1" (replaces -2 :dir rl) (("1" (rewrite "sq_sqrt") (("1" (typepred "sq(x)+sq(y)") (("1" (grind) nil nil)) nil) ("2" (typepred "sq(x)+sq(y)+sq(z)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "sin_acos_ecef") (("1" (rewrite "sin_atan2") (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (flatten) (("1" (assert) (("1" (case "sqrt(1 - sq(z / R)) * R = abs(y)") (("1" (expand "abs") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil) ("2" (hide 2) (("2" (reveal "igz") (("2" (invoke (inst - "%1" "%2") (! 1 1) (! 1 2)) (("2" (assert) (("2" (hide 2) (("2" (delabel "igz") (("2" (rewrite "sq_times") (("2" (rewrite "sq_div") (("2" (replace -1) (("2" (assert) (("2" (field) (("2" (replaces -4 1 :dir rl) (("2" (rewrite "sq_sqrt") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (typepred "sq(y)+sq(z)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "sqrt(1 - sq(z / R)) * (y / abs(x) / sqrt(1 + sq(y / x))) * R = y") (("1" (split +) (("1" (flatten) (("1" (expand "abs") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "abs") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (reveal "igz") (("2" (case "sqrt(1 - sq(z / R)) * (abs(y) / abs(x) / sqrt(1 + sq(y / x))) * R = abs(y)") (("1" (name "d" "abs(y)") (("1" (replace -1) (("1" (expand "abs" -1) (("1" (replaces -1 :dir rl) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (invoke (inst - "%1" "%2") (! 1 1) (! 1 2)) (("1" (assert) (("1" (hide 1) (("1" (delabel "igz") (("1" (rewrite "sq_times") (("1" (rewrite "sq_div") (("1" (rewrite "sq_times") (("1" (rewrite "sq_div") (("1" (rewrite "sq_div") (("1" (rewrite "sq_div") (("1" (rewrite "sq_sqrt") (("1" (rewrite "sq_sqrt") (("1" (field) (("1" (case "sq(R) = sq(x)+sq(y)+sq(z)") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (replace -2 1 :dir rl) (("2" (rewrite "sq_sqrt") (("1" (grind) nil nil) ("2" (typepred "sq(x)+sq(y)+sq(z)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "nnreal_div_posreal_is_nnreal") (("2" (inst?) (("1" (assert) nil nil) ("2" (lemma "sq_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "sqrt_eq_0") (("2" (inst - "1+sq(y)/sq(x)") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (lemma "nnreal_div_posreal_is_nnreal") (("3" (inst?) (("1" (assert) nil nil) ("2" (lemma "sq_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "nnreal_times_nnreal_is_nnreal") (("2" (rewrite "nnreal_times_nnreal_is_nnreal") (("2" (cross-mult 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "abs_div") (("2" (cross-mult 1) (("2" (expand "abs" 1 2) (("2" (assert) (("2" (lemma "sq_le") (("2" (inst?) (("2" (assert) (("2" (replace -3 1 :dir rl) (("2" (rewrite "sq_sqrt") (("1" (typepred "sq(x)+sq(y)") (("1" (grind) nil nil)) nil) ("2" (typepred "sq(x)+sq(y)+sq(z)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "cos_acos") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -1) (("2" (replace -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "sqrt_pos") (("2" (assert) (("2" (lemma "sq_eq_0") (("2" (typepred "sq(x)") (("2" (typepred "sq(y)") (("2" (typepred "sq(z)") (("2" (split -) (("1" (flatten) (("1" (inst - "x") (("1" (grind) nil nil)) nil)) nil) ("2" (inst - "y") (("2" (grind) nil nil)) nil) ("3" (inst - "z") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (typepred "sq(x)+sq(y)+sq(z)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (both-sides-f -1 "sqrt") nil nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (sq_eq_0 formula-decl nil sq reals) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (^ const-decl "real" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (sin_0 formula-decl nil sincos_def trig) (cos_0 formula-decl nil sincos_def trig) (int_times_even_is_even application-judgement "even_int" integers nil) (sin_pi formula-decl nil sincos trig) (cos_pi formula-decl nil sincos trig) (sin_range application-judgement "real_abs_le1" sincos trig) (cos_range application-judgement "real_abs_le1" sincos trig) (sqrt_sq formula-decl nil sqrt reals) (expt def-decl "real" exponentiation nil) (sqrt_0 formula-decl nil sqrt reals) (zero_hat formula-decl nil exponent_props reals) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nat_exp application-judgement "nat" exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sqrt_sq_neg formula-decl nil sqrt reals) (expt_x2 formula-decl nil exponentiation nil) (real_minus_real_is_real application-judgement "real" reals nil) (minus_real_is_real application-judgement "real" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (- const-decl "[numfield -> numfield]" number_fields nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (acos const-decl "nnreal_le_pi" acos trig) (asin const-decl "real_abs_le_pi2" asin trig) (atan2 const-decl "real" atan2 trig) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (sqrt_pos judgement-tcc nil sqrt reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_abs_le1 nonempty-type-eq-decl nil trig_types trig) (cos_acos formula-decl nil trig_inverses trig) (nnreal_times_nnreal_is_nnreal judgement-tcc nil real_types nil) (div_mult_pos_ge1 formula-decl nil real_props nil) (div_cancel2 formula-decl nil real_props nil) (div_div2 formula-decl nil real_props nil) (div_cancel1 formula-decl nil real_props nil) (z skolem-const-decl "real" ECEF nil) (y skolem-const-decl "real" ECEF nil) (R skolem-const-decl "{nnz: nnreal | nnz * nnz = x ^ 2 + y ^ 2 + z ^ 2}" ECEF nil) (sin_atan2 formula-decl nil atan2 trig) (cos_atan2 formula-decl nil atan2 trig) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (<= const-decl "bool" reals nil) (sin_acos_ecef formula-decl nil ECEF nil) (sq_nz_pos application-judgement "posreal" sq reals) (sq_sqrt formula-decl nil sqrt reals) (sq_1 formula-decl nil sq reals) (minus_odd_is_odd application-judgement "odd_int" integers nil) (both_sides_times1 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (nnreal_div_posreal_is_nnreal judgement-tcc nil real_types nil) (x skolem-const-decl "real" ECEF nil) (sqrt_eq_0 formula-decl nil sqrt reals) (sq_div formula-decl nil sq reals) (sq_times formula-decl nil sq reals) (sq_abs formula-decl nil sq reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (sq_le formula-decl nil sq reals) (div_mult_pos_le1 formula-decl nil real_props nil) (abs_div formula-decl nil real_props nil) (npreal_div_posreal_is_npreal application-judgement "npreal" real_types nil) (sqrt_pos application-judgement "posreal" sqrt reals) (real_div_nzreal_is_real application-judgement "real" reals nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig) (real_plus_real_is_real application-judgement "real" reals nil) (spherical2xyz const-decl "Nz_vect3" ECEF nil) (Nz_vect3 type-eq-decl nil vectors_3D vectors) (zero const-decl "Vector" vectors_3D vectors) (posreal nonempty-type-eq-decl nil real_types nil) (Vector type-eq-decl nil vectors_3D vectors) (IFF const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (xyz2spherical const-decl "[# r: {rr: nnreal | (x /= 0 OR y /= 0 OR z /= 0) IMPLIES rr > 0},
   lat: real,
   lon: real #]" ECEF nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (sq const-decl "nonneg_real" sq reals)) shostak) (spherical2xyz_def-2 nil 3719580880 ("" (case "FORALL (zz,qq:nnreal): sq(zz) = sq(qq) IMPLIES zz=qq") (("1" (label "igz" -1) (("1" (hide "igz") (("1" (skeep) (("1" (skoletin :var "AA") (("1" (assert) (("1" (expand "xyz2spherical") (("1" (assert) (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (case "x = 0 AND y=0") (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (replaces -5) (("1" (assert) (("1" (replace -1) (("1" (replace -2) (("1" (assert) (("1" (expand "^" + 1) (("1" (expand "expt") (("1" (assert) (("1" (lemma "sqrt_sq") (("1" (inst - "z") (("1" (split -) (("1" (expand "expt") (("1" (expand "expt") (("1" (expand "sq") (("1" (replaces -1) (("1" (assert) (("1" (expand "spherical2xyz") (("1" (assert) (("1" (rewrite "cos_pi") (("1" (rewrite "sin_0") (("1" (rewrite "sin_pi") (("1" (rewrite "cos_0") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (case "NOT x^2+y^2=0") (("1" (assert) nil nil) ("2" (case "NOT sq(x)+sq(y)=0") (("1" (grind) nil nil) ("2" (lemma "sq_eq_0") (("2" (inst-cp - "x") (("2" (inst - "y") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (assert) (("1" (hide -3) (("1" (lift-if) (("1" (split -) (("1" (ground) nil nil) ("2" (flatten) (("2" (hide 1) (("2" (replaces -1) (("2" (assert) (("2" (case "x = 0 AND y = 0") (("1" (flatten) (("1" (replaces -1) (("1" (replaces -1) (("1" (assert) (("1" (case-replace "sqrt(z^2) = -z") (("1" (expand "spherical2xyz") (("1" (rewrite "cos_pi") (("1" (assert) (("1" (rewrite "sin_pi") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (rewrite "expt_x2") (("2" (rewrite "sq" :dir rl) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (2 3)) (("2" (case "NOT x^2+y^2=0") (("1" (assert) nil nil) ("2" (case "NOT sq(x)+sq(y)=0") (("1" (grind) nil nil) ("2" (lemma "sq_eq_0") (("2" (inst-cp - "x") (("2" (inst - "y") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 2) (("2" (assert) (("2" (replaces -1) (("2" (assert) (("2" (expand "spherical2xyz") (("2" (name "R" "sqrt(x^2+y^2+z^2)") (("1" (replace -1) (("1" (case "R > 0") (("1" (case "x/=0 OR y/=0") (("1" (hide -4) (("1" (assert) (("1" (split +) (("1" (rewrite "cos_atan2") (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (rewrite "sin_acos_ecef") (("1" (case "sqrt(1 - sq(z / R)) * (1 / sqrt(1 + sq(y / x))) * R = abs(x)") (("1" (split +) (("1" (flatten) (("1" (expand "abs") (("1" (expand "sq") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "abs") (("2" (expand "sq") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (reveal "igz") (("2" (invoke (inst - "%1" "%2") (! 1 1) (! 1 2)) (("2" (assert) (("2" (hide 2) (("2" (rewrite "sq_times") (("2" (rewrite "sq_times") (("2" (rewrite "sq_div") (("2" (rewrite "sq_div") (("1" (rewrite "sq_div") (("1" (rewrite "sq_sqrt") (("1" (field) (("1" (replaces -2 1 :dir rl) (("1" (rewrite "sq_sqrt") (("1" (grind) nil nil) ("2" (typepred "sq(x)+sq(y)+sq(z)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "nnreal_div_posreal_is_nnreal") (("2" (inst?) (("1" (assert) nil nil) ("2" (lemma "sq_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "sqrt_eq_0") (("2" (inst - "1+sq(y)/sq(x)") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (lemma "nnreal_div_posreal_is_nnreal") (("3" (inst?) (("1" (assert) nil nil) ("2" (lemma "sq_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("2" (rewrite "abs_div") (("2" (expand "abs" + 2) (("2" (cross-mult 1) (("2" (lemma "sq_le") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (case "FORALL (rr:real): 1*rr = rr") (("1" (rewrite -1) (("1" (hide -1) (("1" (replaces -2 :dir rl) (("1" (rewrite "sq_sqrt") (("1" (typepred "sq(x)+sq(y)") (("1" (grind) nil nil)) nil) ("2" (typepred "sq(x)+sq(y)+sq(z)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "sin_acos_ecef") (("1" (rewrite "sin_atan2") (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (flatten) (("1" (assert) (("1" (case "sqrt(1 - sq(z / R)) * R = abs(y)") (("1" (expand "abs") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil) ("2" (hide 2) (("2" (reveal "igz") (("2" (invoke (inst - "%1" "%2") (! 1 1) (! 1 2)) (("2" (assert) (("2" (hide 2) (("2" (delabel "igz") (("2" (rewrite "sq_times") (("2" (rewrite "sq_div") (("2" (replace -1) (("2" (assert) (("2" (field) (("2" (replaces -4 1 :dir rl) (("2" (rewrite "sq_sqrt") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (typepred "sq(y)+sq(z)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "sqrt(1 - sq(z / R)) * (y / abs(x) / sqrt(1 + sq(y / x))) * R = y") (("1" (split +) (("1" (flatten) (("1" (expand "abs") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "abs") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (reveal "igz") (("2" (case "sqrt(1 - sq(z / R)) * (abs(y) / abs(x) / sqrt(1 + sq(y / x))) * R = abs(y)") (("1" (name "d" "abs(y)") (("1" (replace -1) (("1" (expand "abs" -1) (("1" (replaces -1 :dir rl) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (invoke (inst - "%1" "%2") (! 1 1) (! 1 2)) (("1" (assert) (("1" (hide 1) (("1" (delabel "igz") (("1" (rewrite "sq_times") (("1" (rewrite "sq_div") (("1" (rewrite "sq_times") (("1" (rewrite "sq_div") (("1" (rewrite "sq_div") (("1" (rewrite "sq_div") (("1" (rewrite "sq_sqrt") (("1" (rewrite "sq_sqrt") (("1" (field) (("1" (case "sq(R) = sq(x)+sq(y)+sq(z)") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (replace -2 1 :dir rl) (("2" (rewrite "sq_sqrt") (("1" (grind) nil nil) ("2" (typepred "sq(x)+sq(y)+sq(z)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "nnreal_div_posreal_is_nnreal") (("2" (inst?) (("1" (assert) nil nil) ("2" (lemma "sq_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "sqrt_eq_0") (("2" (inst - "1+sq(y)/sq(x)") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (lemma "nnreal_div_posreal_is_nnreal") (("3" (inst?) (("1" (assert) nil nil) ("2" (lemma "sq_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "nnreal_times_nnreal_is_nnreal") (("2" (rewrite "nnreal_times_nnreal_is_nnreal") (("2" (cross-mult 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "abs_div") (("2" (cross-mult 1) (("2" (expand "abs" 1 2) (("2" (assert) (("2" (lemma "sq_le") (("2" (inst?) (("2" (assert) (("2" (replace -3 1 :dir rl) (("2" (rewrite "sq_sqrt") (("1" (typepred "sq(x)+sq(y)") (("1" (grind) nil nil)) nil) ("2" (typepred "sq(x)+sq(y)+sq(z)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "cos_acos") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -1) (("2" (replace -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "sqrt_pos") (("2" (assert) (("2" (lemma "sq_eq_0") (("2" (typepred "sq(x)") (("2" (typepred "sq(y)") (("2" (typepred "sq(z)") (("2" (split -) (("1" (flatten) (("1" (inst - "x") (("1" (grind) nil nil)) nil)) nil) ("2" (inst - "y") (("2" (grind) nil nil)) nil) ("3" (inst - "z") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (typepred "sq(x)+sq(y)+sq(z)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (both-sides-f -1 "sqrt") (("2" (replaces -1) nil nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (sq_eq_0 formula-decl nil sq reals) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (^ const-decl "real" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (sin_0 formula-decl nil sincos_def trig) (cos_0 formula-decl nil sincos_def trig) (int_times_even_is_even application-judgement "even_int" integers nil) (sin_pi formula-decl nil sincos trig) (cos_pi formula-decl nil sincos trig) (sin_range application-judgement "real_abs_le1" sincos trig) (cos_range application-judgement "real_abs_le1" sincos trig) (sqrt_sq formula-decl nil sqrt reals) (expt def-decl "real" exponentiation nil) (sqrt_0 formula-decl nil sqrt reals) (zero_hat formula-decl nil exponent_props reals) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nat_exp application-judgement "nat" exponentiation nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sqrt_sq_neg formula-decl nil sqrt reals) (expt_x2 formula-decl nil exponentiation nil) (real_minus_real_is_real application-judgement "real" reals nil) (minus_real_is_real application-judgement "real" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (- const-decl "[numfield -> numfield]" number_fields nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (acos const-decl "nnreal_le_pi" acos trig) (asin const-decl "real_abs_le_pi2" asin trig) (atan2 const-decl "real" atan2 trig) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (sqrt_pos judgement-tcc nil sqrt reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_abs_le1 nonempty-type-eq-decl nil trig_types trig) (cos_acos formula-decl nil trig_inverses trig) (nnreal_times_nnreal_is_nnreal judgement-tcc nil real_types nil) (div_mult_pos_ge1 formula-decl nil real_props nil) (div_cancel2 formula-decl nil real_props nil) (div_div2 formula-decl nil real_props nil) (div_cancel1 formula-decl nil real_props nil) nil nil nil (sin_atan2 formula-decl nil atan2 trig) (cos_atan2 formula-decl nil atan2 trig) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (<= const-decl "bool" reals nil) (sin_acos_ecef formula-decl nil ECEF nil) (sq_nz_pos application-judgement "posreal" sq reals) (sq_sqrt formula-decl nil sqrt reals) (sq_1 formula-decl nil sq reals) (minus_odd_is_odd application-judgement "odd_int" integers nil) (both_sides_times1 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (nnreal_div_posreal_is_nnreal judgement-tcc nil real_types nil) nil (sqrt_eq_0 formula-decl nil sqrt reals) (sq_div formula-decl nil sq reals) (sq_times formula-decl nil sq reals) (sq_abs formula-decl nil sq reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (sq_le formula-decl nil sq reals) (div_mult_pos_le1 formula-decl nil real_props nil) (abs_div formula-decl nil real_props nil) (npreal_div_posreal_is_npreal application-judgement "npreal" real_types nil) (sqrt_pos application-judgement "posreal" sqrt reals) (real_div_nzreal_is_real application-judgement "real" reals nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig) (real_plus_real_is_real application-judgement "real" reals nil) (spherical2xyz const-decl "Nz_vect3" ECEF nil) (Nz_vect3 type-eq-decl nil vectors_3D vectors) (zero const-decl "Vector" vectors_3D vectors) (posreal nonempty-type-eq-decl nil real_types nil) (Vector type-eq-decl nil vectors_3D vectors) (IFF const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (> const-decl "bool" reals nil) (xyz2spherical const-decl "[# r: {rr: nnreal | (x /= 0 OR y /= 0 OR z /= 0) IMPLIES rr > 0},
   lat: real,
   lon: real #]" ECEF nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (sq const-decl "nonneg_real" sq reals)) nil) (spherical2xyz_def-1 nil 3650984172 ("" (case "FORALL (zz,qq:nnreal): sq(zz) = sq(qq) IMPLIES zz=qq") (("1" (label "igz" -1) (("1" (hide "igz") (("1" (skeep) (("1" (skoletin) (("1" (assert) (("1" (expand "xyz2spherical") (("1" (assert) (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (case "x = 0 AND y=0") (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (replaces -5) (("1" (assert) (("1" (replace -1) (("1" (replace -2) (("1" (assert) (("1" (expand "^" + 1) (("1" (expand "expt") (("1" (assert) (("1" (lemma "sqrt_sq") (("1" (inst - "z") (("1" (split -) (("1" (expand "^") (("1" (expand "expt") (("1" (expand "expt") (("1" (expand "expt") (("1" (expand "sq") (("1" (replaces -1) (("1" (assert) (("1" (expand "spherical2xyz") (("1" (assert) (("1" (rewrite "cos_pi") (("1" (rewrite "sin_0") (("1" (rewrite "sin_pi") (("1" (rewrite "cos_0") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (case "NOT x^2+y^2=0") (("1" (assert) nil nil) ("2" (case "NOT sq(x)+sq(y)=0") (("1" (grind) nil nil) ("2" (lemma "sq_eq_0") (("2" (inst-cp - "x") (("2" (inst - "y") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (assert) (("1" (hide -3) (("1" (lift-if) (("1" (split -) (("1" (ground) nil nil) ("2" (flatten) (("2" (hide 1) (("2" (replaces -1) (("2" (assert) (("2" (case "x = 0 AND y = 0") (("1" (flatten) (("1" (replaces -1) (("1" (replaces -1) (("1" (assert) (("1" (expand "^" + 1) (("1" (expand "expt") (("1" (assert) (("1" (case "z^2 = sq(z)") (("1" (replaces -1) (("1" (assert) (("1" (expand "spherical2xyz") (("1" (rewrite "cos_pi") (("1" (assert) (("1" (rewrite "sin_pi") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (2 3)) (("2" (case "NOT x^2+y^2=0") (("1" (assert) nil nil) ("2" (case "NOT sq(x)+sq(y)=0") (("1" (grind) nil nil) ("2" (lemma "sq_eq_0") (("2" (inst-cp - "x") (("2" (inst - "y") (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (2 3)) (("2" (case "NOT x^2+y^2=0") (("1" (assert) nil nil) ("2" (case "NOT sq(x)+sq(y)=0") (("1" (grind) nil nil) ("2" (lemma "sq_eq_0") (("2" (inst-cp - "x") (("2" (inst - "y") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 2) (("2" (assert) (("2" (replaces -1) (("2" (assert) (("2" (expand "spherical2xyz") (("2" (name "R" "sqrt(x^2+y^2+z^2)") (("1" (replace -1) (("1" (case "R > 0") (("1" (case "x/=0 OR y/=0") (("1" (hide -4) (("1" (assert) (("1" (split +) (("1" (rewrite "cos_atan2") (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (rewrite "sin_acos_ecef") (("1" (case "sqrt(1 - sq(z / R)) * (1 / sqrt(1 + sq(y / x))) * R = abs(x)") (("1" (split +) (("1" (flatten) (("1" (expand "abs") (("1" (expand "sq") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "abs") (("2" (expand "sq") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (reveal "igz") (("2" (invoke (inst - "%1" "%2") (! 1 1) (! 1 2)) (("2" (assert) (("2" (hide 2) (("2" (rewrite "sq_times") (("2" (rewrite "sq_times") (("2" (rewrite "sq_div") (("2" (rewrite "sq_div") (("1" (rewrite "sq_div") (("1" (rewrite "sq_sqrt") (("1" (field) (("1" (replaces -2 1 :dir rl) (("1" (rewrite "sq_sqrt") (("1" (grind) nil nil) ("2" (typepred "sq(x)+sq(y)+sq(z)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "nnreal_div_posreal_is_nnreal") (("2" (inst?) (("1" (assert) nil nil) ("2" (lemma "sq_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "sqrt_eq_0") (("2" (inst - "1+sq(y)/sq(x)") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (lemma "nnreal_div_posreal_is_nnreal") (("3" (inst?) (("1" (assert) nil nil) ("2" (lemma "sq_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("2" (rewrite "abs_div") (("2" (expand "abs" + 2) (("2" (cross-mult 1) (("2" (lemma "sq_le") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (case "FORALL (rr:real): 1*rr = rr") (("1" (rewrite -1) (("1" (hide -1) (("1" (replaces -2 :dir rl) (("1" (rewrite "sq_sqrt") (("1" (typepred "sq(x)+sq(y)") (("1" (grind) nil nil)) nil) ("2" (typepred "sq(x)+sq(y)+sq(z)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "sin_acos_ecef") (("1" (rewrite "sin_atan2") (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (flatten) (("1" (assert) (("1" (case "sqrt(1 - sq(z / R)) * R = abs(y)") (("1" (expand "abs") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil) ("2" (hide 2) (("2" (reveal "igz") (("2" (invoke (inst - "%1" "%2") (! 1 1) (! 1 2)) (("2" (assert) (("2" (hide 2) (("2" (delabel "igz") (("2" (rewrite "sq_times") (("2" (rewrite "sq_div") (("2" (replace -1) (("2" (assert) (("2" (field) (("2" (replaces -4 1 :dir rl) (("2" (rewrite "sq_sqrt") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (typepred "sq(y)+sq(z)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "sqrt(1 - sq(z / R)) * (y / abs(x) / sqrt(1 + sq(y / x))) * R = y") (("1" (split +) (("1" (flatten) (("1" (expand "abs") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "abs") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (reveal "igz") (("2" (case "sqrt(1 - sq(z / R)) * (abs(y) / abs(x) / sqrt(1 + sq(y / x))) * R = abs(y)") (("1" (name "d" "abs(y)") (("1" (replace -1) (("1" (expand "abs" -1) (("1" (replaces -1 :dir rl) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (invoke (inst - "%1" "%2") (! 1 1) (! 1 2)) (("1" (assert) (("1" (hide 1) (("1" (delabel "igz") (("1" (rewrite "sq_times") (("1" (rewrite "sq_div") (("1" (rewrite "sq_times") (("1" (rewrite "sq_div") (("1" (rewrite "sq_div") (("1" (rewrite "sq_div") (("1" (rewrite "sq_sqrt") (("1" (rewrite "sq_sqrt") (("1" (field) (("1" (case "sq(R) = sq(x)+sq(y)+sq(z)") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (replace -2 1 :dir rl) (("2" (rewrite "sq_sqrt") (("1" (grind) nil nil) ("2" (typepred "sq(x)+sq(y)+sq(z)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "nnreal_div_posreal_is_nnreal") (("2" (inst?) (("1" (assert) nil nil) ("2" (lemma "sq_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "sqrt_eq_0") (("2" (inst - "1+sq(y)/sq(x)") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (lemma "nnreal_div_posreal_is_nnreal") (("3" (inst?) (("1" (assert) nil nil) ("2" (lemma "sq_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "nnreal_times_nnreal_is_nnreal") (("2" (rewrite "nnreal_times_nnreal_is_nnreal") (("2" (cross-mult 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "abs_div") (("2" (cross-mult 1) (("2" (expand "abs" 1 2) (("2" (assert) (("2" (lemma "sq_le") (("2" (inst?) (("2" (assert) (("2" (replace -3 1 :dir rl) (("2" (rewrite "sq_sqrt") (("1" (typepred "sq(x)+sq(y)") (("1" (grind) nil nil)) nil) ("2" (typepred "sq(x)+sq(y)+sq(z)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "cos_acos") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -1) (("2" (replace -2) (("2" (assert) (("2" (assert) (("2" (expand "^" 1) (("2" (expand "expt" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sqrt_pos") (("2" (inst?) (("1" (assert) nil nil) ("2" (lemma "sq_eq_0") (("2" (typepred "sq(x)") (("2" (typepred "sq(y)") (("2" (typepred "sq(z)") (("2" (split -) (("1" (flatten) (("1" (inst - "x") (("1" (grind) nil nil)) nil)) nil) ("2" (inst - "y") (("2" (grind) nil nil)) nil) ("3" (inst - "z") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (typepred "sq(x)+sq(y)+sq(z)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (both-sides-f -1 "sqrt") (("2" (replaces -1) nil nil)) nil)) nil)) nil)) nil) ((sq_eq_0 formula-decl nil sq reals) (sqrt_0 formula-decl nil sqrt reals) (sqrt_sq formula-decl nil sqrt reals) (sqrt_sq_neg formula-decl nil sqrt reals) (sqrt_pos judgement-tcc nil sqrt reals) (cos_acos formula-decl nil trig_inverses trig) (sin_atan2 formula-decl nil atan2 trig) (cos_atan2 formula-decl nil atan2 trig) (sq_nz_pos application-judgement "posreal" sq reals) (sq_sqrt formula-decl nil sqrt reals) (sq_1 formula-decl nil sq reals) (sqrt_eq_0 formula-decl nil sqrt reals) (sq_div formula-decl nil sq reals) (sq_times formula-decl nil sq reals) (sq_abs formula-decl nil sq reals) (sq_le formula-decl nil sq reals) (sqrt_pos application-judgement "posreal" sqrt reals) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (nil application-judgement "nnreal_lt_2pi" atan2 trig) (Nz_vect3 type-eq-decl nil vectors_3D vectors) (zero const-decl "Vector" vectors_3D vectors) (Vector type-eq-decl nil vectors_3D vectors) (sq const-decl "nonneg_real" sq reals)) shostak)) (xyz2spherical_def 0 (xyz2spherical_def-1 nil 3719581495 ("" (skeep) (("" (skoletin) (("" (expand "spherical2xyz") (("" (expand "xyz2spherical") (("" (lift-if) (("" (lift-if) (("" (lift-if) (("" (assert) (("" (case "NOT sqrt(v`x ^ 2 + v`y ^ 2 + v`z ^ 2) = r") (("1" (hide 2) (("1" (replaces -1) (("1" (assert) (("1" (lemma "sq_eq") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (rewrite "sq_sqrt") (("1" (lemma "sin2_cos2") (("1" (inst - "pi-lon") (("1" (name "az" "1") (("1" (case "1*sq(sin(pi/2-lat))+sq(cos(pi/2-lat)) = az") (("1" (replace -3 -1 :dir rl) (("1" (hide -2) (("1" (expand "az") (("1" (hide -2) (("1" (mult-by -1 "sq(r)") (("1" (grind :exclude ("pi" "cos" "sin")) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sin2_cos2") (("2" (inst - "pi/2-lat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "sq(cos(pi - lon) * sin(pi / 2 - lat) * r) +
                                               sq(sin(pi / 2 - lat) * sin(pi - lon) * r)
                                               + sq(r * cos(pi / 2 - lat))") (("2" (grind :exclude ("pi" "cos" "sin")) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "sq(cos(pi - lon) * sin(pi / 2 - lat) * r) +
                                     sq(sin(pi / 2 - lat) * sin(pi - lon) * r)
                                     + sq(r * cos(pi / 2 - lat))") (("2" (grind :exclude ("pi" "cos" "sin")) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "sqrt(v`x ^ 2 + v`y ^ 2) = 0") (("1" (hide +) (("1" (case "NOT (v`x=0 AND v`y = 0)") (("1" (case "NOT (v`x^2+v`y^2=0)") (("1" (assert) nil nil) ("2" (hide-all-but (-1 1)) (("2" (typepred "sq(v`x)+sq(v`y)") (("2" (lemma "sq_eq_0") (("2" (inst-cp - "v`x") (("2" (inst-cp - "v`y") (("2" (typepred "sq(v`x)") (("2" (typepred "sq(v`y)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -5 (-1 -2)) (("2" (assert) (("2" (case "sin(pi/2-lat)=0") (("1" (lemma "sin_eq_0") (("1" (inst?) (("1" (assert) (("1" (skosimp*) (("1" (case "NOT lat = (1/2 - i!1)*pi") (("1" (assert) nil nil) ("2" (case "NOT (i!1*pi < pi AND 0 < i!1*pi)") (("1" (assert) nil nil) ("2" (hide-all-but -1) (("2" (flatten) (("2" (case "i!1<=0") (("1" (mult-by -1 "pi") (("1" (assert) nil nil)) nil) ("2" (case "i!1 = 1") (("1" (replaces -1) (("1" (assert) nil nil)) nil) ("2" (case "i!1>=2") (("1" (mult-by -1 "pi") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (copy 1) (("2" (mult-by 1 "r") (("2" (assert) (("2" (case "NOT (cos(pi-lon)=0 AND sin(pi-lon)=0)") (("1" (lemma "nzreal_times_nzreal_is_nzreal") (("1" (split +) (("1" (inst - "cos(pi-lon)" "sin(pi/2-lat)*r") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (inst - "sin(pi/2-lat)*r" "sin(pi-lon)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "cos_eq_0") (("2" (inst?) (("2" (assert) (("2" (lemma "sin_eq_0") (("2" (inst?) (("2" (assert) (("2" (skosimp*) (("2" (replaces -1 -2) (("2" (case "NOT i!1-i!2=1/2") (("1" (mult-by 1 "pi") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace -1) (("2" (split +) (("1" (replace -2 1) (("1" (assert) (("1" (lemma "acos_cos") (("1" (inst - "pi/2-lat") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -2 1) (("2" (assert) (("2" (lemma "atan_tan") (("2" (case "sin(pi / 2 - lat) = 0") (("1" (lemma "sin_eq_0") (("1" (inst?) (("1" (assert) (("1" (skosimp*) (("1" (case "i!1 <=0") (("1" (mult-by -1 "pi") (("1" (assert) nil nil)) nil) ("2" (case "i!1 =1 ") (("1" (mult-by -1 "pi") (("1" (assert) nil nil)) nil) ("2" (case "i!1 >=2") (("1" (mult-by -1 "pi") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "atan2_cos_sin") (("2" (inst - "pi-lon") (("2" (case "NOT sin(pi/2-lat)>0") (("1" (lemma "sin_gt_0") (("1" (inst - "pi/2-lat") (("1" (assert) nil nil)) nil)) nil) ("2" (mult-by -1 "r") (("2" (lemma "atan2_cancel_pos") (("2" (inst - "sin(pi/2-lat)*r" "cos(pi-lon)" "sin(pi-lon)") (("1" (assert) (("1" (flatten) (("1" (lemma "cos_eq_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "sq(v`x)+sq(v`y)") (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "sq(v`x)+sq(v`y)+sq(v`z)") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Vector type-eq-decl nil vectors_3D vectors) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (/= const-decl "boolean" notequal nil) (zero const-decl "Vector" vectors_3D vectors) (Nz_vect3 type-eq-decl nil vectors_3D vectors) (spherical2xyz const-decl "Nz_vect3" ECEF nil) (nnreal type-eq-decl nil real_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (xyz2spherical const-decl "[# r: {rr: nnreal | (x /= 0 OR y /= 0 OR z /= 0) IMPLIES rr > 0},
   lat: real,
   lon: real #]" ECEF nil) (real_plus_real_is_real application-judgement "real" reals nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sin_range application-judgement "real_abs_le1" sincos trig) (real_minus_real_is_real application-judgement "real" reals nil) (cos_range application-judgement "real_abs_le1" sincos trig) (real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nnreal_le_pi nonempty-type-eq-decl nil trig_types trig) (acos_cos formula-decl nil trig_inverses trig) (both_sides_times_pos_gt1 formula-decl nil real_props nil) (atan2_cancel_pos formula-decl nil atan2 trig) (sin_gt_0 formula-decl nil trig_ineq trig) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (atan2_cos_sin formula-decl nil atan2 trig) (atan_tan formula-decl nil trig_inverses trig) (int_minus_int_is_int application-judgement "int" integers nil) (cos_eq_0 formula-decl nil sincos trig) (nzreal_times_nzreal_is_nzreal judgement-tcc nil real_types nil) (nzreal nonempty-type-eq-decl nil reals nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (both_sides_times1 formula-decl nil real_props nil) (sin_eq_0 formula-decl nil sincos trig) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (<= const-decl "bool" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (sq_eq_0 formula-decl nil sq reals) (cos const-decl "real" sincos_def trig) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig) (lon skolem-const-decl "real" ECEF nil) (sin const-decl "real" sincos_def trig) (lat skolem-const-decl "real" ECEF nil) (r skolem-const-decl "posreal" ECEF nil) (sin2_cos2 formula-decl nil sincos_def trig) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (odd? const-decl "bool" integers nil) (odd_posnat nonempty-type-eq-decl nil naturalnumbers nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (az skolem-const-decl "odd_posnat" ECEF nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (expt def-decl "real" exponentiation nil) (sq const-decl "nonneg_real" sq reals) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (sq_sqrt formula-decl nil sqrt reals) (sq_nz_pos application-judgement "posreal" sq reals) (sq_eq formula-decl nil sq reals) (^ const-decl "real" exponentiation nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig)) nil)))
