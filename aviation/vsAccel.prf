(vsAccel
 (accel_TCC1 0
  (accel_TCC1-1 nil 3612193685
   ("" (expand "deriv_domain?")
    (("" (skosimp*)
      (("" (inst 1 "e!1/2") (("" (assert) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (deriv_domain? const-decl "bool" deriv_domain_def analysis)
    (real_plus_real_is_real application-judgement "real" reals nil))
   nil
   (accel assuming "analysis@integral_split_fun[real].integral_split_fun"
    "deriv_domain: ASSUMPTION deriv_domain_def[T].deriv_domain?")))
 (accel_TCC2 0
  (accel_TCC2-1 nil 3612193685 ("" (assuming-tcc) nil nil)
   ((connected? const-decl "bool" deriv_domain_def analysis)) nil
   (accel assuming "analysis@integral_split_fun[real].integral_split_fun"
    "connected_domain: ASSUMPTION deriv_domain_def[T].connected?")))
 (accel_TCC3 0
  (accel_TCC3-1 nil 3612193685
   ("" (expand "not_one_element?")
    (("" (skosimp*) (("" (inst 1 "x!1+1") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (not_one_element? const-decl "bool" deriv_domain_def analysis))
   nil
   (accel assuming "analysis@integral_split_fun[real].integral_split_fun"
    "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?")))
 (L1_prep 0
  (L1_prep-1 nil 3611481051
   ("" (skosimp*)
    (("" (expand "accel")
      (("" (case " tStar!1<=t!1")
        (("1" (lemma "split_fun_Integrable[real]")
          (("1" (inst?)
            (("1" (lemma "Integral_const_fun[real]")
              (("1" (inst-cp -1 "a!1" "0" "tStar!1")
                (("1" (inst -1 "0" "tStar!1" "t!1")
                  (("1" (assert)
                    (("1" (flatten) (("1" (assert) nil nil)) nil)) nil))
                  nil))
                nil)
               ("2" (assert)
                (("2" (hide-all-but 1)
                  (("2" (expand "connected?") (("2" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "split_fun")
          (("2" (lemma "Integral_restr_eq[real]")
            (("1"
              (inst -1 "0" "t!1" "const_fun(a!1)" "LAMBDA (t: real):
                         IF (t <= tStar!1) THEN const_fun(a!1)(t)
                         ELSE const_fun(0)(t)
                         ENDIF")
              (("1" (split)
                (("1" (flatten) nil nil)
                 ("2" (skosimp*)
                  (("2" (hide 3)
                    (("2" (typepred "x!1") (("2" (grind) nil nil)) nil)) nil))
                  nil)
                 ("3" (hide 3)
                  (("3" (lemma "Integral_const_fun[real]")
                    (("3" (inst?) (("3" (flatten) nil nil)) nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (expand "connected?") (("2" (propax) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((accel const-decl "[real -> real]" vsAccel nil)
    (split_fun const-decl "[T -> real]" integral_split_fun analysis)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (Open_interval type-eq-decl nil intervals_real reals)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Integral_restr_eq formula-decl nil integral analysis)
    (split_fun_Integrable formula-decl nil integral_split_fun analysis)
    (Integral_const_fun formula-decl nil integral analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (derivable_const application-judgement "deriv_fun" derivatives analysis)
    (constant_seq1 application-judgement "(convergent?)" convergence_ops
     analysis)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil))
   nil))
 (velo_TCC1 0
  (velo_TCC1-1 nil 3611332305
   ("" (lemma "L1_prep") (("" (skosimp*) (("" (inst?) nil nil)) nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (L1_prep formula-decl nil vsAccel nil))
   nil
   (velo subtype "vsAccel.accel(vsAccel.tStar, vsAccel.a)"
    "integral_def[real].Integrable_funs(0, vsAccel.t)")))
 (L1_TCC1 0
  (L1_TCC1-1 nil 3611480418 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil (L1 subtype "vsAccel.t" "nnreal")))
 (L1_TCC2 0
  (L1_TCC2-1 nil 3611480418 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil (L1 subtype "vsAccel.tStar" "nnreal")))
 (L1 0
  (L1-2 nil 3612193810
   ("" (skosimp*)
    (("" (expand "velo")
      (("" (expand "accel")
        (("" (lemma "Integral_split_fun[real]")
          ((""
            (inst -1 "const_fun(a!1)" "const_fun(0)" "0" "tmax!1" "tStar!1"
             "t!1")
            (("" (assert)
              (("" (lemma "Integral_const_fun[real]")
                (("1" (inst-cp -1 "a!1" "0" "tStar!1")
                  (("1" (inst -1 "0" "tStar!1" "tmax!1")
                    (("1" (flatten)
                      (("1" (assert)
                        (("1" (flatten)
                          (("1" (assert)
                            (("1" (lift-if)
                              (("1" (assert)
                                (("1" (case "t!1<=tStar!1")
                                  (("1" (assert)
                                    (("1" (replace -7)
                                      (("1"
                                        (lemma "Integral_const_fun[real]")
                                        (("1"
                                          (inst - "a!1" "0" "t!1")
                                          (("1"
                                            (flatten)
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (assert)
                                    (("2" (replace -6)
                                      (("2"
                                        (lemma "Integral_const_fun[real]")
                                        (("2"
                                          (inst-cp -1 "a!1" "0" "tStar!1")
                                          (("2"
                                            (inst -1 "0" "tStar!1" "t!1")
                                            (("2"
                                              (flatten)
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide -1 2)
                  (("2" (expand "connected?") (("2" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((velo const-decl "real" vsAccel nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Integral_split_fun formula-decl nil integral_split_fun analysis)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (constant_seq1 application-judgement "(convergent?)" convergence_ops
     analysis)
    (derivable_const application-judgement "deriv_fun" derivatives analysis)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (<= const-decl "bool" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (Integral_const_fun formula-decl nil integral analysis)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (accel const-decl "[real -> real]" vsAccel nil))
   nil)
  (L1-1 nil 3611332349
   ("" (skosimp*)
    (("" (expand "velo")
      (("" (expand "accel")
        (("" (lemma "Integral_split_fun")
          ((""
            (inst -1 "const_fun(a!1)" "const_fun(0)" "0" "tmax!1" "tStar!1"
             "t!1")
            (("" (assert)
              (("" (lemma "Integral_const_fun[real]")
                (("1" (inst-cp -1 "a!1" "0" "tStar!1")
                  (("1" (inst -1 "0" "tStar!1" "tmax!1")
                    (("1" (flatten)
                      (("1" (assert)
                        (("1" (flatten)
                          (("1" (assert)
                            (("1" (lift-if)
                              (("1" (assert)
                                (("1" (case "t!1<=tStar!1")
                                  (("1" (assert)
                                    (("1" (replace -7)
                                      (("1"
                                        (lemma "Integral_const_fun[real]")
                                        (("1"
                                          (inst - "a!1" "0" "t!1")
                                          (("1"
                                            (flatten)
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (assert)
                                    (("2" (replace -6)
                                      (("2"
                                        (lemma "Integral_const_fun[real]")
                                        (("2"
                                          (inst-cp -1 "a!1" "0" "tStar!1")
                                          (("2"
                                            (inst -1 "0" "tStar!1" "t!1")
                                            (("2"
                                              (flatten)
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide -1 2)
                  (("2" (expand "connected?") (("2" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Integral_split_fun formula-decl nil integral_split_fun analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (Integral_const_fun formula-decl nil integral analysis)
    (const_fun const-decl "[T -> real]" real_fun_ops reals))
   shostak))
 (vsAccelUntil_Vel_TCC1 0
  (vsAccelUntil_Vel_TCC1-2 "" 3790106857
   ("" (skosimp*) (("" (assert) nil nil)) nil) nil shostak
   (vsAccelUntil_Vel subtype
    "number_fields./((number_fields.-)(((number_fields.-)(vsAccel.vStar, vsAccel.v0`z))), vsAccel.accel)"
    "nnreal"))
  (vsAccelUntil_Vel_TCC1-1 nil 3611923017
   ("" (skosimp*)
    (("" (move-terms -1 R 1)
      (("" (div-by -1 "accel!1") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((minus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (vsAccelUntil_Vel subtype
    "number_fields./((number_fields.-)(((number_fields.-)(vsAccel.vStar, vsAccel.v0`z))), vsAccel.accel)"
    "nnreal")))
 (L2_prep_TCC1 0
  (L2_prep_TCC1-1 nil 3611508156 ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (connected? const-decl "bool" deriv_domain_def analysis))
   nil
   (L2_prep assuming "analysis@integral_def[nnreal].integral_def"
    "connected_domain: ASSUMPTION deriv_domain_def[T].connected?")))
 (L2_prep_TCC2 0
  (L2_prep_TCC2-1 nil 3611508156
   ("" (expand "not_one_element?")
    (("" (skosimp*) (("" (inst + "x!1+1") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (not_one_element? const-decl "bool" deriv_domain_def analysis))
   nil
   (L2_prep assuming "analysis@integral_def[nnreal].integral_def"
    "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?")))
 (L2_prep 0
  (L2_prep-2 nil 3612193888
   ("" (skosimp*)
    (("" (lemma "Integral_restr_eq[nnreal]")
      (("1"
        (inst -1 "0" "t!1"
         "LAMBDA (t:nnreal): IF (t<=tStar!1) THEN v0!1 + a!1*t ELSE v0!1+a!1*tStar!1 ENDIF"
         "velo(v0!1, tStar!1, a!1)")
        (("1" (split)
          (("1" (flatten) nil nil)
           ("2" (skosimp*)
            (("2" (lemma "L1")
              (("2" (inst -1 "v0!1" "tStar!1" "x!1" "max(tStar!1, x!1)" "a!1")
                (("2" (expand "max")
                  (("2" (lift-if) (("2" (hide 2) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (case "t!1<=tStar!1")
            (("1" (lemma "Integral_restr_eq[nnreal]")
              (("1"
                (inst -1 "0" "t!1" "LAMBDA (t:nnreal): v0!1 + a!1 * t"
                 "LAMBDA (t: nnreal):
                                                    IF (t <= tStar!1) THEN v0!1 + a!1 * t
                                                    ELSE v0!1 + a!1 * tStar!1
                                                    ENDIF")
                (("1" (lemma "integral_linear[nnreal]")
                  (("1" (inst -1 "0" "t!1" "a!1" "v0!1")
                    (("1" (split)
                      (("1" (flatten) nil nil)
                       ("2" (skosimp*)
                        (("2" (lift-if)
                          (("2" (typepred (x!1))
                            (("2" (hide (-3 3 4)) (("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (skoletin)
                        (("3" (flatten)
                          (("3" (replace -3) (("3" (ground) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (lemma "Integral_restr_eq[nnreal]")
              (("2"
                (inst-cp -1 "0" "tStar!1" "LAMBDA (t:nnreal): v0!1 + a!1 * t"
                 "LAMBDA (t: nnreal):
                                                    IF (t <= tStar!1) THEN v0!1 + a!1 * t
                                                    ELSE v0!1 + a!1 * tStar!1
                                                    ENDIF")
                (("2" (split -2)
                  (("1" (flatten)
                    (("1"
                      (inst -3 "tStar!1" "t!1"
                       "LAMBDA (t:nnreal): v0!1 + a!1 * tStar!1"
                       "LAMBDA (t: nnreal):
                                                            IF (t <= tStar!1) THEN v0!1 + a!1 * t
                                                            ELSE v0!1 + a!1 * tStar!1
                                                            ENDIF")
                      (("1" (split -3)
                        (("1" (flatten)
                          (("1" (hide (-2 -4 3))
                            (("1" (lemma "Integral_split[nnreal]")
                              (("1"
                                (inst -1 "0" "tStar!1" "t!1"
                                 "LAMBDA (t: nnreal):
                                                                    IF (t <= tStar!1) THEN v0!1 + a!1 * t
                                                                    ELSE v0!1 + a!1 * tStar!1
                                                                    ENDIF")
                                (("1" (prop) nil nil)) nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skosimp*)
                          (("2" (lift-if)
                            (("2" (typepred (x!1))
                              (("2" (hide (-4 -5 3 4)) (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (lemma "integral_linear[nnreal]")
                          (("3"
                            (inst -1 "tStar!1" "t!1" "0" "v0!1 +a!1*tStar!1")
                            (("3" (skoletin)
                              (("3" (flatten)
                                (("3" (replace -3) (("3" (ground) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (skosimp*)
                    (("2" (lift-if)
                      (("2" (typepred (x!1))
                        (("2" (hide (4 5)) (("2" (grind) nil nil)) nil)) nil))
                      nil))
                    nil)
                   ("3" (lemma "integral_linear[nnreal]")
                    (("3" (inst -1 "0" "tStar!1" "a!1" "v0!1")
                      (("3" (skoletin)
                        (("3" (flatten)
                          (("3" (replace -3) (("3" (ground) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "connected?")
        (("2" (skosimp*) (("2" (ground) nil nil)) nil)) nil))
      nil))
    nil)
   ((nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Integral_restr_eq formula-decl nil integral analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (L1 formula-decl nil vsAccel nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (constant_seq1 application-judgement "(convergent?)" convergence_ops
     analysis)
    (derivable_const application-judgement "deriv_fun" derivatives analysis)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (accel const-decl "[real -> real]" vsAccel nil)
    (Integral const-decl "real" integral_def analysis)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Open_interval type-eq-decl nil intervals_real reals)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (Integral_split formula-decl nil integral analysis)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (nat_exp application-judgement "nat" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Integrable_funs type-eq-decl nil integral_def analysis)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (Integrable? const-decl "bool" integral_def analysis)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (velo const-decl "real" vsAccel nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_plus_real_is_real application-judgement "real" reals nil))
   nil)
  (L2_prep-1 nil 3611508470
   ("" (skosimp*)
    (("" (lemma "Integral_restr_eq[nnreal]")
      (("1"
        (inst -1 "0" "t!1"
         "LAMBDA (t:nnreal): IF (t<=tStar!1) THEN v0!1 + a!1*t ELSE v0!1+a!1*tStar!1 ENDIF"
         "velo(v0!1, tStar!1, a!1)")
        (("1" (split)
          (("1" (flatten) nil nil)
           ("2" (skosimp*)
            (("2" (lemma "L1")
              (("2" (inst -1 "v0!1" "tStar!1" "x!1" "max(tStar!1, x!1)" "a!1")
                (("2" (expand "max")
                  (("2" (lift-if) (("2" (grind) nil nil)) nil)) nil))
                nil))
              nil))
            nil)
           ("3" (case "t!1<=tStar!1")
            (("1" (lemma "Integral_restr_eq[nnreal]")
              (("1"
                (inst -1 "0" "t!1" "LAMBDA (t:nnreal): v0!1 + a!1 * t"
                 "LAMBDA (t: nnreal):
                    IF (t <= tStar!1) THEN v0!1 + a!1 * t
                    ELSE v0!1 + a!1 * tStar!1
                    ENDIF")
                (("1" (lemma "integral_linear[nnreal]")
                  (("1" (inst -1 "0" "t!1" "a!1" "v0!1")
                    (("1" (split)
                      (("1" (flatten) nil nil)
                       ("2" (skosimp*)
                        (("2" (lift-if)
                          (("2" (typepred (x!1)) (("2" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("3" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (lemma "Integral_restr_eq[nnreal]")
              (("2"
                (inst-cp -1 "0" "tStar!1" "LAMBDA (t:nnreal): v0!1 + a!1 * t"
                 "LAMBDA (t: nnreal):
                    IF (t <= tStar!1) THEN v0!1 + a!1 * t
                    ELSE v0!1 + a!1 * tStar!1
                    ENDIF")
                (("2" (split -2)
                  (("1" (flatten)
                    (("1"
                      (inst -3 "tStar!1" "t!1"
                       "LAMBDA (t:nnreal): v0!1 + a!1 * tStar!1"
                       "LAMBDA (t: nnreal):
                    IF (t <= tStar!1) THEN v0!1 + a!1 * t
                    ELSE v0!1 + a!1 * tStar!1
                    ENDIF")
                      (("1" (split -3)
                        (("1" (flatten)
                          (("1" (hide (-2 -4 3))
                            (("1" (lemma "Integral_split[nnreal]")
                              (("1"
                                (inst -1 "0" "tStar!1" "t!1"
                                 "LAMBDA (t: nnreal):
                    IF (t <= tStar!1) THEN v0!1 + a!1 * t
                    ELSE v0!1 + a!1 * tStar!1
                    ENDIF")
                                (("1" (prop) nil nil)) nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skosimp*)
                          (("2" (lift-if)
                            (("2" (typepred (x!1)) (("2" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("3" (lemma "integral_linear[nnreal]")
                          (("3"
                            (inst -1 "tStar!1" "t!1" "0" "v0!1 +a!1*tStar!1")
                            (("3" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (skosimp*)
                    (("2" (lift-if)
                      (("2" (typepred (x!1)) (("2" (grind) nil nil)) nil))
                      nil))
                    nil)
                   ("3" (lemma "integral_linear[nnreal]")
                    (("3" (inst -1 "0" "tStar!1" "a!1" "v0!1")
                      (("3" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "connected?")
        (("2" (skosimp*) (("2" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((Integral_restr_eq formula-decl nil integral analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (Open_interval type-eq-decl nil intervals_real reals)
    (Integral_split formula-decl nil integral analysis)
    (integral_linear formula-decl nil table_of_integrals analysis))
   shostak))
 (posit_TCC1 0
  (posit_TCC1-1 nil 3611508156
   ("" (lemma "L2_prep") (("" (propax) nil nil)) nil)
   ((L2_prep formula-decl nil vsAccel nil)) nil
   (posit subtype "vsAccel.velo(vsAccel.v0, vsAccel.tStar, vsAccel.a)"
    "integral_def[nnreal].Integrable_funs(0, vsAccel.t)")))
 (L2_TCC1 0
  (L2_TCC1-1 nil 3611508156 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (L2 subtype "2"
    "{i: integers.int | booleans.OR(vsAccel.t /= 0, reals.>=(i, 0))}")))
 (L2_TCC2 0
  (L2_TCC2-1 nil 3611920661 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (L2 subtype "2"
    "{i: integers.int | booleans.OR(vsAccel.tStar /= 0, reals.>=(i, 0))}")))
 (L2 0
  (L2-2 nil 3612193957
   ("" (skosimp*)
    (("" (expand "posit")
      (("" (lemma "L1")
        (("" (case "t!1<=tStar!1")
          (("1" (lemma "Integral_restr_eq[nnreal]")
            (("1"
              (inst -1 "0" "t!1" "LAMBDA (x: nnreal): v0!1 + a!1 * x"
               "velo(v0!1, tStar!1, a!1)")
              (("1" (split)
                (("1" (flatten)
                  (("1" (lift-if 1)
                    (("1" (prop)
                      (("1" (replace -3)
                        (("1" (lemma "integral_linear[nnreal]")
                          (("1" (inst -1 "0" "t!1" "a!1" "v0!1")
                            (("1" (skoletin)
                              (("1" (flatten)
                                (("1" (skoletin)
                                  (("1" (replace -2)
                                    (("1" (replace -4)
                                      (("1"
                                        (ground)
                                        (("1"
                                          (ground)
                                          (("1"
                                            (replace -1)
                                            (("1"
                                              (hide-all-but 1)
                                              (("1" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (skosimp*)
                  (("2" (inst -2 "v0!1" "tStar!1" "x!1" "tmax!1" "a!1")
                    (("2" (typepred (x!1))
                      (("2" (assert)
                        (("2" (flatten) (("2" (assert) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("3" (lemma "integral_linear[nnreal]")
                  (("3" (inst -1 "0" "t!1" "a!1" "v0!1")
                    (("1" (skoletin)
                      (("1" (flatten)
                        (("1" (replace -3) (("1" (ground) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (assert) nil nil) ("3" (assert) nil nil))
              nil)
             ("2" (expand "connected?")
              (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
            nil)
           ("2" (lift-if 2)
            (("2" (prop)
              (("2" (hide 1)
                (("2" (lemma "Integral_split[nnreal]")
                  (("1"
                    (inst -1 "0" "tStar!1" "t!1" "velo(v0!1, tStar!1, a!1)")
                    (("1" (lemma "L2_prep")
                      (("1" (inst-cp -1 "v0!1" "tStar!1" "tStar!1" "a!1")
                        (("1" (inst -1 "v0!1" "tStar!1" "t!1" "a!1")
                          (("1" (lemma "Integrable?_inside[nnreal]")
                            (("1"
                              (inst -1 "0" "t!1" "velo(v0!1, tStar!1, a!1)"
                               "tStar!1" "t!1")
                              (("1" (prop)
                                (("1" (replace -2 :dir rl)
                                  (("1" (lemma "Integral_restr_eq[nnreal]")
                                    (("1"
                                      (inst
                                       -1
                                       "0"
                                       "tStar!1"
                                       "velo(v0!1, tStar!1, a!1)"
                                       "LAMBDA (t: nnreal): v0!1 +a!1*t")
                                      (("1"
                                        (split -1)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (replace -2 :dir rl)
                                            (("1"
                                              (lemma
                                               "integral_linear[nnreal]")
                                              (("1"
                                                (inst
                                                 -1
                                                 "0"
                                                 "tStar!1"
                                                 "a!1"
                                                 "v0!1")
                                                (("1"
                                                  (hide (-7 -8 -2 -3 -5))
                                                  (("1"
                                                    (lemma
                                                     "Integral_restr_eq[nnreal]")
                                                    (("1"
                                                      (inst
                                                       -1
                                                       "tStar!1"
                                                       "t!1"
                                                       "velo(v0!1, tStar!1, a!1)"
                                                       "LAMBDA (t:nnreal): v0!1 + a!1 * tStar!1")
                                                      (("1"
                                                        (split -1)
                                                        (("1"
                                                          (flatten)
                                                          (("1"
                                                            (replace
                                                             -2
                                                             :dir
                                                             rl)
                                                            (("1"
                                                              (lemma
                                                               "integral_linear[nnreal]")
                                                              (("1"
                                                                (inst
                                                                 -1
                                                                 "tStar!1"
                                                                 "t!1"
                                                                 "0"
                                                                 "v0!1+a!1*tStar!1")
                                                                (("1"
                                                                  (skoletin)
                                                                  (("1"
                                                                    (skoletin)
                                                                    (("1"
                                                                      (flatten)
                                                                      (("1"
                                                                        (skoletin)
                                                                        (("1"
                                                                          (skoletin)
                                                                          (("1"
                                                                            (replace
                                                                             -2)
                                                                            (("1"
                                                                              (replace
                                                                               -4)
                                                                              (("1"
                                                                                (replace
                                                                                 -6)
                                                                                (("1"
                                                                                  (replace
                                                                                   -8)
                                                                                  (("1"
                                                                                    (simplify
                                                                                     -)
                                                                                    (("1"
                                                                                      (replace
                                                                                       -1)
                                                                                      (("1"
                                                                                        (replace
                                                                                         -3)
                                                                                        (("1"
                                                                                          (hide-all-but
                                                                                           1)
                                                                                          (("1"
                                                                                            (grind)
                                                                                            nil
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (assert)
                                                                  nil
                                                                  nil)
                                                                 ("3"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (skosimp*)
                                                          (("2"
                                                            (inst
                                                             -4
                                                             "v0!1"
                                                             "tStar!1"
                                                             "x!1"
                                                             "tmax!1"
                                                             "a!1")
                                                            (("2"
                                                              (typepred (x!1))
                                                              (("2"
                                                                (prop)
                                                                (("1"
                                                                  (lift-if)
                                                                  (("1"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (assert)
                                                                  nil
                                                                  nil)
                                                                 ("3"
                                                                  (assert)
                                                                  nil
                                                                  nil)
                                                                 ("4"
                                                                  (lift-if)
                                                                  (("4"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil)
                                                                 ("5"
                                                                  (assert)
                                                                  nil
                                                                  nil)
                                                                 ("6"
                                                                  (assert)
                                                                  nil
                                                                  nil)
                                                                 ("7"
                                                                  (assert)
                                                                  nil
                                                                  nil)
                                                                 ("8"
                                                                  (assert)
                                                                  nil
                                                                  nil)
                                                                 ("9"
                                                                  (assert)
                                                                  nil
                                                                  nil)
                                                                 ("10"
                                                                  (assert)
                                                                  nil
                                                                  nil)
                                                                 ("11"
                                                                  (assert)
                                                                  nil
                                                                  nil)
                                                                 ("12"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2" (assert) nil nil)
                                                       ("3" (assert) nil nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (skosimp*)
                                          (("2"
                                            (inst
                                             -6
                                             "v0!1"
                                             "tStar!1"
                                             "x!1"
                                             "tmax!1"
                                             "a!1")
                                            (("2"
                                              (prop)
                                              (("1"
                                                (lift-if)
                                                (("1"
                                                  (typepred (x!1))
                                                  (("1"
                                                    (prop)
                                                    (("1" (assert) nil nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (typepred (x!1))
                                                (("2" (assert) nil nil))
                                                nil)
                                               ("3"
                                                (typepred (x!1))
                                                (("3" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("3" (propax) nil nil))
                                        nil)
                                       ("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil) ("3" (assert) nil nil)
                                 ("4" (assert) nil nil)
                                 ("5" (assert) nil nil))
                                nil)
                               ("2" (assert) nil nil) ("3" (assert) nil nil))
                              nil))
                            nil)
                           ("2" (assert) nil nil) ("3" (assert) nil nil))
                          nil)
                         ("2" (assert) nil nil))
                        nil))
                      nil)
                     ("2" (assert) nil nil) ("3" (assert) nil nil))
                    nil)
                   ("2" (expand "connected?")
                    (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (posit const-decl "real" vsAccel nil) (<= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (t!1 skolem-const-decl "real" vsAccel nil)
    (tStar!1 skolem-const-decl "real" vsAccel nil)
    (velo const-decl "real" vsAccel nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (< const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Open_interval type-eq-decl nil intervals_real reals)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (^ const-decl "real" exponentiation nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Integrable? const-decl "bool" integral_def analysis)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (Integrable_funs type-eq-decl nil integral_def analysis)
    (Integral const-decl "real" integral_def analysis)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (nat_expt application-judgement "nat" exponentiation nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (expt def-decl "real" exponentiation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nat_exp application-judgement "nat" exponentiation nil)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (Integral_restr_eq formula-decl nil integral analysis)
    (Integral_split formula-decl nil integral analysis)
    (L2_prep formula-decl nil vsAccel nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (Integrable?_inside formula-decl nil integral analysis)
    (L1 formula-decl nil vsAccel nil))
   nil)
  (L2-1 nil 3611914687
   ("" (skosimp*)
    (("" (expand "posit")
      (("" (lemma "L1")
        (("" (case "t!1<=tStar!1")
          (("1" (lemma "Integral_restr_eq[nnreal]")
            (("1"
              (inst -1 "0" "t!1" "LAMBDA (x: nnreal): v0!1 + a!1 * x"
               "velo(v0!1, tStar!1, a!1)")
              (("1" (split)
                (("1" (flatten)
                  (("1" (lift-if 1)
                    (("1" (prop)
                      (("1" (replace -3)
                        (("1" (lemma "integral_linear[nnreal]")
                          (("1" (inst -1 "0" "t!1" "a!1" "v0!1")
                            (("1" (grind) nil nil) ("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (skosimp*)
                  (("2" (inst -2 "v0!1" "tStar!1" "x!1" "tmax!1" "a!1")
                    (("2" (typepred (x!1))
                      (("2" (assert)
                        (("2" (flatten) (("2" (assert) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("3" (lemma "integral_linear[nnreal]")
                  (("3" (inst -1 "0" "t!1" "a!1" "v0!1")
                    (("1" (grind) nil nil) ("2" (assert) nil nil)) nil))
                  nil))
                nil)
               ("2" (assert) nil nil) ("3" (assert) nil nil))
              nil)
             ("2" (expand "connected?")
              (("2" (skosimp*) (("2" (grind) nil nil)) nil)) nil))
            nil)
           ("2" (lift-if 2)
            (("2" (prop)
              (("2" (hide 1)
                (("2" (lemma "Integral_split[nnreal]")
                  (("1"
                    (inst -1 "0" "tStar!1" "t!1" "velo(v0!1, tStar!1, a!1)")
                    (("1" (lemma "L2_prep")
                      (("1" (inst-cp -1 "v0!1" "tStar!1" "tStar!1" "a!1")
                        (("1" (inst -1 "v0!1" "tStar!1" "t!1" "a!1")
                          (("1" (lemma "Integrable?_inside[nnreal]")
                            (("1"
                              (inst -1 "0" "t!1" "velo(v0!1, tStar!1, a!1)"
                               "tStar!1" "t!1")
                              (("1" (prop)
                                (("1" (replace -2 :dir rl)
                                  (("1" (lemma "Integral_restr_eq[nnreal]")
                                    (("1"
                                      (inst
                                       -1
                                       "0"
                                       "tStar!1"
                                       "velo(v0!1, tStar!1, a!1)"
                                       "LAMBDA (t: nnreal): v0!1 +a!1*t")
                                      (("1"
                                        (split -1)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (replace -2 :dir rl)
                                            (("1"
                                              (lemma
                                               "integral_linear[nnreal]")
                                              (("1"
                                                (inst
                                                 -1
                                                 "0"
                                                 "tStar!1"
                                                 "a!1"
                                                 "v0!1")
                                                (("1"
                                                  (hide (-7 -8 -2 -3 -5))
                                                  (("1"
                                                    (lemma
                                                     "Integral_restr_eq[nnreal]")
                                                    (("1"
                                                      (inst
                                                       -1
                                                       "tStar!1"
                                                       "t!1"
                                                       "velo(v0!1, tStar!1, a!1)"
                                                       "LAMBDA (t:nnreal): v0!1 + a!1 * tStar!1")
                                                      (("1"
                                                        (split -1)
                                                        (("1"
                                                          (flatten)
                                                          (("1"
                                                            (replace
                                                             -2
                                                             :dir
                                                             rl)
                                                            (("1"
                                                              (lemma
                                                               "integral_linear[nnreal]")
                                                              (("1"
                                                                (inst
                                                                 -1
                                                                 "tStar!1"
                                                                 "t!1"
                                                                 "0"
                                                                 "v0!1+a!1*tStar!1")
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil)
                                                                 ("2"
                                                                  (assert)
                                                                  nil
                                                                  nil)
                                                                 ("3"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (skosimp*)
                                                          (("2"
                                                            (inst
                                                             -4
                                                             "v0!1"
                                                             "tStar!1"
                                                             "x!1"
                                                             "tmax!1"
                                                             "a!1")
                                                            (("2"
                                                              (typepred (x!1))
                                                              (("2"
                                                                (prop)
                                                                (("1"
                                                                  (lift-if)
                                                                  (("1"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (assert)
                                                                  nil
                                                                  nil)
                                                                 ("3"
                                                                  (assert)
                                                                  nil
                                                                  nil)
                                                                 ("4"
                                                                  (lift-if)
                                                                  (("4"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil)
                                                                 ("5"
                                                                  (assert)
                                                                  nil
                                                                  nil)
                                                                 ("6"
                                                                  (assert)
                                                                  nil
                                                                  nil)
                                                                 ("7"
                                                                  (assert)
                                                                  nil
                                                                  nil)
                                                                 ("8"
                                                                  (assert)
                                                                  nil
                                                                  nil)
                                                                 ("9"
                                                                  (assert)
                                                                  nil
                                                                  nil)
                                                                 ("10"
                                                                  (assert)
                                                                  nil
                                                                  nil)
                                                                 ("11"
                                                                  (assert)
                                                                  nil
                                                                  nil)
                                                                 ("12"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2" (assert) nil nil)
                                                       ("3" (assert) nil nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (skosimp*)
                                          (("2"
                                            (inst
                                             -6
                                             "v0!1"
                                             "tStar!1"
                                             "x!1"
                                             "tmax!1"
                                             "a!1")
                                            (("2"
                                              (prop)
                                              (("1"
                                                (lift-if)
                                                (("1"
                                                  (typepred (x!1))
                                                  (("1"
                                                    (prop)
                                                    (("1" (assert) nil nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (typepred (x!1))
                                                (("2" (assert) nil nil))
                                                nil)
                                               ("3"
                                                (typepred (x!1))
                                                (("3" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("3" (propax) nil nil))
                                        nil)
                                       ("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil) ("3" (assert) nil nil)
                                 ("4" (assert) nil nil)
                                 ("5" (assert) nil nil))
                                nil)
                               ("2" (assert) nil nil) ("3" (assert) nil nil))
                              nil))
                            nil)
                           ("2" (assert) nil nil) ("3" (assert) nil nil))
                          nil)
                         ("2" (assert) nil nil))
                        nil))
                      nil)
                     ("2" (assert) nil nil) ("3" (assert) nil nil))
                    nil)
                   ("2" (expand "connected?")
                    (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Open_interval type-eq-decl nil intervals_real reals)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (Integral_restr_eq formula-decl nil integral analysis)
    (Integral_split formula-decl nil integral analysis)
    (Integrable?_inside formula-decl nil integral analysis))
   shostak))
 (vsAccelUntil_Pos_TCC1 0
  (vsAccelUntil_Pos_TCC1-1 nil 3611997052 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil
   (vsAccelUntil_Pos subtype
    "number_fields./(((number_fields.-)(vsAccel.vStar, vsAccel.v0`z)), vsAccel.accel)"
    "nnreal")))
 (vsAccelUntil_Pos_TCC2 0
  (vsAccelUntil_Pos_TCC2-1 nil 3611997052 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil))
   nil
   (vsAccelUntil_Pos subtype
    "number_fields./((number_fields.-)(((number_fields.-)(vsAccel.vStar, vsAccel.v0`z))), vsAccel.accel)"
    "nnreal")))
 (vsAccelRamp_Vel_TCC1 0
  (vsAccelRamp_Vel_TCC1-1 nil 3612023476
   ("" (skosimp*)
    (("" (expand "vsAccelRamp")
      (("" (lemma "integral_linear[real]")
        (("1" (inst -1 "0" "t!1" "a!1/tRamp!1" "0") (("1" (grind) nil nil))
          nil)
         ("2" (expand "connected?") (("2" (propax) nil nil)) nil))
        nil))
      nil))
    nil)
   ((vsAccelRamp const-decl "real" vsAccel nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (Integral const-decl "real" integral_def analysis)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (Integrable? const-decl "bool" integral_def analysis)
    (integrable? const-decl "bool" integral_def analysis)
    (integral? const-decl "bool" integral_def analysis)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (width const-decl "posreal" integral_def analysis)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil))
   nil
   (vsAccelRamp_Vel subtype "vsAccel.vsAccelRamp(vsAccel.a, vsAccel.tRamp)"
    "integral_def[real].Integrable_funs(0, vsAccel.t)")))
 (Int_ramp_vel_TCC1 0
  (Int_ramp_vel_TCC1-1 nil 3612023476 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (Int_ramp_vel subtype "2"
    "{i: integers.int | booleans.OR(vsAccel.t /= 0, reals.>=(i, 0))}")))
 (Int_ramp_vel 0
  (Int_ramp_vel-2 "no" 3612194634
   ("" (skosimp*)
    (("" (expand "vsAccelRamp_Vel")
      (("" (expand "vsAccelRamp")
        (("" (lemma "integral_linear[real]")
          (("1" (decompose-equality 1)
            (("1" (inst -1 "0" "x!1" "(a!1/tRamp!1)" "0")
              (("1" (flatten) (("1" (grind) nil nil)) nil)) nil)
             ("2" (skosimp*)
              (("2" (inst -1 "0" "t!1" "(a!1/tRamp!1)" "0")
                (("2" (flatten) (("2" (assert) nil nil)) nil)) nil))
              nil))
            nil)
           ("2" (expand "connected?") (("2" (propax) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((vsAccelRamp_Vel const-decl "real" vsAccel nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (bool nonempty-type-eq-decl nil booleans nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (nat_expt application-judgement "nat" exponentiation nil)
    (nat_exp application-judgement "nat" exponentiation nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (int_times_even_is_even application-judgement "even_int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (nnreal_expt application-judgement "nnreal" exponentiation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (expt def-decl "real" exponentiation nil)
    (width const-decl "posreal" integral_def analysis)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (integral? const-decl "bool" integral_def analysis)
    (integrable? const-decl "bool" integral_def analysis)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (^ const-decl "real" exponentiation nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (Integral const-decl "real" integral_def analysis)
    (Integrable_funs type-eq-decl nil integral_def analysis)
    (Integrable? const-decl "bool" integral_def analysis)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (a!1 skolem-const-decl "nzreal" vsAccel nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (tRamp!1 skolem-const-decl "posreal" vsAccel nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (vsAccelRamp const-decl "real" vsAccel nil))
   nil)
  (no "no" 3612194607
   ("" (skosimp*)
    (("" (expand "vsAccelRamp_Vel")
      (("" (expand "vsAccelRamp")
        (("" (lemma "integral_linear[nnreal]")
          (("1" (decompose-equality 1)
            (("1" (inst -1 "0" "x!1" "(a!1/tRamp!1)" "0")
              (("1" (flatten) (("1" (grind) (("1" (postpone) nil nil)) nil))
                nil))
              nil)
             ("2" (postpone) nil nil))
            nil)
           ("2" (postpone) nil nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (Int_ramp_vel-1 nil 3612025680
   ("" (skosimp*)
    (("" (expand "vsAccelRamp_Vel")
      (("" (expand "vsAccelRamp")
        (("" (lemma "integral_linear[nnreal]")
          (("1" (decompose-equality 1)
            (("1" (inst -1 "0" "x!1" "(a!1/tRamp!1)" "0")
              (("1" (flatten) (("1" (grind) nil nil)) nil)) nil)
             ("2" (skosimp*)
              (("2" (inst -1 "0" "t!1" "(a!1/tRamp!1)" "0")
                (("2" (flatten) (("2" (assert) nil nil)) nil)) nil))
              nil))
            nil)
           ("2" (expand "connected?")
            (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((integral_linear formula-decl nil table_of_integrals analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (Integral const-decl "real" integral_def analysis)
    (Integrable_funs type-eq-decl nil integral_def analysis)
    (Integrable? const-decl "bool" integral_def analysis))
   shostak))
 (Int_ramp_vel2 0
  (Int_ramp_vel2-2 nil 3612258994
   ("" (skosimp*)
    (("" (lemma "integral_linear[nnreal]")
      (("1" (inst -1 "0" "t!1" "a!1/tRamp!1" "0") (("1" (grind) nil nil)) nil)
       ("2" (expand "connected?")
        (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (vsAccelRamp const-decl "real" vsAccel nil)
    (Integral const-decl "real" integral_def analysis)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (Integrable? const-decl "bool" integral_def analysis)
    (integrable? const-decl "bool" integral_def analysis)
    (integral? const-decl "bool" integral_def analysis)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (width const-decl "posreal" integral_def analysis)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nnreal_expt application-judgement "nnreal" exponentiation nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil)
  (Int_ramp_vel2-1 nil 3612258323
   ("" (skosimp*)
    (("" (lemma "integral_linear[real]")
      (("1" (inst -1 "0" "t!1" "a!1/tRamp!1" "0")
        (("1" (grind)
          (("1" (expand "vsAccelRamp") (("1" (grind) nil nil)) nil)
           ("2" (expand "vsAccelRamp") (("2" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (expand "connected?") (("2" (propax) nil nil)) nil))
      nil))
    nil)
   ((integral_linear formula-decl nil table_of_integrals analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis))
   shostak))
 (vsAccelRamp_Pos_TCC1 0
  (vsAccelRamp_Pos_TCC1-1 nil 3612023476
   ("" (skosimp*)
    (("" (lemma "Integral_sum[nnreal]")
      (("1"
        (inst -1 "0" "t!1" "LAMBDA (x:nnreal): v0z!1"
         "vsAccelRamp_Vel(a!1, tRamp!1)")
        (("1" (lemma "Integral_const_fun[nnreal]")
          (("1" (inst -1 "v0z!1" "0" "t!1")
            (("1" (flatten)
              (("1" (lemma "Int_ramp_vel")
                (("1" (inst -1 "a!1" "tRamp!1")
                  (("1" (replace -1)
                    (("1" (lemma "integral_x_to_n[nnreal]")
                      (("1" (inst -1 "0" "t!1" "2" "a!1/(2*tRamp!1)")
                        (("1" (split -5)
                          (("1" (flatten) nil nil)
                           ("2" (expand "const_fun") (("2" (propax) nil nil))
                            nil)
                           ("3" (skoletin)
                            (("3" (flatten)
                              (("3" (replace -3) (("3" (ground) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "connected?" 1)
        (("2" (ground) (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Integral_sum formula-decl nil integral analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (Integral_const_fun formula-decl nil integral analysis)
    (integral_x_to_n formula-decl nil table_of_integrals analysis)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (nat_exp application-judgement "nat" exponentiation nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Integral const-decl "real" integral_def analysis)
    (Integrable_funs type-eq-decl nil integral_def analysis)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Integrable? const-decl "bool" integral_def analysis)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (^ const-decl "real" exponentiation nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (Int_ramp_vel formula-decl nil vsAccel nil)
    (vsAccelRamp_Vel const-decl "real" vsAccel nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (vsAccelRamp_Pos subtype
    "LAMBDA (x: real_types.nnreal): (number_fields.+)(vsAccel.v0z, vsAccel.vsAccelRamp_Vel(vsAccel.a, vsAccel.tRamp)(x))"
    "integral_def[nnreal].Integrable_funs(0, vsAccel.t)")))
 (Int_ramp_pos_TCC1 0
  (Int_ramp_pos_TCC1-1 nil 3612023476 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (Int_ramp_pos subtype "3"
    "{i: integers.int | booleans.OR(vsAccel.t /= 0, reals.>=(i, 0))}")))
 (Int_ramp_pos 0
  (Int_ramp_pos-2 "" 3790106875
   ("" (skosimp*)
    (("" (decompose-equality 1)
      (("" (expand "vsAccelRamp_Pos")
        (("" (lemma "Int_ramp_vel")
          (("" (inst -1 "a!1" "tRamp!1")
            (("" (lemma "Integral_sum[nnreal]")
              (("1"
                (inst -1 "0" "x!1" "vsAccelRamp_Vel(a!1, tRamp!1)"
                 "LAMBDA (x:nnreal): v0z!1")
                (("1" (replace -2)
                  (("1" (lemma "integral_linear[nnreal]")
                    (("1" (inst -1 "0" "x!1" "0" "v0z!1")
                      (("1" (lemma "integral_x_to_n[nnreal]")
                        (("1" (inst -1 "0" "x!1" "2" "a!1/(2*tRamp!1)")
                          (("1" (assert)
                            (("1" (flatten)
                              (("1" (assert)
                                (("1" (flatten)
                                  (("1" (assert)
                                    (("1" (replace -2)
                                      (("1"
                                        (replace -4)
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand "connected?")
                (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (Int_ramp_pos-1 nil 3612026020
   ("" (skosimp*)
    (("" (decompose-equality 1)
      (("" (expand "vsAccelRamp_Pos")
        (("" (lemma "Int_ramp_vel")
          (("" (inst -1 "a!1" "tRamp!1")
            (("" (lemma "Integral_sum[nnreal]")
              (("1"
                (inst -1 "0" "x!1" "vsAccelRamp_Vel(a!1, tRamp!1)"
                 "LAMBDA (x:nnreal): v0z!1")
                (("1" (replace -2)
                  (("1" (lemma "integral_linear[nnreal]")
                    (("1" (inst -1 "0" "x!1" "0" "v0z!1")
                      (("1" (lemma "integral_x_to_n[nnreal]")
                        (("1" (inst -1 "0" "x!1" "2" "a!1/(2*tRamp!1)")
                          (("1" (assert)
                            (("1" (flatten)
                              (("1" (assert)
                                (("1" (flatten)
                                  (("1" (assert)
                                    (("1" (replace -2)
                                      (("1"
                                        (replace -4)
                                        (("1"
                                          (assert)
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand "connected?")
                (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnreal_exp application-judgement "nnreal" exponentiation nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (/= const-decl "boolean" notequal nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (vsAccelRamp_Pos const-decl "real" vsAccel nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (^ const-decl "real" exponentiation nil)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Int_ramp_vel formula-decl nil vsAccel nil)
    (Integral_sum formula-decl nil integral analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (nat_expt application-judgement "nat" exponentiation nil)
    (nnreal_expt application-judgement "nnreal" exponentiation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (expt def-decl "real" exponentiation nil)
    (width const-decl "posreal" integral_def analysis)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (integral? const-decl "bool" integral_def analysis)
    (integrable? const-decl "bool" integral_def analysis)
    (Integrable? const-decl "bool" integral_def analysis)
    (Integral const-decl "real" integral_def analysis)
    (nat_exp application-judgement "nat" exponentiation nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (integral_x_to_n formula-decl nil table_of_integrals analysis)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (vsAccelRamp_Vel const-decl "real" vsAccel nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   shostak))
 (vsAccelConst_Vel_TCC1 0
  (vsAccelConst_Vel_TCC1-1 nil 3612023476
   ("" (skosimp*)
    (("" (lemma "integral_linear[real]")
      (("1" (inst -1 "t0!1" "t!1" "0" "a!1")
        (("1" (skoletin)
          (("1" (replace -2)
            (("1" (expand "vsAccelConst")
              (("1" (flatten)
                (("1" (simplify -1) (("1" (propax) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "connected?") (("2" (propax) nil nil)) nil))
      nil))
    nil)
   ((real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Integrable? const-decl "bool" integral_def analysis)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (^ const-decl "real" exponentiation nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Integral const-decl "real" integral_def analysis)
    (Integrable_funs type-eq-decl nil integral_def analysis)
    (vsAccelConst const-decl "real" vsAccel nil)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil))
   nil
   (vsAccelConst_Vel subtype "vsAccel.vsAccelConst(vsAccel.a)"
    "integral_def[real].Integrable_funs(vsAccel.t0, vsAccel.t)")))
 (Int_const_vel 0
  (Int_const_vel-1 nil 3612027083
   ("" (skosimp*)
    (("" (expand "vsAccelConst_Vel")
      (("" (expand "vsAccelConst")
        (("" (lemma "integral_linear[real]")
          (("1" (decompose-equality 1)
            (("1" (inst -1 "t0!1" "x!1" "0" "a!1")
              (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)
             ("2" (skosimp*)
              (("2" (inst -1 "t0!1" "t!1" "0" "a!1")
                (("2" (flatten) (("2" (assert) nil nil)) nil)) nil))
              nil))
            nil)
           ("2" (expand "connected?") (("2" (propax) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (vsAccelConst_Vel const-decl "real" vsAccel nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (bool nonempty-type-eq-decl nil booleans nil)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (Integral const-decl "real" integral_def analysis)
    (Integrable_funs type-eq-decl nil integral_def analysis)
    (Integrable? const-decl "bool" integral_def analysis)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (t0!1 skolem-const-decl "nnreal" vsAccel nil)
    (a!1 skolem-const-decl "real" vsAccel nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (vsAccelConst const-decl "real" vsAccel nil))
   shostak))
 (Int_const_vel2 0
  (Int_const_vel2-1 nil 3612267817
   ("" (skosimp*)
    (("" (lemma "integral_linear[nnreal]")
      (("1" (inst -1 "t0!1" "t!1" "0" "a!1")
        (("1" (skoletin)
          (("1" (expand "vsAccelConst")
            (("1" (simplify -2)
              (("1" (flatten)
                (("1" (skoletin)
                  (("1" (simplify -)
                    (("1" (replace -2)
                      (("1" (replace -4)
                        (("1" (simplify -) (("1" (ground) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "connected?")
        (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Integrable? const-decl "bool" integral_def analysis)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (^ const-decl "real" exponentiation nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Integral const-decl "real" integral_def analysis)
    (Integrable_funs type-eq-decl nil integral_def analysis)
    (vsAccelConst const-decl "real" vsAccel nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   shostak))
 (vsAccelConst_Pos_TCC1 0
  (vsAccelConst_Pos_TCC1-1 nil 3612023476
   ("" (skosimp*)
    (("" (lemma "Integral_sum[nnreal]")
      (("1"
        (inst -1 "t0!1" "t!1" "LAMBDA (x: nnreal): v0z!1"
         "vsAccelConst_Vel(a!1, t0!1)")
        (("1" (lemma "integral_linear[nnreal]")
          (("1" (inst -1 "t0!1" "t!1" "0" "v0z!1")
            (("1" (lemma "Int_const_vel")
              (("1" (inst -1 "a!1" "t0!1")
                (("1" (lemma "integral_linear[nnreal]")
                  (("1" (inst -1 "t0!1" "t!1" "a!1" "-a!1*t0!1")
                    (("1" (assert)
                      (("1" (flatten)
                        (("1" (replace -3)
                          (("1" (assert)
                            (("1" (lemma "integral_linear[nnreal]")
                              (("1"
                                (inst -1 "t0!1" "t!1" "a!1" "-a!1*t0!1+v0z!1")
                                (("1" (assert) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "connected?")
        (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Integral_sum formula-decl nil integral analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (Int_const_vel formula-decl nil vsAccel nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (vsAccelConst_Vel const-decl "real" vsAccel nil)
    (restrict const-decl "R" restrict nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (vsAccelConst_Pos subtype
    "LAMBDA (x: real_types.nnreal): (number_fields.+)(vsAccel.v0z, vsAccel.vsAccelConst_Vel(vsAccel.a, vsAccel.t0)(x))"
    "integral_def[nnreal].Integrable_funs(vsAccel.t0, vsAccel.t)")))
 (Int_const_pos 0
  (Int_const_pos-1 nil 3612084250
   ("" (skosimp*)
    (("" (decompose-equality)
      (("" (expand "vsAccelConst_Pos")
        (("" (lemma "Int_const_vel")
          (("" (inst -1 "a!1" "t0!1")
            (("" (lemma "Integral_sum[nnreal]")
              (("1"
                (inst -1 "t0!1" "x!1" "vsAccelConst_Vel(a!1, t0!1)"
                 "LAMBDA (x:nnreal): v0z!1")
                (("1" (replace -2)
                  (("1" (lemma "integral_linear[nnreal]")
                    (("1" (inst-cp -1 "t0!1" "x!1" "a!1" "-a!1*t0!1")
                      (("1" (inst -1 "t0!1" "x!1" "0" "v0z!1")
                        (("1" (assert)
                          (("1" (flatten)
                            (("1" (assert)
                              (("1" (replace -2)
                                (("1" (expand "restrict")
                                  (("1" (replace -4)
                                    (("1" (assert) (("1" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand "connected?")
                (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnreal_exp application-judgement "nnreal" exponentiation nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (vsAccelConst_Pos const-decl "real" vsAccel nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (^ const-decl "real" exponentiation nil)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Int_const_vel formula-decl nil vsAccel nil)
    (Integral_sum formula-decl nil integral analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (nnreal_expt application-judgement "nnreal" exponentiation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (width const-decl "posreal" integral_def analysis)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (integral? const-decl "bool" integral_def analysis)
    (integrable? const-decl "bool" integral_def analysis)
    (Integrable? const-decl "bool" integral_def analysis)
    (Integral const-decl "real" integral_def analysis)
    (expt def-decl "real" exponentiation nil)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (restrict const-decl "R" restrict nil)
    (vsAccelConst_Vel const-decl "real" vsAccel nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   shostak))
 (sign_not_zero 0
  (sign_not_zero-1 nil 3612273936
   ("" (skosimp*) (("" (expand "Sign") (("" (grind) nil nil)) nil)) nil)
   ((Sign const-decl "real" vsAccel nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil (sign_not_zero subtype "vsAccel.Sign(vsAccel.a, vsAccel.b)" "nzreal")))
 (vsAUWRU_case1_acc_TCC1 0
  (vsAUWRU_case1_acc_TCC1-2 "" 3790106881
   ("" (skosimp*) (("" (assert) nil nil)) nil) nil shostak
   (vsAUWRU_case1_acc assuming
    "analysis@integral_split_fun[nnreal].integral_split_fun"
    "deriv_domain: ASSUMPTION deriv_domain_def[T].deriv_domain?"))
  (vsAUWRU_case1_acc_TCC1-1 nil 3612172317
   ("" (skosimp*)
    (("" (expand "Sign")
      (("" (assert)
        (("" (typepred (accel!1)) (("" (assert) (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((deriv_domain_nnreal formula-decl nil deriv_domain analysis)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil
   (vsAUWRU_case1_acc assuming
    "analysis@integral_split_fun[nnreal].integral_split_fun"
    "deriv_domain: ASSUMPTION deriv_domain_def[T].deriv_domain?")))
 (case1_vel_prep 0
  (case1_vel_prep-3 "" 3790106884
   ("" (skosimp*)
    (("" (skoletin)
      (("" (skoletin)
        (("" (lift-if)
          (("" (prop)
            (("1" (expand "vsAUWRU_case1_acc")
              (("1" (lemma "Integral_restr_eq[nnreal]")
                (("1"
                  (inst -1 "0" "t!1" "vsAccelConst(0)" "LAMBDA (t: nnreal):
                          IF v0z!1 = goalVs!1 THEN vsAccelConst(0)(t)
                          ELSE split_fun[nnreal](sqrt(2
                                              *
                                              (abs(goalVs!1 - v0z!1) * tRamp!1)
                                              /
                                              accel!1),
                                         vsAccelRamp(Sign(v0z!1, goalVs!1)
                                                     *
                                                     accel!1,
                                                     tRamp!1),
                                         vsAccelConst(0))
                                        (t)
                          ENDIF")
                  (("1" (prop)
                    (("1" (skosimp*)
                      (("1" (expand "restrict")
                        (("1" (lift-if 1) (("1" (prop) nil nil)) nil)) nil))
                      nil)
                     ("2" (expand "restrict")
                      (("2" (lemma "integral_linear[nnreal]")
                        (("2" (inst -1 "0" "t!1" "0" "0")
                          (("2" (expand "vsAccelConst")
                            (("2" (assert) (("2" (flatten) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten) nil nil))
                  nil)
                 ("2" (expand "connected?")
                  (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
                nil))
              nil)
             ("2" (case "t!1<=tMax")
              (("1" (lemma "Integral_restr_eq[nnreal]")
                (("1"
                  (inst -1 "0" "t!1"
                   "vsAccelRamp(Sign(v0z!1, goalVs!1)*accel!1, tRamp!1)"
                   "vsAUWRU_case1_acc(v0z!1, goalVs!1, accel!1, tRamp!1)")
                  (("1" (prop)
                    (("1" (skosimp*)
                      (("1" (expand "vsAUWRU_case1_acc")
                        (("1" (lift-if 1)
                          (("1" (prop)
                            (("1" (expand "split_fun")
                              (("1" (lift-if 2)
                                (("1" (typepred (x!1))
                                  (("1" (prop)
                                    (("1" (expand "restrict")
                                      (("1" (assert) nil nil)) nil)
                                     ("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand "restrict")
                      (("2" (expand "vsAccelRamp")
                        (("2" (lemma "integral_linear[nnreal]")
                          (("2"
                            (inst -1 "0" "t!1"
                             "Sign(v0z!1, goalVs!1) * accel!1 / tRamp!1" "0")
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "connected?")
                  (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
                nil)
               ("2" (lemma "Integral_restr_eq[nnreal]")
                (("1"
                  (inst -1 "0" "t!1"
                   "split_fun[nnreal]( tMax, vsAccelRamp(Sign(v0z!1, goalVs!1)*accel!1, tRamp!1), vsAccelConst(0))"
                   "vsAUWRU_case1_acc(v0z!1, goalVs!1, accel!1, tRamp!1)")
                  (("1" (prop)
                    (("1" (skosimp*)
                      (("1" (expand "restrict")
                        (("1" (expand "vsAUWRU_case1_acc")
                          (("1" (lift-if 1)
                            (("1" (assert)
                              (("1" (expand "restrict")
                                (("1" (assert) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand "restrict")
                      (("2" (lemma "Integral_split_fun[nnreal]")
                        (("2"
                          (inst -1
                           "LAMBDA(s:nnreal): vsAccelRamp(Sign(v0z!1, goalVs!1) * accel!1,
                                                      tRamp!1)(s)"
                           "                              LAMBDA(s:nnreal):vsAccelConst(0)(s)"
                           "0" "t!1" "tMax" "t!1")
                          (("1" (prop)
                            (("1" (assert) nil nil) ("2" (grind) nil nil)
                             ("3" (grind) nil nil) ("4" (grind) nil nil)
                             ("5" (assert)
                              (("5" (expand "vsAccelRamp")
                                (("5" (lemma "integral_linear[nnreal]")
                                  (("5"
                                    (inst -1 "0" "tMax"
                                     "(Sign(v0z!1, goalVs!1) * accel!1 / tRamp!1)"
                                     "0")
                                    (("5" (assert) (("5" (flatten) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("6" (expand "vsAccelRamp")
                              (("6" (lemma "integral_linear[nnreal]")
                                (("6" (inst -1 "tMax" "t!1" "0" "0")
                                  (("1" (assert)
                                    (("1" (expand "vsAccelConst")
                                      (("1" (assert) nil nil)) nil))
                                    nil)
                                   ("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil) ("3" (grind) nil nil))
                  nil)
                 ("2" (expand "connected?")
                  (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (case1_vel_prep-2 nil 3612197628
   ("" (skosimp*)
    (("" (skoletin)
      (("" (skoletin)
        (("" (lift-if)
          (("" (prop)
            (("1" (expand "vsAUWRU_case1_acc")
              (("1" (lemma "Integral_restr_eq[nnreal]")
                (("1"
                  (inst -1 "0" "t!1" "vsAccelConst(0)" "LAMBDA (t: nnreal):
                          IF v0z!1 = goalVs!1 THEN vsAccelConst(0)(t)
                          ELSE split_fun[nnreal](sqrt(2
                                              *
                                              (abs(goalVs!1 - v0z!1) * tRamp!1)
                                              /
                                              accel!1),
                                         vsAccelRamp(Sign(v0z!1, goalVs!1)
                                                     *
                                                     accel!1,
                                                     tRamp!1),
                                         vsAccelConst(0))
                                        (t)
                          ENDIF")
                  (("1" (prop)
                    (("1" (skosimp*)
                      (("1" (expand "restrict")
                        (("1" (lift-if 1) (("1" (prop) nil nil)) nil)) nil))
                      nil)
                     ("2" (expand "restrict")
                      (("2" (lemma "integral_linear[nnreal]")
                        (("2" (inst -1 "0" "t!1" "0" "0")
                          (("2" (expand "vsAccelConst")
                            (("2" (assert) (("2" (flatten) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten) nil nil) ("3" (prop) nil nil))
                  nil)
                 ("2" (expand "connected?")
                  (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
                nil))
              nil)
             ("2" (case "t!1<=tMax")
              (("1" (lemma "Integral_restr_eq[nnreal]")
                (("1"
                  (inst -1 "0" "t!1"
                   "vsAccelRamp(Sign(v0z!1, goalVs!1)*accel!1, tRamp!1)"
                   "vsAUWRU_case1_acc(v0z!1, goalVs!1, accel!1, tRamp!1)")
                  (("1" (prop)
                    (("1" (skosimp*)
                      (("1" (expand "vsAUWRU_case1_acc")
                        (("1" (lift-if 1)
                          (("1" (prop)
                            (("1" (expand "split_fun")
                              (("1" (lift-if 2)
                                (("1" (typepred (x!1))
                                  (("1" (prop)
                                    (("1" (expand "restrict")
                                      (("1" (assert) nil nil)) nil)
                                     ("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand "restrict")
                      (("2" (expand "vsAccelRamp")
                        (("2" (lemma "integral_linear[nnreal]")
                          (("2"
                            (inst -1 "0" "t!1"
                             "Sign(v0z!1, goalVs!1) * accel!1 / tRamp!1" "0")
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand "Sign")
                    (("2" (assert) (("2" (grind) nil nil)) nil)) nil))
                  nil)
                 ("2" (expand "connected?")
                  (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
                nil)
               ("2" (lemma "Integral_restr_eq[nnreal]")
                (("1"
                  (inst -1 "0" "t!1"
                   "split_fun[nnreal]( tMax, vsAccelRamp(Sign(v0z!1, goalVs!1)*accel!1, tRamp!1), vsAccelConst(0))"
                   "vsAUWRU_case1_acc(v0z!1, goalVs!1, accel!1, tRamp!1)")
                  (("1" (prop)
                    (("1" (skosimp*)
                      (("1" (expand "restrict")
                        (("1" (expand "vsAUWRU_case1_acc")
                          (("1" (lift-if 1)
                            (("1" (assert)
                              (("1" (expand "restrict")
                                (("1" (assert) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand "restrict")
                      (("2" (lemma "Integral_split_fun[nnreal]")
                        (("2"
                          (inst -1
                           "LAMBDA(s:nnreal): vsAccelRamp(Sign(v0z!1, goalVs!1) * accel!1,
                                                      tRamp!1)(s)"
                           "                              LAMBDA(s:nnreal):vsAccelConst(0)(s)"
                           "0" "t!1" "tMax" "t!1")
                          (("1" (prop)
                            (("1" (assert) nil nil) ("2" (grind) nil nil)
                             ("3" (grind) nil nil) ("4" (grind) nil nil)
                             ("5" (assert)
                              (("5" (expand "vsAccelRamp")
                                (("5" (lemma "integral_linear[nnreal]")
                                  (("5"
                                    (inst -1 "0" "tMax"
                                     "(Sign(v0z!1, goalVs!1) * accel!1 / tRamp!1)"
                                     "0")
                                    (("5" (assert) (("5" (flatten) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("6" (expand "vsAccelRamp")
                              (("6" (lemma "integral_linear[nnreal]")
                                (("6" (inst -1 "tMax" "t!1" "0" "0")
                                  (("1" (assert)
                                    (("1" (expand "vsAccelConst")
                                      (("1" (assert) nil nil)) nil))
                                    nil)
                                   ("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert) nil nil)
                           ("3" (expand "Sign") (("3" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil)
                   ("3" (expand "Sign") (("3" (grind) nil nil)) nil)
                   ("4" (grind) nil nil))
                  nil)
                 ("2" (expand "connected?")
                  (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real nonempty-type-from-decl nil reals nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (vsAUWRU_case1_acc const-decl "real" vsAccel nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (Integrable? const-decl "bool" integral_def analysis)
    (nnreal type-eq-decl nil real_types nil)
    (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (<= const-decl "bool" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (width const-decl "posreal" integral_def analysis)
    (integral? const-decl "bool" integral_def analysis)
    (integrable? const-decl "bool" integral_def analysis)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (Integral const-decl "real" integral_def analysis)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (< const-decl "bool" reals nil)
    (Open_interval type-eq-decl nil intervals_real reals)
    (sign_not_zero application-judgement "nzreal" vsAccel nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (tMax skolem-const-decl "real" vsAccel nil)
    (nat_exp application-judgement "nat" exponentiation nil)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (deriv_domain? const-decl "bool" deriv_domain_def analysis)
    (Integral_split_fun formula-decl nil integral_split_fun analysis)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (v0z!1 skolem-const-decl "real" vsAccel nil)
    (goalVs!1 skolem-const-decl "real" vsAccel nil)
    (Sign const-decl "real" vsAccel nil)
    (vsAccelRamp const-decl "real" vsAccel nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (split_fun const-decl "[T -> real]" integral_split_fun analysis)
    (vsAccelConst const-decl "real" vsAccel nil)
    (restrict const-decl "R" restrict nil)
    (not_one_element_nnreal formula-decl nil deriv_domain analysis)
    (deriv_domain_nnreal formula-decl nil deriv_domain analysis)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (abs_nat formula-decl nil abs_lems reals)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (Integral_restr_eq formula-decl nil integral analysis)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil)
  (case1_vel_prep-1 nil 3612175046
   ("" (skosimp*)
    (("" (skoletin)
      (("" (skoletin)
        (("" (lift-if)
          (("" (prop)
            (("1" (expand "vsAUWRU_case1_acc")
              (("1" (lemma "Integral_restr_eq[nnreal]")
                (("1"
                  (inst -1 "0" "t!1" "vsAccelConst(0)" "LAMBDA (t: nnreal):
                    IF v0z!1 = goalVs!1 THEN vsAccelConst(0)(t)
                    ELSE split_fun(sqrt(2
                                        *
                                        (abs(goalVs!1 - v0z!1) * tRamp!1)
                                        /
                                        accel!1),
                                   vsAccelRamp(Sign(v0z!1, goalVs!1)
                                               *
                                               accel!1,
                                               tRamp!1),
                                   vsAccelConst(0))
                                  (t)
                    ENDIF")
                  (("1" (prop)
                    (("1" (skosimp*)
                      (("1" (expand "restrict")
                        (("1" (lift-if 1) (("1" (prop) nil nil)) nil)) nil))
                      nil)
                     ("2" (expand "restrict")
                      (("2" (lemma "integral_linear[nnreal]")
                        (("2" (inst -1 "0" "t!1" "0" "0")
                          (("2" (expand "vsAccelConst")
                            (("2" (assert) (("2" (flatten) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten) nil nil))
                  nil)
                 ("2" (expand "connected?")
                  (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
                nil))
              nil)
             ("2" (case "t!1<=tMax")
              (("1" (lemma "Integral_restr_eq[nnreal]")
                (("1"
                  (inst -1 "0" "t!1"
                   "vsAccelRamp(Sign(v0z!1, goalVs!1)*accel!1, tRamp!1)"
                   "vsAUWRU_case1_acc(v0z!1, goalVs!1, accel!1, tRamp!1)")
                  (("1" (prop)
                    (("1" (skosimp*)
                      (("1" (expand "vsAUWRU_case1_acc")
                        (("1" (lift-if 1)
                          (("1" (prop)
                            (("1" (expand "split_fun")
                              (("1" (lift-if 2)
                                (("1" (typepred (x!1))
                                  (("1" (prop)
                                    (("1" (expand "restrict")
                                      (("1" (propax) nil nil)) nil)
                                     ("2" (assert) nil nil)
                                     ("3" (expand "restrict")
                                      (("3" (propax) nil nil)) nil)
                                     ("4" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand "restrict")
                      (("2" (expand "vsAccelRamp")
                        (("2" (lemma "integral_linear[nnreal]")
                          (("2"
                            (inst -1 "0" "t!1"
                             "Sign(v0z!1, goalVs!1) * accel!1 / tRamp!1" "0")
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand "Sign")
                    (("2" (assert) (("2" (grind) nil nil)) nil)) nil))
                  nil)
                 ("2" (expand "connected?")
                  (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
                nil)
               ("2" (lemma "Integral_restr_eq[nnreal]")
                (("1"
                  (inst -1 "0" "t!1"
                   "split_fun( tMax, vsAccelRamp(Sign(v0z!1, goalVs!1)*accel!1, tRamp!1), vsAccelConst(0))"
                   "vsAUWRU_case1_acc(v0z!1, goalVs!1, accel!1, tRamp!1)")
                  (("1" (prop)
                    (("1" (skosimp*)
                      (("1" (expand "restrict")
                        (("1" (expand "vsAUWRU_case1_acc")
                          (("1" (lift-if 1) (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand "restrict")
                      (("2" (lemma "Integral_split_fun[nnreal]")
                        (("2"
                          (inst -1
                           "LAMBDA(s:nnreal): vsAccelRamp(Sign(v0z!1, goalVs!1) * accel!1,
                                          tRamp!1)(s)" "
                              LAMBDA(s:nnreal):vsAccelConst(0)(s)" "0" "t!1"
                           "tMax" "t!1")
                          (("1" (prop)
                            (("1" (assert)
                              (("1" (assert)
                                (("1" (hide (-2 4)) (("1" (postpone) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil) ("3" (grind) nil nil)
                             ("4" (grind) nil nil) ("5" (assert) nil nil)
                             ("6" (expand "vsAccelRamp")
                              (("6" (lemma "integral_linear[nnreal]")
                                (("6"
                                  (inst -1 "0" "tMax"
                                   "(Sign(v0z!1, goalVs!1) * accel!1 / tRamp!1)"
                                   "0")
                                  (("1" (grind) nil nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("7" (expand "vsAccelConst")
                              (("7" (lemma "integral_linear[nnreal]")
                                (("7" (inst -1 "tMax" "t!1" "0" "0")
                                  (("1" (grind) nil nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert) nil nil)
                           ("3" (expand "Sign") (("3" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand "Sign") (("2" (grind) nil nil)) nil))
                  nil)
                 ("2" (expand "connected?")
                  (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (vsAUWRU_case1_vel_TCC1 0
  (vsAUWRU_case1_vel_TCC1-1 nil 3612172317
   ("" (skosimp*)
    (("" (lemma "case1_vel_prep")
      (("" (inst -1 "v0z!1" "goalVs!1" "accel!1" "tRamp!1" "t!1")
        (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((case1_vel_prep formula-decl nil vsAccel nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nnreal type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil
   (vsAUWRU_case1_vel subtype
    "vsAccel.vsAUWRU_case1_acc(vsAccel.v0z, vsAccel.goalVs, vsAccel.accel, vsAccel.tRamp)"
    "integral_def[nnreal].Integrable_funs(0, vsAccel.t)")))
 (Integral_case1_vel 0
  (Integral_case1_vel-1 nil 3612174244
   ("" (skosimp*)
    (("" (skoletin)
      (("" (expand "vsAUWRU_case1_vel")
        (("" (expand "vsAUWRU_case1_acc")
          (("" (case "v0z!1=goalVs!1")
            (("1" (lemma "Integral_restr_eq[nnreal]")
              (("1"
                (inst -1 "0" "t!1" "vsAccelConst(0)" "LAMBDA (t: nnreal):
                       IF v0z!1 = goalVs!1 THEN vsAccelConst(0)(t)
                     ELSE split_fun[nnreal]
                                (sqrt(2 * (abs(goalVs!1 - v0z!1) * tRamp!1) /
                                      accel!1),
                                 restrict[real, nnreal, real]
                                    (vsAccelRamp(Sign(v0z!1, goalVs!1)
                                                  *
                                                 accel!1,
                                                 tRamp!1)),
                                 restrict[real, nnreal, real](vsAccelConst(0)))
                               (t)
                       ENDIF")
                (("1" (prop)
                  (("1" (hide -1)
                    (("1" (replace -1)
                      (("1" (hide -1)
                        (("1" (expand "restrict")
                          (("1" (lemma "integral_linear[nnreal]")
                            (("1" (inst -1 "0" "t!1" "0" "0")
                              (("1" (skoletin)
                                (("1" (flatten)
                                  (("1" (skoletin)
                                    (("1" (simplify -)
                                      (("1"
                                        (replace -2)
                                        (("1"
                                          (simplify -)
                                          (("1"
                                            (expand "vsAccelConst")
                                            (("1"
                                              (simplify)
                                              (("1"
                                                (replace -4)
                                                (("1"
                                                  (replace -1)
                                                  (("1"
                                                    (hide (-1 -2 -3 -4))
                                                    (("1" (grind) nil nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 2)
                    (("2" (skosimp*)
                      (("2" (expand "restrict")
                        (("2" (lift-if) (("2" (prop) nil nil)) nil)) nil))
                      nil))
                    nil)
                   ("3" (hide 2)
                    (("3" (lemma "integral_linear[nnreal]")
                      (("3" (inst -1 "0" "t!1" "0" "0")
                        (("3" (expand "restrict")
                          (("3" (expand "vsAccelConst")
                            (("3" (skoletin)
                              (("3" (flatten)
                                (("3" (replace -3)
                                  (("3" (simplify -) (("3" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten) nil nil))
                nil)
               ("2" (expand "connected?")
                (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
              nil)
             ("2"
              (case "t!1<=sqrt(2 * (abs(goalVs!1 - v0z!1) * tRamp!1) /
                                          accel!1)")
              (("1" (lemma "Integral_restr_eq[nnreal]")
                (("1"
                  (inst -1 "0" "t!1" "restrict[real, nnreal, real]
                                       (vsAccelRamp(Sign(v0z!1, goalVs!1)
                                                    *
                                                    accel!1,
                                                    tRamp!1))"
                   "LAMBDA (t: nnreal):
                         IF v0z!1 = goalVs!1 THEN vsAccelConst(0)(t)
                         ELSE split_fun[nnreal]
                                  (sqrt(2 * (abs(goalVs!1 - v0z!1) * tRamp!1) /
                                         accel!1),
                                   restrict[real, nnreal, real]
                                       (vsAccelRamp(Sign(v0z!1, goalVs!1)
                                                    *
                                                    accel!1,
                                                    tRamp!1)),
                                   restrict[real, nnreal, real](vsAccelConst(0)))
                                  (t)
                         ENDIF")
                  (("1" (lemma "Int_ramp_vel2")
                    (("1"
                      (inst -1 "Sign(v0z!1, goalVs!1) * accel!1" "tRamp!1"
                       "t!1")
                      (("1" (flatten)
                        (("1" (prop)
                          (("1" (replace -2)
                            (("1" (expand "restrict")
                              (("1" (replace -4)
                                (("1" (lift-if 2)
                                  (("1" (prop)
                                    (("1" (hide (-2 -3 -4 -5))
                                      (("1" (grind) nil nil)) nil)
                                     ("2" (split-ineq -5)
                                      (("2"
                                        (lemma "sq_sqrt")
                                        (("2"
                                          (mult-eq -2 -2)
                                          (("2"
                                            (inst
                                             -2
                                             "2 * (abs(goalVs!1 - v0z!1) * tRamp!1) / accel!1")
                                            (("2"
                                              (prop)
                                              (("1"
                                                (expand "sq")
                                                (("1"
                                                  (replace -1)
                                                  (("1"
                                                    (hide (-4 -5 -6 -7))
                                                    (("1"
                                                      (expand "^")
                                                      (("1"
                                                        (expand "expt")
                                                        (("1"
                                                          (expand "expt")
                                                          (("1"
                                                            (expand "expt")
                                                            (("1"
                                                              (expand "Sign")
                                                              (("1"
                                                                (expand "abs")
                                                                (("1"
                                                                  (lift-if)
                                                                  (("1"
                                                                    (split)
                                                                    (("1"
                                                                      (flatten)
                                                                      (("1"
                                                                        (prop)
                                                                        (("1"
                                                                          (grind)
                                                                          nil
                                                                          nil)
                                                                         ("2"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (flatten)
                                                                      (("2"
                                                                        (prop)
                                                                        (("1"
                                                                          (grind)
                                                                          nil
                                                                          nil)
                                                                         ("2"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2" (cross-mult) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide (-1 -2 3))
                            (("2" (skosimp*)
                              (("2" (expand "restrict")
                                (("2" (lift-if 1)
                                  (("2" (prop)
                                    (("2" (expand "split_fun")
                                      (("2"
                                        (lift-if)
                                        (("2"
                                          (typepred (x!1))
                                          (("2"
                                            (prop)
                                            (("1" (assert) nil nil)
                                             ("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("3" (expand "restrict") (("3" (propax) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand "Sign")
                    (("2" (flatten)
                      (("2" (expand "connected?")
                        (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "connected?")
                  (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
                nil)
               ("2" (lemma "Integral_split_fun[nnreal]")
                (("1"
                  (inst -1 "restrict[real, nnreal, real]
                                       (vsAccelRamp(Sign(v0z!1, goalVs!1)
                                                    *
                                                    accel!1,
                                                    tRamp!1))"
                   "restrict[real, nnreal, real](vsAccelConst(0))" "0" "t!1"
                   "sqrt(2 * (abs(goalVs!1 - v0z!1) * tRamp!1) /
                                         accel!1)" "t!1")
                  (("1" (lemma "Int_ramp_vel2")
                    (("1"
                      (inst -1 "Sign(v0z!1, goalVs!1)*accel!1" "tRamp!1"
                       "sqrt(2 * (abs(goalVs!1 - v0z!1) * tRamp!1) /
                                       accel!1)")
                      (("1" (lemma "Int_const_vel2")
                        (("1"
                          (inst -1 "0"
                           "sqrt(2 * (abs(goalVs!1 - v0z!1) * tRamp!1) /
                                         accel!1)" "t!1")
                          (("1" (flatten)
                            (("1" (prop)
                              (("1" (expand "restrict")
                                (("1" (lift-if -2)
                                  (("1" (prop)
                                    (("1" (replace -4)
                                      (("1"
                                        (replace -6)
                                        (("1"
                                          (lemma "Integral_restr_eq[nnreal]")
                                          (("1"
                                            (inst
                                             -1
                                             "0"
                                             "t!1"
                                             "split_fun(sqrt(2 * (abs(goalVs!1 - v0z!1) * tRamp!1) /
                                             accel!1),
                                       LAMBDA (s: nnreal):
                                         vsAccelRamp(Sign(v0z!1, goalVs!1) * accel!1,
                                                     tRamp!1)
                                                    (s),
                                       LAMBDA (s: nnreal): vsAccelConst(0)(s))"
                                             "LAMBDA (t: nnreal):
                               IF v0z!1 = goalVs!1 THEN vsAccelConst(0)(t)
                               ELSE split_fun[nnreal]
                                        (sqrt(2 * (abs(goalVs!1 - v0z!1) * tRamp!1) /
                                               accel!1),
                                         LAMBDA (s: nnreal):
                                           vsAccelRamp(Sign(v0z!1, goalVs!1) * accel!1,
                                                       tRamp!1)
                                                      (s),
                                         LAMBDA (s: nnreal): vsAccelConst(0)(s))
                                        (t)
                               ENDIF")
                                            (("1"
                                              (prop)
                                              (("1"
                                                (replace -2)
                                                (("1"
                                                  (replace -3)
                                                  (("1"
                                                    (replace -9)
                                                    (("1"
                                                      (hide -)
                                                      (("1" (grind) nil nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (skeep)
                                                (("2"
                                                  (lift-if 1)
                                                  (("2"
                                                    (split 1)
                                                    (("1" (flatten) nil nil)
                                                     ("2" (propax) nil nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (expand "connected?")
                                                (("2"
                                                  (skeep)
                                                  (("2" (ground) nil nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("3"
                                              (expand "connected?")
                                              (("3"
                                                (skosimp*)
                                                (("3" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (ground) nil nil) ("3" (ground) nil nil)
                               ("4" (ground) nil nil) ("5" (ground) nil nil)
                               ("6" (expand "restrict")
                                (("6" (propax) nil nil)) nil)
                               ("7" (expand "restrict")
                                (("7" (propax) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "connected?")
                  (("2" (skeep) (("2" (ground) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (vsAUWRU_case1_vel const-decl "real" vsAccel nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Sign const-decl "real" vsAccel nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (^ const-decl "real" exponentiation nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (sign_not_zero application-judgement "nzreal" vsAccel nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (vsAUWRU_case1_acc const-decl "real" vsAccel nil)
    (<= const-decl "bool" reals nil) (sq const-decl "nonneg_real" sq reals)
    (div_mult_pos_ge1 formula-decl nil real_props nil)
    (sq_sqrt formula-decl nil sqrt reals)
    (nnreal_expt application-judgement "nnreal" exponentiation nil)
    (Open_interval type-eq-decl nil intervals_real reals)
    (Int_ramp_vel2 formula-decl nil vsAccel nil)
    (Int_const_vel2 formula-decl nil vsAccel nil)
    (deriv_domain? const-decl "bool" deriv_domain_def analysis)
    (Integral_split_fun formula-decl nil integral_split_fun analysis)
    (Integral_restr_eq formula-decl nil integral analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (expt def-decl "real" exponentiation nil)
    (sqrt_0 formula-decl nil sqrt reals)
    (Integral const-decl "real" integral_def analysis)
    (Integrable_funs type-eq-decl nil integral_def analysis)
    (Integrable? const-decl "bool" integral_def analysis)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (deriv_domain_nnreal formula-decl nil deriv_domain analysis)
    (not_one_element_nnreal formula-decl nil deriv_domain analysis)
    (restrict const-decl "R" restrict nil)
    (vsAccelConst const-decl "real" vsAccel nil)
    (split_fun const-decl "[T -> real]" integral_split_fun analysis)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (vsAccelRamp const-decl "real" vsAccel nil)
    (goalVs!1 skolem-const-decl "real" vsAccel nil)
    (v0z!1 skolem-const-decl "real" vsAccel nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   shostak))
 (case1_pos_prep 0
  (case1_pos_prep-1 nil 3612274535
   ("" (skosimp*)
    (("" (skoletin)
      (("" (skoletin)
        (("" (lemma "Integral_restr_eq[nnreal]")
          (("1"
            (inst -1 "0" "t!1"
             "LAMBDA(t:nnreal):IF t< sqrt(2*tRamp!1*deltaV/accel!1) THEN
                    v0z!1 + (Sign(v0z!1, goalVs!1)*accel!1/2)*t^2/tRamp!1
                 ELSE  goalVs!1
     	    ENDIF" "vsAUWRU_case1_vel(v0z!1, goalVs!1, accel!1, tRamp!1)")
            (("1" (prop)
              (("1" (skosimp*)
                (("1" (lemma "Integral_case1_vel")
                  (("1" (inst -1 "v0z!1" "goalVs!1" "accel!1" "tRamp!1" "x!1")
                    (("1" (skoletin)
                      (("1" (replace -1)
                        (("1" (lift-if)
                          (("1" (lift-if 1)
                            (("1" (prop)
                              (("1" (lift-if 2)
                                (("1" (prop)
                                  (("1" (assert) (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (assert) nil nil)
                               ("3" (assert) (("3" (assert) nil nil)) nil)
                               ("4" (assert) nil nil) ("5" (assert) nil nil)
                               ("6" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (case "t!1<=sqrt(2 * tRamp!1 * deltaV / accel!1)")
                (("1" (lemma "Integral_restr_eq[nnreal]")
                  (("1"
                    (inst -1 "0" "t!1" "LAMBDA (t:nnreal): v0z!1 +
                                    (Sign(v0z!1, goalVs!1) * accel!1 / 2) * t ^ 2 /
                                     tRamp!1" "LAMBDA (t: nnreal):
                            IF t < sqrt(2 * tRamp!1 * deltaV / accel!1)
                              THEN v0z!1 +
                                    (Sign(v0z!1, goalVs!1) * accel!1 / 2) * t ^ 2 /
                                     tRamp!1
                            ELSE goalVs!1
                            ENDIF")
                    (("1" (prop)
                      (("1" (skosimp*)
                        (("1" (lift-if 1)
                          (("1" (typepred (x!1))
                            (("1" (assert)
                              (("1" (flatten) (("1" (assert) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (lemma "integral_quadratic[nnreal]")
                        (("2"
                          (inst -1 "0" "t!1"
                           "Sign(v0z!1, goalVs!1) * accel!1 / (2* tRamp!1)"
                           "0" "v0z!1")
                          (("2" (flatten) (("2" (assert) nil nil)) nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (lemma "Integral_restr_eq[nnreal]")
                  (("2" (lemma "Integral_split[nnreal]")
                    (("2"
                      (inst-cp -2 "0" "sqrt(2 * tRamp!1 * deltaV / accel!1)"
                       "LAMBDA (t:nnreal):v0z!1 +
                                    (Sign(v0z!1, goalVs!1) * accel!1 / 2) * t ^ 2 /
                                     tRamp!1" "LAMBDA (t: nnreal):
                            IF t < sqrt(2 * tRamp!1 * deltaV / accel!1)
                              THEN v0z!1 +
                                    (Sign(v0z!1, goalVs!1) * accel!1 / 2) * t ^ 2 /
                                     tRamp!1
                            ELSE goalVs!1
                            ENDIF")
                      (("2" (prop)
                        (("1"
                          (inst -4 "sqrt(2 * tRamp!1 * deltaV / accel!1)"
                           "t!1" "LAMBDA (t:nnreal): goalVs!1"
                           "LAMBDA (t: nnreal):
                              IF t < sqrt(2 * tRamp!1 * deltaV / accel!1)
                                THEN v0z!1 +
                                      (Sign(v0z!1, goalVs!1) * accel!1 / 2) * t ^ 2 /
                                       tRamp!1
                              ELSE goalVs!1
                              ENDIF")
                          (("1" (prop)
                            (("1"
                              (inst -5 "0"
                               "sqrt(2 * tRamp!1 * deltaV / accel!1)" "t!1"
                               "LAMBDA (t: nnreal):
                                IF t < sqrt(2 * tRamp!1 * deltaV / accel!1)
                                  THEN v0z!1 +
                                        (Sign(v0z!1, goalVs!1) * accel!1 / 2) * t ^ 2 /
                                         tRamp!1
                                ELSE goalVs!1
                                ENDIF")
                              (("1" (prop) nil nil)) nil)
                             ("2" (skosimp*)
                              (("2" (lift-if 1)
                                (("2" (typepred (x!1))
                                  (("2" (prop)
                                    (("1" (assert) nil nil)
                                     ("2" (assert) nil nil)
                                     ("3" (assert) nil nil)
                                     ("4" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("3" (lemma "integral_linear[nnreal]")
                              (("3"
                                (inst -1
                                 "sqrt(2 * tRamp!1 * deltaV / accel!1)" "t!1"
                                 "0" "goalVs!1")
                                (("3" (skoletin)
                                  (("3" (flatten)
                                    (("3" (replace -3)
                                      (("3"
                                        (simplify -1)
                                        (("3" (ground) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skosimp*)
                          (("2" (lift-if 1)
                            (("2" (typepred (x!1))
                              (("2" (assert) (("2" (prop) nil nil)) nil))
                              nil))
                            nil))
                          nil)
                         ("3" (lemma "integral_quadratic[nnreal]")
                          (("3"
                            (inst -1 "0"
                             "sqrt(2 * tRamp!1 * deltaV / accel!1)"
                             "Sign(v0z!1, goalVs!1) * accel!1 / (2* tRamp!1)"
                             "0" "v0z!1")
                            (("3" (flatten) (("3" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand "connected?")
            (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real nonempty-type-from-decl nil reals nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (vsAUWRU_case1_vel const-decl "real" vsAccel nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (Integrable? const-decl "bool" integral_def analysis)
    (nnreal type-eq-decl nil real_types nil)
    (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (Integral_restr_eq formula-decl nil integral analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (Integral_case1_vel formula-decl nil vsAccel nil)
    (sign_not_zero application-judgement "nzreal" vsAccel nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (abs_nat formula-decl nil abs_lems reals)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Open_interval type-eq-decl nil intervals_real reals)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (Integrable_funs type-eq-decl nil integral_def analysis)
    (Integral const-decl "real" integral_def analysis)
    (Integral_split formula-decl nil integral analysis)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nat_exp application-judgement "nat" exponentiation nil)
    (integral_quadratic formula-decl nil table_of_integrals analysis)
    (< const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Sign const-decl "real" vsAccel nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (^ const-decl "real" exponentiation nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   shostak))
 (vsAUWRU_case1_pos_TCC1 0
  (vsAUWRU_case1_pos_TCC1-1 nil 3612172317
   ("" (skosimp*)
    (("" (lemma "case1_pos_prep")
      (("" (inst -1 "v0z!1" "v0z!1" "goalVs!1" "accel!1" "tRamp!1" "t!1")
        (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((case1_pos_prep formula-decl nil vsAccel nil)
    (Integrable? const-decl "bool" integral_def analysis)
    (integrable? const-decl "bool" integral_def analysis)
    (integral? const-decl "bool" integral_def analysis)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (width const-decl "posreal" integral_def analysis)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil
   (vsAUWRU_case1_pos subtype
    "vsAccel.vsAUWRU_case1_vel(vsAccel.v0z, vsAccel.goalVs, vsAccel.accel, vsAccel.tRamp)"
    "integral_def[nnreal].Integrable_funs(0, vsAccel.t)")))
 (Integral_case1_pos_TCC1 0
  (Integral_case1_pos_TCC1-1 nil 3612273936 ("" (subtype-tcc) nil nil)
   ((real_minus_real_is_real application-judgement "real" reals nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil))
   nil
   (Integral_case1_pos subtype "3"
    "{i: integers.int | booleans.OR((booleans.NOT)(sqrt.sqrt(number_fields./(number_fields.*(2, number_fields.*(vsAccel.deltaV, vsAccel.tRamp)), vsAccel.accel)) = 0), reals.>=(i, 0))}")))
 (Integral_case1_pos 0
  (Integral_case1_pos-4 nil 3612534160
   ("" (skosimp*)
    (("" (skoletin)
      (("" (expand "vsAUWRU_case1_pos")
        (("" (case "t!1 <  sqrt(2 * (deltaV * tRamp!1) / accel!1)")
          (("1" (lemma "Integral_restr_eq[nnreal]")
            (("1"
              (inst -1 "0" "t!1"
               "LAMBDA(t:nnreal):v0z!1 + (Sign(v0z!1, goalVs!1)*accel!1/2)*t^2/tRamp!1"
               "vsAUWRU_case1_vel(v0z!1, goalVs!1, accel!1, tRamp!1)")
              (("1" (lemma "integral_quadratic[nnreal]")
                (("1"
                  (inst -1 "0" "t!1"
                   "Sign(v0z!1, goalVs!1) * accel!1 /( 2*  tRamp!1)" "0"
                   "v0z!1")
                  (("1" (flatten)
                    (("1" (skoletin)
                      (("1" (prop)
                        (("1" (replace -2)
                          (("1" (assert)
                            (("1" (assert)
                              (("1" (replace -4)
                                (("1" (assert)
                                  (("1" (lemma "Integral_restr_eq[nnreal]")
                                    (("1"
                                      (inst
                                       -1
                                       "0"
                                       "t!1"
                                       "LAMBDA (x: nnreal):
                                         Sign(v0z!1, goalVs!1) * accel!1 / (2 * tRamp!1) * x ^ 2 +
                                          v0z!1"
                                       " LAMBDA (t: nnreal):
                                         (Sign(v0z!1, goalVs!1) * accel!1 / 2) * t ^ 2 / tRamp!1
                                          + v0z!1")
                                      (("1"
                                        (prop)
                                        (("1"
                                          (replace -2)
                                          (("1"
                                            (replace -5)
                                            (("1"
                                              (hide -)
                                              (("1" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (skosimp*)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (lemma "Integral_case1_vel")
                          (("2" (skosimp*)
                            (("2"
                              (inst -1 "v0z!1" "goalVs!1" "accel!1" "tRamp!1"
                               "x!1")
                              (("2" (assert)
                                (("2" (replace -1)
                                  (("2" (lift-if)
                                    (("2" (assert)
                                      (("2"
                                        (prop)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (typepred (x!1))
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (lift-if)
                          (("3" (prop)
                            (("3"
                              (case-replace "(LAMBDA (t: nnreal):
                            v0z!1 +
                             (Sign(v0z!1, goalVs!1) * accel!1 / 2) * t ^ 2 /
                              tRamp!1) = (LAMBDA (x: nnreal):
                            Sign(v0z!1, goalVs!1) * accel!1 / (2 * tRamp!1) * x ^ 2
                             + 0 * x
                             + v0z!1)")
                              (("3" (decompose-equality 1) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand "connected?")
              (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
            nil)
           ("2" (lift-if 2)
            (("2" (prop)
              (("2" (lemma "Integral_split[nnreal]")
                (("1"
                  (case-replace
                   "vsAUWRU_case1_vel(v0z!1, goalVs!1, accel!1, tRamp!1) = LAMBDA (t:nnreal):
       IF t< sqrt(2*tRamp!1*deltaV/accel!1) THEN
                      v0z!1 + (Sign(v0z!1, goalVs!1)*accel!1/2)*t^2/tRamp!1
                   ELSE
                      goalVs!1
       	    ENDIF")
                  (("1" (hide -1)
                    (("1" (lemma "Integral_restr_eq[nnreal]")
                      (("1"
                        (inst-cp -1 "0"
                         "sqrt(2 * (deltaV * tRamp!1) / accel!1)"
                         "LAMBDA(t:nnreal): v0z!1 +
                                 (Sign(v0z!1, goalVs!1) * accel!1 / 2) * t ^ 2 /
                                  tRamp!1" "LAMBDA (t: nnreal):
                         IF t < sqrt(2 * tRamp!1 * deltaV / accel!1)
                           THEN v0z!1 +
                                 (Sign(v0z!1, goalVs!1) * accel!1 / 2) * t ^ 2 /
                                  tRamp!1
                         ELSE goalVs!1
                         ENDIF")
                        (("1"
                          (case-replace "(LAMBDA (t: nnreal):
                            v0z!1 +
                             (Sign(v0z!1, goalVs!1) * accel!1 / 2) * t ^ 2 /
                              tRamp!1) = LAMBDA (t: nnreal):
                            v0z!1 +
                             (Sign(v0z!1, goalVs!1) * accel!1 / (2*tRamp!1)) * t ^ 2")
                          (("1"
                            (case-replace "(LAMBDA (t: nnreal):
                              v0z!1 +
                               (Sign(v0z!1, goalVs!1) * accel!1 / 2) * t ^ 2 /
                                tRamp!1) = LAMBDA (t: nnreal):
                              v0z!1 +
                               (Sign(v0z!1, goalVs!1) * accel!1 / (2*tRamp!1)) * t ^ 2")
                            (("1" (lemma "integral_quadratic[nnreal]")
                              (("1"
                                (inst -1 "0"
                                 "sqrt(2 * tRamp!1 * deltaV / accel!1)"
                                 "(Sign(v0z!1, goalVs!1) * accel!1 / (2 * tRamp!1))"
                                 "0" "v0z!1")
                                (("1" (flatten)
                                  (("1" (prop)
                                    (("1"
                                      (inst
                                       -6
                                       "sqrt(2 * tRamp!1 * deltaV / accel!1)"
                                       "t!1"
                                       "LAMBDA (t:nnreal): goalVs!1"
                                       " LAMBDA (t: nnreal):
                             IF t < sqrt(2 * tRamp!1 * deltaV / accel!1)
                               THEN v0z!1 +
                                     (Sign(v0z!1, goalVs!1) * accel!1 / 2) * t ^ 2 /
                                      tRamp!1
                             ELSE goalVs!1
                             ENDIF")
                                      (("1"
                                        (lemma "integral_linear[nnreal]")
                                        (("1"
                                          (inst
                                           -1
                                           "sqrt(2 * (deltaV * tRamp!1) / accel!1)"
                                           "t!1"
                                           "0"
                                           "goalVs!1")
                                          (("1"
                                            (skoletin)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (prop)
                                                (("1"
                                                  (inst
                                                   -11
                                                   "0"
                                                   "sqrt(2 * tRamp!1 * deltaV / accel!1)"
                                                   "t!1"
                                                   "LAMBDA (t: nnreal):
                               IF t < sqrt(2 * tRamp!1 * deltaV / accel!1)
                                 THEN v0z!1 +
                                       (Sign(v0z!1, goalVs!1) * accel!1 / 2) * t ^ 2 /
                                        tRamp!1
                               ELSE goalVs!1
                               ENDIF")
                                                  (("1"
                                                    (prop)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (replace -2 :dir rl)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (replace -11)
                                                            (("1"
                                                              (replace -9)
                                                              (("1"
                                                                (replace -4)
                                                                (("1"
                                                                  (replace -7)
                                                                  (("1"
                                                                    (replace
                                                                     -6)
                                                                    (("1"
                                                                      (hide -)
                                                                      (("1"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2" (assert) nil nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (skosimp*)
                                                  (("2"
                                                    (lift-if 1)
                                                    (("2"
                                                      (typepred (x!1))
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (flatten)
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("3" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (skosimp*)
                                      (("2"
                                        (lift-if 1)
                                        (("2"
                                          (typepred (x!1))
                                          (("2"
                                            (prop)
                                            (("1" (assert) nil nil)
                                             ("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("3" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (decompose-equality 1) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (decompose-equality 1)
                    (("2" (lemma "Integral_case1_vel")
                      (("2"
                        (inst -1 "v0z!1" "goalVs!1" "accel!1" "tRamp!1" "x!1")
                        (("2" (skoletin)
                          (("2" (replace -1)
                            (("2" (ground)
                              (("2" (assert)
                                (("2" (hide-all-but 1) (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "connected?")
                  (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (vsAUWRU_case1_pos const-decl "real" vsAccel nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Sign const-decl "real" vsAccel nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (^ const-decl "real" exponentiation nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (sign_not_zero application-judgement "nzreal" vsAccel nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (vsAUWRU_case1_vel const-decl "real" vsAccel nil)
    (Integrable? const-decl "bool" integral_def analysis)
    (nat_exp application-judgement "nat" exponentiation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Integrable_funs type-eq-decl nil integral_def analysis)
    (Integral const-decl "real" integral_def analysis)
    (Integral_case1_vel formula-decl nil vsAccel nil)
    (Open_interval type-eq-decl nil intervals_real reals)
    (<= const-decl "bool" reals nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (expt def-decl "real" exponentiation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nnreal_expt application-judgement "nnreal" exponentiation nil)
    (nat_expt application-judgement "nat" exponentiation nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (integral_quadratic formula-decl nil table_of_integrals analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (Integral_restr_eq formula-decl nil integral analysis)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (Integral_split formula-decl nil integral analysis)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil)
  (Integral_case1_pos-3 nil 3612533910
   ("" (skosimp*)
    (("" (skoletin)
      (("" (expand "vsAUWRU_case1_pos")
        (("" (case "t!1 <  sqrt(2 * (deltaV * tRamp!1) / accel!1)")
          (("1" (lemma "Integral_restr_eq[nnreal]")
            (("1"
              (inst -1 "0" "t!1"
               "LAMBDA(t:nnreal):v0z!1 + (Sign(v0z!1, goalVs!1)*accel!1/2)*t!1^2/tRamp!1"
               "vsAUWRU_case1_vel(v0z!1, goalVs!1, accel!1, tRamp!1)")
              (("1" (lemma "integral_quadratic[nnreal]")
                (("1"
                  (inst -1 "0" "t!1"
                   "Sign(v0z!1, goalVs!1) * accel!1 /( 2*  tRamp!1)" "0"
                   "v0z!1")
                  (("1" (flatten)
                    (("1" (skoletin)
                      (("1" (prop)
                        (("1" (replace -2)
                          (("1" (assert)
                            (("1" (assert)
                              (("1" (replace -4)
                                (("1" (assert)
                                  (("1" (lemma "Integral_restr_eq[nnreal]")
                                    (("1"
                                      (inst
                                       -1
                                       "0"
                                       "t!1"
                                       "LAMBDA (x: nnreal):
                         Sign(v0z!1, goalVs!1) * accel!1 / (2 * tRamp!1) * x ^ 2 +
                          v0z!1"
                                       " LAMBDA (t: nnreal):
                         (Sign(v0z!1, goalVs!1) * accel!1 / 2) * t ^ 2 / tRamp!1
                          + v0z!1")
                                      (("1"
                                        (prop)
                                        (("1"
                                          (replace -2)
                                          (("1"
                                            (replace -5)
                                            (("1" (grind) nil)))))
                                         ("2" (postpone) nil)))))))))))))))))
                         ("2" (postpone) nil) ("3" (postpone) nil)))))))))))))
             ("2" (expand "connected?")
              (("2" (skosimp*) (("2" (assert) nil)))))))
           ("2" (postpone) nil))))))))
    nil)
   nil nil)
  (Integral_case1_pos-2 nil 3612533130
   ("" (skosimp*)
    (("" (skoletin)
      (("" (expand "vsAUWRU_case1_pos")
        (("" (case "t!1 <  sqrt(2 * (deltaV * tRamp!1) / accel!1)")
          (("1" (lemma "Integral_restr_eq[nnreal]")
            (("1"
              (inst -1 "0" "t!1"
               "LAMBDA(t:nnreal):v0z!1 + (Sign(v0z!1, goalVs!1)*accel!1/2)*t!1^2/tRamp!1"
               "vsAUWRU_case1_vel(v0z!1, goalVs!1, accel!1, tRamp!1)")
              (("1" (lemma "integral_quadratic[nnreal]")
                (("1"
                  (inst -1 "0" "t!1"
                   "Sign(v0z!1, goalVs!1) * accel!1 /( 2*  tRamp!1)" "0"
                   "v0z!1")
                  (("1" (flatten)
                    (("1" (skoletin)
                      (("1" (prop)
                        (("1" (replace -2)
                          (("1" (assert)
                            (("1" (assert)
                              (("1" (replace -4)
                                (("1" (assert)
                                  (("1" (lemma "Integral_restr_eq[nnreal]")
                                    (("1"
                                      (inst
                                       -1
                                       "0"
                                       "t!1"
                                       "LAMBDA (x: nnreal):
                 Sign(v0z!1, goalVs!1) * accel!1 / (2 * tRamp!1) * x ^ 2 +
                  v0z!1"
                                       " LAMBDA (t: nnreal):
                 (Sign(v0z!1, goalVs!1) * accel!1 / 2) * t!1 ^ 2 / tRamp!1
                  + v0z!1")
                                      (("1"
                                        (prop)
                                        (("1"
                                          (replace -2)
                                          (("1"
                                            (replace -5)
                                            (("1" (grind) nil nil))
                                            nil))
                                          nil)
                                         ("2" (postpone) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (postpone) nil nil) ("3" (postpone) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand "connected?")
              (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
            nil)
           ("2" (postpone) nil nil))
          nil))
        nil))
      nil))
    nil)
   nil nil)
  (Integral_case1_pos-1 nil 3612531465
   ("" (skosimp*)
    (("" (skoletin)
      (("" (expand "vsAUWRU_case1_pos")
        (("" (case "t!1 <=  sqrt(2 * (deltaV * tRamp!1) / accel!1)")
          (("1" (lemma "Integral_restr_eq[nnreal]")
            (("1"
              (inst -1 "0" "t!1"
               "LAMBDA(t:nnreal):v0z!1 + (Sign(v0z!1, goalVs!1)*accel!1/2)*t!1^2/tRamp!1"
               "vsAUWRU_case1_vel(v0z!1, goalVs!1, accel!1, tRamp!1)")
              (("1" (lemma "integral_quadratic[nnreal]")
                (("1"
                  (inst -1 "0" "t!1"
                   "Sign(v0z!1, goalVs!1) * accel!1 /( 2*  tRamp!1)" "0"
                   "v0z!1")
                  (("1" (flatten)
                    (("1" (skoletin)
                      (("1" (prop)
                        (("1" (replace -2)
                          (("1" (assert)
                            (("1" (assert)
                              (("1" (lift-if 1) (("1" (postpone) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (postpone) nil nil) ("3" (postpone) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand "connected?")
              (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
            nil)
           ("2" (postpone) nil nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (vsAUWRU_acc_TCC1 0
  (vsAUWRU_acc_TCC1-1 nil 3612608074
   ("" (skosimp*)
    (("" (expand "deriv_domain?")
      (("" (skosimp*)
        (("" (inst 2 "e!1/2") (("" (assert) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((real_plus_real_is_real application-judgement "real" reals nil)
    (deriv_domain? const-decl "bool" deriv_domain_def analysis)
    (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnreal type-eq-decl nil real_types nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}"
     real_defs nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil
   (vsAUWRU_acc assuming
    "analysis@integral_split_fun[nnreal].integral_split_fun"
    "deriv_domain: ASSUMPTION deriv_domain_def[T].deriv_domain?")))
 (case2_vel_prep 0
  (case2_vel_prep-1 nil 3612608078
   ("" (skosimp*)
    (("" (case "abs(goalVs!1-v0z!1)<=accel!1*tRamp!1/2")
      (("1"
        (case-replace "vsAUWRU_acc(v0z!1, goalVs!1, accel!1, tRamp!1) =
     vsAUWRU_case1_acc(v0z!1, goalVs!1, accel!1, tRamp!1)")
        (("1" (lemma "case1_vel_prep")
          (("1" (inst -1 "v0z!1" "goalVs!1" "accel!1" "tRamp!1" "t!1")
            (("1" (skoletin) (("1" (skoletin) nil nil)) nil)) nil))
          nil)
         ("2" (decompose-equality 1)
          (("2" (expand "vsAUWRU_acc") (("2" (propax) nil nil)) nil)) nil))
        nil)
       ("2"
        (case-replace
         "vsAUWRU_acc(v0z!1, goalVs!1, accel!1, tRamp!1)= split_fun2[nnreal]
                                 (tRamp!1,
                                  (abs(goalVs!1 - v0z!1) +
                                    (accel!1 / 2) * tRamp!1)
                                   / accel!1,
                                  restrict[real, nnreal, real]
                                      (vsAccelRamp(Sign(v0z!1, goalVs!1)
                                                   *
                                                   accel!1,
                                                   tRamp!1)),
                                  restrict[real, nnreal, real]
                                      (vsAccelConst(Sign(v0z!1, goalVs!1)
                                                    *
                                                    accel!1)),
                                  restrict[real, nnreal, real](vsAccelConst(0)))")
        (("1" (hide -1)
          (("1"
            (name "MAX"
                  "max(t!1, max(tRamp!1,(abs(goalVs!1 - v0z!1) + (accel!1 / 2) * tRamp!1) /
                                   accel!1))")
            (("1"
              (case "in_order?[nnreal](0, tRamp!1,  (abs(goalVs!1 - v0z!1) + (accel!1 / 2) * tRamp!1) / accel!1, MAX)")
              (("1" (expand "restrict")
                (("1" (lemma "Int_ramp_vel2")
                  (("1"
                    (inst -1 "Sign(v0z!1, goalVs!1) * accel!1" "tRamp!1"
                     "tRamp!1")
                    (("1" (flatten)
                      (("1" (hide -2)
                        (("1" (lemma "Int_const_vel2")
                          (("1"
                            (inst-cp -1 "Sign(v0z!1, goalVs!1) * accel!1"
                             "tRamp!1"
                             " (abs(goalVs!1 - v0z!1) + (accel!1 / 2) * tRamp!1) /
                                accel!1")
                            (("1"
                              (inst -1 "0"
                               "(abs(goalVs!1 - v0z!1) + (accel!1 / 2) * tRamp!1) /
                                accel!1" "MAX")
                              (("1" (flatten)
                                (("1" (hide (-2 -4))
                                  (("1"
                                    (lemma "split_fun2_Integrable[nnreal]")
                                    (("1"
                                      (inst
                                       -1
                                       " LAMBDA (s: nnreal):
                                 vsAccelRamp(Sign(v0z!1, goalVs!1) * accel!1,
                                             tRamp!1)
                                            (s)"
                                       "                       LAMBDA (s: nnreal):
                                 vsAccelConst(Sign(v0z!1, goalVs!1) * accel!1)(s)"
                                       "                       LAMBDA (s: nnreal): vsAccelConst(0)(s) "
                                       "0"
                                       "MAX"
                                       "tRamp!1"
                                       "(abs(goalVs!1 - v0z!1) + (accel!1 / 2) * tRamp!1) /
                                accel!1")
                                      (("1"
                                        (assert)
                                        (("1"
                                          (lemma "Integrable?_inside[nnreal]")
                                          (("1"
                                            (inst
                                             -1
                                             "0"
                                             "MAX"
                                             "split_fun2[nnreal]
                              (tRamp!1, (abs(goalVs!1 - v0z!1) + (accel!1 / 2) * tRamp!1) /
                                accel!1, LAMBDA (s: nnreal):
                                 vsAccelRamp(Sign(v0z!1, goalVs!1) * accel!1,
                                            tRamp!1)
                                            (s), LAMBDA (s: nnreal):
                                 vsAccelConst(Sign(v0z!1, goalVs!1) * accel!1)(s),
                              LAMBDA (s: nnreal): vsAccelConst(0)(s))"
                                             "0"
                                             "t!1")
                                            (("1"
                                              (expand "in_order?")
                                              (("1"
                                                (prop)
                                                (("1" (assert) nil nil)
                                                 ("2" (assert) nil nil)
                                                 ("3" (assert) nil nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (expand "connected?")
                                              (("2"
                                                (skosimp*)
                                                (("2" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand "in_order?")
                (("2" (prop)
                  (("1" (cross-mult 1)
                    (("1" (hide 3) (("1" (grind-reals) nil nil)) nil)) nil)
                   ("2" (hide 3) (("2" (grind) nil nil)) nil))
                  nil))
                nil)
               ("3" (expand "connected?")
                (("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil)
         ("2" (decompose-equality 1)
          (("1" (expand "vsAUWRU_acc") (("1" (propax) nil nil)) nil)
           ("2" (expand "connected?")
            (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
          nil)
         ("3" (expand "connected?")
          (("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (case1_vel_prep formula-decl nil vsAccel nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (Integrable? const-decl "bool" integral_def analysis)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (nnreal type-eq-decl nil real_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (vsAUWRU_acc const-decl "real" vsAccel nil)
    (vsAUWRU_case1_acc const-decl "real" vsAccel nil)
    (in_order? const-decl "bool" integral_split_fun analysis)
    (Int_ramp_vel2 formula-decl nil vsAccel nil)
    (Int_const_vel2 formula-decl nil vsAccel nil)
    (Integrable?_inside formula-decl nil integral analysis)
    (sign_not_zero application-judgement "nzreal" vsAccel nil)
    (posreal_max application-judgement "{z: posreal | z >= x AND z >= y}"
     real_defs nil)
    (split_fun2_Integrable formula-decl nil integral_split_fun analysis)
    (div_mult_pos_le2 formula-decl nil real_props nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (times_div2 formula-decl nil real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (nonneg_real_max application-judgement
     "{z: nonneg_real | z >= x AND z >= y}" real_defs nil)
    (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (vsAccelConst const-decl "real" vsAccel nil)
    (Sign const-decl "real" vsAccel nil)
    (vsAccelRamp const-decl "real" vsAccel nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (restrict const-decl "R" restrict nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (split_fun2 const-decl "[T -> real]" integral_split_fun analysis)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (deriv_domain? const-decl "bool" deriv_domain_def analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (deriv_domain_nnreal formula-decl nil deriv_domain analysis)
    (not_one_element_nnreal formula-decl nil deriv_domain analysis))
   shostak))
 (vsAUWRU_vel_TCC1 0
  (vsAUWRU_vel_TCC1-1 nil 3612613195
   ("" (lemma "case2_vel_prep") (("" (propax) nil nil)) nil)
   ((case2_vel_prep formula-decl nil vsAccel nil)) nil
   (vsAUWRU_vel subtype
    "vsAccel.vsAUWRU_acc(vsAccel.v0z, vsAccel.goalVs, vsAccel.accel, vsAccel.tRamp)"
    "integral_def[nnreal].Integrable_funs(0, vsAccel.t)")))
 (Integral_AUWRU_vel_TCC1 0
  (Integral_AUWRU_vel_TCC1-1 nil 3612614473
   ("" (skosimp*)
    (("" (expand "deriv_domain?")
      (("" (skosimp*)
        (("" (inst 2 "e!1/2") (("" (assert) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((real_plus_real_is_real application-judgement "real" reals nil)
    (deriv_domain? const-decl "bool" deriv_domain_def analysis)
    (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnreal type-eq-decl nil real_types nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}"
     real_defs nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil
   (Integral_AUWRU_vel assuming
    "analysis@integral_split_fun[nnreal].integral_split_fun"
    "deriv_domain: ASSUMPTION deriv_domain_def[T].deriv_domain?")))
 (Integral_AUWRU_vel 0
  (Integral_AUWRU_vel-1 nil 3612616850
   ("" (skosimp*)
    (("" (lift-if)
      (("" (prop)
        (("1" (expand "vsAUWRU_vel")
          (("1" (expand "vsAUWRU_case1_vel")
            (("1"
              (case " vsAUWRU_acc(v0z!1, goalVs!1, accel!1, tRamp!1) = vsAUWRU_case1_acc(v0z!1, goalVs!1, accel!1, tRamp!1)")
              (("1" (replace -1) (("1" (propax) nil nil)) nil)
               ("2" (decompose-equality 1)
                (("2" (expand "vsAUWRU_case1_acc")
                  (("2" (expand "vsAUWRU_acc")
                    (("2" (expand "vsAUWRU_case1_acc")
                      (("2" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "vsAUWRU_vel")
          (("2"
            (case-replace
             "vsAUWRU_acc(v0z!1, goalVs!1, accel!1, tRamp!1) = split_fun2[nnreal]
                          (tRamp!1,
                           (abs(goalVs!1 - v0z!1) +
                             (accel!1 / 2) * tRamp!1)
                            / accel!1,
                           restrict[real, nnreal, real]
                               (vsAccelRamp(Sign(v0z!1, goalVs!1)
                                            *
                                            accel!1,
                                            tRamp!1)),
                           restrict[real, nnreal, real]
                               (vsAccelConst(Sign(v0z!1, goalVs!1)
                                             *
                                             accel!1)),
                           restrict[real, nnreal, real](vsAccelConst(0)))")
            (("1" (hide -1)
              (("1"
                (name "MAX"
                      "max(t!1, max(tRamp!1, (abs(goalVs!1 - v0z!1) + (accel!1 / 2) * tRamp!1) / accel!1))")
                (("1" (expand "restrict")
                  (("1" (lemma "Int_ramp_vel2")
                    (("1"
                      (inst -1 "Sign(v0z!1, goalVs!1)*accel!1" "tRamp!1"
                       "tRamp!1")
                      (("1" (lemma "Int_const_vel2")
                        (("1"
                          (inst-cp -1 "Sign(v0z!1, goalVs!1)*accel!1"
                           "tRamp!1"
                           "(abs(goalVs!1 - v0z!1) + (accel!1 / 2) * tRamp!1) / accel!1")
                          (("1"
                            (inst -1 "0"
                             "(abs(goalVs!1 - v0z!1) + (accel!1 / 2) * tRamp!1) / accel!1"
                             "MAX")
                            (("1"
                              (name-replace "tMax"
                               "(abs(goalVs!1 - v0z!1) + (accel!1 / 2) * tRamp!1) / accel!1")
                              (("1"
                                (case "in_order?[nnreal](0, tRamp!1, tMax, MAX)")
                                (("1" (lemma "Integral_split_fun2[nnreal]")
                                  (("1"
                                    (inst -1 "LAMBDA (s: nnreal):
                      vsAccelRamp(Sign(v0z!1, goalVs!1) * accel!1, tRamp!1)
                                 (s)" "
                    LAMBDA (s: nnreal):
                      vsAccelConst(Sign(v0z!1, goalVs!1) * accel!1)(s)" "
                    LAMBDA (s: nnreal): vsAccelConst(0)(s)" "0" "MAX"
                                     "tRamp!1" "tMax" "t!1")
                                    (("1" (flatten)
                                      (("1"
                                        (prop)
                                        (("1"
                                          (replace -2)
                                          (("1"
                                            (lift-if 2)
                                            (("1"
                                              (prop)
                                              (("1"
                                                (lemma "Int_ramp_vel2")
                                                (("1"
                                                  (inst
                                                   -1
                                                   "Sign(v0z!1, goalVs!1)*accel!1"
                                                   "tRamp!1"
                                                   "t!1")
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (replace -2)
                                                      (("1"
                                                        (expand "split_fun2")
                                                        (("1"
                                                          (lift-if 1)
                                                          (("1"
                                                            (prop)
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (lemma "Int_const_vel2")
                                                (("2"
                                                  (inst
                                                   -1
                                                   "Sign(v0z!1, goalVs!1)*accel!1"
                                                   "tRamp!1"
                                                   "t!1")
                                                  (("2"
                                                    (flatten)
                                                    (("2"
                                                      (replace -2)
                                                      (("2"
                                                        (replace -12)
                                                        (("2"
                                                          (expand
                                                           "split_fun2")
                                                          (("2"
                                                            (lift-if 1)
                                                            (("2"
                                                              (prop)
                                                              (("2"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("3"
                                                (lemma "Int_const_vel2")
                                                (("3"
                                                  (inst -1 "0" "tMax" "t!1")
                                                  (("3"
                                                    (flatten)
                                                    (("3"
                                                      (replace -2)
                                                      (("3"
                                                        (replace -9)
                                                        (("3"
                                                          (replace -11)
                                                          (("3"
                                                            (expand
                                                             "split_fun2")
                                                            (("3"
                                                              (lift-if 2)
                                                              (("3"
                                                                (prop)
                                                                (("3"
                                                                  (expand
                                                                   "tMax")
                                                                  (("3"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (assert) nil nil)
                                         ("3" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (expand "in_order?")
                                  (("2" (prop)
                                    (("1" (assert)
                                      (("1"
                                        (expand "tMax")
                                        (("1" (grind-reals) nil nil))
                                        nil))
                                      nil)
                                     ("2" (assert) nil nil))
                                    nil))
                                  nil)
                                 ("3" (expand "connected?")
                                  (("3" (skosimp*) (("3" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand "vsAUWRU_acc")
              (("2" (hide 3)
                (("2" (decompose-equality 1)
                  (("1" (expand "connected?")
                    (("1" (skosimp*) (("1" (assert) nil nil)) nil)) nil)
                   ("2" (expand "connected?")
                    (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil)
             ("3" (expand "connected?")
              (("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sign_not_zero application-judgement "nzreal" vsAccel nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (goalVs!1 skolem-const-decl "real" vsAccel nil)
    (v0z!1 skolem-const-decl "real" vsAccel nil)
    (accel!1 skolem-const-decl "posreal" vsAccel nil)
    (tRamp!1 skolem-const-decl "posreal" vsAccel nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (posreal_exp application-judgement "posreal" exponentiation nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (div_mult_pos_le2 formula-decl nil real_props nil)
    (times_div2 formula-decl nil real_props nil)
    (Integral_split_fun2 formula-decl nil integral_split_fun analysis)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (Integral const-decl "real" integral_def analysis)
    (Integrable? const-decl "bool" integral_def analysis)
    (integrable? const-decl "bool" integral_def analysis)
    (integral? const-decl "bool" integral_def analysis)
    (width const-decl "posreal" integral_def analysis)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (nnreal_expt application-judgement "nnreal" exponentiation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posreal_expt application-judgement "posreal" exponentiation nil)
    (posreal_max application-judgement "{z: posreal | z >= x AND z >= y}"
     real_defs nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (tMax skolem-const-decl "posreal" vsAccel nil)
    (in_order? const-decl "bool" integral_split_fun analysis)
    (Int_const_vel2 formula-decl nil vsAccel nil)
    (Int_ramp_vel2 formula-decl nil vsAccel nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (nonneg_real_max application-judgement
     "{z: nonneg_real | z >= x AND z >= y}" real_defs nil)
    (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (vsAccelConst const-decl "real" vsAccel nil)
    (Sign const-decl "real" vsAccel nil)
    (vsAccelRamp const-decl "real" vsAccel nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (restrict const-decl "R" restrict nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (split_fun2 const-decl "[T -> real]" integral_split_fun analysis)
    (deriv_domain? const-decl "bool" deriv_domain_def analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (deriv_domain_nnreal formula-decl nil deriv_domain analysis)
    (not_one_element_nnreal formula-decl nil deriv_domain analysis)
    (vsAUWRU_vel const-decl "real" vsAccel nil)
    (vsAUWRU_case1_acc const-decl "real" vsAccel nil)
    (vsAUWRU_acc const-decl "real" vsAccel nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (vsAUWRU_case1_vel const-decl "real" vsAccel nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   shostak))
 (case2_pos_prep 0
  (case2_pos_prep-2 nil 3612623112
   ("" (skosimp*)
    (("" (case "abs(goalVs!1-v0z!1)<=accel!1*tRamp!1/2")
      (("1"
        (case-replace
         " vsAUWRU_vel(v0z!1, goalVs!1, accel!1, tRamp!1) =  vsAUWRU_case1_vel(v0z!1, goalVs!1, accel!1, tRamp!1)")
        (("1" (lemma "case1_pos_prep")
          (("1" (inst -1 "v0z!1" "v0z!1" "goalVs!1" "accel!1" "tRamp!1" "t!1")
            (("1" (assert) nil nil)) nil))
          nil)
         ("2" (decompose-equality 1)
          (("2" (expand "vsAUWRU_vel")
            (("2" (expand "vsAUWRU_case1_vel")
              (("2" (expand "vsAUWRU_acc")
                (("2" (expand "vsAUWRU_case1_acc") (("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2"
        (case-replace " vsAUWRU_vel(v0z!1, goalVs!1, accel!1, tRamp!1) =
                        split_fun2[nnreal](tRamp!1, (abs(goalVs!1-v0z!1) +(accel!1/2)*tRamp!1)/accel!1,
                 LAMBDA(s:nnreal): v0z!1+(Sign(v0z!1, goalVs!1)*accel!1/(2*tRamp!1))*s^2,
                 LAMBDA(s:nnreal): v0z!1+Sign(v0z!1, goalVs!1)*accel!1*(s-tRamp!1/2),
                 LAMBDA(s:nnreal): goalVs!1)")
        (("1" (hide -1)
          (("1"
            (name-replace "tMax"
             "(abs(goalVs!1 - v0z!1) + (accel!1 / 2) * tRamp!1) /
                              accel!1")
            (("1" (name "Max" "max(t!1, max(tRamp!1, tMax))")
              (("1" (lemma "integral_quadratic[nnreal]")
                (("1"
                  (inst -1 "0" "tRamp!1"
                   "(Sign(v0z!1, goalVs!1) * accel!1 / (2 * tRamp!1))" "0"
                   "v0z!1")
                  (("1" (flatten)
                    (("1" (hide -2)
                      (("1" (lemma "integral_linear[nnreal]")
                        (("1"
                          (inst-cp -1 "tRamp!1" "tMax"
                           "Sign(v0z!1, goalVs!1) * accel!1"
                           "-Sign(v0z!1, goalVs!1) * accel!1*tRamp!1/2 +v0z!1")
                          (("1" (skoletin)
                            (("1" (flatten)
                              (("1" (hide -2)
                                (("1" (inst -3 "tMax" "Max" "0" "goalVs!1")
                                  (("1" (skoletin)
                                    (("1" (flatten)
                                      (("1"
                                        (hide -2)
                                        (("1"
                                          (case
                                           "in_order?[nnreal](0, tRamp!1, tMax, Max)")
                                          (("1"
                                            (lemma
                                             "Integral_split_fun2[nnreal]")
                                            (("1"
                                              (inst
                                               -1
                                               "LAMBDA (x: nnreal):
                              (Sign(v0z!1, goalVs!1) * accel!1 / (2 * tRamp!1)) *
                               x ^ 2
                               + 0 * x
                               + v0z!1"
                                               "f"
                                               "f_1"
                                               "0"
                                               "Max"
                                               "tRamp!1"
                                               "tMax"
                                               "t!1")
                                              (("1"
                                                (prop)
                                                (("1"
                                                  (lemma
                                                   "Integrable?_inside[nnreal]")
                                                  (("1"
                                                    (inst
                                                     -1
                                                     "0"
                                                     "Max"
                                                     "split_fun2(tRamp!1, tMax,
                                         LAMBDA (x: nnreal):
                                           (Sign(v0z!1, goalVs!1) * accel!1 /
                                             (2 * tRamp!1))
                                            * x ^ 2
                                            + 0 * x
                                            + v0z!1,
                                         f, f_1)"
                                                     "0"
                                                     "t!1")
                                                    (("1"
                                                      (prop)
                                                      (("1"
                                                        (case-replace
                                                         "split_fun2(tRamp!1, tMax,
                                             LAMBDA (x: nnreal):
                                               (Sign(v0z!1, goalVs!1) * accel!1 /
                                                 (2 * tRamp!1))
                                                * x ^ 2
                                                + 0 * x
                                                + v0z!1,
                                             f, f_1) = split_fun2[nnreal]
                                      (tRamp!1, tMax,
                                       LAMBDA (s: nnreal):
                                         v0z!1 +
                                          (Sign(v0z!1, goalVs!1) * accel!1 / (2 * tRamp!1))
                                           * s ^ 2,
                                       LAMBDA (s: nnreal):
                                         v0z!1 +
                                          Sign(v0z!1, goalVs!1) * accel!1 *
                                           (s - tRamp!1 / 2),
                                       LAMBDA (s: nnreal): goalVs!1)")
                                                        (("1"
                                                          (decompose-equality
                                                           1)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2" (assert) nil nil)
                                                       ("3" (assert) nil nil)
                                                       ("4" (assert) nil nil))
                                                      nil)
                                                     ("2"
                                                      (expand "connected?")
                                                      (("2"
                                                        (skosimp*)
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (assert) nil nil)
                                                 ("3" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (expand "in_order?")
                                            (("2"
                                              (split)
                                              (("1"
                                                (expand "tMax")
                                                (("1" (grind-reals) nil nil))
                                                nil)
                                               ("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "connected?")
                  (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (decompose-equality 1)
          (("1" (lemma "Integral_AUWRU_vel")
            (("1" (inst -1 "v0z!1" "goalVs!1" "accel!1" "tRamp!1" "x!1")
              (("1" (lift-if -1) (("1" (assert) nil nil)) nil)) nil))
            nil)
           ("2" (expand "connected?")
            (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
          nil)
         ("3" (expand "connected?")
          (("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (vsAUWRU_case1_acc const-decl "real" vsAccel nil)
    (vsAUWRU_acc const-decl "real" vsAccel nil)
    (case1_pos_prep formula-decl nil vsAccel nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (nnreal type-eq-decl nil real_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (vsAUWRU_vel const-decl "real" vsAccel nil)
    (vsAUWRU_case1_vel const-decl "real" vsAccel nil)
    (Integral_AUWRU_vel formula-decl nil vsAccel nil)
    (nonneg_real_max application-judgement
     "{z: nonneg_real | z >= x AND z >= y}" real_defs nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (in_order? const-decl "bool" integral_split_fun analysis)
    (Integrable?_inside formula-decl nil integral analysis)
    (Integral_split_fun2 formula-decl nil integral_split_fun analysis)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (posreal_max application-judgement "{z: posreal | z >= x AND z >= y}"
     real_defs nil)
    (zero_times1 formula-decl nil real_props nil)
    (div_mult_pos_le2 formula-decl nil real_props nil)
    (times_div2 formula-decl nil real_props nil)
    (tMax skolem-const-decl "posreal" vsAccel nil)
    (expt def-decl "real" exponentiation nil)
    (integrable? const-decl "bool" integral_def analysis)
    (integral? const-decl "bool" integral_def analysis)
    (width const-decl "posreal" integral_def analysis)
    (Integral const-decl "real" integral_def analysis)
    (Integrable_funs type-eq-decl nil integral_def analysis)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Integrable? const-decl "bool" integral_def analysis)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (integral_quadratic formula-decl nil table_of_integrals analysis)
    (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (sign_not_zero application-judgement "nzreal" vsAccel nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (^ const-decl "real" exponentiation nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (Sign const-decl "real" vsAccel nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (split_fun2 const-decl "[T -> real]" integral_split_fun analysis)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (deriv_domain? const-decl "bool" deriv_domain_def analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (deriv_domain_nnreal formula-decl nil deriv_domain analysis)
    (not_one_element_nnreal formula-decl nil deriv_domain analysis))
   nil)
  (case2_pos_prep-1 nil 3612620134
   ("" (skosimp*)
    (("" (case "abs(goalVs!1-v0z!1)<=accel!1*tRamp!1/2")
      (("1"
        (case-replace
         " vsAUWRU_vel(v0z!1, goalVs!1, accel!1, tRamp!1) =  vsAUWRU_case1_vel(v0z!1, goalVs!1, accel!1, tRamp!1)")
        (("1" (lemma "case1_pos_prep")
          (("1" (inst -1 "v0z!1" "v0z!1" "goalVs!1" "accel!1" "tRamp!1" "t!1")
            (("1" (assert) nil nil)) nil))
          nil)
         ("2" (decompose-equality 1)
          (("2" (expand "vsAUWRU_vel")
            (("2" (expand "vsAUWRU_case1_vel")
              (("2" (expand "vsAUWRU_acc")
                (("2" (expand "vsAUWRU_case1_acc") (("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2"
        (case-replace " vsAUWRU_vel(v0z!1, goalVs!1, accel!1, tRamp!1) = 
                    split_fun2[nnreal](tRamp!1, (abs(goalVs!1-v0z!1) +(accel!1/2)*tRamp!1)/accel!1, 
             LAMBDA(s:nnreal): v0z!1+(Sign(v0z!1, goalVs!1)*accel!1/(2*tRamp!1))*s^2,
             LAMBDA(s:nnreal): v0z!1+Sign(v0z!1, goalVs!1)*accel!1*(s-tRamp!1/2), 
             LAMBDA(s:nnreal): goalVs!1)")
        (("1" (hide -1)
          (("1"
            (name-replace "tMax"
             "(abs(goalVs!1 - v0z!1) + (accel!1 / 2) * tRamp!1) /
                        accel!1")
            (("1" (name "Max" "max(t!1, max(tRamp!1, tMax))")
              (("1" (lemma "integral_quadratic[nnreal]")
                (("1"
                  (inst -1 "0" "tRamp!1"
                   "(Sign(v0z!1, goalVs!1) * accel!1 / (2 * tRamp!1))" "0"
                   "v0z!1")
                  (("1" (flatten)
                    (("1" (hide -2)
                      (("1" (lemma "integral_linear[nnreal]")
                        (("1"
                          (inst-cp -1 "tRamp!1" "tMax"
                           "Sign(v0z!1, goalVs!1) * accel!1"
                           "-Sign(v0z!1, goalVs!1) * accel!1*tRamp!1/2")
                          (("1" (skoletin)
                            (("1" (flatten)
                              (("1" (hide -2)
                                (("1" (inst -3 "tMax" "Max" "0" "goalVs!1")
                                  (("1" (skoletin)
                                    (("1" (flatten)
                                      (("1"
                                        (hide -2)
                                        (("1"
                                          (case
                                           "in_order?[nnreal](0, tRamp!1, tMax, Max)")
                                          (("1"
                                            (lemma
                                             "Integral_split_fun2[nnreal]")
                                            (("1"
                                              (inst
                                               -1
                                               "LAMBDA (x: nnreal):
                    (Sign(v0z!1, goalVs!1) * accel!1 / (2 * tRamp!1)) *
                     x ^ 2
                     + 0 * x
                     + v0z!1"
                                               "f"
                                               "f_1"
                                               "0"
                                               "Max"
                                               "tRamp!1"
                                               "tMax"
                                               "t!1")
                                              (("1"
                                                (prop)
                                                (("1"
                                                  (lemma
                                                   "Integrable?_inside[nnreal]")
                                                  (("1"
                                                    (inst
                                                     -1
                                                     "0"
                                                     "Max"
                                                     "split_fun2(tRamp!1, tMax,
                             LAMBDA (x: nnreal):
                               (Sign(v0z!1, goalVs!1) * accel!1 /
                                 (2 * tRamp!1))
                                * x ^ 2
                                + 0 * x
                                + v0z!1,
                             f, f_1)"
                                                     "0"
                                                     "t!1")
                                                    (("1"
                                                      (prop)
                                                      (("1"
                                                        (case-replace
                                                         "split_fun2(tRamp!1, tMax,
                             LAMBDA (x: nnreal):
                               (Sign(v0z!1, goalVs!1) * accel!1 /
                                 (2 * tRamp!1))
                                * x ^ 2
                                + 0 * x
                                + v0z!1,
                             f, f_1) = split_fun2[nnreal]
                      (tRamp!1, tMax,
                       LAMBDA (s: nnreal):
                         v0z!1 +
                          (Sign(v0z!1, goalVs!1) * accel!1 / (2 * tRamp!1))
                           * s ^ 2,
                       LAMBDA (s: nnreal):
                         v0z!1 +
                          Sign(v0z!1, goalVs!1) * accel!1 *
                           (s - tRamp!1 / 2),
                       LAMBDA (s: nnreal): goalVs!1)")
                                                        (("1"
                                                          (decompose-equality
                                                           1)
                                                          (("1"
                                                            (expand
                                                             "split_fun2")
                                                            (("1"
                                                              (lift-if 1)
                                                              (("1"
                                                                (assert)
                                                                (("1"
                                                                  (split 1)
                                                                  (("1"
                                                                    (propax)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (assert)
                                                                      (("2"
                                                                        (prop)
                                                                        (("2"
                                                                          (postpone)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (postpone)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (postpone)
                                                        nil
                                                        nil)
                                                       ("3"
                                                        (postpone)
                                                        nil
                                                        nil)
                                                       ("4"
                                                        (postpone)
                                                        nil
                                                        nil))
                                                      nil)
                                                     ("2" (postpone) nil nil))
                                                    nil))
                                                  nil)
                                                 ("2" (postpone) nil nil)
                                                 ("3" (postpone) nil nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (expand "in_order?")
                                            (("2"
                                              (split)
                                              (("1"
                                                (expand "tMax")
                                                (("1" (grind-reals) nil nil))
                                                nil)
                                               ("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "connected?")
                  (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (decompose-equality 1)
          (("1" (lemma "Integral_AUWRU_vel")
            (("1" (inst -1 "v0z!1" "goalVs!1" "accel!1" "tRamp!1" "x!1")
              (("1" (lift-if -1) (("1" (assert) nil nil)) nil)) nil))
            nil)
           ("2" (expand "connected?")
            (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
          nil)
         ("3" (expand "connected?")
          (("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   nil shostak))
 (vsAUWRU_pos_TCC1 0
  (vsAUWRU_pos_TCC1-1 nil 3612624604
   ("" (lemma "case2_pos_prep")
    (("" (skosimp*)
      (("" (inst -1 "v0z!1" "v0z!1" "goalVs!1" "accel!1" "tRamp!1" "t!1") nil
        nil))
      nil))
    nil)
   ((nnreal type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (case2_pos_prep formula-decl nil vsAccel nil))
   nil
   (vsAUWRU_pos subtype
    "vsAccel.vsAUWRU_vel(vsAccel.v0z, vsAccel.goalVs, vsAccel.accel, vsAccel.tRamp)"
    "integral_def[nnreal].Integrable_funs(0, vsAccel.t)")))
 (Integral_AUWRU_pos_TCC1 0
  (Integral_AUWRU_pos_TCC1-1 nil 3612626813 ("" (subtype-tcc) nil nil)
   ((real_minus_real_is_real application-judgement "real" reals nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil))
   nil
   (Integral_AUWRU_pos subtype "3"
    "{i: integers.int | booleans.OR(vsAccel.tRamp /= 0, reals.>=(i, 0))}")))
 (Integral_AUWRU_pos_TCC2 0
  (Integral_AUWRU_pos_TCC2-1 nil 3612626813 ("" (subtype-tcc) nil nil)
   ((real_minus_real_is_real application-judgement "real" reals nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (/= const-decl "boolean" notequal nil))
   nil
   (Integral_AUWRU_pos subtype "2"
    "{i: integers.int | booleans.OR((number_fields./(((number_fields.+)(real_defs.abs((number_fields.-)(vsAccel.goalVs, vsAccel.v0z)), number_fields.*((number_fields./(vsAccel.accel, 2)), vsAccel.tRamp))), vsAccel.accel)) /= 0, reals.>=(i, 0))}")))
 (Integral_AUWRU_pos 0
  (Integral_AUWRU_pos-1 nil 3612627062
   ("" (skosimp*)
    (("" (case "abs(goalVs!1 - v0z!1) <= accel!1 * tRamp!1 / 2")
      (("1" (expand "vsAUWRU_pos")
        (("1" (lift-if)
          (("1" (prop)
            (("1" (expand "vsAUWRU_case1_pos")
              (("1"
                (case-replace
                 "vsAUWRU_vel(v0z!1, goalVs!1, accel!1, tRamp!1) = vsAUWRU_case1_vel(v0z!1, goalVs!1, accel!1, tRamp!1)")
                (("1" (decompose-equality 1)
                  (("1" (lemma "Integral_AUWRU_vel")
                    (("1"
                      (inst -1 "v0z!1" "goalVs!1" "accel!1" "tRamp!1" "x!1")
                      (("1" (lift-if) (("1" (prop) nil nil)) nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (lift-if 2)
        (("2" (prop)
          (("2" (hide 3)
            (("2" (expand "vsAUWRU_pos")
              (("2" (lemma "Integral_AUWRU_vel")
                (("2"
                  (case-replace
                   "vsAUWRU_vel(v0z!1, goalVs!1, accel!1, tRamp!1) =split_fun2[nnreal]
                  (tRamp!1,
                   (abs(goalVs!1 - v0z!1) + (accel!1 / 2) * tRamp!1) / accel!1,
                   LAMBDA (s: nnreal):
                     v0z!1 +
                      (Sign(v0z!1, goalVs!1) * accel!1 / (2 * tRamp!1)) * s ^ 2,
                   LAMBDA (s: nnreal):
                     v0z!1 + Sign(v0z!1, goalVs!1) * accel!1 * (s - tRamp!1 / 2),
                   LAMBDA (s: nnreal): goalVs!1)")
                  (("1" (hide -)
                    (("1"
                      (name-replace "tMax"
                       "(abs(goalVs!1 - v0z!1) + (accel!1 / 2) * tRamp!1) / accel!1")
                      (("1" (name "Max" "max(t!1, max(tRamp!1, tMax))")
                        (("1"
                          (case "in_order?[nnreal](0, tRamp!1, tMax, Max)")
                          (("1" (lemma "integral_quadratic[nnreal]")
                            (("1"
                              (inst -1 "0" "tRamp!1"
                               "(Sign(v0z!1, goalVs!1) * accel!1 / (2 * tRamp!1))"
                               "0" "v0z!1")
                              (("1" (lemma "integral_linear[nnreal]")
                                (("1"
                                  (inst-cp -1 "tRamp!1" "tMax"
                                   "Sign(v0z!1, goalVs!1) * accel!1"
                                   "v0z!1 - Sign(v0z!1, goalVs!1) * accel!1*tRamp!1/2")
                                  (("1" (inst -1 "tMax" "Max" "0" "goalVs!1")
                                    (("1"
                                      (lemma "Integral_split_fun2[nnreal]")
                                      (("1"
                                        (skoletin)
                                        (("1"
                                          (skoletin)
                                          (("1"
                                            (inst
                                             -5
                                             " LAMBDA (x: nnreal):
                    (Sign(v0z!1, goalVs!1) * accel!1 / (2 * tRamp!1)) *
                     x ^ 2
                     + 0 * x
                     + v0z!1"
                                             "f_1"
                                             "f"
                                             "0"
                                             "Max"
                                             "tRamp!1"
                                             "tMax"
                                             "t!1")
                                            (("1"
                                              (prop)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (case-replace
                                                   "split_fun2[nnreal](tRamp!1, tMax, LAMBDA (s: nnreal):
                      (Sign(v0z!1, goalVs!1) * accel!1 / (2 * tRamp!1)) *
                       s ^ 2
                       + v0z!1,
                    LAMBDA (s: nnreal):
                      s * Sign(v0z!1, goalVs!1) * accel!1 -
                       Sign(v0z!1, goalVs!1) * (tRamp!1 / 2) * accel!1
                       + v0z!1,
                    LAMBDA (s: nnreal): goalVs!1)=split_fun2(tRamp!1, tMax,
                          LAMBDA (x: nnreal):          (Sign(v0z!1, goalVs!1) * accel!1 /
                              (2 * tRamp!1))
                            * x ^ 2
                             + v0z!1,
                         f_1, f)")
                                                  (("1"
                                                    (replace -3)
                                                    (("1"
                                                      (lift-if 2)
                                                      (("1"
                                                        (prop)
                                                        (("1"
                                                          (lemma
                                                           "integral_quadratic[nnreal]")
                                                          (("1"
                                                            (inst
                                                             -1
                                                             "0"
                                                             "t!1"
                                                             "(Sign(v0z!1, goalVs!1) * accel!1 / (2 * tRamp!1))"
                                                             "0"
                                                             "v0z!1")
                                                            (("1"
                                                              (flatten)
                                                              (("1"
                                                                (skoletin)
                                                                (("1"
                                                                  (replace -1)
                                                                  (("1"
                                                                    (expand
                                                                     "split_fun2")
                                                                    (("1"
                                                                      (lift-if
                                                                       1)
                                                                      (("1"
                                                                        (prop)
                                                                        (("1"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (lemma
                                                           "integral_linear[nnreal]")
                                                          (("2"
                                                            (inst
                                                             -1
                                                             "tRamp!1"
                                                             "t!1"
                                                             "Sign(v0z!1, goalVs!1) * accel!1"
                                                             "v0z!1 - Sign(v0z!1, goalVs!1) * accel!1*tRamp!1/2")
                                                            (("2"
                                                              (skoletin)
                                                              (("2"
                                                                (flatten)
                                                                (("2"
                                                                  (skoletin)
                                                                  (("2"
                                                                    (replace
                                                                     -16)
                                                                    (("2"
                                                                      (case-replace
                                                                       "f_1=f_2")
                                                                      (("1"
                                                                        (replace
                                                                         -2)
                                                                        (("1"
                                                                          (expand
                                                                           "split_fun2")
                                                                          (("1"
                                                                            (lift-if
                                                                             1)
                                                                            (("1"
                                                                              (prop)
                                                                              (("1"
                                                                                (grind)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (decompose-equality
                                                                         1)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (lemma
                                                           "integral_linear[nnreal]")
                                                          (("3"
                                                            (inst
                                                             -1
                                                             "tMax"
                                                             "t!1"
                                                             "0"
                                                             "goalVs!1")
                                                            (("3"
                                                              (skoletin)
                                                              (("3"
                                                                (flatten)
                                                                (("3"
                                                                  (skoletin)
                                                                  (("3"
                                                                    (replace
                                                                     -15)
                                                                    (("3"
                                                                      (replace
                                                                       -9)
                                                                      (("3"
                                                                        (case-replace
                                                                         "f=f_2")
                                                                        (("1"
                                                                          (replace
                                                                           -2)
                                                                          (("1"
                                                                            (expand
                                                                             "split_fun2")
                                                                            (("1"
                                                                              (lift-if
                                                                               2)
                                                                              (("1"
                                                                                (prop)
                                                                                (("1"
                                                                                  (auto-rewrite
                                                                                   "^")
                                                                                  (("1"
                                                                                    (assert)
                                                                                    (("1"
                                                                                      (auto-rewrite
                                                                                       "expt")
                                                                                      (("1"
                                                                                        (assert)
                                                                                        (("1"
                                                                                          (expand
                                                                                           "F")
                                                                                          (("1"
                                                                                            (cross-mult)
                                                                                            (("1"
                                                                                              (cross-mult)
                                                                                              (("1"
                                                                                                (expand
                                                                                                 "tMax")
                                                                                                (("1"
                                                                                                  (expand
                                                                                                   "abs")
                                                                                                  (("1"
                                                                                                    (lift-if
                                                                                                     2)
                                                                                                    (("1"
                                                                                                      (split
                                                                                                       2)
                                                                                                      (("1"
                                                                                                        (flatten)
                                                                                                        (("1"
                                                                                                          (expand
                                                                                                           "Sign")
                                                                                                          (("1"
                                                                                                            (lift-if
                                                                                                             1)
                                                                                                            (("1"
                                                                                                              (prop)
                                                                                                              (("1"
                                                                                                                (hide
                                                                                                                 +)
                                                                                                                (("1"
                                                                                                                  (grind)
                                                                                                                  nil
                                                                                                                  nil))
                                                                                                                nil)
                                                                                                               ("2"
                                                                                                                (hide
                                                                                                                 -)
                                                                                                                (("2"
                                                                                                                  (grind)
                                                                                                                  nil
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil)
                                                                                                       ("2"
                                                                                                        (flatten)
                                                                                                        (("2"
                                                                                                          (expand
                                                                                                           "Sign")
                                                                                                          (("2"
                                                                                                            (lift-if
                                                                                                             2)
                                                                                                            (("2"
                                                                                                              (split
                                                                                                               2)
                                                                                                              (("1"
                                                                                                                (flatten)
                                                                                                                (("1"
                                                                                                                  (hide
                                                                                                                   -)
                                                                                                                  (("1"
                                                                                                                    (grind)
                                                                                                                    nil
                                                                                                                    nil))
                                                                                                                  nil))
                                                                                                                nil)
                                                                                                               ("2"
                                                                                                                (flatten)
                                                                                                                (("2"
                                                                                                                  (hide
                                                                                                                   -)
                                                                                                                  (("2"
                                                                                                                    (hide
                                                                                                                     2)
                                                                                                                    (("2"
                                                                                                                      (grind)
                                                                                                                      nil
                                                                                                                      nil))
                                                                                                                    nil))
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (decompose-equality
                                                                           1)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (hide 3)
                                                    (("2"
                                                      (decompose-equality 1)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2" (assert) nil nil)
                                               ("3" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand "in_order?")
                            (("2" (prop)
                              (("1" (expand "tMax")
                                (("1" (cross-mult) nil nil)) nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil)
                           ("3" (expand "connected?")
                            (("3" (skosimp*) (("3" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (decompose-equality 1)
                    (("1"
                      (inst -1 "v0z!1" "goalVs!1" "accel!1" "tRamp!1" "x!1")
                      (("1" (lift-if -1) (("1" (assert) nil nil)) nil)) nil)
                     ("2" (expand "connected?")
                      (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil))
                    nil)
                   ("3" (expand "connected?")
                    (("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (vsAUWRU_case1_pos const-decl "real" vsAccel nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (Integral_AUWRU_vel formula-decl nil vsAccel nil)
    (nnreal type-eq-decl nil real_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (vsAUWRU_vel const-decl "real" vsAccel nil)
    (vsAUWRU_case1_vel const-decl "real" vsAccel nil)
    (vsAUWRU_pos const-decl "real" vsAccel nil)
    (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (posreal_exp application-judgement "posreal" exponentiation nil)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (sign_not_zero application-judgement "nzreal" vsAccel nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (not_one_element_nnreal formula-decl nil deriv_domain analysis)
    (deriv_domain_nnreal formula-decl nil deriv_domain analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (deriv_domain? const-decl "bool" deriv_domain_def analysis)
    (^ const-decl "real" exponentiation nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (Sign const-decl "real" vsAccel nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (split_fun2 const-decl "[T -> real]" integral_split_fun analysis)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (in_order? const-decl "bool" integral_split_fun analysis)
    (Integral_split_fun2 formula-decl nil integral_split_fun analysis)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (F skolem-const-decl "[nnreal -> real]" vsAccel nil)
    (tMax skolem-const-decl "posreal" vsAccel nil)
    (div_mult_pos_le2 formula-decl nil real_props nil)
    (times_div2 formula-decl nil real_props nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (times_div1 formula-decl nil real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (integrable? const-decl "bool" integral_def analysis)
    (integral? const-decl "bool" integral_def analysis)
    (width const-decl "posreal" integral_def analysis)
    (expt def-decl "real" exponentiation nil)
    (nnreal_expt application-judgement "nnreal" exponentiation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posreal_expt application-judgement "posreal" exponentiation nil)
    (nat_expt application-judgement "nat" exponentiation nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (nat_exp application-judgement "nat" exponentiation nil)
    (posreal_max application-judgement "{z: posreal | z >= x AND z >= y}"
     real_defs nil)
    (Integral const-decl "real" integral_def analysis)
    (Integrable_funs type-eq-decl nil integral_def analysis)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Integrable? const-decl "bool" integral_def analysis)
    (integral_linear formula-decl nil table_of_integrals analysis)
    (integral_quadratic formula-decl nil table_of_integrals analysis)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (nonneg_real_max application-judgement
     "{z: nonneg_real | z >= x AND z >= y}" real_defs nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   shostak))
 (vsAUWRU_TCC1 0
  (vsAUWRU_TCC1-1 nil 3612632685 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nnreal type-eq-decl nil real_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (vsAUWRU_pos const-decl "real" vsAccel nil)
    (vsAUWRU_vel const-decl "real" vsAccel nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   nil (vsAUWRU subtype "vsAccel.x`1" "[real, real, real]")))
 (same_tMax 0
  (same_tMax-1 nil 3613138887
   ("" (skosimp*)
    (("" (expand "abs")
      (("" (expand "Sign")
        (("" (lift-if)
          (("" (lift-if) (("" (lift-if) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((sign_not_zero application-judgement "nzreal" vsAccel nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (Sign const-decl "real" vsAccel nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   shostak))
 (exceeds_deltav 0
  (exceeds_deltav-1 nil 3612087194
   ("" (skosimp*)
    (("" (assert)
      (("" (split)
        (("1" (flatten)
          (("1" (mult-ineq -1 -1)
            (("1" (lemma "sq_sqrt")
              (("1"
                (inst -1 "2 * (abs(goalVs!1 - v0z!1) * tRamp!1) / abs(a!1)")
                (("1" (split)
                  (("1" (expand "sq")
                    (("1" (replace -1)
                      (("1" (cross-mult -2)
                        (("1" (hide -1)
                          (("1" (div-by -1 "2*tRamp!1")
                            (("1" (assert)
                              (("1" (lemma "Int_ramp_vel")
                                (("1" (inst -1 "a!1" "tRamp!1")
                                  (("1" (replace -1) (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (cross-mult 1) nil nil))
                  nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (hide (1 2 4 5 6))
                (("2" (split) (("1" (grind) nil nil) ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2"
            (case-replace
             "abs(vsAccelRamp_Vel(a!1, tRamp!1)(t!1)) = vsAccelRamp_Vel(abs(a!1), tRamp!1)(t!1)")
            (("1" (hide -1)
              (("1" (lemma "Int_ramp_vel")
                (("1" (inst -1 "abs(a!1)" "tRamp!1")
                  (("1" (replace -1)
                    (("1" (assert)
                      (("1" (cross-mult)
                        (("1" (div-by -2 "abs(a!1)")
                          (("1" (hide -1)
                            (("1"
                              (case "t!1<= sqrt(2 * (abs(goalVs!1 - v0z!1) * tRamp!1) / abs(a!1))")
                              (("1" (mult-ineq -1 -1)
                                (("1" (lemma "sq_sqrt")
                                  (("1"
                                    (inst -1
                                     "2 * (abs(goalVs!1 - v0z!1) * tRamp!1) / abs(a!1)")
                                    (("1" (prop)
                                      (("1"
                                        (expand "sq")
                                        (("1"
                                          (replace -1)
                                          (("1"
                                            (expand "^")
                                            (("1"
                                              (expand "expt")
                                              (("1"
                                                (expand "expt")
                                                (("1"
                                                  (expand "expt")
                                                  (("1" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2" (cross-mult) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (case "abs(t!1) = t!1")
                                  (("1" (replace -1)
                                    (("1"
                                      (case-replace
                                       "abs(sqrt(2 * (abs(goalVs!1 - v0z!1) * tRamp!1) / abs(a!1))) = sqrt(2 * (abs(goalVs!1 - v0z!1) * tRamp!1) / abs(a!1))")
                                      (("1" (assert) nil nil)
                                       ("2"
                                        (typepred (t!1))
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (typepred (t!1))
                                    (("2" (assert)
                                      (("2"
                                        (hide (-2 -3 2 3 4))
                                        (("2"
                                          (expand "abs")
                                          (("2" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (lemma "Int_ramp_vel")
              (("2" (inst-cp -1 "a!1" "tRamp!1")
                (("2" (inst -1 "abs(a!1)" "tRamp!1")
                  (("2" (replace -1)
                    (("2" (replace -2)
                      (("2" (hide -)
                        (("2" (hide 2)
                          (("2" (expand "abs")
                            (("2" (lift-if)
                              (("2" (assert)
                                (("2" (prop)
                                  (("1" (assert)
                                    (("1" (lift-if)
                                      (("1"
                                        (split)
                                        (("1" (assert) nil nil)
                                         ("2"
                                          (assert)
                                          (("2"
                                            (cross-mult)
                                            (("2"
                                              (expand "^")
                                              (("2"
                                                (expand "expt")
                                                (("2"
                                                  (expand "expt")
                                                  (("2"
                                                    (expand "expt")
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (div-by
                                                         -1
                                                         "(t!1*t!1)")
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (lift-if)
                                    (("2" (assert)
                                      (("2"
                                        (split)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (cross-mult)
                                            (("1"
                                              (div-by 2 "t!1^2")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (times_div_cancel2 formula-decl nil extra_real_props nil)
    (div_cancel4 formula-decl nil real_props nil)
    (times_div2 formula-decl nil real_props nil)
    (div_cancel3 formula-decl nil real_props nil)
    (both_sides_div_pos_lt1 formula-decl nil real_props nil)
    (times_div_cancel1 formula-decl nil extra_real_props nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (div_mult_pos_lt1 formula-decl nil real_props nil)
    (le_times_le_any1 formula-decl nil extra_real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (div_mult_pos_lt2 formula-decl nil real_props nil)
    (vsAccelRamp_Vel const-decl "real" vsAccel nil)
    (sq_sqrt formula-decl nil sqrt reals)
    (minus_real_is_real application-judgement "real" reals nil)
    (nnreal_expt application-judgement "nnreal" exponentiation nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nnreal_exp application-judgement "nnreal" exponentiation nil)
    (Int_ramp_vel formula-decl nil vsAccel nil)
    (both_sides_div_pos_gt1 formula-decl nil real_props nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (div_mult_pos_gt2 formula-decl nil extra_real_props nil)
    (sq const-decl "nonneg_real" sq reals)
    (div_mult_pos_ge1 formula-decl nil real_props nil)
    (gt_times_gt_any1 formula-decl nil extra_real_props nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}"
     real_defs nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   shostak))
 (finish_ramp 0
  (finish_ramp-1 nil 3612109828
   ("" (skosimp*) (("" (expand "vsAccelRamp") (("" (assert) nil nil)) nil))
    nil)
   ((vsAccelRamp const-decl "real" vsAccel nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil))
   shostak)))

