(era_examples
 (sqrt23_num_p11 0
  (sqrt23_num_p11-1 nil 3676376596
   ("" (then (era-numerical (! 1 1 2) :precision 11) (assert)) nil)
   ((PI adt-constructor-decl "(pi?)" CauchyExpr_adt
     "exact_real_arith/")
    (pi? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (SQRT adt-constructor-decl "[CauchyExpr -> (sqrt?)]" CauchyExpr_adt
     "exact_real_arith/")
    (sqrt? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (ADD adt-constructor-decl "[[CauchyExpr, CauchyExpr] -> (add?)]"
     CauchyExpr_adt "exact_real_arith/")
    (add? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (SUB adt-constructor-decl "[[CauchyExpr, CauchyExpr] -> (sub?)]"
     CauchyExpr_adt "exact_real_arith/")
    (sub? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (CauchyExpr type-decl nil CauchyExpr_adt "exact_real_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (Output type-eq-decl nil cauchy_numerical "exact_real_arith/")
    (numerical const-decl "Output" cauchy_numerical
     "exact_real_arith/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (numerical_soundness formula-decl nil cauchy_numerical
     "exact_real_arith/")
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def "trig/")
    (pi_bound name-judgement "{r: posreal | pi_lb < r AND r < pi_ub}"
     atan_approx "trig/")
    (sqrt_pos application-judgement "posreal" sqrt "reals/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt "reals/")
    (cos const-decl "real" sincos_def "trig/")
    (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}"
     pi_def "trig/"))
   shostak))
 (sin6sqrt2_num_p11 0
  (sin6sqrt2_num_p11-1 nil 3676376596
   ("" (then (era-numerical (! 1 1 2) :precision 11) (assert)) nil)
   ((SQRT adt-constructor-decl "[CauchyExpr -> (sqrt?)]" CauchyExpr_adt
     "exact_real_arith/")
    (sqrt? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (PI adt-constructor-decl "(pi?)" CauchyExpr_adt
     "exact_real_arith/")
    (pi? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (MULT adt-constructor-decl "[[CauchyExpr, CauchyExpr] -> (mult?)]"
     CauchyExpr_adt "exact_real_arith/")
    (mult? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (DIV adt-constructor-decl "[[CauchyExpr, CauchyExpr] -> (div?)]"
     CauchyExpr_adt "exact_real_arith/")
    (div? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (SIN adt-constructor-decl "[CauchyExpr -> (sin?)]" CauchyExpr_adt
     "exact_real_arith/")
    (sin? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (ADD adt-constructor-decl "[[CauchyExpr, CauchyExpr] -> (add?)]"
     CauchyExpr_adt "exact_real_arith/")
    (add? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (CauchyExpr type-decl nil CauchyExpr_adt "exact_real_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (Output type-eq-decl nil cauchy_numerical "exact_real_arith/")
    (numerical const-decl "Output" cauchy_numerical
     "exact_real_arith/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (numerical_soundness formula-decl nil cauchy_numerical
     "exact_real_arith/")
    (sqrt_pos application-judgement "posreal" sqrt "reals/")
    (sin_range application-judgement "real_abs_le1" sincos "trig/")
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def "trig/")
    (pi_bound name-judgement "{r: posreal | pi_lb < r AND r < pi_ub}"
     atan_approx "trig/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (sin const-decl "real" sincos_def "trig/")
    (cos const-decl "real" sincos_def "trig/")
    (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}"
     pi_def "trig/")
    (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt "reals/"))
   shostak))
 (exp_pi_num_p9 0
  (exp_pi_num_p9-1 nil 3676376596
   ("" (then (era-numerical (! 1 1 2) :precision 9) (assert)) nil)
   ((PI adt-constructor-decl "(pi?)" CauchyExpr_adt
     "exact_real_arith/")
    (pi? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (EXP adt-constructor-decl "[CauchyExpr -> (exp?)]" CauchyExpr_adt
     "exact_real_arith/")
    (exp? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (SUB adt-constructor-decl "[[CauchyExpr, CauchyExpr] -> (sub?)]"
     CauchyExpr_adt "exact_real_arith/")
    (sub? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (CauchyExpr type-decl nil CauchyExpr_adt "exact_real_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (Output type-eq-decl nil cauchy_numerical "exact_real_arith/")
    (numerical const-decl "Output" cauchy_numerical
     "exact_real_arith/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (numerical_soundness formula-decl nil cauchy_numerical
     "exact_real_arith/")
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def "trig/")
    (pi_bound name-judgement "{r: posreal | pi_lb < r AND r < pi_ub}"
     atan_approx "trig/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (ln const-decl "real" ln_exp "lnexp_fnd/")
    (exp const-decl "{py | x = ln(py)}" ln_exp "lnexp_fnd/")
    (cos const-decl "real" sincos_def "trig/")
    (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}"
     pi_def "trig/"))
   shostak))
 (div_small_num_z8_p24 0
  (div_small_num_z8_p24-1 nil 3676376596
   (""
    (then (era-numerical (! 1 1 2) :precision 24 :zero-prec 8)
     (assert))
    nil)
   ((PI adt-constructor-decl "(pi?)" CauchyExpr_adt
     "exact_real_arith/")
    (pi? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (MULT adt-constructor-decl "[[CauchyExpr, CauchyExpr] -> (mult?)]"
     CauchyExpr_adt "exact_real_arith/")
    (mult? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (DIV adt-constructor-decl "[[CauchyExpr, CauchyExpr] -> (div?)]"
     CauchyExpr_adt "exact_real_arith/")
    (div? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (CauchyExpr type-decl nil CauchyExpr_adt "exact_real_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (Output type-eq-decl nil cauchy_numerical "exact_real_arith/")
    (numerical const-decl "Output" cauchy_numerical
     "exact_real_arith/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (numerical_soundness formula-decl nil cauchy_numerical
     "exact_real_arith/")
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def "trig/")
    (pi_bound name-judgement "{r: posreal | pi_lb < r AND r < pi_ub}"
     atan_approx "trig/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (cos const-decl "real" sincos_def "trig/")
    (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}"
     pi_def "trig/"))
   shostak))
 (ln_small_num_z7_p9 0
  (ln_small_num_z7_p9-1 nil 3676376596
   (""
    (then (era-numerical (! 1 1 2) :precision 9 :zero-prec 7) (assert))
    nil)
   ((LN adt-constructor-decl "[CauchyExpr -> (ln?)]" CauchyExpr_adt
     "exact_real_arith/")
    (ln? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (CauchyExpr type-decl nil CauchyExpr_adt "exact_real_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (Output type-eq-decl nil cauchy_numerical "exact_real_arith/")
    (numerical const-decl "Output" cauchy_numerical
     "exact_real_arith/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (numerical_soundness formula-decl nil cauchy_numerical
     "exact_real_arith/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (ln const-decl "real" ln_exp "lnexp_fnd/")
    (Integral const-decl "real" integral_def "analysis/"))
   shostak))
 (trivial_binding 0
  (trivial_binding-1 nil 3676376596
   ("" (then (skeep) (era-numerical "q * q") (assert)) nil)
   ((val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (numerical_soundness formula-decl nil cauchy_numerical
     "exact_real_arith/")
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (numerical const-decl "Output" cauchy_numerical
     "exact_real_arith/")
    (Output type-eq-decl nil cauchy_numerical "exact_real_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (CauchyExpr type-decl nil CauchyExpr_adt "exact_real_arith/")
    (mult? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (MULT adt-constructor-decl "[[CauchyExpr, CauchyExpr] -> (mult?)]"
     CauchyExpr_adt "exact_real_arith/"))
   shostak))
 (sq_sin_cos_1 0
  (sq_sin_cos_1-1 nil 3703179302
   ("" (then (era-numerical "sq(sin(1)) + sq(cos(1))") (assert)) nil)
   ((COS adt-constructor-decl "[CauchyExpr -> (cos?)]" CauchyExpr_adt
     "exact_real_arith/")
    (cos? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (SIN adt-constructor-decl "[CauchyExpr -> (sin?)]" CauchyExpr_adt
     "exact_real_arith/")
    (sin? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (POW adt-constructor-decl "[[CauchyExpr, nat] -> (pow?)]"
     CauchyExpr_adt "exact_real_arith/")
    (pow? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (ADD adt-constructor-decl "[[CauchyExpr, CauchyExpr] -> (add?)]"
     CauchyExpr_adt "exact_real_arith/")
    (add? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (CauchyExpr type-decl nil CauchyExpr_adt "exact_real_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (Output type-eq-decl nil cauchy_numerical "exact_real_arith/")
    (numerical const-decl "Output" cauchy_numerical
     "exact_real_arith/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (numerical_soundness formula-decl nil cauchy_numerical
     "exact_real_arith/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (sq const-decl "nonneg_real" sq "reals/")
    (sin const-decl "real" sincos_def "trig/")
    (cos const-decl "real" sincos_def "trig/")
    (sq_expt2 formula-decl nil sq "reals/")
    (cos_range application-judgement "real_abs_le1" sincos "trig/")
    (sin_range application-judgement "real_abs_le1" sincos "trig/"))
   shostak))
 (pi_num_b210 0
  (pi_num_b210-1 nil 3703167028
   (""
    (then (beta) (era-numerical (! 1 1 2) :precision 210 :bin-prec? t)
     (assert))
    nil)
   ((PI adt-constructor-decl "(pi?)" CauchyExpr_adt
     "exact_real_arith/")
    (pi? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (CauchyExpr type-decl nil CauchyExpr_adt "exact_real_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (Output type-eq-decl nil cauchy_numerical "exact_real_arith/")
    (numerical const-decl "Output" cauchy_numerical
     "exact_real_arith/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (numerical_soundness formula-decl nil cauchy_numerical
     "exact_real_arith/")
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def "trig/")
    (pi_bound name-judgement "{r: posreal | pi_lb < r AND r < pi_ub}"
     atan_approx "trig/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (cos const-decl "real" sincos_def "trig/")
    (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}"
     pi_def "trig/"))
   shostak))
 (ln2_num_b210 0
  (ln2_num_b210-1 nil 3703167782
   (""
    (then (beta) (era-numerical (! 1 1 2) :precision 210 :bin-prec? t)
     (assert))
    nil)
   ((Integral const-decl "real" integral_def "analysis/")
    (ln const-decl "real" ln_exp "lnexp_fnd/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (numerical_soundness formula-decl nil cauchy_numerical
     "exact_real_arith/")
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (numerical const-decl "Output" cauchy_numerical
     "exact_real_arith/")
    (Output type-eq-decl nil cauchy_numerical "exact_real_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (CauchyExpr type-decl nil CauchyExpr_adt "exact_real_arith/")
    (ln? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (LN adt-constructor-decl "[CauchyExpr -> (ln?)]" CauchyExpr_adt
     "exact_real_arith/"))
   shostak))
 (e_num_b210 0
  (e_num_b210-1 nil 3703167782
   (""
    (then (beta) (era-numerical (! 1 1 2) :precision 210 :bin-prec? t)
     (assert))
    nil)
   ((CONST adt-constructor-decl "[rat -> (const?)]" CauchyExpr_adt
     "exact_real_arith/")
    (const? adt-recognizer-decl "[CauchyExpr -> boolean]"
     CauchyExpr_adt "exact_real_arith/")
    (EXP adt-constructor-decl "[CauchyExpr -> (exp?)]" CauchyExpr_adt
     "exact_real_arith/")
    (exp? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (CauchyExpr type-decl nil CauchyExpr_adt "exact_real_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (Output type-eq-decl nil cauchy_numerical "exact_real_arith/")
    (numerical const-decl "Output" cauchy_numerical
     "exact_real_arith/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (numerical_soundness formula-decl nil cauchy_numerical
     "exact_real_arith/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (e const-decl "posreal" ln_exp "lnexp_fnd/"))
   shostak))
 (sqrt2_num_b210 0
  (sqrt2_num_b210-1 nil 3703167782
   (""
    (then (beta) (era-numerical (! 1 1 2) :precision 210 :bin-prec? t)
     (assert))
    nil)
   ((sqrt_pos application-judgement "posreal" sqrt "reals/")
    (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt "reals/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (numerical_soundness formula-decl nil cauchy_numerical
     "exact_real_arith/")
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (numerical const-decl "Output" cauchy_numerical
     "exact_real_arith/")
    (Output type-eq-decl nil cauchy_numerical "exact_real_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (CauchyExpr type-decl nil CauchyExpr_adt "exact_real_arith/")
    (sqrt? adt-recognizer-decl "[CauchyExpr -> boolean]" CauchyExpr_adt
     "exact_real_arith/")
    (SQRT adt-constructor-decl "[CauchyExpr -> (sqrt?)]" CauchyExpr_adt
     "exact_real_arith/"))
   shostak)))

