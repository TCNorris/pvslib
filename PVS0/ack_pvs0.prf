(ack_pvs0
 (ack_op1_TCC1 0
  (ack_op1_TCC1-1 nil 3682020741 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (/= const-decl "boolean" notequal nil))
   nil (ack_op1 subtype "(number_fields.-)(ack_pvs0.m, 1)" "nat")))
 (ack_op2_TCC1 0
  (ack_op2_TCC1-1 nil 3682020741 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil (ack_op2 subtype "(number_fields.-)(ack_pvs0.v1`1, 1)" "nat")))
 (M1_TCC1 0
  (M1_TCC1-1 nil 3682020741 ("" (subtype-tcc) nil nil) nil nil
   (M1 subtype "LAMBDA (m, n: naturalnumbers.nat): reals.<(m, n)"
    "(orders[MT].well_founded?)")))
 (A0_TCC1 0
  (A0_TCC1-1 nil 3662226670 ("" (eval-formula) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   nil (A0 subtype "(: 1, 0 :)" "listn[Sign3].listn(2)")))
 (A0_TCC2 0
  (A0_TCC2-1 nil 3662226670 ("" (eval-formula) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (A0 subtype "(: (number_fields.-)(1), (number_fields.-)(1) :)"
       "listn[Sign3].listn(2)")))
 (A0_TCC3 0
  (A0_TCC3-1 nil 3662226670 ("" (eval-formula) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (A0 subtype
       "(: (: 1, 0 :), (: (number_fields.-)(1), (number_fields.-)(1) :) :)"
       "Measure_Matrix[2]")))
 (A1_TCC1 0
  (A1_TCC1-1 nil 3662226670 ("" (eval-formula) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   nil (A1 subtype "(: 1, (number_fields.-)(1) :)" "listn[Sign3].listn(2)")))
 (A1_TCC2 0
  (A1_TCC2-1 nil 3662226670 ("" (eval-formula) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (A1 subtype
       "(: (: 1, (number_fields.-)(1) :), (: (number_fields.-)(1), (number_fields.-)(1) :) :)"
       "Measure_Matrix[2]")))
 (A2_TCC1 0
  (A2_TCC1-1 nil 3662226670 ("" (eval-formula) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   nil (A2 subtype "(: 0, (number_fields.-)(1) :)" "listn[Sign3].listn(2)")))
 (A2_TCC2 0
  (A2_TCC2-1 nil 3662226670 ("" (eval-formula) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   nil (A2 subtype "(: (number_fields.-)(1), 1 :)" "listn[Sign3].listn(2)")))
 (A2_TCC3 0
  (A2_TCC3-1 nil 3683896183 ("" (eval-formula) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (A2 subtype
       "(: (: 0, (number_fields.-)(1) :), (: (number_fields.-)(1), 1 :) :)"
       "Measure_Matrix[2]")))
 (ack_mm_TCC1 0
  (ack_mm_TCC1-5 "" 3681839843 ("" (pvs0-mm "ack") nil nil)
   ((pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (indi_f_equiv formula-decl nil ccg_to_mwg CCG)
    (CallingContext type-eq-decl nil cc_def CCG)
    (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs)
    (cdigraph const-decl "bool" c_digraphs_def digraphs)
    (FunMeasures type-eq-decl nil ccg_def CCG)
    (CCG type-eq-decl nil ccg_def CCG)
    (below type-eq-decl nil naturalnumbers nil)
    (FunMeasure type-eq-decl nil ccg_def CCG)
    (make_ccg const-decl "CCG" ccg_def CCG)
    (sound_ccg_digraph const-decl "bool" pvs0_to_dg nil)
    (ack_dg const-decl "(sound_ccg_digraph(pvs0_ack))" ack_pvs0 nil)
    (ack_measures const-decl "FunMeasures" ack_pvs0 nil)
    (digraph_type type-eq-decl nil c_digraphs_imp digraphs)
    (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp
                   digraphs)
    (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]"
                   c_digraphs_imp digraphs)
    (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs)
    (vert? const-decl "bool" digraphs_ digraphs)
    (vert type-eq-decl nil digraphs_ digraphs)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (Sign3 type-eq-decl nil sign3 reals)
    (length def-decl "nat" list_props nil)
    (listn type-eq-decl nil listn structures)
    (Measure_Matrix type-eq-decl nil measures CCG)
    (indi_f type-eq-decl nil ccg_to_mwg CCG)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (A0 const-decl "Measure_Matrix" ack_pvs0 nil)
    (A1 const-decl "Measure_Matrix" ack_pvs0 nil)
    (A2 const-decl "Measure_Matrix" ack_pvs0 nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (PVS0Bool type-decl nil PVS0Bool_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Path type-eq-decl nil pvs0_cc nil) (MT type-eq-decl nil pvs0_prelude nil)
    (< const-decl "bool" reals nil) (PVS0 type-eq-decl nil pvs0_expr nil)
    (semantic_rel_expr inductive-decl "bool" pvs0_expr nil)
    (pvs0_ack const-decl "PVS0" ack_pvs0 nil)
    (eval_conds def-decl "bool" pvs0_cc nil)
    (indi_f_sound_iter def-decl "{b: bool |
   (FORALL (i_: below(N), j_: below(N)):
      i_ > i OR (i_ = i AND j_ >= j) IMPLIES
       FORALL (c: vert(dg(G))):
         (get(f(c))(i_, j_) = 1 IMPLIES gt(ms(G), c, i_, j_, FALSE)) AND
          (get(f(c))(i_, j_) = 0 IMPLIES gt(ms(G), c, i_, j_, TRUE)))
    = b}" ccg_to_mwg CCG)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (eval_op2 const-decl "Val" pvs0_expr nil) (gt const-decl "bool" ccg CCG)
    (le const-decl "bool" ccg_def CCG)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (eval_op1 const-decl "Val" pvs0_expr nil)
    (nth def-decl "T" list_props nil) (ge const-decl "bool" ccg_def CCG)
    (indi_f_sound_all_vertex def-decl "bool" ccg_to_mwg CCG)
    (rec adt-constructor-decl "[PVS0Expr -> (rec?)]" PVS0Expr_adt nil)
    (rec? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (op2 adt-constructor-decl "[[nat, PVS0Expr, PVS0Expr] -> (op2?)]"
     PVS0Expr_adt nil)
    (op2? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (pvs0not adt-constructor-decl "[PVS0Expr[T] -> (pvs0not?)]" PVS0Bool_adt
     nil)
    (pvs0not? adt-recognizer-decl "[PVS0Bool -> boolean]" PVS0Bool_adt nil)
    (pvs0bool adt-constructor-decl "[PVS0Expr[T] -> (pvs0bool?)]" PVS0Bool_adt
     nil)
    (pvs0bool? adt-recognizer-decl "[PVS0Bool -> boolean]" PVS0Bool_adt nil)
    (vr adt-constructor-decl "(vr?)" PVS0Expr_adt nil)
    (vr? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (op1 adt-constructor-decl "[[nat, PVS0Expr] -> (op1?)]" PVS0Expr_adt nil)
    (op1? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (ack_mm subtype
           "LAMBDA (v: digraphs_[CallingContext[[nat, nat], PVS0Expr[[nat, nat]], list[PVS0Bool[[nat, nat]]], Path[[nat, nat]]], digraph_type[CallingContext[[nat, nat], PVS0Expr[[nat, nat]], list[PVS0Bool[[nat, nat]]], Path[[nat, nat]]]], c_digraphs_imp[CallingContext[[nat, nat], PVS0Expr[[nat, nat]], list[PVS0Bool[[nat, nat]]], Path[[nat, nat]]]].digraph_verts, c_digraphs_imp[CallingContext[[nat, nat], PVS0Expr[[nat, nat]], list[PVS0Bool[[nat, nat]]], Path[[nat, nat]]]].digraph_edges, c_digraphs_imp[CallingContext[[nat, nat], PVS0Expr[[nat, nat]], list[PVS0Bool[[nat, nat]]], Path[[nat, nat]]]].digraph_size, c_digraphs_imp[CallingContext[[nat, nat], PVS0Expr[[nat, nat]], list[PVS0Bool[[nat, nat]]], Path[[nat, nat]]]].digraph_make].vert(dg(ccg_def[[nat, nat], PVS0Expr_adt[[nat, nat]].PVS0Expr, list_adt[PVS0Bool_adt[[nat, nat]].PVS0Bool].list, Path[[nat, nat]], MT, LAMBDA (m, n: naturalnumbers.nat): reals.<(m, n), 2].make_ccg(ack_pvs0.ack_dg, ack_pvs0.ack_measures)))): IF v`nid = (: 1, 2 :) THEN ack_pvs0.A0 ELSIF v`nid = (: 2, 2 :) THEN ack_pvs0.A1 ELSE ack_pvs0.A2 ENDIF"
           "(ccg_to_mwg[[nat, nat], PVS0Expr_adt[[nat, nat]].PVS0Expr, list_adt[PVS0Bool_adt[[nat, nat]].PVS0Bool].list, Path[[nat, nat]], MT, LAMBDA (m, n: naturalnumbers.nat): reals.<(m, n), 2, pvs0_expr[[nat, nat]].semantic_rel_expr(ack_pvs0.pvs0_ack), pvs0_cc[[nat, nat]].eval_conds(ack_pvs0.pvs0_ack)].indi_f_sound(ccg_def[[nat, nat], PVS0Expr_adt[[nat, nat]].PVS0Expr, list_adt[PVS0Bool_adt[[nat, nat]].PVS0Bool].list, Path[[nat, nat]], MT, LAMBDA (m, n: naturalnumbers.nat): reals.<(m, n), 2].make_ccg(ack_pvs0.ack_dg, ack_pvs0.ack_measures)))")))
 (pvs0_ack_terminating 0
  (pvs0_ack_terminating-1 nil 3707303588 ("" (pvs0-terminating "ack") nil nil)
   ((scp_iff_pvs0_terminates formula-decl nil scp_iff_pvs0 nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pvs0_ack const-decl "PVS0" ack_pvs0 nil)
    (PVS0 type-eq-decl nil pvs0_expr nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (list type-decl nil list_adt nil)
    (ccg_termination_pvs0 const-decl "bool" ccg_to_pvs0 nil)
    (eval_conds def-decl "bool" pvs0_cc nil)
    (semantic_rel_expr inductive-decl "bool" pvs0_expr nil)
    (mwg_termination_to_ccg_termination formula-decl nil ccg_to_mwg CCG)
    (CCG type-eq-decl nil ccg_def CCG) (make_ccg const-decl "CCG" ccg_def CCG)
    (c_bounding_from_gl_termination formula-decl nil bounding_circuits CCG)
    (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg
     CCG)
    (weight const-decl "Measure_Matrix[N]" ccg_to_mwg CCG)
    (edge type-eq-decl nil digraphs_ digraphs)
    (edge? const-decl "bool" digraphs_ digraphs)
    (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs)
    (edges const-decl "bool" c_digraphs_def digraphs)
    (c_digraph type-eq-decl nil c_digraphs_def digraphs)
    (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs)
    (wdg type-eq-decl nil matrix_wdg CCG)
    (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs)
    (id const-decl "Measure_Matrix" measures CCG)
    (* const-decl "Measure_Matrix" measures CCG)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (ack_mm const-decl "(indi_f_sound(make_ccg(ack_dg, ack_measures)))"
            ack_pvs0 nil)
    (indi_f_sound const-decl "bool" ccg_to_mwg CCG)
    (indi_f type-eq-decl nil ccg_to_mwg CCG)
    (Measure_Matrix type-eq-decl nil measures CCG)
    (listn type-eq-decl nil listn structures)
    (length def-decl "nat" list_props nil)
    (Sign3 type-eq-decl nil sign3 reals)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (vert type-eq-decl nil digraphs_ digraphs)
    (vert? const-decl "bool" digraphs_ digraphs)
    (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs)
    (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]"
                   c_digraphs_imp digraphs)
    (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp
                   digraphs)
    (digraph_type type-eq-decl nil c_digraphs_imp digraphs)
    (ack_dg const-decl "(sound_ccg_digraph(pvs0_ack))" ack_pvs0 nil)
    (sound_ccg_digraph const-decl "bool" pvs0_to_dg nil)
    (cdigraph const-decl "bool" c_digraphs_def digraphs)
    (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs)
    (CallingContext type-eq-decl nil cc_def CCG)
    (ack_measures const-decl "FunMeasures" ack_pvs0 nil)
    (FunMeasures type-eq-decl nil ccg_def CCG)
    (FunMeasure type-eq-decl nil ccg_def CCG)
    (Path type-eq-decl nil pvs0_cc nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (PVS0Bool type-decl nil PVS0Bool_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (ccg_implies_scp_pvs0 formula-decl nil ccg_to_pvs0 nil)
    (MT type-eq-decl nil pvs0_prelude nil) (< const-decl "bool" reals nil))
   nil
   (pvs0_ack_terminating subtype "ack_pvs0.pvs0_ack"
    "(pvs0_lang[[nat, nat]].terminating?)")))
 (pvs0_ack_tcc_termination 0
  (pvs0_ack_tcc_termination-2 nil 3707172681
   ("" (use "terminates_implies_pvs0_tcc") (("" (assert) nil nil)) nil)
   ((pvs0_ack_terminating name-judgement "(terminating?)" ack_pvs0 nil)
    (list type-decl nil list_adt nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (PVS0 type-eq-decl nil pvs0_expr nil)
    (pvs0_ack const-decl "PVS0" ack_pvs0 nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (terminates_implies_pvs0_tcc formula-decl nil measure_termination nil))
   nil
   (pvs0_ack_tcc_termination subtype "ack_pvs0.pvs0_ack"
    "(measure_termination_defs[[nat, nat], MT, LAMBDA (m, n: naturalnumbers.nat): reals.<(m, n)].pvs0_tcc_termination)"))
  (pvs0_ack_tcc_termination-1 nil 3681660963
   ("" (use "ack_terminates")
    (("" (use "terminates_implies_pvs0_tcc") (("" (assert) nil nil)) nil))
    nil)
   ((terminates_implies_pvs0_tcc formula-decl nil measure_termination nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (EvalOp2 type-eq-decl nil pvs0_expr nil)
    (EvalOp1 type-eq-decl nil pvs0_expr nil))
   nil
   (pvs0_ack_tcc_termination subtype "ack_pvs0.pvs0_ack"
    "(measure_termination_defs[[nat, nat], MT, LAMBDA (m, n: naturalnumbers.nat): reals.<(m, n)].pvs0_tcc_termination)")))
 (ack_msr 0
  (ack_msr-2 nil 3683905380
   ("" (typepred "pvs0_ack")
    (("" (expand "pvs0_tcc_termination") (("" (propax) nil nil)) nil)) nil)
   ((pvs0_ack_tcc_termination name-judgement "(pvs0_tcc_termination)" ack_pvs0
     nil)
    (pvs0_ack_terminating name-judgement "(terminating?)" ack_pvs0 nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (PVS0 type-eq-decl nil pvs0_expr nil)
    (MT type-eq-decl nil pvs0_prelude nil) (< const-decl "bool" reals nil)
    (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil)
    (pvs0_ack const-decl "PVS0" ack_pvs0 nil)
    (terminating? const-decl "bool" pvs0_lang nil))
   nil)
  (ack_msr-1 nil 3683905327 ("" (assert) (("" (postpone) nil nil)) nil) nil
   shostak))
 (ack_wfm_TCC1 0
  (ack_wfm_TCC1-2 nil 3653236289
   ("" (lemma "pvs0_ack_tcc_termination")
    (("" (expand "pvs0_tcc_termination")
      (("" (skeep -) (("" (inst? 1) nil nil)) nil)) nil))
    nil)
   ((pvs0_tcc_termination const-decl "bool" measure_termination_defs nil)
    (wfm skolem-const-decl "WFM[[nat, nat], MT, LAMBDA (m, n: nat): m < n]"
     ack_pvs0 nil)
    (pvs0_ack const-decl "PVS0" ack_pvs0 nil)
    (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil)
    (PVS0 type-eq-decl nil pvs0_expr nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (list type-decl nil list_adt nil)
    (WFM type-eq-decl nil measure_termination_defs nil)
    (< const-decl "bool" reals nil) (MT type-eq-decl nil pvs0_prelude nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (pvs0_ack_terminating name-judgement "(terminating?)" ack_pvs0 nil)
    (pvs0_ack_tcc_termination name-judgement "(pvs0_tcc_termination)" ack_pvs0
     nil)
    (pvs0_ack_tcc_termination judgement-tcc nil ack_pvs0 nil))
   nil
   (ack_wfm existence ""
    "(measure_termination_defs[[nat, nat], MT, LAMBDA (m, n: naturalnumbers.nat): reals.<(m, n)].pvs0_tcc_termination_pred(ack_pvs0.pvs0_ack))"))
  (ack_wfm_TCC1-1 nil 3653236216 ("" (existence-tcc) nil nil) nil nil
   (ack_wfm existence ""
    "(measure_termination_defs[[nat, nat], MT, LAMBDA (m, n: naturalnumbers.nat): reals.<(m, n)].pvs0_tcc_termination_pred(ack_pvs0.pvs0_ack))"))))

