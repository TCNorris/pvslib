(pvs0_cc (eval_conds_TCC1 0 (eval_conds_TCC1-1 nil 3651334721 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)) nil (eval_conds termination "pvs0_cc.eval_conds(pvs0_cc.pvs0)(pvs0_cc.q, pvs0_cc.env)" "nil"))) (valid_path_TCC1 0 (valid_path_TCC1-2 nil 3651338294 ("" (termination-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (<< adt-def-decl "(strict_well_founded?[PVS0Expr])" PVS0Expr_adt nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rac const-decl "T" more_list_props structures)) nil (valid_path termination "pvs0_cc.valid_path(pvs0_cc.a)" "nil")) (valid_path_TCC1-1 nil 3651338028 ("" (well-founded-tcc) nil nil) nil nil (valid_path termination "pvs0_cc.valid_path(pvs0_cc.a)" "nil"))) (valid_path_TCC2 0 (valid_path_TCC2-1 nil 3651338028 ("" (termination-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (<< adt-def-decl "(strict_well_founded?[PVS0Expr])" PVS0Expr_adt nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rac const-decl "T" more_list_props structures)) nil (valid_path termination "pvs0_cc.valid_path(pvs0_cc.a1)" "nil"))) (valid_path_TCC3 0 (valid_path_TCC3-1 nil 3651338028 ("" (termination-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (<< adt-def-decl "(strict_well_founded?[PVS0Expr])" PVS0Expr_adt nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rac const-decl "T" more_list_props structures) (rdc const-decl "list[T]" more_list_props structures)) nil (valid_path termination "pvs0_cc.valid_path(pvs0_cc.a2)" "nil"))) (valid_path_TCC4 0 (valid_path_TCC4-1 nil 3651338028 ("" (termination-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (<< adt-def-decl "(strict_well_founded?[PVS0Expr])" PVS0Expr_adt nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rac const-decl "T" more_list_props structures)) nil (valid_path termination "pvs0_cc.valid_path(pvs0_cc.a)" "nil"))) (valid_path_TCC5 0 (valid_path_TCC5-1 nil 3651338028 ("" (termination-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (<< adt-def-decl "(strict_well_founded?[PVS0Expr])" PVS0Expr_adt nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rac const-decl "T" more_list_props structures)) nil (valid_path termination "pvs0_cc.valid_path(pvs0_cc.c)" "nil"))) (valid_path_TCC6 0 (valid_path_TCC6-1 nil 3651338028 ("" (termination-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (<< adt-def-decl "(strict_well_founded?[PVS0Expr])" PVS0Expr_adt nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rac const-decl "T" more_list_props structures) (rdc const-decl "list[T]" more_list_props structures)) nil (valid_path termination "pvs0_cc.valid_path(pvs0_cc.t)" "nil"))) (valid_path_TCC7 0 (valid_path_TCC7-1 nil 3651338028 ("" (termination-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (<< adt-def-decl "(strict_well_founded?[PVS0Expr])" PVS0Expr_adt nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rac const-decl "T" more_list_props structures) (rdc const-decl "list[T]" more_list_props structures)) nil (valid_path termination "pvs0_cc.valid_path(pvs0_cc.e)" "nil"))) (subterm_at_TCC1 0 (subterm_at_TCC1-2 nil 3651338539 ("" (skeep) (("" (grind) nil nil)) nil) ((subterm adt-def-decl "boolean" PVS0Expr_adt nil)) nil (subterm_at subtype "pvs0_cc.expr" "({res: PVS0Expr_adt[pvs0_cc.Val].PVS0Expr | PVS0Expr_adt[pvs0_cc.Val].subterm(res, pvs0_cc.expr)})")) (subterm_at_TCC1-1 nil 3651338398 ("" (subtype-tcc) nil nil) nil nil (subterm_at subtype "pvs0_cc.expr" "({res: PVS0Expr_adt[pvs0_cc.Val].PVS0Expr | PVS0Expr_adt[pvs0_cc.Val].subterm(res, pvs0_cc.expr)})"))) (subterm_at_TCC2 0 (subterm_at_TCC2-2 nil 3651338571 ("" (skeep*) (("" (typepred "path") (("" (replace -3) (("" (expand "valid_path" -2) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((valid_path def-decl "bool" pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (subterm_at subtype "more_list_props[nat].rdc(pvs0_cc.path)" "(pvs0_cc.valid_path(pvs0_cc.a))")) (subterm_at_TCC2-1 nil 3651338398 ("" (subtype-tcc) nil nil) nil nil (subterm_at subtype "more_list_props[nat].rdc(pvs0_cc.path)" "(pvs0_cc.valid_path(pvs0_cc.a))"))) (subterm_at_TCC3 0 (subterm_at_TCC3-1 nil 3651338398 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (Path type-eq-decl nil pvs0_cc nil) (Val formal-nonempty-type-decl nil pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (valid_path def-decl "bool" pvs0_cc nil) (rac const-decl "T" more_list_props structures) (rdc const-decl "list[T]" more_list_props structures) (<< adt-def-decl "(strict_well_founded?[PVS0Expr])" PVS0Expr_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (subterm_at termination "pvs0_cc.subterm_at(pvs0_cc.a, more_list_props[nat].rdc(pvs0_cc.path))" "nil"))) (subterm_at_TCC4 0 (subterm_at_TCC4-2 nil 3651338598 ("" (skeep*) (("" (typepred "v(a, rdc(path))") (("1" (expand "subterm" 2) (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "path") (("2" (replace -3) (("2" (expand "valid_path" -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((rdc const-decl "list[T]" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (<< adt-def-decl "(strict_well_founded?[PVS0Expr])" PVS0Expr_adt nil) (strict_well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil pvs0_cc nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (subterm_at subtype "pvs0_cc.subterm_at(pvs0_cc.a, more_list_props[nat].rdc(pvs0_cc.path))" "({res: PVS0Expr_adt[pvs0_cc.Val].PVS0Expr | PVS0Expr_adt[pvs0_cc.Val].subterm(res, pvs0_cc.expr)})")) (subterm_at_TCC4-1 nil 3651338398 ("" (subtype-tcc) nil nil) nil nil (subterm_at subtype "pvs0_cc.subterm_at(pvs0_cc.a, more_list_props[nat].rdc(pvs0_cc.path))" "({res: PVS0Expr_adt[pvs0_cc.Val].PVS0Expr | PVS0Expr_adt[pvs0_cc.Val].subterm(res, pvs0_cc.expr)})"))) (subterm_at_TCC5 0 (subterm_at_TCC5-3 "" 3804629101 ("" (skeep*) (("" (typepred "path") (("" (replace -3) (("" (expand "valid_path" -2) (("" (assert) nil nil)) nil)) nil)) nil)) nil) nil shostak (subterm_at subtype "more_list_props[nat].rdc(pvs0_cc.path)" "(pvs0_cc.valid_path(pvs0_cc.a))")) (subterm_at_TCC5-2 nil 3651338620 ("" (skeep*) (("" (typepred "path") (("" (replace -4) (("" (expand "valid_path" -2) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((valid_path def-decl "bool" pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (subterm_at subtype "more_list_props[nat].rdc(pvs0_cc.path)" "(pvs0_cc.valid_path(pvs0_cc.a))")) (subterm_at_TCC5-1 nil 3651338398 ("" (subtype-tcc) nil nil) nil nil (subterm_at subtype "more_list_props[nat].rdc(pvs0_cc.path)" "(pvs0_cc.valid_path(pvs0_cc.a))"))) (subterm_at_TCC6 0 (subterm_at_TCC6-3 "" 3804629155 ("" (skeep*) (("" (typepred "v(a, rdc(path))") (("1" (replace -2) (("1" (expand "subterm" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "path") (("2" (replace -3) (("2" (expand "valid_path" -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak (subterm_at subtype "pvs0_cc.subterm_at(pvs0_cc.a, more_list_props[nat].rdc(pvs0_cc.path))" "({res: PVS0Expr_adt[pvs0_cc.Val].PVS0Expr | PVS0Expr_adt[pvs0_cc.Val].subterm(res, pvs0_cc.expr)})")) (subterm_at_TCC6-2 nil 3651338641 ("" (skeep*) (("" (typepred "v(a, rdc(path))") (("1" (replace -3) (("1" (expand "subterm" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "path") (("2" (replace -4) (("2" (expand "valid_path" -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((rdc const-decl "list[T]" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (<< adt-def-decl "(strict_well_founded?[PVS0Expr])" PVS0Expr_adt nil) (strict_well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil pvs0_cc nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (subterm_at subtype "pvs0_cc.subterm_at(pvs0_cc.a, more_list_props[nat].rdc(pvs0_cc.path))" "({res: PVS0Expr_adt[pvs0_cc.Val].PVS0Expr | PVS0Expr_adt[pvs0_cc.Val].subterm(res, pvs0_cc.expr)})")) (subterm_at_TCC6-1 nil 3651338398 ("" (subtype-tcc) nil nil) nil nil (subterm_at subtype "pvs0_cc.subterm_at(pvs0_cc.a, more_list_props[nat].rdc(pvs0_cc.path))" "({res: PVS0Expr_adt[pvs0_cc.Val].PVS0Expr | PVS0Expr_adt[pvs0_cc.Val].subterm(res, pvs0_cc.expr)})"))) (subterm_at_TCC7 0 (subterm_at_TCC7-2 nil 3651338679 ("" (termination-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (Val formal-nonempty-type-decl nil pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (valid_path def-decl "bool" pvs0_cc nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (length def-decl "nat" list_props nil) (reverse def-decl "list[T]" list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rac const-decl "T" more_list_props structures) (rdc const-decl "list[T]" more_list_props structures)) nil (subterm_at subtype "more_list_props[nat].rdc(pvs0_cc.path)" "(pvs0_cc.valid_path(pvs0_cc.b))")) (subterm_at_TCC7-1 nil 3651338398 ("" (subtype-tcc) nil nil) nil nil (subterm_at subtype "more_list_props[nat].rdc(pvs0_cc.path)" "(pvs0_cc.valid_path(pvs0_cc.b))"))) (subterm_at_TCC8 0 (subterm_at_TCC8-1 nil 3651338398 ("" (termination-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (Val formal-nonempty-type-decl nil pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (valid_path def-decl "bool" pvs0_cc nil) (rdc const-decl "list[T]" more_list_props structures) (length def-decl "nat" list_props nil) (<< adt-def-decl "(strict_well_founded?[PVS0Expr])" PVS0Expr_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rac const-decl "T" more_list_props structures)) nil (subterm_at termination "pvs0_cc.subterm_at(pvs0_cc.b, more_list_props[nat].rdc(pvs0_cc.path))" "nil"))) (subterm_at_TCC9 0 (subterm_at_TCC9-2 nil 3651338717 ("" (skeep*) (("" (typepred "v(b, rdc(path))") (("1" (replace -2) (("1" (expand "subterm" 3) (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "path") (("2" (replace -3) (("2" (expand "valid_path" -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((rdc const-decl "list[T]" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (<< adt-def-decl "(strict_well_founded?[PVS0Expr])" PVS0Expr_adt nil) (strict_well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil pvs0_cc nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (subterm_at subtype "pvs0_cc.subterm_at(pvs0_cc.b, more_list_props[nat].rdc(pvs0_cc.path))" "({res: PVS0Expr_adt[pvs0_cc.Val].PVS0Expr | PVS0Expr_adt[pvs0_cc.Val].subterm(res, pvs0_cc.expr)})")) (subterm_at_TCC9-1 nil 3651338398 ("" (subtype-tcc) nil nil) nil nil (subterm_at subtype "pvs0_cc.subterm_at(pvs0_cc.b, more_list_props[nat].rdc(pvs0_cc.path))" "({res: PVS0Expr_adt[pvs0_cc.Val].PVS0Expr | PVS0Expr_adt[pvs0_cc.Val].subterm(res, pvs0_cc.expr)})"))) (subterm_at_TCC10 0 (subterm_at_TCC10-2 nil 3651338741 ("" (skeep*) (("" (typepred "path") (("" (replace -3) (("" (expand "valid_path" -2) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((valid_path def-decl "bool" pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (subterm_at subtype "more_list_props[nat].rdc(pvs0_cc.path)" "(pvs0_cc.valid_path(pvs0_cc.a))")) (subterm_at_TCC10-1 nil 3651338398 ("" (subtype-tcc) nil nil) nil nil (subterm_at subtype "more_list_props[nat].rdc(pvs0_cc.path)" "(pvs0_cc.valid_path(pvs0_cc.a))"))) (subterm_at_TCC11 0 (subterm_at_TCC11-1 nil 3651338398 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (Path type-eq-decl nil pvs0_cc nil) (Val formal-nonempty-type-decl nil pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (valid_path def-decl "bool" pvs0_cc nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (rac const-decl "T" more_list_props structures) (rdc const-decl "list[T]" more_list_props structures) (<< adt-def-decl "(strict_well_founded?[PVS0Expr])" PVS0Expr_adt nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (subterm_at termination "pvs0_cc.subterm_at(pvs0_cc.a, more_list_props[nat].rdc(pvs0_cc.path))" "nil"))) (subterm_at_TCC12 0 (subterm_at_TCC12-2 nil 3651338767 ("" (skeep*) (("" (typepred "v(a, rdc(path))") (("1" (replace -2) (("1" (expand "subterm" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "path") (("2" (replace -3) (("2" (expand "valid_path" -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((rdc const-decl "list[T]" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (<< adt-def-decl "(strict_well_founded?[PVS0Expr])" PVS0Expr_adt nil) (strict_well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil pvs0_cc nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (subterm_at subtype "pvs0_cc.subterm_at(pvs0_cc.a, more_list_props[nat].rdc(pvs0_cc.path))" "({res: PVS0Expr_adt[pvs0_cc.Val].PVS0Expr | PVS0Expr_adt[pvs0_cc.Val].subterm(res, pvs0_cc.expr)})")) (subterm_at_TCC12-1 nil 3651338398 ("" (subtype-tcc) nil nil) nil nil (subterm_at subtype "pvs0_cc.subterm_at(pvs0_cc.a, more_list_props[nat].rdc(pvs0_cc.path))" "({res: PVS0Expr_adt[pvs0_cc.Val].PVS0Expr | PVS0Expr_adt[pvs0_cc.Val].subterm(res, pvs0_cc.expr)})"))) (subterm_at_TCC13 0 (subterm_at_TCC13-2 nil 3651338789 ("" (skeep*) (("" (typepred "path") (("" (replace -3) (("" (expand "valid_path" -2) (("" (assert) (("" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((valid_path def-decl "bool" pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (subterm_at subtype "more_list_props[nat].rdc(pvs0_cc.path)" "(pvs0_cc.valid_path(IF more_list_props[nat].rac(pvs0_cc.path) = 0 THEN pvs0_cc.c ELSIF more_list_props[nat].rac(pvs0_cc.path) = 1 THEN pvs0_cc.t ELSE pvs0_cc.e ENDIF))")) (subterm_at_TCC13-1 nil 3651338398 ("" (subtype-tcc) nil nil) nil nil (subterm_at subtype "more_list_props[nat].rdc(pvs0_cc.path)" "(pvs0_cc.valid_path(IF more_list_props[nat].rac(pvs0_cc.path) = 0 THEN pvs0_cc.c ELSIF more_list_props[nat].rac(pvs0_cc.path) = 1 THEN pvs0_cc.t ELSE pvs0_cc.e ENDIF))"))) (subterm_at_TCC14 0 (subterm_at_TCC14-1 nil 3651338398 ("" (termination-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (Val formal-nonempty-type-decl nil pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (valid_path def-decl "bool" pvs0_cc nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (<< adt-def-decl "(strict_well_founded?[PVS0Expr])" PVS0Expr_adt nil) (length def-decl "nat" list_props nil) (rdc const-decl "list[T]" more_list_props structures) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rac const-decl "T" more_list_props structures)) nil (subterm_at termination "pvs0_cc.subterm_at(IF more_list_props[nat].rac(pvs0_cc.path) = 0 THEN pvs0_cc.c ELSIF more_list_props[nat].rac(pvs0_cc.path) = 1 THEN pvs0_cc.t ELSE pvs0_cc.e ENDIF, more_list_props[nat].rdc(pvs0_cc.path))" "nil"))) (subterm_at_TCC15 0 (subterm_at_TCC15-2 nil 3651338818 ("" (skeep*) (("" (typepred "(v(IF rac(path) = 0 THEN c
                 ELSIF rac(path) = 1 THEN t
                 ELSE e
                 ENDIF,
                 rdc(path)))") (("1" (replace -2) (("1" (expand "subterm" 2) (("1" (flatten) (("1" (lift-if) (("1" (prop) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "path") (("2" (replace -3) (("2" (expand "valid_path" -2) (("2" (assert) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rdc const-decl "list[T]" more_list_props structures) (rac const-decl "T" more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (<< adt-def-decl "(strict_well_founded?[PVS0Expr])" PVS0Expr_adt nil) (strict_well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil pvs0_cc nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (subterm_at subtype "pvs0_cc.subterm_at(IF more_list_props[nat].rac(pvs0_cc.path) = 0 THEN pvs0_cc.c ELSIF more_list_props[nat].rac(pvs0_cc.path) = 1 THEN pvs0_cc.t ELSE pvs0_cc.e ENDIF, more_list_props[nat].rdc(pvs0_cc.path))" "({res: PVS0Expr_adt[pvs0_cc.Val].PVS0Expr | PVS0Expr_adt[pvs0_cc.Val].subterm(res, pvs0_cc.expr)})")) (subterm_at_TCC15-1 nil 3651338398 ("" (subtype-tcc) nil nil) nil nil (subterm_at subtype "pvs0_cc.subterm_at(IF more_list_props[nat].rac(pvs0_cc.path) = 0 THEN pvs0_cc.c ELSIF more_list_props[nat].rac(pvs0_cc.path) = 1 THEN pvs0_cc.t ELSE pvs0_cc.e ENDIF, more_list_props[nat].rdc(pvs0_cc.path))" "({res: PVS0Expr_adt[pvs0_cc.Val].PVS0Expr | PVS0Expr_adt[pvs0_cc.Val].subterm(res, pvs0_cc.expr)})"))) (subterm_at_TCC16 0 (subterm_at_TCC16-2 nil 3651338845 ("" (skeep*) (("" (expand "subterm") (("" (propax) nil nil)) nil)) nil) ((subterm adt-def-decl "boolean" PVS0Expr_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (subterm_at subtype "pvs0_cc.expr" "({res: PVS0Expr_adt[pvs0_cc.Val].PVS0Expr | PVS0Expr_adt[pvs0_cc.Val].subterm(res, pvs0_cc.expr)})")) (subterm_at_TCC16-1 nil 3651338398 ("" (subtype-tcc) nil nil) nil nil (subterm_at subtype "pvs0_cc.expr" "({res: PVS0Expr_adt[pvs0_cc.Val].PVS0Expr | PVS0Expr_adt[pvs0_cc.Val].subterm(res, pvs0_cc.expr)})"))) (path_conditions_TCC1 0 (path_conditions_TCC1-3 "" 3790336255 ("" (measure-induct+ "length(path_)" "path_") (("" (skeep) (("" (typepred "path") (("" (expand "valid_path" 1) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (hide-all-but (-1 -3 -5)) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (hide-all-but (-1 -3 -5)) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (inst -4 "rdc(x!1)") (("1" (inst -4 "get_arg(expr)" "rdc(path)" "n") (("1" (split -4) (("1" (assert) (("1" (expand "valid_path" -4) (("1" (prop) (("1" (replace -6) (("1" (lemma "rac_append[nat]") (("1" (inst -1 "(: n:)" "x!1") (("1" (expand "append") (("1" (expand "append") (("1" (replaces -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -4) (("2" (lemma "rdc_append[nat]") (("2" (inst -1 "(:n:)" "x!1") (("2" (expand "append") (("2" (expand "append") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 2)) (("3" (expand "rdc") (("3" (rewrite "length_reverse") (("3" (use "length_reverse[nat]") (("3" (replaces -1 :dir rl) (("3" (rewrite "length_null_list" :dir rl) (("3" (use "length_reverse[nat]") (("3" (replaces -1 2 :dir rl) (("3" (rewrite "length_null_list") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "valid_path" -3) (("2" (assert) nil nil)) nil) ("3" (replace -5) (("3" (assert) nil nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand "valid_path" -3) (("1" (assert) (("1" (replace -5) (("1" (lemma "rac_append[nat]") (("1" (inst -1 "(: n:)" "x!1") (("1" (expand "append") (("1" (expand "append") (("1" (replaces -1) (("1" (inst -4 "rdc(x!1)") (("1" (case "length(rdc(x!1)) < length(x!1)") (("1" (assert) (("1" (split -4) (("1" (flatten) (("1" (assert) (("1" (inst?) (("1" (inst -6 "rdc(path)" "n") (("1" (split -6) (("1" (propax) nil nil) ("2" (replace -6) (("2" (lemma "rdc_append[nat]") (("2" (inst -1 "(: n :)" "x!1") (("2" (expand "append") (("2" (expand "append") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (inst -6 "get_arg2(expr)" "rdc(path)" "n") (("2" (split -6) (("1" (propax) nil nil) ("2" (lemma "rdc_append[nat]") (("2" (inst -1 "(: n:)" "x!1") (("2" (expand "append") (("2" (expand "append") (("2" (replace -7) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (expand "rdc") (("2" (rewrite "length_reverse") (("2" (rewrite "length_null_list" :dir rl) (("2" (use "length_reverse[nat]") (("2" (replaces -1 :dir rl) (("2" (rewrite "length_null_list") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (replace -5) (("1" (expand "valid_path" -3) (("1" (assert) (("1" (flatten) (("1" (inst -5 "rdc(x!1)") (("1" (lemma "rac_append[nat]") (("1" (inst -1 "(: n:)" "x!1") (("1" (expand "append") (("1" (expand "append") (("1" (replaces -1) (("1" (inst -5 "get_arg(expr)" "rdc(path)" "n") (("1" (split -5) (("1" (assert) nil nil) ("2" (lemma "rdc_append[nat]") (("2" (inst -1 "(:n:)" "x!1") (("2" (expand "append") (("2" (expand "append") (("2" (replace -6) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 2)) (("3" (expand "rdc" 1) (("3" (rewrite "length_reverse") (("3" (rewrite "length_null_list" :dir rl) (("3" (use "length_reverse[nat]") (("3" (replaces -1 :dir rl) (("3" (rewrite "length_null_list") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -3 "rdc(x!1)") (("2" (case "length(rdc(x!1)) < length(x!1)") (("1" (assert) (("1" (expand "valid_path" -3) (("1" (assert) (("1" (split -3) (("1" (flatten) (("1" (inst -5 "get_cond(expr)" "rdc(path)" "n") (("1" (split -5) (("1" (lemma "rac_append[nat]") (("1" (inst -1 "(: n:)" "x!1") (("1" (expand "append") (("1" (expand "append") (("1" (replace -7) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5) (("2" (lemma "rdc_append[nat]") (("2" (inst -1 "(:n:)" "x!1") (("2" (expand "append") (("2" (expand "append") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -5 "get_if(expr)" "rdc(path)" "n") (("2" (split -5) (("1" (replace -6) (("1" (lemma "rac_append[nat]") (("1" (inst -1 "(: n:)" "x!1") (("1" (expand "append") (("1" (expand "append") (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5) (("2" (lemma "rdc_append[nat]") (("2" (inst -1 "(:n:)" "x!1") (("2" (expand "append") (("2" (expand "append") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (inst -5 "get_else(expr)" "rdc(path)" "n") (("3" (split -5) (("1" (replace -6) (("1" (lemma "rac_append[nat]") (("1" (inst -1 "(:n:)" "x!1") (("1" (expand "append") (("1" (expand "append") (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "rdc_append[nat]") (("2" (inst -1 "(:n:)" "x!1") (("2" (expand "append") (("2" (expand "append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (expand "rdc") (("2" (rewrite "length_reverse") (("2" (rewrite "length_null_list" :dir rl) (("2" (use "length_reverse[nat]") (("2" (replaces -1 :dir rl) (("2" (rewrite "length_null_list") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (x!1 skolem-const-decl "list[nat]" pvs0_cc nil) (rdc const-decl "list[T]" more_list_props structures) (append def-decl "list[T]" list_props nil) (rac_append formula-decl nil more_list_props structures) (rdc_append formula-decl nil more_list_props structures) (length_null_list formula-decl nil more_list_props structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (TRUE const-decl "bool" booleans nil) (length_reverse formula-decl nil list_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (reverse def-decl "list[T]" list_props nil) (get_arg shared-adt-accessor-decl "[{x: PVS0Expr | op1?(x) OR rec?(x)} -> PVS0Expr]" PVS0Expr_adt nil) (path skolem-const-decl "(valid_path(expr))" pvs0_cc nil) (rec? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (expr skolem-const-decl "PVS0Expr[Val]" pvs0_cc nil) (op1? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (get_arg2 adt-accessor-decl "[(op2?) -> PVS0Expr]" PVS0Expr_adt nil) (get_arg1 adt-accessor-decl "[(op2?) -> PVS0Expr]" PVS0Expr_adt nil) (op2? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (get_else adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil) (get_if adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil) (get_cond adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil) (ite? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil pvs0_cc nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak (path_conditions subtype "pvs0_cc.path_" "(pvs0_cc.valid_path(pvs0_cc.expr))")) (path_conditions_TCC1-2 nil 3651338867 ("" (measure-induct+ "length(path_)" "path_") (("" (skeep) (("" (typepred "path") (("" (expand "valid_path" 1) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (hide-all-but (-1 -3 -5)) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (hide-all-but (-1 -3 -5)) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (inst -4 "rdc(x!1)") (("1" (inst -4 "get_arg(expr)" "rdc(path)" "n") (("1" (split -4) (("1" (assert) (("1" (expand "valid_path" -4) (("1" (prop) (("1" (replace -6) (("1" (lemma "rac_append[nat]") (("1" (inst -1 "(: n:)" "x!1") (("1" (expand "append") (("1" (expand "append") (("1" (replaces -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -4) (("2" (lemma "rdc_append[nat]") (("2" (inst -1 "(:n:)" "x!1") (("2" (expand "append") (("2" (expand "append") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 2)) (("3" (expand "rdc") (("3" (rewrite "length_reverse") (("3" (use "length_reverse[nat]") (("3" (replaces -1 :dir rl) (("3" (rewrite "length_null_list" :dir rl) (("3" (use "length_reverse[nat]") (("3" (replaces -1 2 :dir rl) (("3" (rewrite "length_null_list") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "valid_path" -3) (("2" (assert) nil nil)) nil) ("3" (replace -5) (("3" (assert) nil nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand "valid_path" -3) (("1" (assert) (("1" (replace -5) (("1" (lemma "rac_append[nat]") (("1" (inst -1 "(: n:)" "x!1") (("1" (expand "append") (("1" (expand "append") (("1" (replaces -1) (("1" (inst -4 "rdc(x!1)") (("1" (case "length(rdc(x!1)) < length(x!1)") (("1" (assert) (("1" (split -4) (("1" (flatten) (("1" (assert) (("1" (inst?) (("1" (inst -6 "rdc(path)" "n") (("1" (split -6) (("1" (propax) nil nil) ("2" (replace -6) (("2" (lemma "rdc_append[nat]") (("2" (inst -1 "(: n :)" "x!1") (("2" (expand "append") (("2" (expand "append") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (inst -6 "get_arg2(expr)" "rdc(path)" "n") (("2" (split -6) (("1" (propax) nil nil) ("2" (lemma "rdc_append[nat]") (("2" (inst -1 "(: n:)" "x!1") (("2" (expand "append") (("2" (expand "append") (("2" (replace -7) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (expand "rdc") (("2" (rewrite "length_reverse") (("2" (rewrite "length_null_list" :dir rl) (("2" (use "length_reverse[nat]") (("2" (replaces -1 :dir rl) (("2" (rewrite "length_null_list") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (replace -5) (("1" (expand "valid_path" -3) (("1" (assert) (("1" (flatten) (("1" (inst -5 "rdc(x!1)") (("1" (lemma "rac_append[nat]") (("1" (inst -1 "(: n:)" "x!1") (("1" (expand "append") (("1" (expand "append") (("1" (replaces -1) (("1" (inst -5 "get_arg(expr)" "rdc(path)" "n") (("1" (split -5) (("1" (assert) nil nil) ("2" (lemma "rdc_append[nat]") (("2" (inst -1 "(:n:)" "x!1") (("2" (expand "append") (("2" (expand "append") (("2" (replace -6) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 2)) (("3" (expand "rdc" 1) (("3" (rewrite "length_reverse") (("3" (rewrite "length_null_list" :dir rl) (("3" (use "length_reverse[nat]") (("3" (replaces -1 :dir rl) (("3" (rewrite "length_null_list") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -3 "rdc(x!1)") (("2" (case "length(rdc(x!1)) < length(x!1)") (("1" (assert) (("1" (expand "valid_path" -3) (("1" (lift-if) (("1" (assert) (("1" (split -3) (("1" (flatten) (("1" (inst -5 "get_cond(expr)" "rdc(path)" "n") (("1" (split -5) (("1" (lemma "rac_append[nat]") (("1" (inst -1 "(: n:)" "x!1") (("1" (expand "append") (("1" (expand "append") (("1" (replace -7) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5) (("2" (lemma "rdc_append[nat]") (("2" (inst -1 "(:n:)" "x!1") (("2" (expand "append") (("2" (expand "append") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -5 "get_if(expr)" "rdc(path)" "n") (("2" (split -5) (("1" (replace -6) (("1" (lemma "rac_append[nat]") (("1" (inst -1 "(: n:)" "x!1") (("1" (expand "append") (("1" (expand "append") (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5) (("2" (lemma "rdc_append[nat]") (("2" (inst -1 "(:n:)" "x!1") (("2" (expand "append") (("2" (expand "append") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (inst -5 "get_else(expr)" "rdc(path)" "n") (("3" (split -5) (("1" (replace -6) (("1" (lemma "rac_append[nat]") (("1" (inst -1 "(:n:)" "x!1") (("1" (expand "append") (("1" (expand "append") (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "rdc_append[nat]") (("2" (inst -1 "(:n:)" "x!1") (("2" (expand "append") (("2" (expand "append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (expand "rdc") (("2" (rewrite "length_reverse") (("2" (rewrite "length_null_list" :dir rl) (("2" (use "length_reverse[nat]") (("2" (replaces -1 :dir rl) (("2" (rewrite "length_null_list") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null? adt-recognizer-decl "[list -> boolean]" list_adt nil) nil (rdc const-decl "list[T]" more_list_props structures) (append def-decl "list[T]" list_props nil) (rac_append formula-decl nil more_list_props structures) (rdc_append formula-decl nil more_list_props structures) (length_null_list formula-decl nil more_list_props structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (TRUE const-decl "bool" booleans nil) (length_reverse formula-decl nil list_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (reverse def-decl "list[T]" list_props nil) (get_arg shared-adt-accessor-decl "[{x: PVS0Expr | op1?(x) OR rec?(x)} -> PVS0Expr]" PVS0Expr_adt nil) nil (rec? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) nil (op1? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (get_arg2 adt-accessor-decl "[(op2?) -> PVS0Expr]" PVS0Expr_adt nil) (get_arg1 adt-accessor-decl "[(op2?) -> PVS0Expr]" PVS0Expr_adt nil) (op2? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (get_else adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil) (get_if adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil) (get_cond adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil) (ite? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil pvs0_cc nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) nil (path_conditions subtype "pvs0_cc.path_" "(pvs0_cc.valid_path(pvs0_cc.expr))")) (path_conditions_TCC1-1 nil 3651338398 ("" (subtype-tcc) nil nil) nil nil (path_conditions subtype "pvs0_cc.path_" "(pvs0_cc.valid_path(pvs0_cc.expr))"))) (path_conditions_TCC2 0 (path_conditions_TCC2-1 nil 3651338398 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (Path type-eq-decl nil pvs0_cc nil) (Val formal-nonempty-type-decl nil pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (valid_path def-decl "bool" pvs0_cc nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)) nil (path_conditions termination "pvs0_cc.path_conditions(pvs0_cc.expr, pvs0_cc.path_)" "nil"))))
