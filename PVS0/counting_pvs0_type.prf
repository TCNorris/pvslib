(counting_pvs0_type
 (G_TCC1 0
  (G_TCC1-1 nil 3665445335
   ("" (lemma "T_bij_nat") (("" (skeep) (("" (inst?) nil nil)) nil)) nil)
   ((T formal-nonempty-type-decl nil counting_pvs0_type nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (injective? const-decl "bool" functions nil)
    (FF skolem-const-decl "[T -> nat]" counting_pvs0_type nil)
    (T_bij_nat formula-decl nil counting_pvs0_type nil))
   nil
   (G existence ""
    "{F: [counting_pvs0_type.T -> naturalnumbers.nat] | functions[counting_pvs0_type.T, nat].injective?(F)}")))
 (base_TCC1 0
  (base_TCC1-1 nil 3664903592
   ("" (skeep)
    (("" (expand "is_finite")
      ((""
        (inst + "n+2"
         "LAMBDA (e:(inbase(n))): IF cnst?(e) and G(get_val(e))<=n then G(get_val(e)) ELSE n+1 ENDIF")
        (("1" (expand "injective?")
          (("1" (skeep)
            (("1" (lift-if -1)
              (("1" (split -1)
                (("1" (flatten)
                  (("1" (lift-if -3)
                    (("1" (split -3)
                      (("1" (flatten)
                        (("1" (typepred (G))
                          (("1" (expand "injective?")
                            (("1" (inst?)
                              (("1" (assert)
                                (("1" (lemma "PVS0Expr_cnst_extensionality")
                                  (("1" (inst?) (("1" (assert) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (typepred (x1))
                          (("2" (expand "inbase")
                            (("2" (split -1)
                              (("1" (typepred (x2))
                                (("1" (expand "inbase")
                                  (("1" (assert) nil nil)) nil))
                                nil)
                               ("2" (flatten) (("2" (assert) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (lift-if -1)
                    (("2" (split -1)
                      (("1" (flatten) (("1" (assert) nil nil)) nil)
                       ("2" (typepred (x1))
                        (("2" (expand "inbase")
                          (("2" (split -1)
                            (("1" (typepred (x2))
                              (("1" (expand "inbase")
                                (("1" (split -1)
                                  (("1" (assert) nil nil)
                                   ("2" (flatten) (("2" (ground) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (flatten)
                              (("2" (assert) (("2" (ground) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep) (("2" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((is_finite const-decl "bool" finite_sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (PVS0Expr_cnst_extensionality formula-decl nil PVS0Expr_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (below type-eq-decl nil nat_types nil)
    (T formal-nonempty-type-decl nil counting_pvs0_type nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (inbase const-decl "bool" counting_pvs0_type nil)
    (n skolem-const-decl "nat" counting_pvs0_type nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cnst? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (<= const-decl "bool" reals nil)
    (injective? const-decl "bool" functions nil)
    (G const-decl "{F: [T -> nat] | injective?(F)}" counting_pvs0_type nil)
    (get_val adt-accessor-decl "[(cnst?) -> T]" PVS0Expr_adt nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil))
   nil
   (base subtype "counting_pvs0_type.inbase(counting_pvs0_type.n)"
    "finite_set[PVS0Expr[T]]")))
 (inop1_at_TCC1 0
  (inop1_at_TCC1-1 nil 3665481394 ("" (subtype-tcc) nil nil) nil nil
   (inop1_at subtype "counting_pvs0_type.e"
    "{x: PVS0Expr_adt[counting_pvs0_type.T].PVS0Expr | booleans.OR(PVS0Expr_adt[counting_pvs0_type.T].op1?(x), PVS0Expr_adt[counting_pvs0_type.T].rec?(x))}")))
 (inop1_at_TCC2 0
  (inop1_at_TCC2-1 nil 3665481394 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-nonempty-type-decl nil counting_pvs0_type nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (member const-decl "bool" sets nil))
   nil
   (inop1_at subtype "counting_pvs0_type.e"
    "{x: PVS0Expr_adt[counting_pvs0_type.T].PVS0Expr | booleans.OR(PVS0Expr_adt[counting_pvs0_type.T].op1?(x), PVS0Expr_adt[counting_pvs0_type.T].op2?(x))}")))
 (op1_at_TCC1 0
  (op1_at_TCC1-1 nil 3665449744
   ("" (skeep)
    (("" (typepred (fexp))
      (("" (expand "is_finite")
        (("" (skeep)
          (("" (inst 1 "N" "lambda(e: (inop1_at(fexp, n))): f(get_arg(e))")
            (("1" (expand "injective?")
              (("1" (skeep)
                (("1" (inst -1 "get_arg(x1)" "get_arg(x2)")
                  (("1" (assert)
                    (("1" (lemma "PVS0Expr_op1_extensionality")
                      (("1" (inst -1 "x1" "x2")
                        (("1" (assert)
                          (("1" (typepred (x1))
                            (("1" (typepred (x2))
                              (("1" (expand "inop1_at")
                                (("1" (flatten) (("1" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (typepred (x2))
                          (("2" (assert)
                            (("2" (expand "inop1_at") (("2" (propax) nil nil))
                              nil))
                            nil))
                          nil)
                         ("3" (typepred (x1))
                          (("3" (expand "inop1_at") (("3" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skeep :preds? t)
              (("2" (expand "inop1_at")
                (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil))
              nil)
             ("3" (skeep :preds? t)
              (("3" (assert)
                (("3" (expand "inop1_at") (("3" (propax) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (T formal-nonempty-type-decl nil counting_pvs0_type nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (member const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (PVS0Expr_op1_extensionality formula-decl nil PVS0Expr_adt nil)
    (x2 skolem-const-decl "(inop1_at(fexp, n))" counting_pvs0_type nil)
    (x1 skolem-const-decl "(inop1_at(fexp, n))" counting_pvs0_type nil)
    (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil)
    (get_arg shared-adt-accessor-decl
     "[{x: PVS0Expr | op1?(x) OR rec?(x)} -> PVS0Expr]" PVS0Expr_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (inop1_at const-decl "bool" counting_pvs0_type nil)
    (fexp skolem-const-decl "finite_set[PVS0Expr[T]]" counting_pvs0_type nil)
    (n skolem-const-decl "nat" counting_pvs0_type nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (op1? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (rec? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil))
   nil
   (op1_at subtype
    "counting_pvs0_type.inop1_at(counting_pvs0_type.fexp, counting_pvs0_type.n)"
    "finite_set[PVS0Expr[T]]")))
 (op1_upto_TCC1 0
  (op1_upto_TCC1-2 nil 3665775964
   ("" (skolem 1 ("fexp" "_"))
    (("" (induct "n")
      (("1" (case-replace "inop1_upto(fexp, 0) = inop1_at(fexp, 0)")
        (("1" (assert)
          (("1" (lemma "op1_at_TCC1") (("1" (inst?) nil nil)) nil)) nil)
         ("2" (hide 2)
          (("2" (decompose-equality 1)
            (("2" (expand "inop1_upto")
              (("2" (expand "inop1_at")
                (("2" (assert) (("2" (iff) (("2" (ground) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skeep)
        (("2"
          (case "inop1_upto(fexp, j+1) = union(inop1_upto(fexp, j), inop1_at(fexp, j+1))")
          (("1" (lemma "op1_at_TCC1")
            (("1" (inst?)
              (("1" (replaces -2)
                (("1" (assert)
                  (("1" (lemma "finite_union[PVS0Expr[T]]")
                    (("1" (inst?) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (decompose-equality 1)
            (("2" (expand "union")
              (("2" (iff)
                (("2" (ground)
                  (("1" (expand "inop1_upto")
                    (("1" (expand "member")
                      (("1" (expand "inop1_at")
                        (("1" (flatten)
                          (("1" (expand "member") (("1" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand "inop1_upto")
                    (("2" (expand "member")
                      (("2" (assert)
                        (("2" (flatten) (("2" (assert) nil nil)) nil)) nil))
                      nil))
                    nil)
                   ("3" (expand "member")
                    (("3" (expand "inop1_at")
                      (("3" (expand "inop1_upto")
                        (("3" (flatten) (("3" (assert) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (T formal-nonempty-type-decl nil counting_pvs0_type nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (inop1_upto const-decl "bool" counting_pvs0_type nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (op1_at_TCC1 subtype-tcc nil counting_pvs0_type nil)
    (inop1_at const-decl "bool" counting_pvs0_type nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (union const-decl "set" sets nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (finite_union judgement-tcc nil finite_sets nil)
    (TRUE const-decl "bool" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (member const-decl "bool" sets nil))
   nil
   (op1_upto subtype
    "counting_pvs0_type.inop1_upto(counting_pvs0_type.fexp, counting_pvs0_type.n)"
    "finite_set[PVS0Expr[T]]")))
 (inop2_at_TCC1 0
  (inop2_at_TCC1-1 nil 3665481394 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-nonempty-type-decl nil counting_pvs0_type nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (member const-decl "bool" sets nil))
   nil
   (inop2_at subtype "counting_pvs0_type.e"
    "{x: PVS0Expr_adt[counting_pvs0_type.T].PVS0Expr | booleans.OR(PVS0Expr_adt[counting_pvs0_type.T].op1?(x), PVS0Expr_adt[counting_pvs0_type.T].op2?(x))}")))
 (finpair_TCC1 0
  (finpair_TCC1-1 nil 3665489802
   ("" (skeep :preds? t)
    (("" (expand "is_finite")
      (("" (skeep)
        (("" (name "F" "lambda(e: (infinpair(fexp))): (f(e`1), f(e`2))")
          (("1"
            (case "injective?[(infinpair(fexp)), [below[N], below[N]]](F)")
            (("1" (lemma "is_finite_cross[below[N], below[N]]")
              (("1" (assert)
                (("1" (expand "is_finite_type")
                  (("1"
                    (case "EXISTS (M:nat), (g: [below[N] -> below[M]]): injective?(g)")
                    (("1" (ground)
                      (("1" (skeep :preds? t)
                        (("1" (inst 1 "N!1" "g o F")
                          (("1"
                            (lemma
                             "composition_injective[(infinpair(fexp)), [below[N], below[N]], below[N!1]]")
                            (("1" (inst?) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide-all-but 1)
                      (("2" (inst 1 "N" "id")
                        (("2" (expand "injective?")
                          (("2" (skeep)
                            (("2" (expand "id") (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide 2)
              (("2" (expand "injective?")
                (("2" (skeep)
                  (("2" (expand "F")
                    (("2" (decompose-equality 1)
                      (("1" (flatten)
                        (("1" (inst -4 "x1`1" "x2`1") (("1" (assert) nil nil))
                          nil))
                        nil)
                       ("2" (inst -3 "x1`2" "x2`2")
                        (("2" (assert) (("2" (assert) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (skeep)
            (("2" (typepred (e))
              (("2" (expand "infinpair")
                (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil))
              nil))
            nil)
           ("3" (skeep)
            (("3" (typepred (e))
              (("3" (expand "infinpair")
                (("3" (expand "member") (("3" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((is_finite const-decl "bool" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (infinpair const-decl "bool" counting_pvs0_type nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (T formal-nonempty-type-decl nil counting_pvs0_type nil)
    (F skolem-const-decl "[(infinpair(fexp)) -> [below[N], below[N]]]"
     counting_pvs0_type nil)
    (is_finite_cross formula-decl nil finite_cross finite_sets)
    (is_finite_type const-decl "bool" finite_sets nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (O const-decl "T3" function_props nil)
    (g skolem-const-decl "[[below[N], below[N]] -> below[N!1]]"
     counting_pvs0_type nil)
    (N!1 skolem-const-decl "nat" counting_pvs0_type nil)
    (N skolem-const-decl "nat" counting_pvs0_type nil)
    (composition_injective judgement-tcc nil function_props nil)
    (injective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil))
   nil
   (finpair subtype "counting_pvs0_type.infinpair(counting_pvs0_type.fexp)"
    "finite_set[[PVS0Expr[T], PVS0Expr[T]]]")))
 (op2_at_TCC1 0
  (op2_at_TCC1-1 nil 3665481394
   ("" (skeep)
    (("" (lemma "finpair_TCC1")
      (("" (inst?)
        (("" (expand "is_finite")
          (("" (skeep)
            ((""
              (name "F"
                    "lambda (ee:(inop2_at(fexp, n))): (get_arg1(ee), get_arg2(ee)) ")
              (("1"
                (case "injective?[ (inop2_at(fexp, n)), (infinpair(fexp))](F)")
                (("1" (inst 1 "N" " f o F")
                  (("1" (assert)
                    (("1"
                      (lemma
                       "composition_injective[(inop2_at(fexp, n)), (infinpair(fexp)), below[N]]")
                      (("1" (inst?) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (hide (-2 2))
                  (("2" (expand "injective?")
                    (("2" (skeep)
                      (("2" (expand "F")
                        (("2" (typepred (x1))
                          (("2" (expand "inop2_at")
                            (("2" (flatten)
                              (("2" (typepred (x2))
                                (("2" (expand "inop2_at")
                                  (("2" (flatten)
                                    (("2"
                                      (lemma "PVS0Expr_op2_extensionality")
                                      (("2"
                                        (inst -1 "x1" "x2")
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (hide (-2 2))
                  (("3" (skeep)
                    (("3" (expand "infinpair")
                      (("3" (expand "F")
                        (("3" (typepred (x1))
                          (("3" (expand "inop2_at")
                            (("3" (assert)
                              (("3" (flatten) (("3" (assert) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skeep)
                (("2" (typepred (ee))
                  (("2" (expand "inop2_at") (("2" (flatten) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finpair_TCC1 subtype-tcc nil counting_pvs0_type nil)
    (get_arg2 adt-accessor-decl "[(op2?) -> PVS0Expr]" PVS0Expr_adt nil)
    (get_arg1 adt-accessor-decl "[(op2?) -> PVS0Expr]" PVS0Expr_adt nil)
    (op2? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (inop2_at const-decl "bool" counting_pvs0_type nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (PVS0Expr_op2_extensionality formula-decl nil PVS0Expr_adt nil)
    (F skolem-const-decl "[(inop2_at(fexp, n)) -> [PVS0Expr[T], PVS0Expr[T]]]"
     counting_pvs0_type nil)
    (O const-decl "T3" function_props nil)
    (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil)
    (composition_injective judgement-tcc nil function_props nil)
    (injective? const-decl "bool" functions nil)
    (infinpair const-decl "bool" counting_pvs0_type nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (T formal-nonempty-type-decl nil counting_pvs0_type nil))
   nil
   (op2_at subtype
    "counting_pvs0_type.inop2_at(counting_pvs0_type.fexp, counting_pvs0_type.n)"
    "finite_set[PVS0Expr[T]]")))
 (op2_upto_TCC1 0
  (op2_upto_TCC1-2 nil 3665775993
   ("" (skolem 1 ("fexp" "_"))
    (("" (induct "n")
      (("1" (case-replace "inop2_upto(fexp, 0) = inop2_at(fexp, 0)")
        (("1" (lemma "op2_at_TCC1") (("1" (inst?) nil nil)) nil)
         ("2" (hide 2)
          (("2" (decompose-equality 1)
            (("2" (expand "inop2_upto")
              (("2" (expand "inop2_at")
                (("2" (iff) (("2" (ground) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skeep)
        (("2"
          (case "inop2_upto(fexp, j+1) = union(inop2_upto(fexp, j), inop2_at(fexp, j+1))")
          (("1" (lemma "op2_at_TCC1")
            (("1" (inst?)
              (("1" (replaces -2)
                (("1" (lemma "finite_union[PVS0Expr[T]]")
                  (("1" (inst?) (("1" (ground) nil nil)) nil)) nil))
                nil))
              nil))
            nil)
           ("2" (decompose-equality 1)
            (("2" (expand "union")
              (("2" (iff)
                (("2" (ground)
                  (("1" (expand "inop2_upto")
                    (("1" (expand "member")
                      (("1" (expand "inop2_at")
                        (("1" (flatten)
                          (("1" (expand "member") (("1" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand "inop2_upto")
                    (("2" (expand "member")
                      (("2" (assert)
                        (("2" (flatten) (("2" (assert) nil nil)) nil)) nil))
                      nil))
                    nil)
                   ("3" (expand "member")
                    (("3" (expand "inop2_at")
                      (("3" (expand "inop2_upto")
                        (("3" (flatten) (("3" (assert) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (T formal-nonempty-type-decl nil counting_pvs0_type nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (inop2_upto const-decl "bool" counting_pvs0_type nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (op2_at_TCC1 subtype-tcc nil counting_pvs0_type nil)
    (inop2_at const-decl "bool" counting_pvs0_type nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (union const-decl "set" sets nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (finite_union judgement-tcc nil finite_sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (j skolem-const-decl "nat" counting_pvs0_type nil)
    (fexp skolem-const-decl "finite_set[PVS0Expr[T]]" counting_pvs0_type nil)
    (TRUE const-decl "bool" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (member const-decl "bool" sets nil))
   nil
   (op2_upto subtype
    "counting_pvs0_type.inop2_upto(counting_pvs0_type.fexp, counting_pvs0_type.n)"
    "finite_set[PVS0Expr[T]]")))
 (fintrip_TCC1 0
  (fintrip_TCC1-1 nil 3665491138
   ("" (skeep)
    (("" (typepred (fexp))
      (("" (expand "is_finite")
        (("" (skeep)
          ((""
            (name "F"
                  "lambda(e: (infintrip(fexp))): ((f(e`1), f(e`2)), f(e`3))")
            (("1" (lemma "is_finite_cross[below[N], below[N]]")
              (("1" (expand "is_finite_type")
                (("1"
                  (case "EXISTS (M:nat), (g: [below[N] -> below[M]]): injective?(g)")
                  (("1" (ground)
                    (("1"
                      (lemma
                       "is_finite_cross[[below[N], below[N]], below[N]]")
                      (("1" (expand "is_finite_type")
                        (("1" (ground)
                          (("1"
                            (case "injective?[(infintrip(fexp)), [[below[N], below[N]], below[N]]](F)")
                            (("1" (skeep :preds? t)
                              (("1" (inst 1 "N!1" "g o F")
                                (("1"
                                  (lemma
                                   "composition_injective[(infintrip(fexp)), [[below[N], below[N]], below[N]], below[N!1]]")
                                  (("1" (inst?) nil nil)) nil))
                                nil))
                              nil)
                             ("2" (hide (-1 -2 -3 2))
                              (("2" (expand "injective?")
                                (("2" (skeep)
                                  (("2" (decompose-equality 1)
                                    (("1" (expand "F")
                                      (("1"
                                        (inst -3 "x1`1" "x2`1")
                                        (("1"
                                          (assert)
                                          (("1" (flatten) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (expand "F")
                                      (("2"
                                        (flatten)
                                        (("2"
                                          (inst -5 "x1`2" "x2`2")
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("3" (expand "F")
                                      (("3"
                                        (flatten)
                                        (("3"
                                          (inst -5 "x1`3" "x2`3")
                                          (("3" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide-all-but 1)
                    (("2" (inst 1 "N" "id")
                      (("2" (expand "injective?")
                        (("2" (skeep)
                          (("2" (expand "id") (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skeep :preds? t)
              (("2" (expand "infintrip")
                (("2" (expand "member") (("2" (flatten) nil nil)) nil)) nil))
              nil)
             ("3" (skeep :preds? t)
              (("3" (expand "infintrip")
                (("3" (flatten)
                  (("3" (expand "member") (("3" (propax) nil nil)) nil)) nil))
                nil))
              nil)
             ("4" (skeep :preds? t)
              (("4" (expand "infintrip")
                (("4" (expand "member") (("4" (flatten) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (T formal-nonempty-type-decl nil counting_pvs0_type nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (member const-decl "bool" sets nil)
    (is_finite_cross formula-decl nil finite_cross finite_sets)
    (injective? const-decl "bool" functions nil)
    (composition_injective judgement-tcc nil function_props nil)
    (N skolem-const-decl "nat" counting_pvs0_type nil)
    (N!1 skolem-const-decl "nat" counting_pvs0_type nil)
    (g skolem-const-decl "[[[below[N], below[N]], below[N]] -> below[N!1]]"
     counting_pvs0_type nil)
    (fexp skolem-const-decl "finite_set[PVS0Expr[T]]" counting_pvs0_type nil)
    (F skolem-const-decl
     "[(infintrip(fexp)) -> [[below[N], below[N]], below[N]]]"
     counting_pvs0_type nil)
    (O const-decl "T3" function_props nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (is_finite_type const-decl "bool" finite_sets nil)
    (infintrip const-decl "bool" counting_pvs0_type nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   nil
   (fintrip subtype "counting_pvs0_type.infintrip(counting_pvs0_type.fexp)"
    "finite_set[[PVS0Expr[T], PVS0Expr[T], PVS0Expr[T]]]")))
 (ite_set_TCC1 0
  (ite_set_TCC1-1 nil 3665403166
   ("" (skeep)
    (("" (lemma "fintrip_TCC1")
      (("" (inst?)
        (("" (expand "is_finite")
          (("" (skeep)
            ((""
              (name "F"
                    "lambda (ee:(inite_set(fexp))): (get_cond(ee), get_if(ee), get_else(ee)) ")
              (("1"
                (case "injective?[ (inite_set(fexp)), (infintrip(fexp))](F)")
                (("1" (inst 1 "N" " f o F")
                  (("1"
                    (lemma
                     "composition_injective[(inite_set(fexp)), (infintrip(fexp)), below[N]]")
                    (("1" (inst?) nil nil)) nil))
                  nil)
                 ("2" (hide (-2 2))
                  (("2" (expand "injective?")
                    (("2" (skeep)
                      (("2" (expand "F")
                        (("2" (flatten)
                          (("2" (lemma "PVS0Expr_ite_extensionality")
                            (("2" (inst -1 "x1" "x2") (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (hide (-2 2))
                  (("3" (skeep)
                    (("3" (expand "infintrip")
                      (("3" (expand "F")
                        (("3" (typepred (x1))
                          (("3" (expand "inite_set")
                            (("3" (assert)
                              (("3" (flatten) (("3" (assert) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skeep)
                (("2" (typepred (ee))
                  (("2" (expand "inite_set") (("2" (flatten) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((fintrip_TCC1 subtype-tcc nil counting_pvs0_type nil)
    (get_else adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil)
    (get_if adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil)
    (get_cond adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil)
    (ite? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (inite_set const-decl "bool" counting_pvs0_type nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (PVS0Expr_ite_extensionality formula-decl nil PVS0Expr_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil)
    (O const-decl "T3" function_props nil)
    (F skolem-const-decl
     "[(inite_set(fexp)) -> [PVS0Expr[T], PVS0Expr[T], PVS0Expr[T]]]"
     counting_pvs0_type nil)
    (f skolem-const-decl "[(infintrip(fexp)) -> below[N]]" counting_pvs0_type
     nil)
    (N skolem-const-decl "nat" counting_pvs0_type nil)
    (fexp skolem-const-decl "finite_set[PVS0Expr[T]]" counting_pvs0_type nil)
    (composition_injective judgement-tcc nil function_props nil)
    (injective? const-decl "bool" functions nil)
    (infintrip const-decl "bool" counting_pvs0_type nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (T formal-nonempty-type-decl nil counting_pvs0_type nil))
   nil
   (ite_set subtype "counting_pvs0_type.inite_set(counting_pvs0_type.fexp)"
    "finite_set[PVS0Expr[T]]")))
 (inrec_set_TCC1 0
  (inrec_set_TCC1-1 nil 3665403166 ("" (subtype-tcc) nil nil) nil nil
   (inrec_set subtype "counting_pvs0_type.e"
    "{x: PVS0Expr_adt[counting_pvs0_type.T].PVS0Expr | booleans.OR(PVS0Expr_adt[counting_pvs0_type.T].op1?(x), PVS0Expr_adt[counting_pvs0_type.T].rec?(x))}")))
 (rec_set_TCC1 0
  (rec_set_TCC1-1 nil 3665403166
   ("" (skeep)
    (("" (typepred (fexp))
      (("" (expand "is_finite")
        (("" (skeep :preds? t)
          (("" (inst 1 "N" "LAMBDA(e:(inrec_set(fexp))): f(get_arg(e))")
            (("1" (expand "injective?")
              (("1" (skeep)
                (("1" (inst - "get_arg(x1)" "get_arg(x2)")
                  (("1" (assert)
                    (("1" (lemma "PVS0Expr_rec_extensionality")
                      (("1" (inst -1 "x1" "x2")
                        (("1" (assert) nil nil)
                         ("2" (typepred (x2))
                          (("2" (expand "inrec_set") (("2" (assert) nil nil))
                            nil))
                          nil)
                         ("3" (typepred (x1))
                          (("3" (expand "inrec_set") (("3" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skeep :preds? t)
              (("2" (expand "inrec_set")
                (("2" (flatten)
                  (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil))
                nil))
              nil)
             ("3" (skeep :preds? t)
              (("3" (expand "inrec_set") (("3" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (T formal-nonempty-type-decl nil counting_pvs0_type nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (member const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (PVS0Expr_rec_extensionality formula-decl nil PVS0Expr_adt nil)
    (x2 skolem-const-decl "(inrec_set(fexp))" counting_pvs0_type nil)
    (x1 skolem-const-decl "(inrec_set(fexp))" counting_pvs0_type nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (get_arg shared-adt-accessor-decl
     "[{x: PVS0Expr | op1?(x) OR rec?(x)} -> PVS0Expr]" PVS0Expr_adt nil)
    (inrec_set const-decl "bool" counting_pvs0_type nil)
    (fexp skolem-const-decl "finite_set[PVS0Expr[T]]" counting_pvs0_type nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (op1? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (rec? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil))
   nil
   (rec_set subtype "counting_pvs0_type.inrec_set(counting_pvs0_type.fexp)"
    "finite_set[PVS0Expr[T]]")))
 (level_set_member 0
  (level_set_member-1 nil 3665414687
   ("" (skeep)
    (("" (expand "level_set" 1)
      (("" (expand "member" 1)
        (("" (expand "union" 1 1)
          (("" (flatten)
            (("" (expand "member" +)
              (("" (expand "union" 2 1)
                (("" (flatten)
                  (("" (expand "member" +)
                    (("" (expand "union" 3 1)
                      (("" (flatten)
                        (("" (expand "member" +)
                          (("" (expand "union" 4 1)
                            (("" (flatten)
                              (("" (expand "member" +)
                                (("" (expand "union" 5 1)
                                  (("" (flatten)
                                    (("" (expand "member" +)
                                      ((""
                                        (expand "member")
                                        (("" (ground) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((level_set const-decl "finite_set[PVS0Expr]" counting_pvs0_type nil)
    (union const-decl "set" sets nil) (member const-decl "bool" sets nil))
   shostak))
 (level_TCC1 0
  (level_TCC1-1 nil 3665405240 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil (level subtype "(number_fields.-)(counting_pvs0_type.n, 1)" "nat")))
 (level_TCC2 0
  (level_TCC2-1 nil 3665405240 ("" (termination-tcc) nil nil) nil nil
   (level termination
          "counting_pvs0_type.level((number_fields.-)(counting_pvs0_type.n, 1))"
          "nil")))
 (levels_increase 0
  (levels_increase-1 nil 3665415148
   ("" (skolem 1 ("m" "_" "e"))
    ((""
      (case "FORALL (k:nat): member(e, level(m)) IMPLIES member(e, level(m+k))")
      (("1" (skeep)
        (("1" (inst -1 "n-m") (("1" (assert) nil nil) ("2" (assert) nil nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (induct "k")
          (("1" (assert) (("1" (flatten) nil nil)) nil)
           ("2" (skeep)
            (("2" (assert)
              (("2" (hide -2)
                (("2" (expand "level" 1)
                  (("2" (lemma "level_set_member")
                    (("2" (inst -1 "level(j+m)" "e" "1+j+m")
                      (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (level def-decl "finite_set[PVS0Expr]" counting_pvs0_type nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (T formal-nonempty-type-decl nil counting_pvs0_type nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (n skolem-const-decl "nat" counting_pvs0_type nil)
    (m skolem-const-decl "nat" counting_pvs0_type nil)
    (pred type-eq-decl nil defined_types nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (level_set_member formula-decl nil counting_pvs0_type nil))
   shostak))
 (levels_cover 0
  (levels_cover-1 nil 3665406228
   ("" (induct "e" 1 PVS0Expr_induction)
    (("1" (skeep)
      (("1" (inst + "G(cnst1_var)")
        (("1" (expand "member")
          (("1" (expand "level")
            (("1" (split 1)
              (("1" (flatten)
                (("1" (expand "base")
                  (("1" (expand "inbase") (("1" (propax) nil nil)) nil)) nil))
                nil)
               ("2" (flatten)
                (("2" (lemma "level_set_member")
                  (("2"
                    (inst -1 "level(G(cnst1_var) - 1)" "cnst(cnst1_var)"
                     "G(cnst1_var)")
                    (("1" (case "member(cnst(cnst1_var), base(G(cnst1_var)))")
                      (("1" (assert)
                        (("1" (expand "member") (("1" (propax) nil nil)) nil))
                        nil)
                       ("2" (hide -)
                        (("2" (expand "member")
                          (("2" (expand "base")
                            (("2" (expand "inbase") (("2" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (inst + "0")
      (("2" (expand "member")
        (("2" (expand "level")
          (("2" (expand "base")
            (("2" (expand "inbase") (("2" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil)
     ("3" (skeep)
      (("3" (skeep)
        (("3" (name "N" " max(n, op11_var)")
          (("3" (lemma "levels_increase")
            (("3" (inst -1 "n" "N" "op12_var")
              (("3" (assert)
                (("3" (inst 1 "1+N")
                  (("3" (lemma "level_set_member")
                    (("3" (expand "level" 1)
                      (("3"
                        (inst -1 "level(N)" "op1(op11_var, op12_var)" "1+N")
                        (("3"
                          (case "member(op1(op11_var, op12_var), op1_upto(level(N), 1 + N))")
                          (("1" (assert) nil nil)
                           ("2" (expand "member")
                            (("2" (expand "op1_upto")
                              (("2" (expand "inop1_upto")
                                (("2" (propax) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skeep)
      (("4" (skeep)
        (("4" (skeep)
          (("4" (name "N" "max(op21_var, max(n!1, n))")
            (("4" (lemma "levels_increase")
              (("4" (inst-cp -1 "n!1" "N" "op23_var")
                (("4" (inst -1 "n" "N" "op22_var")
                  (("4" (assert)
                    (("4" (inst 1 "1+N")
                      (("4" (lemma "level_set_member")
                        (("4" (expand "level" 1)
                          (("4"
                            (inst -1 "level(N)"
                             "op2(op21_var, op22_var, op23_var)" "1+N")
                            (("4"
                              (case "member(op2(op21_var, op22_var, op23_var),
                                                        op2_upto(level(N), 1 + N))")
                              (("1" (assert) nil nil)
                               ("2" (expand "member")
                                (("2" (expand "op2_upto")
                                  (("2" (expand "inop2_upto")
                                    (("2" (propax) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep)
      (("5" (skeep)
        (("5" (inst + "n+1")
          (("5" (expand "member")
            (("5" (expand "level" 1)
              (("5" (case "rec_set(level(n))(rec(rec1_var))")
                (("1" (lemma "level_set_member")
                  (("1" (inst -1 "level(n)" "rec(rec1_var)" "1+n")
                    (("1" (expand "member") (("1" (assert) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (hide 2)
                  (("2" (expand "rec_set")
                    (("2" (expand "inrec_set")
                      (("2" (expand "member") (("2" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep)
      (("6" (skeep)
        (("6" (skeep)
          (("6" (skeep)
            (("6" (name "N" "max(n!2, max(n!1, n))")
              (("6" (lemma "levels_increase")
                (("6" (inst-cp -1 "n!2" "N" "ite3_var")
                  (("6" (assert)
                    (("6" (inst-cp -1 "n!1" "N" "ite2_var")
                      (("6" (assert)
                        (("6" (inst-cp -1 "n" "N" "ite1_var")
                          (("6" (assert)
                            (("6" (hide -1)
                              (("6" (inst 1 "1+N")
                                (("6" (expand "level" 1)
                                  (("6" (lemma "level_set_member")
                                    (("6"
                                      (inst
                                       -1
                                       "level(N)"
                                       "ite(ite1_var, ite2_var, ite3_var)"
                                       "1+N")
                                      (("6"
                                        (case
                                         "member(ite(ite1_var, ite2_var, ite3_var), ite_set(level(N)))")
                                        (("1" (assert) nil nil)
                                         ("2"
                                          (hide (-1 2))
                                          (("2"
                                            (expand "ite_set")
                                            (("2"
                                              (expand "inite_set")
                                              (("2"
                                                (expand "member")
                                                (("2" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ite adt-constructor-decl "[[PVS0Expr, PVS0Expr, PVS0Expr] -> (ite?)]"
     PVS0Expr_adt nil)
    (ite? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (inite_set const-decl "bool" counting_pvs0_type nil)
    (ite_set const-decl "finite_set[PVS0Expr]" counting_pvs0_type nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (inrec_set const-decl "bool" counting_pvs0_type nil)
    (rec adt-constructor-decl "[PVS0Expr -> (rec?)]" PVS0Expr_adt nil)
    (rec? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (rec_set const-decl "finite_set[PVS0Expr]" counting_pvs0_type nil)
    (op2_upto const-decl "finite_set[PVS0Expr]" counting_pvs0_type nil)
    (inop2_upto const-decl "bool" counting_pvs0_type nil)
    (op2? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (op2 adt-constructor-decl "[[nat, PVS0Expr, PVS0Expr] -> (op2?)]"
     PVS0Expr_adt nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs
     nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (<= const-decl "bool" reals nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (op1_upto const-decl "finite_set[PVS0Expr]" counting_pvs0_type nil)
    (inop1_upto const-decl "bool" counting_pvs0_type nil)
    (op1? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (op1 adt-constructor-decl "[[nat, PVS0Expr] -> (op1?)]" PVS0Expr_adt nil)
    (levels_increase formula-decl nil counting_pvs0_type nil)
    (base const-decl "finite_set[PVS0Expr]" counting_pvs0_type nil)
    (inbase const-decl "bool" counting_pvs0_type nil)
    (level_set_member formula-decl nil counting_pvs0_type nil)
    (cnst? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (cnst adt-constructor-decl "[T -> (cnst?)]" PVS0Expr_adt nil)
    (cnst1_var skolem-const-decl "T" counting_pvs0_type nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (injective? const-decl "bool" functions nil)
    (G const-decl "{F: [T -> nat] | injective?(F)}" counting_pvs0_type nil)
    (PVS0Expr_induction formula-decl nil PVS0Expr_adt nil)
    (T formal-nonempty-type-decl nil counting_pvs0_type nil)
    (level def-decl "finite_set[PVS0Expr]" counting_pvs0_type nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil))
   shostak))
 (nat_onto_PVS0Expr 0
  (nat_onto_PVS0Expr-1 nil 3665419284
   ("" (lemma "nat_surjection")
    (("" (inst -1 "level")
      (("" (lemma "levels_cover")
        (("" (assert)
          (("" (split -2) (("1" (propax) nil nil) ("2" (propax) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (level def-decl "finite_set[PVS0Expr]" counting_pvs0_type nil)
    (levels_cover formula-decl nil counting_pvs0_type nil)
    (nat_surjection formula-decl nil nat_surjection sets_aux)
    (T formal-nonempty-type-decl nil counting_pvs0_type nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil))
   shostak)))

