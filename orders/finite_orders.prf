(finite_orders
 (IMP_finite_types_TCC1 0
  (IMP_finite_types_TCC1-1 nil 3315153951
   ("" (rewrite "finite_type") nil nil)
   ((finite_type formula-decl nil finite_orders nil)) nil
   (IMP_finite_types assuming "finite_types[finite_orders.T]"
    "finite_type: ASSUMPTION finite_sets[finite_types.T].is_finite_type")))
 (finite_lower_semilattice_is_complete 0
  (finite_lower_semilattice_is_complete-2 "" 3744940543
   ("" (skosimp)
    (("" (expand* "complete_lower_semilattice?" "lower_semilattice?")
      (("" (prop)
        (("" (skolem!)
          (("" (case-replace "S!1 = emptyset")
            (("" (inst?)
              (("" (rewrite "emptyset_is_empty?")
                (("" (assert)
                  (("" (lemma "finite_type")
                    (("" (expand "is_finite_type")
                      (("" (expand "is_finite")
                        (("" (skeep)
                          ((""
                            (inst 1 "N"
                             "restrict[T, (S!1), below[N]](g)")
                            (("" (expand "injective?")
                              ((""
                                (skeep :preds? t)
                                ((""
                                  (expand "restrict")
                                  ((""
                                    (inst?)
                                    (("" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (finite_lower_semilattice_is_complete-1 nil 3315153982
   ("" (skosimp)
    (("" (expand* "complete_lower_semilattice?" "lower_semilattice?")
      (("" (prop)
        (("" (skolem!)
          (("" (case-replace "S!1 = emptyset")
            (("" (inst?) (("" (rewrite "emptyset_is_empty?") nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lower_semilattice? const-decl "bool" bounded_orders nil)
    (complete_lower_semilattice? const-decl "bool" bounded_orders nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (empty? const-decl "bool" sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (S!1 skolem-const-decl "set[T]" finite_orders nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite_type const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (restrict const-decl "R" restrict nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_type formula-decl nil finite_orders nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" finite_orders nil)
    (emptyset_is_empty? formula-decl nil sets_lemmas nil)
    (emptyset const-decl "set" sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-nonempty-type-decl nil finite_orders nil))
   shostak))
 (finite_upper_semilattice_is_complete 0
  (finite_upper_semilattice_is_complete-2 "" 3744940666
   ("" (skosimp)
    (("" (expand* "complete_upper_semilattice?" "upper_semilattice?")
      (("" (prop)
        (("" (skolem!)
          (("" (case-replace "S!1 = emptyset")
            (("" (inst?)
              (("" (rewrite "emptyset_is_empty?")
                (("" (assert)
                  (("" (lemma "finite_type")
                    (("" (expand "is_finite_type")
                      (("" (expand "is_finite")
                        (("" (skeep :preds? t)
                          ((""
                            (inst 1 "N"
                             "restrict[T, (S!1), below[N]](g)")
                            (("" (expand "injective?")
                              ((""
                                (skeep :preds? t)
                                ((""
                                  (expand "restrict")
                                  ((""
                                    (inst?)
                                    (("" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (finite_upper_semilattice_is_complete-1 nil 3315154016
   ("" (skosimp)
    (("" (expand* "complete_upper_semilattice?" "upper_semilattice?")
      (("" (prop)
        (("" (skolem!)
          (("" (case-replace "S!1 = emptyset")
            (("" (inst?) (("" (rewrite "emptyset_is_empty?") nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((upper_semilattice? const-decl "bool" bounded_orders nil)
    (complete_upper_semilattice? const-decl "bool" bounded_orders nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (empty? const-decl "bool" sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (S!1 skolem-const-decl "set[T]" finite_orders nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite_type const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (restrict const-decl "R" restrict nil)
    (finite_type formula-decl nil finite_orders nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" finite_orders nil)
    (emptyset_is_empty? formula-decl nil sets_lemmas nil)
    (emptyset const-decl "set" sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-nonempty-type-decl nil finite_orders nil))
   shostak))
 (finite_lattice_is_complete 0
  (finite_lattice_is_complete-1 nil 3315153951
   ("" (skolem-typepred)
    (("" (expand* "complete_lattice?" "lattice?")
      (("" (prop)
        (("1" (rewrite "finite_upper_semilattice_is_complete")
          (("1" (rewrite "least_bounded_above_emptyset")
            (("1" (rewrite "all_finite_greatest_bounded") nil nil))
            nil))
          nil)
         ("2" (rewrite "finite_lower_semilattice_is_complete")
          (("2" (rewrite "greatest_bounded_below_emptyset")
            (("2" (rewrite "all_finite_least_bounded") nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((complete_lattice? const-decl "bool" bounded_orders nil)
    (finite_lower_semilattice_is_complete formula-decl nil
     finite_orders nil)
    (all_finite_least_bounded formula-decl nil bounded_orders nil)
    (upper_semilattice? const-decl "bool" bounded_orders nil)
    (greatest_bounded_below_emptyset formula-decl nil bounded_orders
     nil)
    (finite_upper_semilattice_is_complete formula-decl nil
     finite_orders nil)
    (finite_emptyset name-judgement "finite_set[T]" finite_orders nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (all_finite_greatest_bounded formula-decl nil bounded_orders nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (fullset const-decl "set" sets nil)
    (lower_semilattice? const-decl "bool" bounded_orders nil)
    (fullset_is_nonempty_finite name-judgement
     "non_empty_finite_set[T]" finite_orders nil)
    (least_bounded_above_emptyset formula-decl nil bounded_orders nil)
    (lattice? const-decl "bool" bounded_orders nil)
    (pred type-eq-decl nil defined_types nil)
    (T formal-nonempty-type-decl nil finite_orders nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (finite_lattice_is_complete subtype "finite_orders.x"
    "(bounded_orders[finite_orders.T].complete_lattice?)")))
 (finite_strict_order_is_well_founded 0
  (finite_strict_order_is_well_founded-2 "" 3744940820
   ("" (skolem-typepred)
    (("" (expand "well_founded?")
      (("" (measure-induct+ "card(p)" ("p"))
        (("1" (skolem!)
          (("1" (inst - "remove(y!1, x!2)")
            (("1" (prop)
              (("1" (inst-cp + "y!1")
                (("1" (skosimp* t)
                  (("1" (inst + "y!2")
                    (("1" (skolem-typepred)
                      (("1" (inst-cp - "x!3")
                        (("1" (inst - "x!4")
                          (("1" (expand* "remove" "member" "/=")
                            (("1" (lemma "transitive")
                              (("1"
                                (inst - "x!1" "x!3" "y!1" "y!2")
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand* "remove" "member" "/=")
                          (("2" (use "irreflexive")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand* "remove" "member")
                      (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (inst 2 "y!1")
                (("2" (skolem-typepred)
                  (("2" (inst + "x!3")
                    (("2" (expand* "remove" "member" "/=")
                      (("2" (use "irreflexive")
                        (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (rewrite "card_remove") (("3" (assert) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide-all-but 1)
          (("2" (lemma "finite_type")
            (("2" (expand "is_finite_type")
              (("2" (lemma "is_finite")
                (("2" (replace -1 :hide? t)
                  (("2" (beta)
                    (("2" (skeep)
                      (("2"
                        (inst 1 "N" "restrict[T, (p!1), below[N]](g)")
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak
   (finite_strict_order_is_well_founded subtype "finite_orders.x"
    "(orders[finite_orders.T].well_founded?)"))
  (finite_strict_order_is_well_founded-1 nil 3315153951
   ("" (skolem-typepred)
    (("" (expand "well_founded?")
      (("" (measure-induct+ "card(p)" ("p"))
        (("" (skolem!)
          (("" (inst - "remove(y!1, x!2)")
            (("" (prop)
              (("1" (inst-cp + "y!1")
                (("1" (skosimp* t)
                  (("1" (inst + "y!2")
                    (("1" (skolem-typepred)
                      (("1" (inst-cp - "x!3")
                        (("1" (inst - "x!4")
                          (("1" (expand* "remove" "member" "/=")
                            (("1" (lemma "transitive")
                              (("1"
                                (inst - "x!1" "x!3" "y!1" "y!2")
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand* "remove" "member" "/=")
                          (("2" (use "irreflexive")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand* "remove" "member")
                      (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (inst 2 "y!1")
                (("2" (skolem-typepred)
                  (("2" (inst + "x!3")
                    (("2" (expand* "remove" "member" "/=")
                      (("2" (use "irreflexive")
                        (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (rewrite "card_remove") (("3" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-nonempty-type-decl nil finite_orders nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_order? const-decl "bool" orders nil)
    (measure_induction formula-decl nil measure_induction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (< const-decl "bool" reals nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (remove const-decl "set" sets nil)
    (card_remove formula-decl nil finite_sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (x!2 skolem-const-decl "pred[T]" finite_orders nil)
    (y!1 skolem-const-decl "T" finite_orders nil)
    (y!2 skolem-const-decl "(remove(y!1, x!2))" finite_orders nil)
    (x!3 skolem-const-decl "(x!2)" finite_orders nil)
    (member const-decl "bool" sets nil)
    (/= const-decl "boolean" notequal nil)
    (transitive? const-decl "bool" relations nil)
    (PRED type-eq-decl nil defined_types nil)
    (transitive formula-decl nil relations_extra nil)
    (x!4 skolem-const-decl "(x!2)" finite_orders nil)
    (irreflexive formula-decl nil relations_extra nil)
    (irreflexive? const-decl "bool" relations nil)
    (finite_type formula-decl nil finite_orders nil)
    (restrict const-decl "R" restrict nil)
    (below type-eq-decl nil nat_types nil)
    (injective? const-decl "bool" functions nil)
    (is_finite_type const-decl "bool" finite_sets nil)
    (well_founded? const-decl "bool" orders nil))
   nil
   (finite_strict_order_is_well_founded subtype "finite_orders.x"
    "(orders[finite_orders.T].well_founded?)")))
 (finite_strict_total_order_is_well_ordered 0
  (finite_strict_total_order_is_well_ordered-1 nil 3315153951
   ("" (skolem-typepred)
    (("" (expand "well_ordered?")
      (("" (rewrite "finite_strict_order_is_well_founded") nil nil))
      nil))
    nil)
   ((well_ordered? const-decl "bool" orders nil)
    (strict_order? const-decl "bool" orders nil)
    (finite_strict_order_is_well_founded judgement-tcc nil
     finite_orders nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (T formal-nonempty-type-decl nil finite_orders nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (finite_strict_total_order_is_well_ordered subtype "finite_orders.x"
    "(orders[finite_orders.T].well_ordered?)"))))

